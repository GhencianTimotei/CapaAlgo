using System.Text;
using System.Collections.Generic;
using SiriusConfigurator.DataLayer;
using SiriusConfigurator.StatusHandler;
using SRXml = SiriusConfigurator.BusinessLayer.BEntities.Xml;

namespace SiriusConfigurator
{
    public class ScriptClass
    {    
        string H_FILE_HEADER = @" /*!
* \defgroup MOD_MCAL_OS
* \{
******************************************************************************
*
* \par Module Owner:
* Huf Group
*
* \par Initial Project:
* 1656.001 BSW
*
******************************************************************************
* \par Description:
*  This is the configurable header file for the MOD_MCAL_OS module.
*  Contains definitions for types, defines and external functions' declarations.
******************************************************************************
*
* %PCMS_HEADER_SUBSTITUTION_START:%
*
* Configuration Management Information Log (generated by Dimensions CM)
*
*
* CM Item: %PID:%
* Item name: %PM:%
* Location: %ARCHIVE:%
* Revision: %PR:%
* Date: %DATE:%
* Author: %AUTHOR:%
*
* %PCMS_HEADER_SUBSTITUTION_END:% *
******************************************************************************
*
* \par Layer:
*  Mcal
*
* \par Compiler dialect:
*  C99
*
* \par Controller:
*  RL78, RH850, S32K
*
* \par Estimated resources:
* | Resource | Amount   | Remarks         |
* | ---------| -------- | ----------------|
* | ROM      | x Byte   | on x controller |
* | RAM      | y Byte   | on x controller |
* | NVRAM    | z Byte   | on x controller |
* | Runtime Init | X ms |                 |
* | Runtime Task | X ms |                 |
*
******************************************************************************/  ";

        string H_FILE_FOOTER = @"/* %PCMS_HEADER_SUBSTITUTION_START:%
******************************************************************************
* Document Management Information Log (generated by Dimensions CM)
*
* Description:
* %PD:%
*
* Used by Baselines:
* %PIRB:%
*
* Used by Dimensions CM Projects:
* %PIRW:%
*
* Change History:
* %PL:%
*
* %PCMS_HEADER_SUBSTITUTION_END:%
*/";

string S_FILE_HEADER = @" /*!
* \defgroup MOD_MCAL_OS
* \{
******************************************************************************
*
* \par Module Owner:
* Huf Group
*
* \par Initial Project:
* 1656.001 BSW
*
******************************************************************************
* \par Description:
*  This file contains the definitions of the PendSV and SVCall interrupts' handlers.
*  It is generated only for the S32K controller and is used in case background task
*  is enabled.
******************************************************************************
*
* %PCMS_HEADER_SUBSTITUTION_START:%
*
* Configuration Management Information Log (generated by Dimensions CM)
*
*
* CM Item: %PID:%
* Item name: %PM:%
* Location: %ARCHIVE:%
* Revision: %PR:%
* Date: %DATE:%
* Author: %AUTHOR:%
*
* %PCMS_HEADER_SUBSTITUTION_END:% *
******************************************************************************
*
* \par Layer:
*  Mcal
*
* \par Compiler dialect:
*  C99
*
* \par Controller:
*  S32K
*
* \par Estimated resources:
* | Resource | Amount   | Remarks         |
* | ---------| -------- | ----------------|
* | ROM      | x Byte   | on x controller |
* | RAM      | y Byte   | on x controller |
* | NVRAM    | z Byte   | on x controller |
* | Runtime Init | X ms |                 |
* | Runtime Task | X ms |                 |
*
******************************************************************************/  ";

        string S_FILE_FOOTER = @"/* %PCMS_HEADER_SUBSTITUTION_START:%
******************************************************************************
* Document Management Information Log (generated by Dimensions CM)
*
* Description:
* %PD:%
*
* Used by Baselines:
* %PIRB:%
*
* Used by Dimensions CM Projects:
* %PIRW:%
*
* Change History:
* %PL:%
*
* %PCMS_HEADER_SUBSTITUTION_END:%
*/";

string S_PENDSV_HEADER = @"/*!
 ****************************************************************************
 * \brief
 * PendSV exception handler is used to save the context on stack. It is set to pending from Os_ISR_Tick.
 *
 * \details
 * When entering an exception, the processor changes from Thread mode(where Process Stack is used)
 * to Handler Mode(where the Main Stack is used) and saves the processor state(r0-r3, r12, r14, r15, PSR)
 * on the Process Stack.
 * On the PendSV handler, first, Os_ContextSaved_BO is checked.  If the value is TRUE, it
 * means that the previous execution of PendSV_Handler was not yet followed by a execution of SVC_Handler (the context was
 * saved on the stack, but not removed yet). In this case it is not necessary to save the context again, therefore the exception
 * handler is exited. If the value is FALSE, Os_ContextSaved_BO is set to TRUE and execution proceeds.
 * The current address of the Processor stack is saved in a general purpose register
 * in order to use that address for storing the modified context on the Process Stack.
 * Then, the r4-r11 registers are stored on the stack because they are not saved automatically 
 * when an exception occurs and the Arm Procedure Call Standard specifies that their value must be preserved
 * between function calls. After this, the new context from which Os_CheckAlarms is called will be created as follows:
 * - for PSR register the value 0x01000000 will be used(T bit should be 1 because the Cortex M4 processor only supports
 *   Thumb instructions; otherwise, if T=0, a fault is generated; the rest of the bits are irrelevant for Os_CheckAlarms
 *   and are set to 0
 * - for R15(Program Counter) and R14(Link Register), the address of Os_CheckAlarms will be used
 * - r12, r0-r3 are saved with the current value because their value does not impact the execution of Os_CheckAlarms
 * The modified context is saved on the stack and the Process Stack Pointer will be updated with the new
 * address stored in the general purpose register after all the storing was performed.
 * On exception exit, the modified context will be unstacked, the processor will change back to Thread mode
 * and will start executing Os_CheckAlarms.
 ****************************************************************************
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  The module has to be initialized
 *
 * \param[IN] -
 * \param[OUT] -
 * \param[IN/OUT] -
 *
 * \par Used global variables:
 * \parblock
 * __Read:__
 * none
 *
 * __Write:__
 * none
 *
 * __Read/Write:__
 * Os_ContextSaved_BO
 *
 * \endparblock
 *
 * \par Called functions: none
 *
 * \returns  void
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS

 ****************************************************************************/  ";
 
 string S_SVCALL_HEADER = @"/*!
 ****************************************************************************
 * \brief
 * SVCall exception handler is used to restore the context from the stack.It is set to
 * pending from Os_CheckAlarms, right after the OS_CHECK_ALARMS_FUNCTION is executed.
 *
 * \details
 * When executing this function, the processor will be in Handler Mode and the Main Stack will be used.
 * As a first action, Os_ContextSaved_BO is set to FALSE (as a proof that SVC_Handler was executed).
 * The current value of the Process Stack Pointer is saved in a general purpose register. Then,
 * to that value 40 bytes are added in order to reach the address from where the r4-r11 are stored.
 * 40 bytes: - 2 registers are saved on the Process Stack when entering Os_CheckAlarms(2 x 4 bytes = 8 bytes)
 *           - processor state(r0-r3, r12, r14, r15 and PSR) is saved on the Process Stack when the SVCall
 *             exception is entered (8 x 4 bytes = 32 bytes)
 * After that, the r4-r11 registers are restored with their initial value, before the program was interrupted,
 * and the value of the Process Stack Pointer will be updated with the new address(after the r4-r11 registers were loaded).
 * On exception exit, the processor will return to its initial state, right before the Os_ISR_Tick interrupted.
 ****************************************************************************
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  The module has to be initialized
 *
 * \param[IN] -
 * \param[OUT] -
 * \param[IN/OUT] -
 *
 * \par Used global variables:
 * \parblock
 * __Read:__
 * none
 *
 * __Write:__
 * Os_ContextSaved_BO
 *
 * __Read/Write:__
 * none
 *
 * \endparblock
 *
 * \par Called functions: none
 *
 *
 * \returns  void
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/ ";
 
 string HTypes_FILE_HEADER = @"/*!
 * \defgroup MOD_MCAL_OS (Os_TypesCfg.h)
 * \{
 ******************************************************************************
 * \image html ""Kopf_oZusatz_A4hoch_4C.jpg""
 *
 * \par Module Owner:
 * Huf Group
 *
 * \par Initial Project:
 * 1656.001 BSW
 *
 ******************************************************************************
 * \par Description:
 * Generated configuration header file for Mcal and Serv OS. It contains the configurable
 * types needed by OS.
 *
 ******************************************************************************
 *
 * %PCMS_HEADER_SUBSTITUTION_START:%
 *
 * Configuration Management Information Log (generated by Dimensions CM)
 *
 *
 * CM Item: %PID:%
 * Item name: %PM:%
 * Location: %ARCHIVE:%
 * Revision: %PR:%
 * Date: %DATE:%
 * Author: %AUTHOR:%
 *
 * %PCMS_HEADER_SUBSTITUTION_END:% *
 ******************************************************************************
 *
 * \par Layer:
 * Operating System, Service Layer
 *
 * \par Compiler dialect:
 * C99
 *
 * \par Controller:
 * Independent
 *
 * \par Estimated resources:
 * | Resource | Amount   | Remarks         |
 * | ---------| -------- | ----------------|
 * | ROM      | x Byte   | on x controller |
 * | RAM      | y Byte   | on x controller |
 * | NVRAM    | z Byte   | on x controller |
 * | Runtime Init | X ms |                 |
 * | Runtime Task | X ms |                 |
 *
 ******************************************************************************/";
 
 string S_PENDSV_CODE = @"PendSV_Handler:
    /*[SWPS_SWS_MCALOS_00035]*/
	/*Disable interrupts*/
	CPSID i
	/* Store in r0 the address of Os_ContextSaved_BO*/
	LDR r0, =Os_ContextSaved_BO
	/* Store in r2 the value of Os_ContextSaved_BO*/
	LDRB r2, [r0]
	/* Check if the value of Os_ContextSaved_BO is FALSE */
	CMP r2, #0x00
	/* In case the value is TRUE, jump to B2 and exit the interrupt*/
	BNE .B2
	/* Set Os_ContextSaved_BO to TRUE */
	MOV r1, #0x01
	STRB r1, [r0]
	/*Since handler mode is active, the main stack is used; we need to save the context on the process stack
	 *store the current PSP value into r0 and use it to store the registers*/
	MRS r0, PSP
	/*Flush the pipeline of the processor, so that all instructions following the ISB are fetched
	 *from cache or memory again, after the ISB instruction has been completed*/
	ISB /*Instruction Synchronization Barrier*/
	/*Store r4-r11 registers onto the stack because they are not saved automatically when an exception occurs
	 *and the Arm Procedure Call Standard specifies that their value must be preserved between function calls )*/
	STMDB r0!, {r4,r5,r6,r7,r8,r9,r10,r11}
	/*Save the new process stack pointer value(stored into r0) in r4 because later we will need to store
	 *r0 on the stack and it cannot be used as destination and source at the same time with stmdb instruction and writeback(!) specified*/
	MOV r4, r0
	/*Save in r8 the value that will be used as PSR register; Set Thumb bit(bit[24]) to 1 for correct return in Thumb state
	 *the value of the APSR bits is not important for the execution of Os_CheckAlarms, so they are set to 0*/
	MOV.W r8, #0x01000000
	/*Save into r7 the value that will be use for Program Counter; in this case, store the address of the Os_CheckAlarms*/
	LDR r7, =Os_CheckAlarms
	/*Save into r6 the value that will be used as Link Register*/
	MOV r6, r7
	/*Store the values that will be used for Link Register, Program Counter and PSR on the stack*/
	STMDB r4!, {r6,r7,r8} /*r14(LR), r15(PC), PSR*/
	/*Store r0-r12 registers on the stack*/
	STMDB r4!, {r0,r1,r2,r3,r12}
	/*Update process stack pointer with the new address after all the registers were stored*/
	MSR PSP, r4
	/*Instruction Synchronization Barrier*/
	ISB
	.B2:
	/*Enable interrupts*/
	CPSIE i
	
	/*Exit interrupt*/
	BX lr

";
	
 string S_SVCALL_CODE = @"SVC_Handler:
     /*[SWPS_SWS_MCALOS_00036]*/
    /*Disable interrupts*/
	CPSID i
	
	/* Load in r0 the address of Os_ContextSaved_BO*/
	LDR r0, =Os_ContextSaved_BO
	/* Set r1 to 0*/
	MOV r1, #0x00
	/* Set the value of Os_ContextSaved_BO to FALSE(0x00)*/
	STRB r1, [r0]
	
	/*Since handler mode is active, the main stack is used; we need to save the context on the process stack
	 *store the current PSP value into r0 and use it to restore the registers*/
	MRS r0, PSP
	/*Flush the pipeline of the processor, so that all instructions following the ISB are fetched
	 *from cache or memory again, after the ISB instruction has been completed*/
	ISB /*Instruction Synchronization Barrier*/
	/*Set the stack pointer to point to the address right after the r4-r11 registers were stored in the stack
	 *add 40 bytes to the current address (2 registers were stored when entering Os_CheckAlarms function
	 *and 8 when entering the exception)*/
	ADDW r0,r0, #40
	/*Pop r4-r11 registers from the stack */
	LDMFD r0!, {r4,r5,r6,r7,r8,r9,r10,r11}
	/*Update process stack pointer with the new value after all the registers were loaded*/
	MSR PSP, r0
	/*Instruction Synchronization Barrier*/
	ISB
	/*Enable interrupts*/
	CPSIE i
	/*Exit interrupt*/
	BX lr

";

        private StringBuilder HGenerationStream;
	    private StringBuilder SGenerationStream;
        private DL_Component siriusApp;
		private StringBuilder HTypesGenerationStream;
        private NodeExt osGeneral;
        private NodeExt osTickNode; 
        				
        public ScriptClass()
        {
            siriusApp = new DL_Component();
            HGenerationStream = new StringBuilder();
			SGenerationStream = new StringBuilder();
			HTypesGenerationStream = new StringBuilder();
            osGeneral = siriusApp.GetNode("OsMcalGeneral")[0];
            osTickNode = siriusApp.GetNode("OsTick")[0];
        }

		public string Dynamic(NodeExt node, SRXml.AttributesXml attribute)
		{
	    	//MessageHandler.SetLog(MessageHandler.ActionTypes.OK, "CheckAttribute reached--"+node.Name+ "  "+attribute.Attribute);
     						
			if (node.Name == "OsTick") 
			{
				if ((attribute.Attribute == "OsSelectTimerInterface") && (attribute.Value == "OS_TIMER_RJ_RL78"))
				{
					SRXml.AttributesXml FreqCalc = node.Attributes.Find(x => x.Attribute == "OsClockSourceFreqCalc");
					siriusApp.SetEnable(node, FreqCalc, true);
					siriusApp.SetValueOfAttribute(node, FreqCalc, "Automatic");
					SRXml.AttributesXml Freq = node.Attributes.Find(x => x.Attribute == "OsFreqUserInput");
					siriusApp.SetEnable(node, Freq, false);
					SRXml.AttributesXml Tick = node.Attributes.Find(x => x.Attribute == "OsTickClockSource");
					siriusApp.SetEnable(node, Tick, true);
					SRXml.AttributesXml GptTimer = node.Attributes.Find(x => x.Attribute == "OsGptTimer");
					siriusApp.SetEnable(node, GptTimer, false);
			    }
				
			    if ((attribute.Attribute == "OsSelectTimerInterface") && (attribute.Value == "OS_TIMER_EXTERNAL"))
				{
					SRXml.AttributesXml ClockSource = node.Attributes.Find(x => x.Attribute == "OsClockSourceFreqCalc");
					siriusApp.SetEnable(node, ClockSource, false);
					siriusApp.SetValueOfAttribute(node, ClockSource, "User input");
					SRXml.AttributesXml Freq = node.Attributes.Find(x => x.Attribute == "OsFreqUserInput");
					siriusApp.SetEnable(node, Freq, false);
					SRXml.AttributesXml GptTimer = node.Attributes.Find(x => x.Attribute == "OsGptTimer");
					siriusApp.SetEnable(node, GptTimer, false);
					SRXml.AttributesXml ClockSrs = node.Attributes.Find(x => x.Attribute == "OsTickClockSource");
					siriusApp.SetEnable(node, ClockSrs, false);
				}
				
				if ((attribute.Attribute == "OsSelectTimerInterface") && (attribute.Value == "OS_TIMER_BSW_GPT"))
				{
					/* in case BSW Gpt Timer is selected, freq calculation shall be Automatic because the implementation is based on BSW GPT interfaces using 
					   a configured GPT channel and a MCU configuration. Gpt is dependent of MCU. */
					SRXml.AttributesXml FreqCalc = node.Attributes.Find(x => x.Attribute == "OsClockSourceFreqCalc");
					siriusApp.SetEnable(node, FreqCalc, false);
					siriusApp.SetValueOfAttribute(node, FreqCalc, "Automatic");
					SRXml.AttributesXml UserInputFreq = node.Attributes.Find(x => x.Attribute == "OsFreqUserInput");
					siriusApp.SetEnable(node, UserInputFreq, false);
					SRXml.AttributesXml ClockSrs = node.Attributes.Find(x => x.Attribute == "OsTickClockSource");
					siriusApp.SetEnable(node, ClockSrs, false);
					SRXml.AttributesXml GptTimer = node.Attributes.Find(x => x.Attribute == "OsGptTimer");
					siriusApp.SetEnable(node, GptTimer, true);
				}
				if ((attribute.Attribute == "OsSelectTimerInterface") && ((attribute.Value == "OS_TIMER_OSTM0_RH850") || (attribute.Value == "OS_TIMER_SYSTICK_S32K")))
				{
					SRXml.AttributesXml FreqCalc = node.Attributes.Find(x => x.Attribute == "OsClockSourceFreqCalc");
					siriusApp.SetEnable(node, FreqCalc, false);
					siriusApp.SetValueOfAttribute(node, FreqCalc, "User input");
					SRXml.AttributesXml UserInputFreq = node.Attributes.Find(x => x.Attribute == "OsFreqUserInput");
					siriusApp.SetEnable(node, UserInputFreq, true);
					SRXml.AttributesXml ClockSrs = node.Attributes.Find(x => x.Attribute == "OsTickClockSource");
					siriusApp.SetEnable(node, ClockSrs, false);
					SRXml.AttributesXml GptTimer = node.Attributes.Find(x => x.Attribute == "OsGptTimer");
					siriusApp.SetEnable(node, GptTimer, false);
				}
				
			    if ((attribute.Attribute == "OsClockSourceFreqCalc") && (attribute.Value == "Automatic"))
				{
				    SRXml.AttributesXml UserInputFreq = node.Attributes.Find(x => x.Attribute == "OsFreqUserInput");
					siriusApp.SetEnable(node, UserInputFreq, false);
					SRXml.AttributesXml ClockSource = node.Attributes.Find(x => x.Attribute == "OsTickClockSource");
					siriusApp.SetEnable(node, ClockSource, true);
				}
				
				if ((attribute.Attribute == "OsClockSourceFreqCalc") && (attribute.Value == "User input"))
				{
				    SRXml.AttributesXml ClockS = node.Attributes.Find(x => x.Attribute == "OsTickClockSource");
					siriusApp.SetEnable(node, ClockS, false);
					SRXml.AttributesXml UserInputF = node.Attributes.Find(x => x.Attribute == "OsFreqUserInput");
					siriusApp.SetEnable(node, UserInputF, true);
				}
				
				if ((attribute.Attribute == "OsIsrUsedInSleepMode") && (attribute.Value == "false"))
			    {
				    SRXml.AttributesXml TaskName = node.Attributes.Find(x => x.Attribute == "OsSleepModeInterface");
				    siriusApp.SetEnable(node, TaskName, false);
			    }
				
				if ((attribute.Attribute == "OsIsrUsedInSleepMode") && (attribute.Value == "true"))
			    {
				    SRXml.AttributesXml TaskName = node.Attributes.Find(x => x.Attribute == "OsSleepModeInterface");
				    siriusApp.SetEnable(node, TaskName, true);
			    }
		    }
			
			return "OK";
		}
		
		//OK,WARNING,ERROR,FATAL_ERROR
        public string Validate()
		{
            string retVal = "OK";
            bool status;
            bool SettingFound;
		    string calcMode;
            string clockSettingId;
			string GptSettingId;
            float userFreq;
            int index;
			string TimerRJSourceSel;
		          
			if (!(osGeneral.GetAttribute("OsControllerFamily").Equals("RL78")) && (osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_RJ_RL78")))
			{
				MessageHandler.SetLog(MessageHandler.ActionTypes.ERROR, "TimerRJ RL78 shall be selected only for RL78 uc. See OsControllerFamily and OsSelectTimerInterface attributes." );
                retVal = "ERROR";
                return retVal;
			}
			if (!(osGeneral.GetAttribute("OsControllerFamily").Equals("RL78")) && (osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_BSW_GPT")))
			{
				MessageHandler.SetLog(MessageHandler.ActionTypes.ERROR, "BSW GPT Timer shall be selected only for RL78 uc. See OsControllerFamily and OsSelectTimerInterface attributes." );
                retVal = "ERROR";
                return retVal;
			}
			if (!(osGeneral.GetAttribute("OsControllerFamily").Equals("RH850")) && (osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_OSTM0_RH850")))
			{
				MessageHandler.SetLog(MessageHandler.ActionTypes.ERROR, "OSTM0 Timer shall be selected only for RH850 uc. See OsControllerFamily and OsSelectTimerInterface attributes." );
                retVal = "ERROR";
                return retVal;
			}
			if (!(osGeneral.GetAttribute("OsControllerFamily").Equals("S32K")) && (osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_SYSTICK_S32K")))
			{
				MessageHandler.SetLog(MessageHandler.ActionTypes.ERROR, "SYSTICK Timer shall be selected only for S32K uc. See OsControllerFamily and OsSelectTimerInterface attributes." );
                retVal = "ERROR";
                return retVal;
			}
			
            calcMode = osTickNode.GetAttribute("OsClockSourceFreqCalc");

            if(calcMode.Equals("Automatic"))
            {
                //Automatic frequency calculation based on RL78 TimerRJ or GPT timer configuration
                clockSettingId = osTickNode.GetAttribute("OsTickClockSource");
                SettingFound = false;

				List<NodeExt> Mcu_ClockConfigs = siriusApp.GetNode("McuClockSetting");
				List<NodeExt> Mcu_PeripheralConfigs = siriusApp.GetNode("PeripheralSettings");
                //Search for McuClockSettingId 
                for (index = 0; ((index < Mcu_ClockConfigs.Count) && (SettingFound == false)); index++)
                {
                    if(Mcu_ClockConfigs[index].GetAttribute("McuClockSettingId").Equals(clockSettingId))
                    {
						SettingFound = true;
						TimerRJSourceSel = Mcu_PeripheralConfigs[index].GetAttribute("TimerRJ"); /*Timer RJ count source select*/
						if ("ELC_event" == TimerRJSourceSel)
						{
							MessageHandler.SetLog(MessageHandler.ActionTypes.ERROR, "TimerRJ count source ELC_event is not supported for OS tick generation ");
                            retVal = "ERROR";
							return retVal;
						}
						if (("CpuClock" != TimerRJSourceSel) && ("CpuClock/8" != TimerRJSourceSel) && ("CpuClock/2" != TimerRJSourceSel) && ("LSIntOsc" != TimerRJSourceSel) && ("SubLSIntOsc" != TimerRJSourceSel))
						{
							MessageHandler.SetLog(MessageHandler.ActionTypes.ERROR, "Invalid value for MCU Peripheral configuration: TimerRJ");
                            retVal = "ERROR";
							return retVal;
						}
                    }
                }

                if(SettingFound == false)
                {
                    MessageHandler.SetLog(MessageHandler.ActionTypes.ERROR, "Os/OsGeneral/OsTick OsTickClockSource selected clock source was not found!");
                    retVal = "ERROR";
                    return retVal;
                }
				
				if (osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_BSW_GPT"))
				{
					GptSettingId = osTickNode.GetAttribute("OsGptTimer");
					SettingFound = false;
				    
					List<NodeExt> Gpt_Channels = siriusApp.GetNode("GptChannel");
				    //Search for ChannelName 
					for (index = 0; ((index < Gpt_Channels.Count) && (SettingFound == false)); index++)
                    {
                        if(Gpt_Channels[index].GetAttribute("ChannelName").Equals(GptSettingId))
                        {
							SettingFound = true;
							if ((Gpt_Channels[index].GetAttribute("NotificationCallback") != "NULL") || (Gpt_Channels[index].GetAttribute("EnableWakeup") == "true"))
							{
								MessageHandler.SetLog(MessageHandler.ActionTypes.ERROR, "OS configured GPT Timer shall be handled by OS, so Gpt/GptConfig/GptChannel/NotificationCallback shall be NULL and Gpt/GptConfig/GptChannel/EnableWakeup shall be FALSE");
                                retVal = "ERROR";
					            return retVal;
							}
						}
					}
					if(SettingFound == false)
                    {
                        MessageHandler.SetLog(MessageHandler.ActionTypes.ERROR, "Os/OsGeneral/OsTick OsGptTimer selected timer was not found into Gpt configuration!");
                        retVal = "ERROR";
					    return retVal;
					}
                }
			}            
            else
            {
				float.TryParse(osTickNode.GetAttribute("OsFreqUserInput"), out userFreq);
                if (userFreq <= 0.0)
                {
                    MessageHandler.SetLog(MessageHandler.ActionTypes.ERROR, "OsFreqUserInput has invalid value");
                    retVal = "ERROR";
                    return retVal;
                }
            }

            if (osTickNode.GetAttribute("OsIsrUsedInSleepMode") == "true")
            {
				string OsSleepModeInterface;
				OsSleepModeInterface = osTickNode.GetAttribute("OsSleepModeInterface").Trim();
				if(OsSleepModeInterface.Equals(""))
				{
				    MessageHandler.SetLog(MessageHandler.ActionTypes.ERROR, "OsSleepModeInterface must not be empty when OsIsrUsedInSleepMode is set true");
                    retVal = "ERROR";
                    return retVal;	
				}
                else
				{
					status = ValidateIdentifier(OsSleepModeInterface);

                    if (false == status)
                    {
                        MessageHandler.SetLog(MessageHandler.ActionTypes.ERROR, "OsSleepModeInterface is not a valid identifier");
                        retVal = "ERROR";
                        return retVal;
                    }
				}
			}
            return retVal;
		}
		
	    private bool ValidateIdentifier(string identifier)
        {
            bool valid = true;

            if (char.IsLetter(identifier[0]))
            {
                char c;

                for (int i = 1; i < identifier.Length; i++)
                {
                    c = identifier[i];
                    if ((!char.IsLetterOrDigit(c)) && (c != '_'))
                    {
                        valid = false;
                        break;
                    }
                }
            }
            else
            {
                //first character is not a letter
                valid = false;
            }

            return valid;
        }
		
        private void AddHFileHeader()
        {
            HGenerationStream.Append(H_FILE_HEADER);
            HGenerationStream.AppendLine();
        }


        private void AddHIncludes()
        {
			List<NodeExt> SFR_Guard = siriusApp.GetNode("SFR_Guard");
			
			HGenerationStream.AppendLine(@"/* Include files */");   
			HGenerationStream.AppendLine("/* polyspace-begin MISRA-C3:1.1 [Not a defect:Unset] \"Includes are necessary into current implementation\" */");
            /*----------------------------------includes for SFR guard safety feature--------------------------------------*/
            if (SFR_Guard.Count == 1)
            {
                if (SFR_Guard[0].GetAttribute("EnableSFRGuardFeature") == "true")
                {
					HGenerationStream.AppendLine("#include \"Safety_SFRGuard.h\"");
                }
            }
            /*----------------------------------end of includes for SFR guard safety feature-------------------------------*/			
            HGenerationStream.AppendLine("#include \"Os_CommonCfg.h\"");
		
		    if (osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_BSW_GPT"))
		    {
			    HGenerationStream.AppendLine("#include \"Gpt.h\"");
		    }
		    HGenerationStream.AppendLine("#include \"" + osGeneral.GetAttribute("OsIncludeHeaderFile") + "\"");
			if (osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_SYSTICK_S32K"))
		    {
			    HGenerationStream.AppendLine("#include \"Mcal.h\"");
		    }
		    HGenerationStream.AppendLine("/* polyspace-end MISRA-C3:1.1 [Not a defect:Unset] \"Includes are necessary into current implementation\" */");
		
		    HGenerationStream.AppendLine();
		}

        private void AddHFileFooter()
        {
            HGenerationStream.Append(H_FILE_FOOTER);
            HGenerationStream.AppendLine();
        }
		
		 private void CompleteHTypesFile()
        {
            string pathHFile = @"..\GenFiles\Source\Os_TypesCfg.h";
            System.IO.File.WriteAllText(pathHFile, HTypesGenerationStream.ToString());
        }
		
        private void CompleteHFile()
        {
            string pathHFile = @"..\GenFiles\Source\Os_Mcal_Cfg.h";
           
            System.IO.File.WriteAllText(pathHFile, HGenerationStream.ToString());
        }
		
		private void AddSFileHeader()
        {
            SGenerationStream.Append(S_FILE_HEADER);
            SGenerationStream.AppendLine();
        }
		 private void AddSFileFooter()
        {
            SGenerationStream.Append(S_FILE_FOOTER);
            SGenerationStream.AppendLine();
        }
		
		private void AddHTypesFileHeader()
        {
            HTypesGenerationStream.Append(HTypes_FILE_HEADER);
            HTypesGenerationStream.AppendLine();
        }

		private void AddHTypesFileFooter()
        {
            HTypesGenerationStream.Append(H_FILE_FOOTER);
            HTypesGenerationStream.AppendLine();
        }

		
		 private void CompleteSFile()
        {
            string pathSFile = @"..\GenFiles\Source\Os_Mcal_Int_Cfg.s";
           
            System.IO.File.WriteAllText(pathSFile, SGenerationStream.ToString());
        }

		private void calcTimerRJFreq(out float timerRJFreq_MHz, int clockSettingIndex)
        {
			float fIL_kHz = 15F; //15 kHz
		    float XT1_kHz = 32.768F; //32.768 kHz
		    List<NodeExt> Mcu_PeripheralConfigs = siriusApp.GetNode("PeripheralSettings");
			List<NodeExt> Mcu_ClockConfigs = siriusApp.GetNode("McuClockSetting");
            string TimerRJSourceSel = Mcu_PeripheralConfigs[clockSettingIndex].GetAttribute("TimerRJ"); /*Timer RJ count source select*/
            float CPUClock = float.Parse(Mcu_ClockConfigs[clockSettingIndex].GetAttribute("McuCpuClockFrequency"));
            timerRJFreq_MHz = 0;
            switch (TimerRJSourceSel)
            {
                case "CpuClock":
                    timerRJFreq_MHz = CPUClock;
                    break;

                case "CpuClock/8":
                    timerRJFreq_MHz = CPUClock / 8;
                    break;
					
                case "CpuClock/2":
                    timerRJFreq_MHz = CPUClock / 2;
                    break;
					
                case "LSIntOsc":
                    timerRJFreq_MHz = fIL_kHz / 1000F; 
                    break;
					
				case "SubLSIntOsc":
				    if ("true"==Mcu_ClockConfigs[clockSettingIndex].GetAttribute("LsIntOscEnabled"))
				    {
				    	timerRJFreq_MHz = fIL_kHz / 1000F; 
				    }
				    else
				    {
                        timerRJFreq_MHz = XT1_kHz / 1000F; 
				    }                 
				    break;	
					
				default:
				/* case shall not happen, validation is done */
                    break;
            }
        }
		
		private float CalculateGptFreq(string prescaler, string hwtimer)
		{
			float freq = 0;
		  
		    /* All the possible TAU prescaler configurations linked to their 2^x value. */
            Dictionary<string,int> TauVal = new Dictionary<string,int>();
            TauVal["fclk"] = 1;
            TauVal["fclk/2"] = 2;
			TauVal["fclk/2^2"] = 4;
			TauVal["fclk/2^3"] = 8;
            TauVal["fclk/2^4"] = 16;
			TauVal["fclk/2^5"] = 32;
			TauVal["fclk/2^6"] = 64;
			TauVal["fclk/2^7"] = 128;
			TauVal["fclk/2^8"] = 256;
			TauVal["fclk/2^9"] = 512;
			TauVal["fclk/2^10"] = 1024;
			TauVal["fclk/2^11"] = 2048;
			TauVal["fclk/2^12"] = 4096;
			TauVal["fclk/2^13"] = 8192;
			TauVal["fclk/2^14"] = 16384;
			TauVal["fclk/2^15"] = 32768;
			
			List<NodeExt> Gpt_Tau0Set = siriusApp.GetNode("TAU0Settings");
			List<NodeExt> Gpt_Tau1Set = siriusApp.GetNode("TAU1Settings");
			
			List<NodeExt> Mcu_ClockConfigs = siriusApp.GetNode("McuClockSetting");
		    NodeExt GptGeneral = siriusApp.GetNode("GptGeneral")[0];
			for (int index = 0; index < Mcu_ClockConfigs.Count; index++)
			{
				if (Mcu_ClockConfigs[index].GetAttribute("McuClockSettingId") == GptGeneral.GetAttribute("GptClockSource"))
				{
					freq = float.Parse(Mcu_ClockConfigs[index].GetAttribute("McuCpuClockFrequency"));
					break;
				}
			}
			
			switch(prescaler)
			{
				case "GPT_PRS00":
				{
				if ((hwtimer == "GPT_CH00") || (hwtimer == "GPT_CH01") || (hwtimer == "GPT_CH02") || (hwtimer == "GPT_CH03") || (hwtimer == "GPT_CH04")
					|| (hwtimer == "GPT_CH05") || (hwtimer == "GPT_CH06") || (hwtimer == "GPT_CH07"))
					{
						if (Gpt_Tau0Set.Count != 0)
						{
						freq = freq / TauVal[Gpt_Tau0Set[0].GetAttribute("Tau0Prescaler0")];
						}
					}
					else
					{
						if (Gpt_Tau1Set.Count != 0)
						{
						freq = freq / TauVal[Gpt_Tau1Set[0].GetAttribute("Tau1Prescaler0")];
						}
					}
					
				}
				break;
				case "GPT_PRS01":
				{
					if ((hwtimer == "GPT_CH00") || (hwtimer == "GPT_CH01") || (hwtimer == "GPT_CH02") || (hwtimer == "GPT_CH03") || (hwtimer == "GPT_CH04")
					|| (hwtimer == "GPT_CH05") || (hwtimer == "GPT_CH06") || (hwtimer == "GPT_CH07"))
					{
						if (Gpt_Tau0Set.Count != 0)
						{
						freq = freq / TauVal[Gpt_Tau0Set[0].GetAttribute("Tau0Prescaler1")];
						}
					}
					else
					{
						if (Gpt_Tau1Set.Count != 0)
						{
						freq = freq / TauVal[Gpt_Tau1Set[0].GetAttribute("Tau1Prescaler1")];
						}
					}
				}
				break;
				case "GPT_PRS02":
				{
					if ((hwtimer == "GPT_CH00") || (hwtimer == "GPT_CH01") || (hwtimer == "GPT_CH02") || (hwtimer == "GPT_CH03") || (hwtimer == "GPT_CH04")
					|| (hwtimer == "GPT_CH05") || (hwtimer == "GPT_CH06") || (hwtimer == "GPT_CH07"))
					{
						if (Gpt_Tau0Set.Count != 0)
						{
						freq = freq / TauVal[Gpt_Tau0Set[0].GetAttribute("Tau0Prescaler2")];
						}
					}
					else
					{
						if (Gpt_Tau1Set.Count != 0)
						{
						freq = freq / TauVal[Gpt_Tau1Set[0].GetAttribute("Tau1Prescaler2")];
						}
					}
				}
				break;
				case "GPT_PRS03":
				{
					if ((hwtimer == "GPT_CH00") || (hwtimer == "GPT_CH01") || (hwtimer == "GPT_CH02") || (hwtimer == "GPT_CH03") || (hwtimer == "GPT_CH04")
					|| (hwtimer == "GPT_CH05") || (hwtimer == "GPT_CH06") || (hwtimer == "GPT_CH07"))
					{
						if (Gpt_Tau0Set.Count != 0)
						{
						freq = freq / TauVal[Gpt_Tau0Set[0].GetAttribute("Tau0Prescaler3")];
						}
					}
					else
					{
						if (Gpt_Tau1Set.Count != 0)
						{
						freq = freq / TauVal[Gpt_Tau1Set[0].GetAttribute("Tau1Prescaler3")];
						}
					}
				}
				break;
				default:
				break;
			}
			return freq;
		}
		
        private void GenerateHFile()
        {
            int index;
            string calcMode;
          	int IRQtime;
            float timerTicks;
			string OsGptTimer;
			string GptAlocatedHwTimer;
			bool SettingFound;
			float TimerFreq_MHz = 0;
			string GptChPrescaler;
			string TimerIntReg;
			string TimerFlagReg;
			
			/* All the possible GPT HW timer configurations linked to their interrupt mask flags. */
            Dictionary<string,string> HwTimersMask = new Dictionary<string,string>();
            HwTimersMask["GPT_CH00"] = "TMMK00";
            HwTimersMask["GPT_CH01"] = "TMMK01";
			HwTimersMask["GPT_CH02"] = "TMMK02";
			HwTimersMask["GPT_CH03"] = "TMMK03";
			HwTimersMask["GPT_CH04"] = "TMMK04";
			HwTimersMask["GPT_CH05"] = "TMMK05";
			HwTimersMask["GPT_CH06"] = "TMMK06";
			HwTimersMask["GPT_CH07"] = "TMMK07";
			HwTimersMask["GPT_CH10"] = "TMMK10";
            HwTimersMask["GPT_CH11"] = "TMMK11";
			HwTimersMask["GPT_CH12"] = "TMMK12";
			HwTimersMask["GPT_CH13"] = "TMMK13";
			HwTimersMask["GPT_CH14"] = "TMMK14";
			HwTimersMask["GPT_CH15"] = "TMMK15";
			HwTimersMask["GPT_CH16"] = "TMMK16";
			HwTimersMask["GPT_CH17"] = "TMMK17";
			
			/* All the possible GPT HW timer configurations linked to their interrupt request flags. */
            Dictionary<string,string> HwTimersIF = new Dictionary<string,string>();
            HwTimersIF["GPT_CH00"] = "TMIF00";
            HwTimersIF["GPT_CH01"] = "TMIF01";
			HwTimersIF["GPT_CH02"] = "TMIF02";
			HwTimersIF["GPT_CH03"] = "TMIF03";
			HwTimersIF["GPT_CH04"] = "TMIF04";
			HwTimersIF["GPT_CH05"] = "TMIF05";
			HwTimersIF["GPT_CH06"] = "TMIF06";
			HwTimersIF["GPT_CH07"] = "TMIF07";
			HwTimersIF["GPT_CH10"] = "TMIF10";
            HwTimersIF["GPT_CH11"] = "TMIF11";
			HwTimersIF["GPT_CH12"] = "TMIF12";
			HwTimersIF["GPT_CH13"] = "TMIF13";
			HwTimersIF["GPT_CH14"] = "TMIF14";
			HwTimersIF["GPT_CH15"] = "TMIF15";
			HwTimersIF["GPT_CH16"] = "TMIF16";
			HwTimersIF["GPT_CH17"] = "TMIF17";
			
			/* Generate Os_Mcal_Cfg.h */
            /*******************************/

            AddHFileHeader();

            HGenerationStream.AppendLine("#ifndef OS_MCAL_CFG_H_                   /* To avoid double inclusion */");
            HGenerationStream.AppendLine("#define OS_MCAL_CFG_H_");
            HGenerationStream.AppendLine();
           
            AddHIncludes();

			HGenerationStream.AppendLine("/* polyspace-begin MISRA-C3:2.5 [Not a defect:Unset] \"Macros are useful to integration project or into different configurations\" */"); 
			HGenerationStream.AppendLine("/*[SWPS_SWS_MCALOS_00037]*/");
			HGenerationStream.AppendLine("/* Define timer interrupt cycle time in us */");
			HGenerationStream.AppendLine("#define OS_TICK_TIME_US ((U16)"+ osTickNode.GetAttribute("OsTickTimeUs") +")");
            HGenerationStream.AppendLine();

			HGenerationStream.AppendLine("#define OS_RL78                0u");
			HGenerationStream.AppendLine("#define OS_RH850               1u");
			HGenerationStream.AppendLine("#define OS_S32K                2u");
			HGenerationStream.AppendLine("#define OS_OTHER_UC_FAMILY     3u");
			HGenerationStream.AppendLine("/* Use RL78,RH850, S32K or other controller family */");
			if(!osGeneral.GetAttribute("OsControllerFamily").Equals("Other uc family"))
			{
				HGenerationStream.AppendLine("#define OS_CONTROLLER_FAMILY   " +"OS_" + osGeneral.GetAttribute("OsControllerFamily"));
			}
			else
			{
				HGenerationStream.AppendLine("#define OS_CONTROLLER_FAMILY   OS_OTHER_UC_FAMILY");
			}
			
			HGenerationStream.AppendLine();
			HGenerationStream.AppendLine("#define OS_TIMER_RJ_RL78       0u");
			HGenerationStream.AppendLine("#define OS_TIMER_BSW_GPT       1u");
			HGenerationStream.AppendLine("#define OS_TIMER_EXTERNAL      2u");
			HGenerationStream.AppendLine("#define OS_TIMER_OSTM0_RH850   3u");
			HGenerationStream.AppendLine("#define OS_TIMER_SYSTICK_S32K  4u");
			HGenerationStream.AppendLine("/* Use TimerRJ RL78, a BSW Gpt timer, OSTM0 timer, SYSTICK timer or the timer is handled externally */");
            HGenerationStream.AppendLine("#define OS_TIMER_SOURCE   "+ osTickNode.GetAttribute("OsSelectTimerInterface") + " /*[SWPS_SWS_MCALOS_00002]*/");
      		
			HGenerationStream.AppendLine("/* polyspace-end MISRA-C3:2.5 [Not a defect:Unset] \"Macros are useful to integration project or into different configurations\" */");  
			HGenerationStream.AppendLine();
			
			if (osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_SYSTICK_S32K"))
			{
				HGenerationStream.AppendLine(" /* SysTick registers and bits' definition */");
				HGenerationStream.AppendLine("#define SYSTICK_CSR_BASE_ADDRS      (0xE000E010u)  /* SysTick Control and Status Register */");
				HGenerationStream.AppendLine("#define SYSTICK_RVR_BASE_ADDRS      (0xE000E014u)  /* SysTick Reload Value Register */");
				HGenerationStream.AppendLine("#define SYSTICK_CVR_BASE_ADDRS      (0xE000E018u)  /* SysTick Current Value Register */");
				HGenerationStream.AppendLine("#define SCB_ICSR_BASE_ADDRS         (0xE000ED04u)  /* Interrupt Control and State Register */");
				HGenerationStream.AppendLine("#define SYSTICK_CSR_ENABLE_MASK     (0x00000001u)  /* This bit enables the counter: 0 - disabled, 1 - enabled*/");
				HGenerationStream.AppendLine("#define SYSTICK_CSR_TICKINT_MASK    (0x00000002u)  /* This bit enables SysTick exception request: 0 - disabled, 1 - enabled */");
				HGenerationStream.AppendLine("#define SYSTICK_CSR_CLKSOURCE_MASK  (0x00000004u)  /* This bit indicates the clock source: 0 - external clock, 1 - processor clock */");
				HGenerationStream.AppendLine("#define SCB_ICSR_PENDSTCLR_MASK     (0x02000000u)  /* SysTick exception clear-pending bit. Write: 0 - no effect, 1 - removes the pending state from the SysTick exception.*/");
				HGenerationStream.AppendLine();
			}
			
			if (osGeneral.GetAttribute("OsControllerFamily").Equals("S32K"))
			{
				HGenerationStream.AppendLine("#if (STD_ON == OS_ENABLE_BACKGROUND_TASK)");
				HGenerationStream.AppendLine("#define PENDSV_SET_PENDING_MASK      (0x10000000u)  /* PendSV set-pending bit mask */");
				HGenerationStream.AppendLine("#define SVCALL_SET_PENDING_MASK      (0x00008000u)  /* SVCall set-pending bit mask */");
				HGenerationStream.AppendLine("#define SCB_SHCSR_BASE_ADDRS         (0xE000ED24u)  /* System Handler Control and State Register(SHCSR) base address */");
				HGenerationStream.AppendLine("#endif");
			}
			
			if (osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_RJ_RL78") || osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_BSW_GPT") || osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_OSTM0_RH850")|| osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_SYSTICK_S32K"))
			{
				TimerIntReg = " "; 
                TimerFlagReg = " ";
               			
		        calcMode = osTickNode.GetAttribute("OsClockSourceFreqCalc");

		     	if (osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_RJ_RL78"))
		    	{
					TimerIntReg = "TRJMK0";
					TimerFlagReg = "TRJIF0";
					if (calcMode.Equals("Automatic"))
                    {
                        //Search for McuClockSettingId 
                        SettingFound = false;
                        string clockSettingId = osTickNode.GetAttribute("OsTickClockSource");
						List<NodeExt> Mcu_ClockConfigs = siriusApp.GetNode("McuClockSetting");
                        for (index = 0; ((index < Mcu_ClockConfigs.Count) && (SettingFound == false)); index++)
                        {
                            if (Mcu_ClockConfigs[index].GetAttribute("McuClockSettingId").Equals(clockSettingId))
                            {
                                SettingFound = true;
                                calcTimerRJFreq(out TimerFreq_MHz, index);
                                HGenerationStream.Append(@"/*TIMER RJ is used to generate the OS tick */
/*Make sure that the TIMER RJ is enabled in MCU configuration */
/* Timer frequency used for tick generation: TIMER_FREQ = " + TimerFreq_MHz.ToString() + @"MHz, as configured in MCU */
");
                            }
                        }
                    }
                    else
                    {
                        float.TryParse(osTickNode.GetAttribute("OsFreqUserInput"), out TimerFreq_MHz);
                        HGenerationStream.AppendLine("/*OS tick timer frequency configured by user is TIMER_FREQ = " + TimerFreq_MHz.ToString() + "MHz */");
                    }
			    }
			
			    if (osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_BSW_GPT"))
			    {
					/* identify GPT timer interrupt registers */
					List<NodeExt> Gpt_Channels = siriusApp.GetNode("GptChannel");
					OsGptTimer = osTickNode.GetAttribute("OsGptTimer");
					SettingFound = false;
			
					for (index = 0; ((index < Gpt_Channels.Count) && (SettingFound == false)); index++)
                    {
                        if(Gpt_Channels[index].GetAttribute("ChannelName").Equals(OsGptTimer))
                        {
					        SettingFound = true;
							GptAlocatedHwTimer = Gpt_Channels[index].GetAttribute("AlocatedHwTimer");
				         	TimerIntReg = HwTimersMask[GptAlocatedHwTimer];
				          	TimerFlagReg = HwTimersIF[GptAlocatedHwTimer];
					
					        /* calculate GPT timer frequency */
				         	GptChPrescaler = Gpt_Channels[index].GetAttribute("ChannelPrescaler");
				           	TimerFreq_MHz = CalculateGptFreq(GptChPrescaler,GptAlocatedHwTimer);
				         	HGenerationStream.Append(@"/*Gpt timer is used to generate the OS tick */
/*Make sure that the TAU is enabled in MCU configuration */
/* Timer frequency used for tick generation: TIMER_FREQ = " + TimerFreq_MHz.ToString() + @"MHz, as configured in MCU and GPT */
");
						}
					}
					
                	HGenerationStream.AppendLine("#define OS_GPT_TIMER  " + OsGptTimer);
			    }
				
				if ((osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_OSTM0_RH850")) || (osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_SYSTICK_S32K")))
		    	{
					float.TryParse(osTickNode.GetAttribute("OsFreqUserInput"), out TimerFreq_MHz);
                    HGenerationStream.AppendLine("/*OS tick timer frequency configured by user is TIMER_FREQ = " + TimerFreq_MHz.ToString() + "MHz */");
			    }
             
               	int.TryParse(osTickNode.GetAttribute("OsTickTimeUs"), out IRQtime);
                timerTicks = IRQtime * TimerFreq_MHz;
                HGenerationStream.AppendLine("/* timer ticks are calculated based on the timer frequency and the expected interrupt time OS_TICK_TIME_US * TIMER_FREQ */");
			    if ((osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_OSTM0_RH850") || (osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_SYSTICK_S32K"))))
				{
					HGenerationStream.AppendLine("#define OS_TIMER_TICKS     (U32)("+ ((int)timerTicks).ToString() + ")");
				}
				else
				{
					HGenerationStream.AppendLine("#define OS_TIMER_TICKS     (U16)("+ ((int)timerTicks).ToString() + ")");
				}	
				
			    HGenerationStream.AppendLine();
				HGenerationStream.AppendLine("/* polyspace-begin MISRA-C3:D4.9,2.5 [Not a defect:Unset] \"Macro used to facilitate an easier adaptation. Can be used into integration project.\" */"); 
				HGenerationStream.AppendLine("/* OS Timer interrupt handlers */");	
				HGenerationStream.AppendLine("/*[SWPS_SWS_MCALOS_00009], [SWPS_SWS_MCALOS_00010], [SWPS_SWS_MCALOS_00011]*/");	
				if (osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_OSTM0_RH850"))
				{
					HGenerationStream.AppendLine("#define OS_ENABLE_TIMER_INT()         ICOSTM0 &= 0xFF7Fu" + "  /*[SWPS_SWS_MCALOS_00027]*/");	
				    HGenerationStream.AppendLine("#define OS_DISABLE_TIMER_INT()        ICOSTM0 |= 0x0080u" + "  /*[SWPS_SWS_MCALOS_00028]*/");
				    HGenerationStream.AppendLine("#define OS_CLEAR_TIMER_PENDING_INT()  ICOSTM0 &= 0xEFFFu" + "  /*[SWPS_SWS_MCALOS_00029]*/");
				}
				else
				{
					if (osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_SYSTICK_S32K"))
					{
						HGenerationStream.AppendLine("#define OS_ENABLE_TIMER_INT()         REG_BIT_SET32(SYSTICK_CSR_BASE_ADDRS, SYSTICK_CSR_TICKINT_MASK)" + "  /*[SWPS_SWS_MCALOS_00027]*/");	
						HGenerationStream.AppendLine("#define OS_DISABLE_TIMER_INT()        REG_BIT_CLEAR32(SYSTICK_CSR_BASE_ADDRS, SYSTICK_CSR_TICKINT_MASK)" + "  /*[SWPS_SWS_MCALOS_00028]*/");
						HGenerationStream.AppendLine("#define OS_CLEAR_TIMER_PENDING_INT()  REG_BIT_SET32(SCB_ICSR_BASE_ADDRS, SCB_ICSR_PENDSTCLR_MASK)" + "  /*[SWPS_SWS_MCALOS_00029]*/");
					}
					else
					{
						HGenerationStream.AppendLine("#define OS_ENABLE_TIMER_INT()         " + TimerIntReg + " = 0u" + "  /*[SWPS_SWS_MCALOS_00027]*/");	
						HGenerationStream.AppendLine("#define OS_DISABLE_TIMER_INT()        " + TimerIntReg + " = 1u" + "  /*[SWPS_SWS_MCALOS_00028]*/");
						HGenerationStream.AppendLine("#define OS_CLEAR_TIMER_PENDING_INT()  " + TimerFlagReg + " = 0u" + "  /*[SWPS_SWS_MCALOS_00029]*/");
					}
				}
				HGenerationStream.AppendLine("/* polyspace-end MISRA-C3:D4.9,2.5 [Not a defect:Unset] \"Macro used to facilitate an easier adaptation. Can be used into integration project.\" */"); 
				HGenerationStream.AppendLine();
			}
			
			if ("false" == osTickNode.GetAttribute("OsIsrUsedInSleepMode"))
			{
			   HGenerationStream.AppendLine("#define OS_ISR_USED_IN_SLEEP_MODE  STD_OFF");
			}
			else
			{
				HGenerationStream.AppendLine("#define OS_ISR_USED_IN_SLEEP_MODE  STD_ON");
				HGenerationStream.AppendLine("/* polyspace +1 MISRA-C3:D4.9 [Not a defect:Unset] \"Macro used to facilitate an easier adaptation\" */");
			    HGenerationStream.AppendLine("#define OS_SLEEP_MODE_CALLOUT_INTERFACE()  " + osTickNode.GetAttribute("OsSleepModeInterface") + "()" + "  /*[SWPS_SWS_MCALOS_00038]*/");
				HGenerationStream.AppendLine("/* polyspace +1 MISRA-C3:8.5 [Not a defect:Unset] \"Was decided that all configured callback functions will be declared as external into the configuration file\" */");
			    HGenerationStream.AppendLine("extern void " + osTickNode.GetAttribute("OsSleepModeInterface") + "(void);");
			}
			
			HGenerationStream.AppendLine();
			HGenerationStream.AppendLine("/*[SWPS_SWS_MCALOS_00006]*/");
            HGenerationStream.AppendLine("/* Enable/disable functionality of saving context on stack - used for background task functionality */");
           
		    HGenerationStream.AppendLine("#if (STD_OFF == OS_ENABLE_BACKGROUND_TASK)");
            HGenerationStream.AppendLine("#define OS_SAVE_CONTEXT_ON_STACK STD_OFF");
            HGenerationStream.AppendLine("#else");
			HGenerationStream.AppendLine("#define OS_SAVE_CONTEXT_ON_STACK STD_ON");
			HGenerationStream.AppendLine("/* polyspace +1 MISRA-C3:D4.9 [Not a defect:Unset] \"Macro used to facilitate an easier adaptation\" */");
			HGenerationStream.AppendLine("#define OS_CHECK_ALARMS_FUNCTION()   Os_AlarmsEvaluation()");
			HGenerationStream.AppendLine("extern void Os_AlarmsEvaluation(void);");
			HGenerationStream.AppendLine();
			HGenerationStream.AppendLine("/* polyspace-begin MISRA-C3:D4.9 [Not a defect:Unset] \"Macro used to facilitate an easier adaptation.\" */"); 
			if (osGeneral.GetAttribute("OsControllerFamily").Equals("RL78"))
				{
					HGenerationStream.AppendLine("/* Used into tick ISR to save current context and push Os_CheckAlarms() on stack to be executed after exiting from ISR.");
                    HGenerationStream.AppendLine("* Next steps shall be done:");
					if ("false" == osTickNode.GetAttribute("OsIsrUsedInSleepMode"))
					{
                        HGenerationStream.AppendLine("*  1. save AX, BC, DE, HL, ES and CS on stack (instr 1-8)");
                        HGenerationStream.AppendLine("*  2. save Os_CheckAlarms() function address and add it on stack (instr 9-13)*/");
                        HGenerationStream.AppendLine("#define OS_SAVE_CONTEXT()\\");
                        HGenerationStream.AppendLine("do \\");
                        HGenerationStream.AppendLine("{  \\");
                        HGenerationStream.AppendLine("__asm(\"PUSH AX\");\\");
                        HGenerationStream.AppendLine("__asm(\"PUSH BC\");\\");
                        HGenerationStream.AppendLine("__asm(\"PUSH DE\");\\");
                        HGenerationStream.AppendLine("__asm(\"PUSH HL\");\\");
                        HGenerationStream.AppendLine("__asm(\"MOV A, CS\");\\");
					    HGenerationStream.AppendLine("__asm(\"MOV X, A\");\\");
				    	HGenerationStream.AppendLine("__asm(\"MOV A, ES\");\\");
					    HGenerationStream.AppendLine("__asm(\"PUSH AX\");\\");
					    HGenerationStream.AppendLine("__asm(\"MOVW AX, _Os_HighAddrOsFunc\"); \\");
					    HGenerationStream.AppendLine("__asm(\"MOV A, #0x86\"); \\");
					    HGenerationStream.AppendLine("__asm(\"PUSH AX\");\\");
					    HGenerationStream.AppendLine("__asm(\"MOVW AX, _Os_LowAddrOsFunc\"); \\");
					    HGenerationStream.AppendLine("__asm(\"PUSH AX\");\\");
					    HGenerationStream.AppendLine("}while(0u)");
			 
					    HGenerationStream.AppendLine("/* Used into Os_CheckAlarms() to restore the context. It restores CS, ES, HL, DE, BC and AX.");
					    HGenerationStream.AppendLine("* After restoring the registers it executes RETI instruction so function will be exited(so next");
					    HGenerationStream.AppendLine("* function instructions will not be executed anymore) and will return at the instruction that was");
					    HGenerationStream.AppendLine("* executed before the interrupt. PSW is restored by RETI instruction */");
					    HGenerationStream.AppendLine("#define OS_RESTORE_CONTEXT() \\");
					    HGenerationStream.AppendLine("do \\");
					    HGenerationStream.AppendLine("{\\");
					    HGenerationStream.AppendLine("__asm(\"POP AX\");\\");
					    HGenerationStream.AppendLine("__asm(\"MOV ES, A\");\\");
					    HGenerationStream.AppendLine("__asm(\"MOV A, X\");\\");
					    HGenerationStream.AppendLine("__asm(\"MOV CS, A\");\\");
					    HGenerationStream.AppendLine("__asm(\"POP HL\");\\");
					    HGenerationStream.AppendLine("__asm(\"POP DE\");\\");
					    HGenerationStream.AppendLine("__asm(\"POP BC\");\\");
					    HGenerationStream.AppendLine("__asm(\"POP AX\");\\");
					    HGenerationStream.AppendLine("__asm(\"RETI\");\\");
					    HGenerationStream.AppendLine("}while(0)");
					}
					else
					{
						HGenerationStream.AppendLine("*  1. save Os_CheckAlarms() function address and add it on stack (instr 1-4)");
						HGenerationStream.AppendLine("*  2. save AX, BC, DE, HL, ES and CS on stack (instr 5-13) */");
                        HGenerationStream.AppendLine("#define OS_SAVE_CONTEXT()\\");
                        HGenerationStream.AppendLine("do \\");
                        HGenerationStream.AppendLine("{  \\");
						HGenerationStream.AppendLine("__asm(\"MOVW AX, _Os_HighAddrOsFunc\"); \\");
					    HGenerationStream.AppendLine("__asm(\"MOV A, #0x86\"); \\");
					    HGenerationStream.AppendLine("__asm(\"PUSH AX\");\\");
					    HGenerationStream.AppendLine("__asm(\"MOVW AX, _Os_LowAddrOsFunc\"); \\");
					    HGenerationStream.AppendLine("__asm(\"PUSH AX\");\\");
                        HGenerationStream.AppendLine("__asm(\"PUSH AX\");\\");
                        HGenerationStream.AppendLine("__asm(\"PUSH BC\");\\");
                        HGenerationStream.AppendLine("__asm(\"PUSH DE\");\\");
                        HGenerationStream.AppendLine("__asm(\"PUSH HL\");\\");
                        HGenerationStream.AppendLine("__asm(\"MOV A, CS\");\\");
					    HGenerationStream.AppendLine("__asm(\"MOV X, A\");\\");
				    	HGenerationStream.AppendLine("__asm(\"MOV A, ES\");\\");
					    HGenerationStream.AppendLine("__asm(\"PUSH AX\");\\");
					    HGenerationStream.AppendLine("}while(0u)");
			 
					    HGenerationStream.AppendLine("/* Used into Os_CheckAlarms() to restore the context. It restores CS, ES, HL, DE, BC and AX.");
					    HGenerationStream.AppendLine("* After restoring the registers it executes RETI instruction so function will be exited(so next");
					    HGenerationStream.AppendLine("* function instructions will not be executed anymore) and will return at the instruction that was");
					    HGenerationStream.AppendLine("* executed before the interrupt. PSW is restored by RETI instruction */");
					    HGenerationStream.AppendLine("#define OS_RESTORE_CONTEXT() \\");
					    HGenerationStream.AppendLine("do \\");
					    HGenerationStream.AppendLine("{\\");
					    HGenerationStream.AppendLine("__asm(\"POP AX\");\\");
					    HGenerationStream.AppendLine("__asm(\"MOV ES, A\");\\");
					    HGenerationStream.AppendLine("__asm(\"MOV A, X\");\\");
					    HGenerationStream.AppendLine("__asm(\"MOV CS, A\");\\");
					    HGenerationStream.AppendLine("__asm(\"POP HL\");\\");
					    HGenerationStream.AppendLine("__asm(\"POP DE\");\\");
					    HGenerationStream.AppendLine("__asm(\"POP BC\");\\");
					    HGenerationStream.AppendLine("__asm(\"POP AX\");\\");
					    HGenerationStream.AppendLine("__asm(\"RETI\");\\");
					    HGenerationStream.AppendLine("}while(0)");
					}
				}
			else
				{
					if (osGeneral.GetAttribute("OsControllerFamily").Equals("S32K"))
					{
						HGenerationStream.AppendLine("/*Used into tick ISR to set as pending the PendSV exception; on the PendSV's handler the current context will be saved ");
						HGenerationStream.AppendLine("*and Os_CheckAlarms() will be pushed on stack to be executed after exiting from PendSV handler.*/");
						HGenerationStream.AppendLine("#define OS_SAVE_CONTEXT()    REG_BIT_SET32(SCB_ICSR_BASE_ADDRS, PENDSV_SET_PENDING_MASK)");
						HGenerationStream.AppendLine("/* Used into Os_CheckAlarms() to set SVCall exception to pending; on the SVCall's handler the context will be restored*/");
						HGenerationStream.AppendLine("#define OS_RESTORE_CONTEXT() REG_BIT_SET32(SCB_SHCSR_BASE_ADDRS, SVCALL_SET_PENDING_MASK)");
					}
					else
					{
						HGenerationStream.AppendLine("/* Used into tick ISR to save current context and push Os_CheckAlarms() on stack to be executed after exiting from ISR.*/");
						HGenerationStream.AppendLine("#define OS_SAVE_CONTEXT()");
						HGenerationStream.AppendLine("/* Used into Os_CheckAlarms() to restore the context.*/");
						HGenerationStream.AppendLine("#define OS_RESTORE_CONTEXT() ");
					}
				}
				
            HGenerationStream.AppendLine("/* polyspace-end MISRA-C3:D4.9 [Not a defect:Unset] \"Macro used to facilitate an easier adaptation.\" */");
			HGenerationStream.AppendLine("#endif /*OS_ENABLE_BACKGROUND_TASK*/");
			
			HGenerationStream.AppendLine();
            HGenerationStream.AppendLine("/* Disable interrupts */");
			HGenerationStream.AppendLine("/* [SWPS_SWS_MCALOS_00008] */");
			HGenerationStream.AppendLine("/* polyspace +1 MISRA-C3:D4.9 [Not a defect:Unset] \"Macro used to facilitate an easier adaptation\" */");
            HGenerationStream.AppendLine("#define OS_DISABLE_INTERRUPT() "+ osGeneral.GetAttribute("OsDisableInterrupts") + " /*[SWPS_SWS_MCALOS_00026]*/");
            HGenerationStream.AppendLine("/* Enable interrupts */");
			HGenerationStream.AppendLine("/* [SWPS_SWS_MCALOS_00007] */");
			HGenerationStream.AppendLine("/* polyspace +1 MISRA-C3:D4.9 [Not a defect:Unset] \"Macro used to facilitate an easier adaptation\" */");
            HGenerationStream.AppendLine("#define OS_ENABLE_INTERRUPT() " + osGeneral.GetAttribute("OsEnableInterrupts") + " /*[SWPS_SWS_MCALOS_00025]*/");
            
			HGenerationStream.AppendLine();
			
			HGenerationStream.AppendLine("#define OS_DEBUG_EN  STD_OFF");
			HGenerationStream.AppendLine("#if(STD_OFF != OS_DEBUG_EN)");
			
			HGenerationStream.AppendLine("/* polyspace +1 MISRA-C3:D4.9 [Not a defect:Unset] \" The macro is used to facilitate an easy adaptation. \" */");
			if (osGeneral.GetAttribute("OsControllerFamily").Equals("RL78"))
			{
				HGenerationStream.AppendLine("#define OS_TICK_PIN_TOGGLE()      P0 ^= 0x01u");
			}
			
			if (osGeneral.GetAttribute("OsControllerFamily").Equals("RH850"))
			{
				HGenerationStream.AppendLine("#define OS_TICK_PIN_TOGGLE()      P1 ^= 0x0001u");
			}
			
			if (!(osGeneral.GetAttribute("OsControllerFamily").Equals("RH850")) && !(osGeneral.GetAttribute("OsControllerFamily").Equals("RL78")))
			{
				HGenerationStream.AppendLine("#define OS_TICK_PIN_TOGGLE()    ");
			}
			
			HGenerationStream.AppendLine("#endif /* OS_DEBUG_EN */");
			
            HGenerationStream.AppendLine();

            HGenerationStream.AppendLine("#endif /* OS_MCAL_CFG_H_ */");

            HGenerationStream.AppendLine();

            AddHFileFooter();

            CompleteHFile();
        }

		private void GenerateHTypesFile()
		{
			/* Generate Os_TypesCfg.h */
            /*******************************/

            AddHTypesFileHeader();
			HTypesGenerationStream.AppendLine("#ifndef OS_GENTYPESCFG_H_                   /* To avoid double inclusion */");
            HTypesGenerationStream.AppendLine("#define OS_GENTYPESCFG_H_");
            HTypesGenerationStream.AppendLine();
			/*check if OsMcal module is available*/
		
			HTypesGenerationStream.AppendLine("/*Define types*/");
			HTypesGenerationStream.AppendLine("/*[SWPS_SWS_MCALOS_00013], [SWPS_SWS_MCALOS_00014]*/");
			/*check the timer used and generate TickType and TickRefType */
			if(osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_SYSTICK_S32K"))
			{
				/*if SysTick timer is used, TickType is on 32 bits*/
				HTypesGenerationStream.AppendLine("typedef U32 TickType;/* Type for the counter which is incremented every OS tick*/");
				HTypesGenerationStream.AppendLine("typedef U32 Os_CounterType; /* Type of the OS counter */");
			}
			else
			{
				if ((osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_OSTM0_RH850"))
					|| (osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_RJ_RL78")) || (osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_BSW_GPT")))
					{
						/*if OSTM0 timer or RJ timer or a GPT timer are used, TickType is on 16 bits*/
						HTypesGenerationStream.AppendLine("typedef U16 TickType;/* Type for the counter which is incremented every OS tick*/");
						HTypesGenerationStream.AppendLine("typedef U16 Os_CounterType; /* Type of the OS counter */");
					}
				else
				{
					if(osTickNode.GetAttribute("OsSelectTimerInterface").Equals("OS_TIMER_EXTERNAL"))
					{
						/*in case an external timer is used*/
						HTypesGenerationStream.AppendLine("typedef U16 TickType;/* Type for the counter which is incremented every OS tick*/");
						HTypesGenerationStream.AppendLine("typedef U16 Os_CounterType; /* Type of the OS counter */");
					}
				}
			}
			HTypesGenerationStream.AppendLine("#endif /* OS_GENTYPESCFG_H_ */");
			HTypesGenerationStream.AppendLine();
			AddHTypesFileFooter();
			CompleteHTypesFile();
			
		}
		
		private void GenerateSFile()
        {
			AddSFileHeader();
			SGenerationStream.AppendLine();
			SGenerationStream.AppendLine("    MODULE interrupts.s");
			SGenerationStream.AppendLine("	EXTERN Os_CheckAlarms");
			SGenerationStream.AppendLine("	EXTERN Os_ContextSaved_BO");
			SGenerationStream.AppendLine("	PUBLIC PendSV_Handler");
			SGenerationStream.AppendLine("	PUBLIC SVC_Handler");
			SGenerationStream.AppendLine("	SECTION .text : CODE (2)");
			SGenerationStream.AppendLine();
			SGenerationStream.AppendLine(S_PENDSV_HEADER);
			SGenerationStream.Append(S_PENDSV_CODE);
			SGenerationStream.AppendLine(S_SVCALL_HEADER);
			SGenerationStream.Append(S_SVCALL_CODE);
			SGenerationStream.AppendLine("	END");
			
			AddSFileFooter();
            CompleteSFile();
			
		}
        public string Generate()
        { 
            GenerateHFile();
			if((osGeneral.GetAttribute("OsControllerFamily").Equals("S32K")))
			{
				GenerateSFile();
			}
			GenerateHTypesFile();
            return "OK";
        }
	}
}
