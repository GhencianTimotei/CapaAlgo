/* polyspace MISRA-C3:1.1 [Justified:Low] "The defined macros are controller specific macros from registers header file" */
/*!
 * \defgroup Os Mcal (Os_Mcal.c) Mod Os Mcal functions
 * \{
 ******************************************************************************
 * \image html "Kopf_oZusatz_A4hoch_4C.jpg"
 *
 * \par Module Owner:
 * Huf Group
 *
 * \par Initial Project:
 * 1656.001 BSW
 *
 ******************************************************************************
 * \par Description:
 *  Operating System, MCAL Layer
 *
 ******************************************************************************
 *
 * %PCMS_HEADER_SUBSTITUTION_START:%
 *
 * Configuration Management Information Log (generated by Dimensions CM)
 *
 *
 * CM Item: %PID:%
 * Item name: %PM:%
 * Location: %ARCHIVE:%
 * Revision: %PR:%
 * Date: %DATE:%
 * Author: %AUTHOR:%
 *
 * %PCMS_HEADER_SUBSTITUTION_END:% *
 ******************************************************************************
 *
 * \par Layer:
 *  MCAL
 *
 * \par Compiler dialect:
 *  C99
 *
 * \par Controller:
 *  RL78/RH850/S32X
 *
 * \par Estimated resources:
 * | Resource | Amount   | Remarks         |
 * | ---------| -------- | ----------------|
 * | ROM      | x Byte   | on x controller |
 * | RAM      | y Byte   | on x controller |
 * | NVRAM    | z Byte   | on x controller |
 * | Runtime Init | X ms |                 |
 * | Runtime Task | X ms |                 |
 *
 ******************************************************************************/

/* Provide interface */
/* ----------------- */
#include "Os_Mcal.h"

/* Used interfaces from other modules */

/* Private function macros, types and data */
/* ---------------------------------------------------- */
#if (OS_TIMER_SOURCE == OS_TIMER_OSTM0_RH850)
#define OS_INTOSTM0_MASK_U32           (U32)0xFFFFFFFFu
#define OS_TABLE_INTERRUPT_U16         (U16)0x0040u
#define OS_INTERRUPT_LEVEL_U16         (U16)0xFFF0u
#define OS_OSTM0_CTRL_REGISTER_U8      (U8)0x00u
#define OS_START_TIMER_U8              (U8)0x01u
#define OS_STOP_TIMER_U8               (U8)0x01u
#endif /* #if (OS_TIMER_SOURCE == OS_TIMER_OSTM0_RH850) */

/* Private data-types */

/* Variable definition */
#if (STD_OFF != OS_SAVE_CONTEXT_ON_STACK)
/* polyspace +3 MISRA-C3:8.7 [Justified:Low] "Variables used into assembly instructions, they can not be static" */
/* polyspace +2 MISRA-C3:8.4 [Justified:Low] "The variable is declared into the assembly file where the interrupt handlers are defined." */
/* Flag used to detect if the context was saved on stack and not restored yet */
volatile boolean Os_ContextSaved_BO = (boolean)FALSE;
#endif

/* Flag used to detect if OS tick variable shall count ticks or not
 * It depends on OS Scheduler from OS SERV module */
static boolean Os_TickRunning = (boolean)FALSE;

/* OS Tick counter */
volatile Os_CounterType Os_TickCounter = 0u;

#if ((STD_OFF != OS_SAVE_CONTEXT_ON_STACK) && (OS_CONTROLLER_FAMILY == OS_RL78))
/* polyspace +3 MISRA-C3:8.7 [Justified:Low] "Variables used into assembly instructions, they can not be static" */
/* variables used to save Os_CheckAlarms() function address */
U16 Os_HighAddrOsFunc;
U16 Os_LowAddrOsFunc;

/* Private functions declaration */
static void Os_CheckAlarms(void);
#endif /* ((STD_OFF != OS_SAVE_CONTEXT_ON_STACK) && (OS_CONTROLLER_FAMILY == OS_RL78)) */

/*--------------------------------------------------------
-------------  FUNCTIONS IMPLEMENTATION  -----------------
--------------------------------------------------------*/

/* -------- Private functions implementation ---------- */

#if (STD_ON == OS_SAVE_CONTEXT_ON_STACK)
/*!
 ******************************************************************************
 * \brief
 * Evaluate/update alarms and restores the context
 *
 * \details
 * This function is used in case background task is enabled. It is pushed on
 * stack into tick interrupt and is executed after exiting from the interrupt.
 * It evaluates the alarms and for RL78 it restores the context before interrupt
 * happened and for S32K controller it sets to pending the SVCall exception which
 * will restore the context.
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         Reentrant
 *
 * \pre           -
 * \post          -
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *
 *   \glob_item{in,  Os_HighAddrOsFunc, Os_LowAddrOsFunc global variable used}
 *
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        PDES-BSW
 * \version       1.0
 * \date          04.09.2019
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 04.09.2019, PDES-BSW:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/*[SWPS_SWS_MCALOS_00039]*/
#if(OS_CONTROLLER_FAMILY == OS_RL78)
static void Os_CheckAlarms(void)
#elif(OS_CONTROLLER_FAMILY == OS_S32K)
void Os_CheckAlarms(void)
#endif
{
   OS_CHECK_ALARMS_FUNCTION();
   /* Restore registers saved on stack */
   OS_DISABLE_INTERRUPT();
#if (OS_CONTROLLER_FAMILY == OS_RL78)
   /* Set Os_ContextSaved_BO to FALSE - the context will be restored */
   Os_ContextSaved_BO = FALSE;
#endif /* #if (OS_CONTROLLER_FAMILY == OS_RL78) */
   /*[SWPS_SWS_MCALOS_00040]*/
   OS_RESTORE_CONTEXT();
   OS_ENABLE_INTERRUPT();
}
#endif

/* -------- Extern functions implementation ------------ */
/*!
 ******************************************************************************
 * \brief
 * Initialize MCAL OS
 *
 * \details
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         Non Reentrant
 *
 * \pre           -
 * \post          -
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *
 *   \glob_item{out, Os_HighAddrOsFunc, sets high address of Os_CheckAlarms function}
 *   \glob_item{out, Os_LowAddrOsFunc, sets low address of Os_CheckAlarms function}
 *   \glob_item{out, Os_TickCounter, initialize counter with 0}
 *
 * \glob_end
 *
 * \returns        void
 *******************************************************************************
 *
 * \author        PDES-BSW
 * \version       1.0
 * \date          19.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 04.09.2019, PDES-BSW:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks: It is called by OS into Os_Init() function
 ******************************************************************************/
void Os_InitMcal(void) /*[SWPS_SWS_MCALOS_00015]*/
{
   /*[SWPS_SWS_MCALOS_00016]*/
   Os_TickCounter = 0u;
#if ((STD_OFF != OS_SAVE_CONTEXT_ON_STACK) && (OS_CONTROLLER_FAMILY == OS_RL78))
   /* polyspace +2 MISRA-C3:11.1 [Justified:Low] "Function address is needed" */
   Os_HighAddrOsFunc = (U16)(((U32)(&Os_CheckAlarms) & 0xFF0000u) >> 16u);
   Os_LowAddrOsFunc = (U16)(((U32)&Os_CheckAlarms) & 0x00FFFFu);
#endif /* (STD_OFF != OS_SAVE_CONTEXT_ON_STACK) && (OS_CONTROLLER_FAMILY == OS_RL78) */
}


#if ((OS_TIMER_SOURCE == OS_TIMER_RJ_RL78) || (OS_TIMER_SOURCE == OS_TIMER_BSW_GPT))
/*!
 ******************************************************************************
 * \brief
 * Initialise OS timer source
 * \details
 * Initialise RL78 timer RJ or enables GPT timer interrupt if they are configured to be
 * used for OS tick
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         Non Reentrant
 *
 * \pre           -
 * \post          -
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *
 * \glob_end
 *
 * \returns        void
 *******************************************************************************
 *
 * \author        PDES-BSW
 * \version       1.0
 * \date          04.09.2019
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 04.09.2019, PDES-BSW:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* polyspace +1 MISRA-C3:5.1 [Justified:Low] "C99 standard is used to compile, Huf naming convention" */
void Os_TimerInit(void) /*[SWPS_SWS_MCALOS_00012], [SWPS_SWS_MCALOS_00017]*/
{
   /*[SWPS_SWS_MCALOS_00018]*/
   /* MCU makes the initial configurations: peripheral enable, clock source selection */

#ifdef SAFETY_SFR_GUARD
#if(SAFETY_SFR_GUARD == STD_ON)
   (void)SafetyDisableSFRGuard(SAFETY_SFRGUARD_INT); /*disable SFR guard*/
#endif /* SAFETY_SFR_GUARD */
#endif /* SAFETY_SFR_GUARD */

   /* unmask the Timer interrupt */
   OS_ENABLE_TIMER_INT();

#ifdef SAFETY_SFR_GUARD
#if(SAFETY_SFR_GUARD == STD_ON)
   (void)SafetyEnableSFRGuard(SAFETY_SFRGUARD_INT); /*enable SFR guard*/
#endif /* SAFETY_SFR_GUARD */
#endif /* SAFETY_SFR_GUARD */

#if (OS_TIMER_SOURCE == OS_TIMER_RJ_RL78)
   /* set Timer RJ mode as Timer mode */
   TRJMR0 &= (U8)0xF0;
   /* load the compare value in the Reload Register */
   TRJ0 = OS_TIMER_TICKS - 1u;
#endif /* #if (OS_TIMER_SOURCE == OS_TIMER_RJ_RL78) */
}
#endif /* #if ((OS_TIMER_SOURCE == OS_TIMER_RJ_RL78) || (OS_TIMER_SOURCE == OS_TIMER_BSW_GPT)) */

#if (OS_TIMER_SOURCE == OS_TIMER_OSTM0_RH850)
/*!
 ******************************************************************************
 * \brief
 * Initialise OS timer source
 * \details
 * Initialise OSTM timer of RH850 F1L controller if it is configured to be
 * used for OS tick
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         Non Reentrant
 *
 * \pre           -
 * \post          -
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *
 * \glob_end
 *
 * \returns        void
 *******************************************************************************
 *
 * \author        PDES-BSW
 * \version       1.0
 * \date          27.05.2020
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 27.05.2020, PDES-BSW:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* polyspace +1 MISRA-C3:5.1 [Justified:Low] "C99 standard is used to compile, Huf naming convention" */
void Os_TimerInit(void) /*[SWPS_SWS_MCALOS_00012], [SWPS_SWS_MCALOS_00017] */
{
   /*[SWPS_SWS_MCALOS_00018]*/
   /* MCU makes the initial configurations: peripheral enable, clock source selection */

   FEINTFMSK &= OS_INTOSTM0_MASK_U32;    /* Set INTOSTM0 Interrupt Mask: disable FE INTOSTM0 */
   ICOSTM0 |= OS_TABLE_INTERRUPT_U16;      /* Table interrupt is enabled by setting the table bit to 1 */
   OS_ENABLE_TIMER_INT();                /* unmask the Timer interrupt */

   /* Timer OSTM0 Configuration */
   OSTM0CTL = OS_OSTM0_CTRL_REGISTER_U8; /* Timer OSTM0 Control Register, Interval Timer Mode */
   OSTM0CMP = OS_TIMER_TICKS - 1u;       /*  load the value in the Compare Register */

   /* highest interrupt level */
   ICOSTM0 &= OS_INTERRUPT_LEVEL_U16;
}
#endif /* #if (OS_TIMER_SOURCE == OS_TIMER_OSTM0_RH850) */

#if (OS_TIMER_SOURCE == OS_TIMER_SYSTICK_S32K)
/*!
 ******************************************************************************
 * \brief
 * Initialise OS timer source
 * \details
 * Initialise SysTick timer of S32K controller if it is configured to be
 * used for OS tick
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         Non Reentrant
 *
 * \pre           -
 * \post          -
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *
 * \glob_end
 *
 * \returns        void
 *******************************************************************************
 *
 * \author        PDES-BSW
 * \version       1.0
 * \date          23.02.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 23.02.2021, PDES-BSW:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* polyspace +1 MISRA-C3:5.1 [Justified:Low] "C99 standard is used to compile, Huf naming convention" */
void Os_TimerInit(void) /*[SWPS_SWS_MCALOS_00012], [SWPS_SWS_MCALOS_00017] */
{
   /*[SWPS_SWS_MCALOS_00018]*/
   /* MCU makes the initial configurations: peripheral enable, clock source selection */

   /* Disable SysTick */
   REG_BIT_CLEAR32(SYSTICK_CSR_BASE_ADDRS, SYSTICK_CSR_TICKINT_MASK);
   /* Program Reload value register */
   REG_WRITE32(SYSTICK_RVR_BASE_ADDRS, OS_TIMER_TICKS - 1u);
   /* Clear current value register */
   REG_WRITE32(SYSTICK_CVR_BASE_ADDRS, 0u);
   /* Set processor clock as source clock and enable the SysTick Interrupt */
   REG_BIT_SET32(SYSTICK_CSR_BASE_ADDRS,(SYSTICK_CSR_CLKSOURCE_MASK | SYSTICK_CSR_TICKINT_MASK));
}
#endif /*OS_TIMER_SYSTICK_S32K*/
#if ((OS_TIMER_SOURCE == OS_TIMER_RJ_RL78) || (OS_TIMER_SOURCE == OS_TIMER_BSW_GPT))
/*!
 ******************************************************************************
 * \brief
 * Start timer used for OS tick
 *
 * \details
 * This function is able to start RL78 Timer RJ or a RL78 BSW GPT timer
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         Non Reentrant
 *
 * \pre           -
 * \post          -
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *
 * \glob_end
 *
 * \returns        void
 ********************************************************************************
 *
 * \author        PDES-BSW
 * \version       1.0
 * \date          04.09.2019
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 04.09.2019, PDES-BSW:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* polyspace +1 MISRA-C3:5.1 [Justified:Low] "C99 standard is used to compile, Huf naming convention" */
void Os_TimerStart(void) /*[SWPS_SWS_MCALOS_00004],  [SWPS_SWS_MCALOS_00019] */
{
   /*[SWPS_SWS_MCALOS_00020]*/
#ifdef SAFETY_SFR_GUARD
#if(SAFETY_SFR_GUARD == STD_ON)
   (void)SafetyDisableSFRGuard(SAFETY_SFRGUARD_INT);
#endif
#endif
   /* clear timer interrupt before starting the timer counting */
   OS_CLEAR_TIMER_PENDING_INT();
#ifdef SAFETY_SFR_GUARD
#if(SAFETY_SFR_GUARD == STD_ON)
   (void)SafetyEnableSFRGuard(SAFETY_SFRGUARD_INT); /*enable SFR guard*/
#endif /* SAFETY_SFR_GUARD */
#endif /* SAFETY_SFR_GUARD */

#if (OS_TIMER_SOURCE == OS_TIMER_RJ_RL78)
   /* start Timer RJ counting */
   TRJCR0 |= 0x01u;
#endif /* #if (OS_TIMER_SOURCE == OS_TIMER_RJ_RL78) */

#if (OS_TIMER_SOURCE == OS_TIMER_BSW_GPT)
   Gpt_StartTimer(OS_GPT_TIMER, OS_TIMER_TICKS);
#endif /* #if (OS_TIMER_SOURCE == OS_TIMER_BSW_GPT) */
}
#endif /* #if ((OS_TIMER_SOURCE == OS_TIMER_RJ_RL78) || (OS_TIMER_SOURCE == OS_TIMER_BSW_GPT)) */

#if (OS_TIMER_SOURCE == OS_TIMER_OSTM0_RH850)
/*!
 ******************************************************************************
 * \brief
 * Start timer used for OS tick
 *
 * \details
 * This function is able to start RH850 OSMT0 Timer
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         Non Reentrant
 *
 * \pre           -
 * \post          -
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *
 * \glob_end
 *
 * \returns        void
 ********************************************************************************
 *
 * \author        PDES-BSW
 * \version       1.0
 * \date          27.05.2020
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 27.05.2020, PDES-BSW:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* polyspace +1 MISRA-C3:5.1 [Justified:Low] "C99 standard is used to compile, Huf naming convention" */
void Os_TimerStart(void) /*[SWPS_SWS_MCALOS_00004],  [SWPS_SWS_MCALOS_00019]*/
{
   /*[SWPS_SWS_MCALOS_00020]*/
   /* clear timer interrupt before starting the timer counting */
   OS_CLEAR_TIMER_PENDING_INT();

   OSTM0TS = OS_START_TIMER_U8;    /* Set Timer Start Trigger Register */
}
#endif /* #if (OS_TIMER_SOURCE == OS_TIMER_OSTM0_RH850) */

#if (OS_TIMER_SOURCE == OS_TIMER_SYSTICK_S32K)
/*!
 ******************************************************************************
 * \brief
 * Start timer used for OS tick
 *
 * \details
 * This function is able to start SysTick Timer for S32K controller.
 * When setting the ENABLE bit to 1, the counter loads the RELOAD value from the
 * SYST_RVR register into the SYST_CVR(current value register) and then counts down.
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         Non Reentrant
 *
 * \pre           -
 * \post          -
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *
 * \glob_end
 *
 * \returns        void
 ********************************************************************************
 *
 * \author        PDES-BSW
 * \version       1.0
 * \date          23.02.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 23.02.2021, PDES-BSW:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* polyspace +1 MISRA-C3:5.1 [Justified:Low] "C99 standard is used to compile, Huf naming convention" */
void Os_TimerStart(void) /*[SWPS_SWS_MCALOS_00004],  [SWPS_SWS_MCALOS_00019]*/
{
   /*[SWPS_SWS_MCALOS_00020]*/
   /* Clear timer interrupt before starting the timer counting */
   OS_CLEAR_TIMER_PENDING_INT();
   /*Start SysTick counting*/
   REG_BIT_SET32(SYSTICK_CSR_BASE_ADDRS, SYSTICK_CSR_ENABLE_MASK);
}
#endif /*OS_TIMER_SYSTICK_S32K*/

#if ((OS_TIMER_SOURCE == OS_TIMER_RJ_RL78) || (OS_TIMER_SOURCE == OS_TIMER_BSW_GPT))
/*!
 ******************************************************************************
 * \brief
 * Stop timer used for OS tick
 *
 * \details
 * This function is able to stop RL78 Timer RJ or a RL78 BSW GPT timer
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         Non Reentrant
 *
 * \pre           -
 * \post          -
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *
 * \glob_end
 *
 * \returns        void
 ********************************************************************************
 *
 * \author        PDES-BSW
 * \version       1.0
 * \date          15.10.2019
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 15.10.2019, PDES-BSW:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* polyspace +1 MISRA-C3:5.1 [Justified:Low] "C99 standard is used to compile, Huf naming convention" */
void Os_TimerStop(void) /*[SWPS_SWS_MCALOS_00005], [SWPS_SWS_MCALOS_00021]*/
{
   /*[SWPS_SWS_MCALOS_00022]*/
#if (OS_TIMER_SOURCE == OS_TIMER_RJ_RL78)
   /* stop Timer RJ counting */
   TRJCR0 &= 0xFEu;
#endif /* #if (OS_TIMER_SOURCE == OS_TIMER_RJ_RL78) */

#if (OS_TIMER_SOURCE == OS_TIMER_BSW_GPT)
   Gpt_StopTimer(OS_GPT_TIMER);
#endif /* #if (OS_TIMER_SOURCE == OS_TIMER_BSW_GPT) */
}
#endif /* #if ((OS_TIMER_SOURCE == OS_TIMER_RJ_RL78) || (OS_TIMER_SOURCE == OS_TIMER_BSW_GPT)) */

#if (OS_TIMER_SOURCE == OS_TIMER_OSTM0_RH850)
/*!
 ******************************************************************************
 * \brief
 * Stop timer used for OS tick
 *
 * \details
 * This function is able to stop RH850 OSMT0 Timer
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         Non Reentrant
 *
 * \pre           -
 * \post          -
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *
 * \glob_end
 *
 * \returns        void
 ********************************************************************************
 *
 * \author        PDES-BSW
 * \version       1.0
 * \date          27.05.2020
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 27.05.2020, PDES-BSW:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* polyspace +1 MISRA-C3:5.1 [Justified:Low] "C99 standard is used to compile, Huf naming convention" */
void Os_TimerStop(void) /*[SWPS_SWS_MCALOS_00005], [SWPS_SWS_MCALOS_00021] */
{
   /*[SWPS_SWS_MCALOS_00022]*/
   OSTM0TT = OS_STOP_TIMER_U8;    /* Clear Timer Start Trigger Register */
}
#endif /* #if (OS_TIMER_SOURCE == OS_TIMER_OSTM0_RH850)  */

#if (OS_TIMER_SOURCE == OS_TIMER_SYSTICK_S32K)
/*!
 ******************************************************************************
 * \brief
 * Stop timer used for OS tick
 *
 * \details
 * This function is able to stop SysTick timer for S32K controller
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         Non Reentrant
 *
 * \pre           -
 * \post          -
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *
 * \glob_end
 *
 * \returns        void
 ********************************************************************************
 *
 * \author        PDES-BSW
 * \version       1.0
 * \date          23.02.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 23.02.2021, PDES-BSW:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* polyspace +1 MISRA-C3:5.1 [Justified:Low] "C99 standard is used to compile, Huf naming convention" */
void Os_TimerStop(void) /*[SWPS_SWS_MCALOS_00005], [SWPS_SWS_MCALOS_00021]*/
{
   /*[SWPS_SWS_MCALOS_00022]*/
   /*Stop SysTick counting*/
   REG_BIT_CLEAR32(SYSTICK_CSR_BASE_ADDRS, SYSTICK_CSR_ENABLE_MASK);
}
#endif /*OS_TIMER_SYSTICK_S32K*/

/*!
 ******************************************************************************
 * \brief
 * Sets tick counting status
 *
 * \details
 * This function is called by OS SERV module to inform MCAL module about the state
 * of the alarms
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         Non Reentrant
 *
 * \pre           -
 * \post          -
 *
 * \param[out]     void
 * \param[in]      OS_AlarmStarted - TRUE - alarms are started
 *                                 - FALSE - alarms are stopped
 * \glob_start
 *   \glob_item{out,  Os_TickRunning, sets it to TRUE or FALSE depending of OS Scheduler state}
 * \glob_end
 *
 * \returns        void
 ********************************************************************************
 *
 * \author        PDES-BSW
 * \version       1.0
 * \date          04.09.2019
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 04.09.2019, PDES-BSW:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
void Os_SetTickStatus(boolean OS_AlarmStarted) /*[SWPS_SWS_MCALOS_00023]*/
{
   /*[SWPS_SWS_MCALOS_00024]*/
   Os_TickRunning = OS_AlarmStarted;
}

/*!
 ******************************************************************************
 * \brief
 * ISR for OS tick
 *
 * \details
 *
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         Non reentrant
 *
 * \pre           -
 * \post          -
 *
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  Os_TickRunning, if TRUE, Os_TickCounter is incremented}
 *   \glob_item{out, Os_TickCounter, OS tick counter is incremented by 1}
 * \glob_end
 *
 * \returns        void
 ********************************************************************************
 *
 * \author        PDES-BSW
 * \version       1.0
 * \date          20.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 04.09.2019, PDES-BSW:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
#if USE_PRAGMA == TRUE
#pragma vector = INTTRJ0_vect
#endif
/* polyspace +1 MISRA-C3:8.4,8.5 [Justified:Low] "Declared into interrupt vector related file" */
ISR(Os_ISR_Tick) /*[SWPS_SWS_MCALOS_00003], [SWPS_SWS_MCALOS_00030] */
{
   /* polyspace +1 RTE:UNR [Not a defect:Unset] "Variable is false when GetResource is called(used into LPM); otherwise it's always true after initialization." */
   if((boolean)FALSE != Os_TickRunning)
   {
      /* If background task is OFF there is no preemption */
#if (STD_OFF != OS_SAVE_CONTEXT_ON_STACK)
      /* Interrupts are disabled, but multiple servicing is possible ( level 0, 1 and 2) */
      /* Save context */
      /*[SWPS_SWS_MCALOS_00034]*/
#if (OS_CONTROLLER_FAMILY == OS_RL78)
      /* Check whether a context was already been saved on the stack and not restored.
       * This way is avoided the corruption of the stack in case of high interrupt load. */
      if(FALSE == Os_ContextSaved_BO)
      {
         /* Save the context. */
         OS_SAVE_CONTEXT();
         /* Set Os_ContextSaved_BO to TRUE - the context was saved on stack. */
         Os_ContextSaved_BO = TRUE;
      }
      /* polyspace +2 RTE:UNR [Not a defect:Unset] "The code is reached when background mode is enabled for RL78 and the context was already saved, but not restored." */
      else
      {
         /* Do nothing; a context was already saved. */
      }
#elif (OS_CONTROLLER_FAMILY == OS_S32K)
      /* Save the context. */
      OS_SAVE_CONTEXT();
#endif /* #if (OS_CONTROLLER_FAMILY == OS_RL78) */
#endif /* OS_SAVE_CONTEXT_ON_STACK */
      /* polyspace +1 RTE:OVFL MISRA-C3:D4.1 [Not a defect:Unset] "The overflow is intended; the variable is used to store the ticks of the OS and overflow does not affect the functionality of the program" */
      Os_TickCounter++; /*[SWPS_SWS_MCALOS_00031]*/
   }
#if (STD_OFF != OS_ISR_USED_IN_SLEEP_MODE)
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "The code is reachable when the alarms are stopped and the ISR is enabled to be used in sleep mode." */
   else
   {
      /*[SWPS_SWS_MCALOS_00032], [SWPS_SWS_MCALOS_00033]*/
      OS_SLEEP_MODE_CALLOUT_INTERFACE();
   }
#endif
#if(STD_OFF != OS_DEBUG_EN)
   OS_TICK_PIN_TOGGLE();
#endif /* OS_DEBUG_EN */
}

/* %PCMS_HEADER_SUBSTITUTION_START:%
 ******************************************************************************
 * Document Management Information Log (generated by Dimensions CM)
 *
 * Description:
 * %PD:%
 *
 * Used by Baselines:
 * %PIRB:%
 *
 * Used by Dimensions CM Projects:
 * %PIRW:%
 *
 * Change History:
 * %PL:%
 *
 * %PCMS_HEADER_SUBSTITUTION_END:%
 */
