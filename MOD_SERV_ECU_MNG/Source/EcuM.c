/*
 *!
 * \defgroup <module_group (MOD_) Module purpose>
 * \{
 ******************************************************************************
 * \image html "Kopf_oZusatz_A4hoch_4C.jpg"
 *
 * \par Module Owner:
 *   Huf Huelsbeck & Fuerst GmbH & Co. KG \n
 *   Steeger Str. 17 \n
 *   42551 Velbert \n
 *   Department PDE-S
 *
 ******************************************************************************
 *
 * \par Purpose:
 *    Ecu Manager service, Service Layer (AUTOSAR 4.2)
 *
 * \par Compiler:
 *    IAR
 *
 * \par Controller:
 *    Independent
 *
 * \par Resources:
 *    | Resource      | Amount    | Remarks     |
 *    | ------------- | --------: | ----------- |
 *    | CODE          |    x Byte |             |
 *    | ROM           |    x Byte |             |
 *    | RAM           |    x Byte |             |
 *    | EEPROM        |    x Byte |             |
 *    | Runtime Init  |    X ms   |             |
 *    | Runtime Task  |    X ms   |             |
 *
 * \par Quality:
 *    | Factor            | Excl  | Good  | Fair  | Poor  |
 *    | ----------------- | ----: | ----: | ----: | ----: |
 *    | _Maintainability_ |   0 % |   0 % |   0 % |   0 % |
 *    | Analyzability     |   0 % |   0 % |   0 % |   0 % |
 *    | Changeability     |   0 % |   0 % |   0 % |   0 % |
 *    | Stability         |   0 % |   0 % |   0 % |   0 % |
 *    | Testability       |   0 % |   0 % |   0 % |   0 % |
 *
 * \par MISRA rules violations:
 *     \li
 *
 ******************************************************************************
 *
 * \attention
 *   \li text for Information, to do ..
 *
 ******************************************************************************
 * %PCMS_HEADER_SUBSTITUTION_START:%
 *
 * Document Management Information Log (generated by Dimensions CM)
 *
 *
 *  CM Item:   %PID:%
 *  Itemname:   %PM:%
 *  Location:  %ARCHIVE:%
 *  Revision:  %PR:%
 *  Date:      %DATE:%
 *  Author:    %AUTHOR:%
 *
 * %PCMS_HEADER_SUBSTITUTION_END:%
 *
 ******************************************************************************/


/*!
 \defgroup module_group_det Details
 \ingroup module_group
 \{
 */


/* Provide interface */
/* ----------------- */
#include "EcuM.h"

/* Used interfaces from other modules */
#include "Mcu.h"

#if(ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
#include "Det.h"
#endif

#if (ECUM_NVM_WRITE_ALL_ENABLED == STD_ON)
#include "NvM.h"
#endif /*ECUM_NVM_WRITE_ALL_ENABLED == STD_ON*/

#if (ECUM_INCLUDE_COMM_CFG == STD_ON)
#include "ComM_EcuMBswM.h"
#include "ComM.h"
#endif /*ECUM_INCLUDE_COMM_CFG == STD_ON*/

/* Private function macros, types and data */
/* ---------------------------------------------------- */
/* PRIVATE MACROS AND CONSTANTS DEFINITION TO BE DONE IN THE CONFIG HEADER */

# define ECUM_U16_TIMER_EXPIRED                   (U16)(0x00u)
/* polyspace-begin MISRA-C3:D4.9 [Not a defect:Unset] "Macro used to facilitate easier configuration." */
# define ECUM_SET_TIMER(timer, value)             timer = value
# define ECUM_GET_TIMER(timer)                    timer
# define ECUM_DECREMENT_TIMER(timer)              timer--
/* polyspace-end MISRA-C3:D4.9 [Not a defect:Unset] "Macro used to facilitate easier configuration." */

#define ECUM_NO_RUN_REQUESTS          (U32)(0x00u)
#define ECUM_NO_POST_RUN_REQUESTS     (U32)(0x00u)

#define ECUM_INTENDED_RESTART_FLAG_VALUE      (U16) (0x5AA5)

/* Private data-types */

/* Variable definition */
static EcuM_ModeType EcuM_CurrentMode = ECUM_UNINITIALIZED;
static EcuM_WakeupSourceType EcuM_ValidatedWakeups = ECUM_WKSOURCE_NONE;
static EcuM_WakeupSourceType EcuM_EnabledWakeups = ECUM_WKSOURCE_NONE;
static EcuM_StateType EcuM_State;
static EcuM_StateType EcuM_NextState;
static EcuM_StateType EcuM_ShutdownTarget;
static U8 EcuM_ShutdownMode;
static U32 EcuM_U32_RunRequests;                  /* each set bit represents an EcuM user from EcuM_UserType which have requested EcuM RUN state */
static U32 EcuM_U32_PostRunRequests;              /* each set bit represents an EcuM user from EcuM_UserType which have requested EcuM POST RUN state */
static U16 EcuM_U16_Timer;
static BOOL EcuM_BO_KillAllRunRequestsInProgress;
static BOOL EcuM_BO_KillAllPostRunRequestsInProgress;
static BOOL EcuM_BO_Initialised;                  /* TRUE - if EcuM_Init was called , FALSE - if EcuM_Init was not called */
static BOOL EcuM_EnableLowPowerManager;
/* store last shutdown target and mode into noinit RAM */
#define ECUM_LAST_SHUTDOWN_TARGET_START_SEC_VAR
/* polyspace-begin MISRA-C3:20.1 [Not a defect:Unset] "The file inclusion is used for memory mapping." */
#include "EcuM_MemMap.h"
static EcuM_StateType EcuM_LastShutdownTarget;
#define ECUM_LAST_SHUTDOWN_TARGET_STOP_SEC_VAR
#include "EcuM_MemMap.h"

#define ECUM_LAST_SHUTDOWN_MODE_START_SEC_VAR
#include "EcuM_MemMap.h"
static U8 EcuM_LastShutdownMode;
#define ECUM_LAST_SHUTDOWN_MODE_STOP_SEC_VAR
#include "EcuM_MemMap.h"

#define ECUM_INTENDED_RESTART_FLAG_START_SEC_VAR
#include "EcuM_MemMap.h"
static U16 EcuM_U16_IntendedRestartFlag;
#define ECUM_INTENDED_RESTART_FLAG_STOP_SEC_VAR
#include "EcuM_MemMap.h"
/* polyspace-end MISRA-C3:20.1 [Not a defect:Unset] "The file inclusion is used for memory mapping." */

#if (ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
static EcuM_WakeupSourceType EcuM_PendingWakeups = ECUM_WKSOURCE_NONE;
static EcuM_WakeupSourceType EcuM_ExpiredWakeups = ECUM_WKSOURCE_NONE;
static EcuM_WakeupSourceType EcuM_PendingStartWakeups = ECUM_WKSOURCE_NONE;
static U16 EcuM_U16_ValidationTimer = ECUM_U16_TIMER_EXPIRED;
#endif

/* Private functions declaration */
static void EcuM_StartupTwo(void);
static void EcuM_StateMachine(void);
static void EcuM_Internal_App_Run(void);
static void EcuM_Internal_Go_Sleep(void);
static void EcuM_Internal_Sleep(void);
static void EcuM_Internal_Go_Off_One(void);
static void EcuM_Internal_Wakeup_One(void);
#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
static void EcuM_Internal_Wakeup_Validation(void);
static void EcuM_Internal_Wakeup_Reaction(void);
#endif

/*--------------------------------------------------------
-------------  FUNCTIONS IMPLEMENTATION  -----------------
--------------------------------------------------------*/
/* polyspace-begin MISRA-C3:5.1 [Justified:Unset] "C99 standard is used to compile, Autosar naming convention." */
/* -------- Extern functions implementation ------------ */

/* [SWS_EcuM_02813] */
#if(ECUM_VERSION_INFO_API_ENABLED == STD_ON)
/*!
 ******************************************************************************
 * \brief
 * Returns the version information of this module.
 *
 * \details
 * If ECUM_DEV_ERROR_DETECT_ENABLED is STD_ON and versioninfo is a NULL pointer,
 * ECUM_E_NULL_POINTER error will be send to DET
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     versioninfo - Pointer to where to store the version information of this module.
 * \param[in]      void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
void EcuM_GetVersionInfo(Std_VersionInfoType* versioninfo)
{
#if(ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
   /* [SWS_EcuMf_00034], [BSW_SWS_EcuMf_00002] */
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "Code is reached when function is called with NULL pointer parameter" */
   if (NULL == versioninfo)
   {
      Det_ReportErrorStatus(EventId,ECUM_E_NULL_POINTER);
   }
   else
#endif
   {
      /* polyspace +6 MISRA-C3:D4.14 [Not a defect:Unset] "Parameter is checked when ECUM_DEV_ERROR_DETECT_ENABLED is STD_ON" */
      versioninfo->vendorID = (U16)ECUM_VENDOR_ID;
      versioninfo->moduleID = (U16)ECUM_MODULE_ID;

      versioninfo->sw_major_version = (U8)ECUM_SW_MAJOR_VERSION;
      versioninfo->sw_minor_version = (U8)ECUM_SW_MINOR_VERSION;
      versioninfo->sw_patch_version = (U8)ECUM_SW_PATCH_VERSION;
   }
}
#endif

/* [SWS_EcuM_02811] */
/*!
 ******************************************************************************
 * \brief
 * Initializes the ECU state manager and carries out the startup procedure.
 *
 * \details
 * If the wakeup was validated the execution will continue with RUN state otherwise
 * it will continue with WAKEUP VALIDATION state
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
void EcuM_Init(void)
{
#if (ECUM_RESET_REASON_OF_WAKEUP_ENABLE == STD_ON)
   U8 U8_Index;
   U8 U8_Index2;
   Mcu_ResetType EcuM_ResetReason;
#endif
   /* [SWS_EcuM_00749] */
   EcuM_CurrentMode = ECUM_STARTUP;
   ECUM_SET_TIMER(EcuM_U16_Timer,ECUM_U16_TIMER_EXPIRED);
   /* [SWS_EcuM_00600] */
   EcuM_BO_KillAllRunRequestsInProgress = ECUM_FALSE;
   /* [SWS_EcuMf_00103] */
   EcuM_BO_KillAllPostRunRequestsInProgress = ECUM_FALSE;
   EcuM_U32_RunRequests = 0x00;
   EcuM_U32_PostRunRequests = 0x00;
   EcuM_BO_Initialised = ECUM_TRUE;
   EcuM_EnableLowPowerManager = ECUM_FALSE;

#if (ECUM_CURRENT_MODE_CALLOUT == STD_ON)
   /* [SWS_EcuM_00750] */
   EcuM_OnModeChange(EcuM_CurrentMode);
#endif
   EcuM_State = ECUM_STATE_STARTUP;
   /* [SWS_EcuM_02411] */
#if(ECUM_CALLOUT_DRIVER_INIT_ZERO == STD_ON)
   EcuM_AL_DriverInitZero();
#endif

   EcuM_State = ECUM_STATE_STARTUP_ONE;
#if(ECUM_CALLOUT_DRIVER_INIT_ONE == STD_ON)
   EcuM_AL_DriverInitOne(&EcuM_Config_Set);
#endif

   /* [SWS_EcuM_02623] */
#if (ECUM_RESET_REASON_OF_WAKEUP_ENABLE == STD_ON)
   /* [SWS_EcuM_02858] */
   EcuM_ResetReason = Mcu_GetResetReason();
   /* map the reset reason to a wake up source */
   for (U8_Index = 0u; U8_Index < ECUM_NO_OF_RESET_REASONS; U8_Index ++)
   {
      if (EcuM_ResetReason == EcuM_ResetReasonWkpSources[U8_Index].EcuM_ResetReason)
      {
         for(U8_Index2 = 0u; U8_Index2 < ECUM_NO_OF_WAKEUP_SOURCES; U8_Index2 ++)
         {
            if (EcuM_WkpSourceValidation[U8_Index2].EcuM_WkpSource == EcuM_ResetReasonWkpSources[U8_Index].EcuM_WkpSource)
            {
#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
               /* polyspace +1 RTE:UNR DEFECT:USELESS_IF MISRA-C3:14.3 [Not a defect:Unset] "Condition is false when wakeup source needs validation and true if not" */
               if(ECUM_NO_VALIDATION_TIMEOUT == EcuM_WkpSourceValidation[U8_Index2].EcuM_ValidationTimeout)
               {
                  /* validate the wake up */
                  EcuM_ValidatedWakeups |= EcuM_ResetReasonWkpSources[U8_Index].EcuM_WkpSource;
               }
#else
               /* validate the wake up */
               EcuM_ValidatedWakeups |= EcuM_ResetReasonWkpSources[U8_Index].EcuM_WkpSource;
#endif
               break;
            }
         }
         break;
      }
#if (ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
      /* reset reason could not be mapped to a wake up source */
      if ((ECUM_NO_OF_RESET_REASONS - 1) == U8_Index)
      {
         /* [SWS_EcuM_02601] */
         EcuM_ValidatedWakeups |= ECUM_WKSOURCE_RESET;
      }
#endif
   }
#else
   EcuM_ValidatedWakeups |= ECUM_WKSOURCE_RESET;
#endif
   /* [SWS_EcuM_02181] */
   /* [SWS_EcuM_02411] */
   (void)EcuM_SelectShutdownTarget(ECUM_DEFAULT_SHUTDOWN_TARGET, ECUM_DEFAULT_SHUTDOWN_MODE);

   /* [SWS_EcuM_02603] */
   ECUM_START_OS() ;

   EcuM_StartupTwo();

   /* [SWS_EcuM_00632] */
#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
   /* polyspace +2 DEFECT:DEAD_CODE RTE:UNR MISRA-C3:2.1,14.3 [Not a defect:Unset] "Code is reached when when wakeup sources were not validated yet" */
   if (ECUM_WKSOURCE_NONE == EcuM_ValidatedWakeups)
   {
      /* the wake up needs to be validated - go to WAKEUP VALIDATION state */
      EcuM_NextState = ECUM_STATE_WAKEUP_VALIDATION;
   }
   else
#endif
   {
      /* the wake up was validated - go to RUN state */
      EcuM_NextState = ECUM_STATE_APP_RUN;
   }

   /* polyspace +2 RTE:UNR [Not a defect:Unset] "The variable is placed into a no init RAM section and is set in case an RESET shutdown target was requested by user" */
   if (ECUM_INTENDED_RESTART_FLAG_VALUE != EcuM_U16_IntendedRestartFlag)
   {
      /* it was not an reset, RAM memory was lost */
      EcuM_LastShutdownTarget = ECUM_STATE_OFF;
      EcuM_LastShutdownMode = ECUM_UNUSED_SLEEP_MODE;
   }
}

/* [SWS_EcuM_00328] */
/* [SWS_EcuM_02812] */
/*!
 ******************************************************************************
 * \brief
 * Typically called from the shutdown hook, this function takes over execution
 * control and will carry out GO OFF II activities.
 *
 * \details
 * It executes the GO OFF II activities depending of the selected shutdown target
 * (reset or switch off)
 * If a wakeup event is detected during this state the shutdown target will be changed
 * to reset
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* polyspace+1 MISRA-C3:D4.5 [Justified:Low] "No overlapping visibility" */
void EcuM_Shutdown(void)
{
   EcuM_State = ECUM_STATE_GO_OFF_TWO;
   /* polyspace+1 MISRA-C3:2.2 [Not a defect:Low] "Dummy implementation: This callout is called when entering to GO OFF II state" */
   EcuM_OnGoOffTwo();

   ECUM_DISABLE_ALL_INTERRUPTS();
   if ((ECUM_WKSOURCE_NONE != EcuM_ValidatedWakeups)
#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
            || (ECUM_WKSOURCE_NONE != EcuM_PendingWakeups)
#endif
   )
   {
      /* [SWS_EcuM_02756] */
      /* wake up events were detected during shutdown so select RESET as shutdown target */
      EcuM_ShutdownTarget = ECUM_STATE_RESET;
      EcuM_ShutdownMode = ECUM_UNUSED_SLEEP_MODE;
   }

   /* [SWS_EcuM_02157] */
   /*  Save the value of the current shutdown target for usage after a restart */
   EcuM_LastShutdownTarget = EcuM_ShutdownTarget;
   EcuM_LastShutdownMode = EcuM_ShutdownMode;

   switch (EcuM_ShutdownTarget)
   {
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached if RESET is selected as shutdown target" */
      case ECUM_STATE_RESET:
      {
         /* set internal variable to remember that the restart was intended */
         EcuM_U16_IntendedRestartFlag = ECUM_INTENDED_RESTART_FLAG_VALUE;
         /* [SWS_EcuM_02858] */
         Mcu_PerformReset();
      }
      break;

      /* polyspace+7 MISRA-C3:2.2 [Not a defect:Low] "Case is reached if OFF is selected as shutdown target" */
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached if OFF is selected as shutdown target" */
      case ECUM_STATE_OFF:
      {
         /* Set the variable to 0 - this is necessary if a restart of the system occurred after a short time
          * RAM may be valid in this time */
         EcuM_U16_IntendedRestartFlag = 0;
         EcuM_AL_SwitchOff();
#if (ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
         /* this should never happen, EcuM_AL_SwitchOff() should not return, could happen only if an hardware error occurs */
         /* [BSW_SWS_EcuMf_00002] */
         Det_ReportErrorStatus(EventId,ECUM_E_SWITCH_OFF_ERROR);
#endif
         while (1)
         {

         }
      }
      /* polyspace +1 MISRA-C3:2.1 [Not a defect:Unset] "Code will never be reached, break was added just for correct structure of switch instruction" */
      break;

      /* polyspace +1 RTE:UNR [Not a defect:Unset] "Default switch shall not be reached into normal usage" */
      default:
      {
         /* do nothing */
      }
      break;
   }
}

/* [SWS_EcuM_00814] */
/*!
 ******************************************************************************
 * \brief
 * Places a request for the RUN state. Requests can be placed by every user made
 * known to the state manager at configuration time.
 *
 * \details
 * If KillAllRunRequests is in progress EcuM does not accept any new request
 * and returns E_NOT_OK unless the resulting shutdown has been completed
 * If ECUM_DEV_ERROR_DETECT_ENABLED is set to STD_ON it returns E_NOT_OK
 * and sends errors to DET in next cases:
 * ECUM_E_INVALID_PARAMETER - if the user is not in the EcuM users list,
 * ECUM_E_MULTIPLE_RUN_REQUESTS - on multiple requests by the same user ID
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     user - ID of the entity requesting the RUN state
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       Std_ReturnType:
                  E_OK: The request was accepted by EcuM
                  E_NOT_OK: The request was not accepted by EcuM
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* polyspace+1 MISRA-C3:D4.5 [Justified:Low] "No overlapping visibility" */
Std_ReturnType EcuM_RequestRUN(EcuM_UserType user)
{
   Std_ReturnType ReturnValue = E_OK;

#if (ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
   /* [BSW_SWS_EcuMf_00002] */
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "Code is reached when the received user is not correct" */
   if (ECUM_NO_OF_USERS <= user)
   {
      Det_ReportErrorStatus(EventId,ECUM_E_INVALID_PARAMETER);
      /* the user is not in the EcuM users list */
      ReturnValue = E_NOT_OK;
   }
   else
#endif
   {
      /* polyspace +9 RTE:UNR [Not a defect:Unset] "If branch is reached when function was called after a EcuM_KillAllRUNRequests() was done, else branch is reached when EcuM_KillAllRUNRequests() was not called" */
      if (ECUM_TRUE == EcuM_BO_KillAllRunRequestsInProgress)
      {
         /* [SWS_EcuM_00668] */
         /* [SWS_EcuM_00600] */
         /* EcuM must not accept any new request unless the resulting shutdown has been completed */
         ReturnValue = E_NOT_OK;
      }
      else
      {
         /* [SWS_EcuM_00143] */
         /* [SWS_EcuM_00144] */
         /* check if the user have placed another run request */
#if (ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
         /* [BSW_SWS_EcuMf_00002] */
         /* polyspace +2 RTE:UNR [Not a defect:Unset] "Code is reached when a run request for the same user was done" */
         if (1u == (EcuM_U32_RunRequests &((U32)1u << user)))
         {
            Det_ReportErrorStatus(EventId,ECUM_E_MULTIPLE_RUN_REQUESTS);
            ReturnValue = E_NOT_OK;
         }
         else
#endif
         {
            /* place the new request */
            EcuM_U32_RunRequests |= ((U32)1u << user);
         }
      }
   }
   return ReturnValue;
}

/* [SWS_EcuM_00815] */
/*!
 ******************************************************************************
 * \brief
 * Releases a RUN request previously done with a call to EcuM_RequestRUN
 *
 * \details
 * If ECUM_DEV_ERROR_DETECT_ENABLED is set to STD_ON it returns E_NOT_OK
 * and sends errors to DET in next cases:
 * ECUM_E_INVALID_PARAMETER - if the user is not in the EcuM users list,
 * ECUM_E_MISMATCHED_RUN_RELEASE - on releasing without a matching request
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     user - ID of the entity releasing the RUN state
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       Std_ReturnType:
                  E_OK: The request was accepted by EcuM
                  E_NOT_OK: The request was not accepted by EcuM
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* polyspace+1 MISRA-C3:D4.5 [Justified:Low] "No overlapping visibility" */
Std_ReturnType EcuM_ReleaseRUN(EcuM_UserType user)
{
   Std_ReturnType ReturnValue = E_OK;
#if (ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
   /* [BSW_SWS_EcuMf_00002] */
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "Code is reached when the received user is not correct" */
   if (ECUM_NO_OF_USERS <= user)
   {
      Det_ReportErrorStatus(EventId,ECUM_E_INVALID_PARAMETER);
      /* the user is not in the EcuM users list */
      ReturnValue = E_NOT_OK;
   }
   else
   {
      /* polyspace +9 RTE:UNR [Not a defect:Unset] "If branch is reached in case function was called without calling prior EcuM_RequestRUN(), else branch is reached when EcuM_RequestRUN() was called before EcuM_ReleaseRUN() " */
      /* check if the corresponding RUN request was placed */
      if (0u == (EcuM_U32_RunRequests & ((U32)1u << user)))
      {
         /* can not release without a matching request */
         Det_ReportErrorStatus(EventId,ECUM_E_MISMATCHED_RUN_RELEASE);
         ReturnValue = E_NOT_OK;
      }
      else
      {
         /* release the RUN request for the received user */
         EcuM_U32_RunRequests &= (~((U32)1u << user));
      }
   }
#else
   /* release the RUN request for the received user */
   EcuM_U32_RunRequests &= (~((U32)1u << user));
#endif

   return ReturnValue;
}

/* [SWS_EcuM_00819] */
/*!
 ******************************************************************************
 * \brief
 * Places a request for the POST RUN state. Requests can be placed by every user made
 * known to the state manager at configuration time.
 *
 * \details
 * The POST_RUN state can be requested by software components to indicate that they
 * need to execute cleanup or saving activities before the ECU goes to sleep.
 * If KillAllPostRunRequests is in progress EcuM does not accept any new request
 * and returns E_NOT_OK unless the resulting shutdown has been completed
 * If ECUM_DEV_ERROR_DETECT_ENABLED is set to STD_ON it returns E_NOT_OK
 * and sends errors to DET in next cases:
 * ECUM_E_INVALID_PARAMETER - if the user is not in the EcuM users list,
 * ECUM_E_MULTIPLE_RUN_REQUESTS - on multiple requests by the same user ID
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     user - ID of the entity requesting the POST RUN state
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       Std_ReturnType:
                  E_OK: The request was accepted by EcuM
                  E_NOT_OK: The request was not accepted by EcuM
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* polyspace+1 MISRA-C3:D4.5 [Justified:Low] "No overlapping visibility" */
Std_ReturnType EcuM_RequestPOST_RUN(EcuM_UserType user)
{
   Std_ReturnType ReturnValue = E_OK;

#if (ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
   /* [BSW_SWS_EcuMf_00002] */
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "Code is reached when the received user is not correct" */
   if (ECUM_NO_OF_USERS <= user)
   {
      Det_ReportErrorStatus(EventId,ECUM_E_INVALID_PARAMETER);
      /* the user is not in the EcuM users list */
      ReturnValue = E_NOT_OK;
   }
   else
#endif
   {
      /* polyspace +2 RTE:UNR [Not a defect:Unset] "Code is reached when function was called after a EcuM_KillAllRUNRequests() was done" */
      if (ECUM_TRUE == EcuM_BO_KillAllPostRunRequestsInProgress)
      {
         /* [SWS_EcuMf_00103] */
         /* EcuM must not accept any new request unless the resulting shutdown has been completed */
         ReturnValue = E_NOT_OK;
      }
      else
      {
#if (ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
         /* [BSW_SWS_EcuMf_00002] */
         /* check if the user have placed another post run request */
         /* polyspace +2 RTE:UNR [Not a defect:Unset] "Code is reached when a post run request for the same user was done" */
         if (1u == (EcuM_U32_PostRunRequests & ((U32)1u << user)))
         {
            Det_ReportErrorStatus(EventId,ECUM_E_MULTIPLE_RUN_REQUESTS);
            ReturnValue = E_NOT_OK;
         }
         else
#endif
         {
            /* place the new request */
            EcuM_U32_PostRunRequests |=  ((U32)1u << user);
         }
      }
   }

   return ReturnValue;
}

/* [SWS_EcuM_00820] */
/*!
 ******************************************************************************
 * \brief
 * Releases a POST RUN request previously done with a call to EcuM_RequestPOST_RUN
 *
 * \details
 * If ECUM_DEV_ERROR_DETECT_ENABLED is set to STD_ON it returns E_NOT_OK
 * and sends errors to DET in next cases:
 * ECUM_E_INVALID_PARAMETER - if the user is not in the EcuM users list,
 * ECUM_E_MISMATCHED_RUN_RELEASE - on releasing without a matching request
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     user - ID of the entity releasing the POST RUN state
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       Std_ReturnType:
                  E_OK: The request was accepted by EcuM
                  E_NOT_OK: The request was not accepted by EcuM
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* polyspace+1 MISRA-C3:D4.5 [Justified:Low] "No overlapping visibility" */
Std_ReturnType EcuM_ReleasePOST_RUN(EcuM_UserType user)
{
   Std_ReturnType ReturnValue = E_OK;
#if (ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
   /* [BSW_SWS_EcuMf_00002] */
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "Code is reached when the received user is not correct" */
   if (ECUM_NO_OF_USERS <= user)
   {
      Det_ReportErrorStatus(EventId,ECUM_E_INVALID_PARAMETER);
      /* the user is not in the EcuM users list */
      ReturnValue = E_NOT_OK;
   }
   else
   {
      /* polyspace +3 RTE:UNR [Not a defect:Unset] "Code is reached in case function was called without calling prior EcuM_RequestPOST_RUN()" */
      /* check if the corresponding RUN request was placed */
      if (0u == (EcuM_U32_PostRunRequests &((U32)1u << user)))
      {
         /* can not release without a matching request */
         Det_ReportErrorStatus(EventId,ECUM_E_MISMATCHED_RUN_RELEASE);
         ReturnValue = E_NOT_OK;

      }
      else
      {
         /* release the POST-RUN request for the received user */
         EcuM_U32_PostRunRequests &= (~((U32)1u << user));
      }
   }
#else
   /* release the POST-RUN request for the received user */
   EcuM_U32_PostRunRequests &= (~((U32)1u << user));
#endif

   return ReturnValue;
}

/* [SWS_EcuM_00821] */
/*!
 ******************************************************************************
 * \brief
 * The function unconditionally clears all requests to RUN.
 *
 * \details
 *  As an effect the ECU State Manager switches to RUN III (POST RUN) state which
 *  allows for a controlled shutdown and does not accept any new Run request unless
 *  the resulting shutdown has been completed.
 *  If this function is called ECUM_E_ALL_RUN_REQUESTS_KILLED error will be send to DET.
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       Std_ReturnType:
                  E_OK: The request was accepted by EcuM
                  E_NOT_OK: The request was not accepted by EcuM
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
void EcuM_KillAllRUNRequests(void)
{
   /* [SWS_EcuM_00600] */
   EcuM_BO_KillAllRunRequestsInProgress = ECUM_TRUE; /* mark that a kill all RUN request is in progress, the var will be switched to ECUM_FALSE when entering into SLEEP state */
   /* [SWS_EcuM_00872] */
   EcuM_U32_RunRequests = 0x00; /* release all RUN requests */
   /* stop the RUN state timer */
   ECUM_SET_TIMER(EcuM_U16_Timer,ECUM_U16_TIMER_EXPIRED);
   /* stop wake up validation timer  */
#if (ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
   ECUM_SET_TIMER(EcuM_U16_ValidationTimer,ECUM_U16_TIMER_EXPIRED);
#endif

#if (ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
   /* [BSW_SWS_EcuMf_00002] */
   Det_ReportErrorStatus(EventId,ECUM_E_ALL_RUN_REQUESTS_KILLED);
#endif
}

/* [SWS_EcuMf_00101] */
/*!
 ******************************************************************************
 * \brief
 * The function unconditionally clears all requests to POST RUN.
 *
 * \details
 *  As an effect the ECU State Manager does not accept any new Post Run request unless
 *  the resulting shutdown has been completed.
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       Std_ReturnType:
                  E_OK: The request was accepted by EcuM
                  E_NOT_OK: The request was not accepted by EcuM
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
void EcuM_KillAllPostRUNRequests(void)
{
   /* [SWS_EcuMf_00103] */
   EcuM_BO_KillAllPostRunRequestsInProgress = ECUM_TRUE; /* mark that a kill all POST-RUN request is in progress, the var will be switched to ECUM_FALSE when entering into SLEEP state */
   /* [SWS_EcuMf_00102] */
   EcuM_U32_PostRunRequests = 0x00; /* release all POST-RUN requests */
}

/* [SWS_EcuM_02822] */
/* [SWS_EcuM_02585] */
/* [SWS_EcuM_00232] */
/*!
 ******************************************************************************
 * \brief
 * Selects the shutdown target.
 *
 * \details
 *  Only the following subset of the EcuM_StateType value range is accepted for parameter target:
 * -   ECUM_STATE_SLEEP
 * -   ECUM_STATE_RESET
 * -   ECUM_STATE_OFF
 * All other values will be rejected and ECUM_E_INVALID_PARAMETER will be send to DET.
 * EcuM_SelectShutdownTarget shall not be called in ECUM_STATE_SHUTDOWN sub states,
 * ECUM_STATE_SLEEP, ECUM_STATE_OFF and ECUM_STATE_RESET because the shutdown target will not be set,
 * an error will be generated and ECUM_E_MODULE_NOT_IN_PROPER_STATE will be send to DET.
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     target - The selected shutdown target.
 *                EcuM_NewSleepMode_U8 - The identifier of a sleep mode as defined by configuration (if target is
 *                ECUM_STATE_SLEEP) or ECUM_UNUSED_SLEEP_MODE (if target is ECUM_STATE_RESET or ECUM_STATE_OFF)
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       Std_ReturnType:
                  E_OK: The new shutdown target was set
                  E_NOT_OK: The new shutdown target was not set
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* polyspace +1 MISRA-C3:8.7 [Not a defect:Unset] "Function is an interface and can be used into integration project" */
Std_ReturnType EcuM_SelectShutdownTarget(EcuM_StateType target, U8 EcuM_NewSleepMode_U8)
{
   Std_ReturnType ReturnValue = E_OK;

#if (ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
   /* [BSW_SWS_EcuMf_00002] */
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "Code is reached in case function is called into incorrect state " */
   if(ECUM_STATE_APP_POST_RUN < EcuM_State)
   {
      /* EcuM_SelectShutdownTarget shall not be called in  ECUM_STATE_SHUTDOWN sub states, ECUM_STATE_SLEEP, ECUM_STATE_OFF and ECUM_STATE_RESET */
      Det_ReportErrorStatus(EventId,ECUM_E_MODULE_NOT_IN_PROPER_STATE);
      ReturnValue = E_NOT_OK;
   }
   else
#endif
   {
#if (ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
      /* [BSW_SWS_EcuMf_00002] */
      /* [SWS_EcuM_00624] */
      /* [SWS_EcuM_02185] */
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "Conditions are reached based on the selected shutdown target" */
      if (((ECUM_STATE_RESET == target) || (ECUM_STATE_OFF == target)) || ((ECUM_STATE_SLEEP == target) && (ECUM_NO_OF_SLEEP_MODES > EcuM_NewSleepMode_U8)))
#endif
      {
         EcuM_ShutdownTarget = target;
         /* The mode parameter shall only be used if the target parameter equals ECUM_STATE_SLEEP.
          * In all other cases, it shall be ignored. */
         /* polyspace +2 RTE:UNR [Not a defect:Unset] "Code is reached when selected shutdown target is SLEEP" */
         if (ECUM_STATE_SLEEP == target)
         {
            EcuM_ShutdownMode = EcuM_NewSleepMode_U8;
         }
         else
            /* polyspace +1 RTE:UNR [Not a defect:Unset] "Code is reached when selected shutdown target is different than SLEEP" */
         {
            EcuM_ShutdownMode =  ECUM_UNUSED_SLEEP_MODE;
         }

      }
#if (ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
      else
         /* [BSW_SWS_EcuMf_00002] */
         /* polyspace +1 RTE:UNR [Not a defect:Unset] "Code is reached when selected shutdown target is not correct" */
      {
         Det_ReportErrorStatus(EventId,ECUM_E_INVALID_PARAMETER);
         ReturnValue = E_NOT_OK;
      }
#endif
   }
   return ReturnValue;
}

/* [SWS_EcuM_02824] */
/*!
 ******************************************************************************
 * \brief
 * Returns the currently selected shutdown target as set by EcuM_SelectShutdownTarget.
 *
 * \details
 *  If a NULL pointer is being passed as parameter ECUM_E_NULL_POINTER will be send to DET.
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    shutdowntarget - One of these values is returned:
 *                ECUM_STATE_SLEEP, ECUM_STATE_RESET, ECUM_STATE_OFF
 *                sleepmode - If the out parameter "shutdowntarget" is
 *                ECUM_STATE_SLEEP, sleepmode tells which of the
 *                configured sleep modes was actually chosen, in all the others
 *                cases its value will be 0xFF (ECUM_UNUSED_SLEEP_MODE)
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       Std_ReturnType:
                  E_OK: The service has succeeded
                  E_NOT_OK: The service has failed due to NULL pointer being passed
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
Std_ReturnType EcuM_GetShutdownTarget(EcuM_StateType* shutdownTarget, U8* sleepMode)
{
   Std_ReturnType ReturnValue = E_OK;

#if(ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
   /* [SWS_EcuM_02788], [BSW_SWS_EcuMf_00002]  */
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "Code is reached when function is called with NULL pointer parameters" */
   if ((NULL == shutdownTarget) || (NULL == sleepMode))
   {
      Det_ReportErrorStatus(EventId,ECUM_E_NULL_POINTER);
      ReturnValue = E_NOT_OK;
   }
   else
#endif
   {
      /* polyspace +2 MISRA-C3:D4.14 [Not a defect:Unset] "Parameter is checked when ECUM_DEV_ERROR_DETECT_ENABLED is STD_ON" */
      *shutdownTarget = EcuM_ShutdownTarget;
      *sleepMode = EcuM_ShutdownMode;
   }

   return ReturnValue;
}

/* [SWS_EcuM_02825] */
/*!
 ******************************************************************************
 * \brief
 * Returns the shutdown target of the previous shutdown process.
 *
 * \details
 *  The return value describes the ECU state from which the last wake up or
 *  power up occurred. This function returns always the same value until the
 *  next shutdown. If a NULL pointer is being passed as parameter ECUM_E_NULL_POINTER
 *  will be send to DET.
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    shutdowntarget - One of these values is returned:
 *                ECUM_STATE_SLEEP, ECUM_STATE_RESET, ECUM_STATE_OFF
 *                sleepmode - If the out parameter "shutdowntarget" is
 *                ECUM_STATE_SLEEP, sleepmode tells which of the
 *                configured sleep modes was actually chosen, in all the others
 *                cases its value will be 0xFF (ECUM_UNUSED_SLEEP_MODE)
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       Std_ReturnType:
                  E_OK: The service has succeeded
                  E_NOT_OK: The service has failed due to NULL pointer being passed
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
Std_ReturnType EcuM_GetLastShutdownTarget(EcuM_StateType* shutdownTarget, U8* sleepMode)
{
   Std_ReturnType ReturnValue = E_OK;

#if(ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
   /* [BSW_SWS_EcuMf_00002] */
   /* [SWS_EcuM_02337] */
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "Code is reached when function is called with NULL pointer parameters" */
   if ((NULL == shutdownTarget) || (NULL == sleepMode))
   {
      Det_ReportErrorStatus(EventId,ECUM_E_NULL_POINTER);
      ReturnValue = E_NOT_OK;
   }
   else
#endif
   {
      /* polyspace +4 MISRA-C3:D4.14 [Not a defect:Unset] "Parameter is checked when ECUM_DEV_ERROR_DETECT_ENABLED is STD_ON" */
      /* [SWS_EcuM_02156] */
      *shutdownTarget = EcuM_LastShutdownTarget;
      /* [SWS_EcuM_02336] */
      *sleepMode = EcuM_LastShutdownMode;
   }

   return ReturnValue;
}

/* [SWS_EcuM_00823] */
/*!
 ******************************************************************************
 * \brief
 * Returns the internal state of EcuM.
 *
 * \details
 *  Possible states are: ECUM_STATE_STARTUP, ECUM_STATE_STARTUP_ONE,  ECUM_STATE_STARTUP_TWO,
 *  ECUM_STATE_APP_RUN, ECUM_STATE_APP_POST_RUN, ECUM_STATE_PREP_SHUTDOWN, ECUM_STATE_GO_SLEEP,
 *  ECUM_STATE_GO_OFF_ONE, ECUM_STATE_SLEEP, ECUM_STATE_WAKEUP_ONE, ECUM_STATE_WAKEUP_VALIDATION,
 *  ECUM_STATE_WAKEUP_REACTION, ECUM_STATE_WAKEUP_TWO.
 *  If the received parameter is NULL it will return E_NOT_OK.
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    EcuM_State_UT - The value of the internal state variable.
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       Std_ReturnType:
                  E_OK: The out parameter was set successfully.
                  E_NOT_OK: The out parameter was not set.
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
Std_ReturnType EcuM_GetState(EcuM_StateType* EcuM_State_UT)
{
   Std_ReturnType ReturnValue = E_OK;

   /* polyspace +2 RTE:UNR [Not a defect:Unset] "Code is reached when function is called with NULL pointer parameter" */
   if (NULL == EcuM_State_UT)
   {
      ReturnValue = E_NOT_OK;
   }
   else
   {
      *EcuM_State_UT = EcuM_State;
   }

   return ReturnValue;
}

/* [SWS_EcuM_02827] */
/* [SWS_EcuM_01156] */
/* [SWS_EcuMf_00045] */
/*!
 ******************************************************************************
 * \brief
 * Returns pending wake up events which have been set but not yet validated.
 *
 * \details
 * Non Interruptible function
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       EcuM_WakeupSourceType - all pending wake up events
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
EcuM_WakeupSourceType EcuM_GetPendingWakeupEvents(void)
{
   EcuM_WakeupSourceType ReturnVal = ECUM_WKSOURCE_NONE;

#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
   ECUM_DISABLE_ALL_INTERRUPTS();
   ReturnVal = EcuM_PendingWakeups;
   ECUM_ENABLE_ALL_INTERRUPTS();
#endif

   return ReturnVal;
}

/* [SWS_EcuM_02828] */
/*!
 ******************************************************************************
 * \brief
 * Clears all wake up events like pending, validated and expired events.
 *
 * \details
 * If one of the wakeup sources send as parameter was not defined in the configuration
 * and is not known by EcuM an error will be send to DET (ECUM_E_UNKNOWN_WAKEUP_SOURCE)
 * and the wake up events will not be cleared.
 * Non interruptible function
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     sources - wake up sources for which events will be cleared
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* polyspace +1 MISRA-C3:8.7 [Not a defect:Unset] "Function is an interface and can be used into integration project" */
void EcuM_ClearWakeupEvent(EcuM_WakeupSourceType sources)
{
   ECUM_DISABLE_ALL_INTERRUPTS();

#if(ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
   /* [BSW_SWS_EcuMf_00002] */
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "Condition is evaluated to TRUE in case the received wakeup source is not correct" */
   if(ECUM_WKSOURCE_ALL_SOURCES < sources)
   {
      Det_ReportErrorStatus(EventId,ECUM_E_UNKNOWN_WAKEUP_SOURCE);
   }
   else
#endif
   {
      /* [SWS_EcuM_02683] */
      /* Clear the validated wake ups */
      EcuM_ValidatedWakeups &= (EcuM_WakeupSourceType)(~sources);
#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
      /* Clear the pending and expired wake ups */
      EcuM_PendingWakeups &= (EcuM_WakeupSourceType)(~sources);
      EcuM_ExpiredWakeups &= (EcuM_WakeupSourceType)(~sources);
      EcuM_PendingStartWakeups &= (EcuM_WakeupSourceType)(~sources);
#endif
   }
   ECUM_ENABLE_ALL_INTERRUPTS();
}

/* [SWS_EcuM_02830] */
/*!
 ******************************************************************************
 * \brief
 * Returns validated wake up events.
 *
 * \details
 * Non interruptible function
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       EcuM_WakeupSourceType - all validated wake up events
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* polyspace +1 MISRA-C3:8.7 [Not a defect:Unset] "Function is an interface and can be used into integration project" */
EcuM_WakeupSourceType EcuM_GetValidatedWakeupEvents(void)
{
   EcuM_WakeupSourceType ReturnVal = ECUM_WKSOURCE_NONE;

   ECUM_DISABLE_ALL_INTERRUPTS();
   /* [SWS_EcuM_02533] */
   ReturnVal = EcuM_ValidatedWakeups;
   ECUM_ENABLE_ALL_INTERRUPTS();

   return ReturnVal;
}

/* [SWS_EcuM_02831] */
/*!
 ******************************************************************************
 * \brief
 * Returns expired wake up events.
 *
 * \details
 * Returns all events that have been set and for which validation has failed.
 * Events which do not need validation are not reported by this function.
 * Non interruptible function
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       EcuM_WakeupSourceType - expired wake up events
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* polyspace +1 MISRA-C3:8.7 [Not a defect:Unset] "Function is an interface and can be used into integration project" */
EcuM_WakeupSourceType EcuM_GetExpiredWakeupEvents(void)
{
   EcuM_WakeupSourceType RetVal = ECUM_WKSOURCE_NONE;

#if (ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
   ECUM_DISABLE_ALL_INTERRUPTS();
   RetVal = EcuM_ExpiredWakeups;
   ECUM_ENABLE_ALL_INTERRUPTS();
#endif

   return RetVal;
}

/* [SWS_EcuM_00832] */
/*!
 ******************************************************************************
 * \brief
 * Returns sum status of the wake up sources passed in the parameter.
 *
 * \details
 * The sum status shall be computed according to the following algorithm:
 *  If (EcuM_GetValidatedWakeupEvents() AND sources) is not 0 then return ECUM_WKSTATUS_VALIDATED.
 *  If (EcuM_GetPendingWakeupEvents() AND sources) is not 0 then return ECUM_WKSTATUS_PENDING.
 *  If (EcuM_GetExpiredWakeupEvents() AND sources) is not 0 then return ECUM_WKSTATUS_EXPIRED.
 *  Otherwise, return ECUM_WKSTATUS_NONE.
 *  If one of the wakeup sources send as parameter was not defined in the configuration
 *  and is not known by EcuM an error will be send to DET (ECUM_E_UNKNOWN_WAKEUP_SOURCE)
 *  and the returned status will be ECUM_WKSTATUS_NONE.
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     sources - the sources for which the status is returned
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       EcuM_WakeupSourceType - Sum status of all wake up sources passed in the in
 *                parameter.
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
EcuM_WakeupStatusType EcuM_GetStatusOfWakeupSource(EcuM_WakeupSourceType sources)
{
   /* [SWS_EcuM_00754] */
   EcuM_WakeupStatusType RetVal = ECUM_WKSTATUS_NONE;

#if (ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
   /* [BSW_SWS_EcuMf_00002] */
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "Condition is evaluated to TRUE in case the received wakeup source is not correct" */
   if  (ECUM_WKSOURCE_ALL_SOURCES < sources)
   {
      Det_ReportErrorStatus(EventId,ECUM_E_UNKNOWN_WAKEUP_SOURCE);
   }
   else
#endif
   {
#if (ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
      /* polyspace +2 RTE:UNR [Not a defect:Unset] "Code is reached when when at least one of the received wakeup sources expired" */
      if (ECUM_WKSOURCE_NONE != (EcuM_GetExpiredWakeupEvents() & sources))
      {
         /* if a least one wake up event is expired, the status will be ECUM_WKSTATUS_EXPIRED */
         RetVal = ECUM_WKSTATUS_EXPIRED;
      }
      /* polyspace +2 RTE:UNR [Not a defect:Unset] "Code is reached when when at least one of the received wakeup sources is pending for validation" */
      if (ECUM_WKSOURCE_NONE != (EcuM_GetPendingWakeupEvents() & sources))
      {
         /* if at least one wake up event is pending for validation, the status will be ECUM_WKSTATUS_PENDING */
         RetVal = ECUM_WKSTATUS_PENDING;
      }
#endif
      /* polyspace +2 RTE:UNR [Not a defect:Unset] "Condition is evaluated to TRUE in case at least one of the received wakeup sources is valid" */
      if ( ECUM_WKSOURCE_NONE != (EcuM_GetValidatedWakeupEvents() & sources))
      {
         /* if at least one wake up event is validated, the status will be ECUM_WKSTATUS_VALIDATED */
         RetVal = ECUM_WKSTATUS_VALIDATED;
      }
   }
   return RetVal;
}

/*!
 ******************************************************************************
 * \brief
 * Selects a boot target.
 *
 * \details
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     target - the selected boot target
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       Std_ReturnType E_OK: The new boot target was accepted by EcuM
 *                               E_NOT_OK: The new boot target was not accepted by EcuM
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 * For this release the function is not implemented.
 ******************************************************************************/
/*Std_ReturnType EcuM_SelectBootTarget(EcuM_BootTargetType target)
{
   Std_ReturnType ReturnValue = E_NOT_OK;

   return ReturnValue;
}*/

/*!
 ******************************************************************************
 * \brief
 * Returns the current boot target
 *
 * \details
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    target - the selected boot target
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       Std_ReturnType E_OK: The service always succeeds
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 * For this release the function is not implemented.
 ******************************************************************************/
/*Std_ReturnType EcuM_GetBootTarget(EcuM_BootTargetType * target)
{
   Std_ReturnType ReturnValue = E_NOT_OK;

   return ReturnValue;
}*/

/* [SWS_EcuM_02837] */
/*!
 ******************************************************************************
 * \brief
 * This function implements all activities of EcuM while the OS is up and running.
 *
 * \details
 * If the EcuM_MainFunction is called without having called EcuM_Init in advance
 * (so the EcuM is un-initialized) the EcuM_MainFunction will return immediately
 * without performing any functionality and without raising any errors.
 ******************************************************************************
 *
 * \sync
 * \reent
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* polyspace+1 MISRA-C3:8.7 [Justified:Low] "External declaration is needed" */
void EcuM_MainFunction(void)
{
#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
   /* decrement the validation timer if it was started */
   if (ECUM_U16_TIMER_EXPIRED < ECUM_GET_TIMER(EcuM_U16_ValidationTimer))
   {
      ECUM_DECREMENT_TIMER(EcuM_U16_ValidationTimer);
   }
#endif
   /* [SWS_EcuMf_00029] */
   /* polyspace +2 RTE:UNR MISRA-C3:14.3 [Not a defect:Unset] "Condition is false in case EcuM was not initialized" */
   if (ECUM_TRUE == EcuM_BO_Initialised)
   {
      EcuM_StateMachine();
   }
}

/* [SWS_EcuM_00826] */
/* [SWS_EcuM_02566] */
/*!
 ******************************************************************************
 * \brief
 * Callback used to set a wake up event.
 *
 * \details
 * If the wake up event is not a single bit mask, in the valid range and in the
 * selected sleep mode then the wake up event is ignored and ECUM_E_UNKNOWN_WAKEUP_SOURCE
 * error is send to DET.
 * If the wake up event was already set in the actual session it will be ignored.
 * If the wake up event has passed the above filters and it needs validation,
 * the validation timer will be started/prolonged if already started with the validation
 * timeout of the wake up source established into the configuration.
 * If the wake up event does not need validation it will be automatically validated by calling EcuM_ValidateWakeupEvent.
 * Non interruptible function
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     sources - wake up source id
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
void EcuM_SetWakeupEvent(EcuM_WakeupSourceType sources)
{
#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
   U8 U8_Index;
#endif

   /* [SWS_EcuM_02572] */
   /* polyspace+6 MISRA-C3:12.2 [Justified:Low] "The right hand operand is bigger than the maximum of the left hand operand." */
   /* Check if the wake up source parameter is a single bit mask, in a valid range and in the selected sleep mode */
   /* polyspace +5 RTE:UNR [Not a defect:Unset] "Code is reached in case the received wakeup source is not correct" */
   /* polyspace +4 RTE:OBAI MISRA-C3:D4.1,18.1 [Not a defect:Unset] "Value of EcuM_ShudownMode is set in the ranges of ECUM_NO_OF_SLEEP_MODES if EcuM_ShutdownTarget is ECUM_STATE_SLEEP" */
   if ((((EcuM_WakeupSourceType) 0u) != (((sources) - ((EcuM_WakeupSourceType) 1u)) & sources))
            || ((sources) >= (1u << ECUM_NO_OF_WAKEUP_SOURCES))
            || ((ECUM_STATE_SLEEP == EcuM_ShutdownTarget) && (0u == (sources & EcuM_S_SleepModeSet[EcuM_ShutdownMode].EcuM_WkpSources))))
   {
#if (ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
      /* [BSW_SWS_EcuMf_00002] */
      /* [SWS_EcuMf_00120] */
      /* ignore the wake up event because the wake up source is not known */
      Det_ReportErrorStatus(EventId,ECUM_E_UNKNOWN_WAKEUP_SOURCE);
#endif
   }
   else
   {
      ECUM_DISABLE_ALL_INTERRUPTS();
      /* [SWS_EcuM_02712] */
      /* check if the wake up event was not already set */
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "Condition is evaluated to FALSE in case the wakeup event was already set" */
      if ( (ECUM_WKSOURCE_NONE == (EcuM_ValidatedWakeups & sources))
#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
               &&
               (ECUM_WKSOURCE_NONE == (EcuM_PendingWakeups & sources))
#endif
      )
      {
#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_OFF)
         /* [SWS_EcuM_02566] */
         EcuM_ValidateWakeupEvent(sources);
#else
         /* check if the wake up event requires validation */
         for (U8_Index = 0u; U8_Index < ECUM_NO_OF_WAKEUP_SOURCES; U8_Index++)
         {
            if (EcuM_WkpSourceValidation[U8_Index].EcuM_WkpSource == sources)
            {
               /* [SWS_EcuM_01117] */
               EcuM_PendingWakeups |= sources;
               /* [SWS_EcuM_00494] */
               /* [SWS_EcuM_02975] */
               if (ECUM_NO_VALIDATION_TIMEOUT != EcuM_WkpSourceValidation[U8_Index].EcuM_ValidationTimeout)
               {
                  /* set pending wakeup source to be started into wakeup validation phase */
                  EcuM_PendingStartWakeups |= sources;
                  if (ECUM_GET_TIMER(EcuM_U16_ValidationTimer) < EcuM_WkpSourceValidation[U8_Index].EcuM_ValidationTimeout)
                  {
                     /* [SWS_EcuM_02709] */
                     /* [SWS_EcuM_00714] */
                     /* [SWS_EcuM_02565] */
                     /* [SWS_EcuM_02707] */
                     /* start timeout timer for validation */
                     ECUM_SET_TIMER(EcuM_U16_ValidationTimer,(EcuM_WkpSourceValidation[U8_Index].EcuM_ValidationTimeout));
                  }
               }
               else
               {
                  /* [SWS_EcuM_02566] */
                  /* [SWS_EcuM_02976] */
                  /* wake up does not need validation, validate the wake up event */
                  EcuM_ValidateWakeupEvent(sources);
               }
               break;
            }
         }
#endif
      }
      ECUM_ENABLE_ALL_INTERRUPTS();
   }
}

/* [SWS_EcuM_02829] */
/*!
 ******************************************************************************
 * \brief
 * Callback used to validate a wake up event.
 *
 * \details
 * After wake up, the ECU State Manager will stop the process during the
 * WAKEUP VALIDATION state/sequence to wait for validation of the wake up event.
 * This API service is used to indicate to the ECU Manager module that the wake up
 * event indicated in the sources parameter has been validated.
 * If the wake up event is not a single bit mask, in the valid range and the
 * corresponding wake up was not set before then the wake up event is ignored
 * and ECUM_E_UNKNOWN_WAKEUP_SOURCE error is send to DET.
 * If ComM is integrated and validation is successful, ComM will be informed about the
 * wakeup event if the wakeup source was a communication channel
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     sources - event that have been validated
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       void
 *
 ******************************************************************************
 *
 * \author        PES-SWPS
 * \version       1.1
 * \date          12.05.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* polyspace +1 MISRA-C3:8.7 [Not a defect:Unset] "Function is an interface and can be used into integration project" */
void EcuM_ValidateWakeupEvent(EcuM_WakeupSourceType source)
{
#if (ECUM_INCLUDE_COMM_CFG == STD_ON)
   U8 A_Index_U8;
   BOOL A_WakeupSourceFound_BO = FALSE;
#endif /* #if (ECUM_INCLUDE_COMM_CFG == STD_ON) */
   /* [SWS_EcuM_02496] */
   /* [SWS_EcuM_00344] */
#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
#if (ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
   /* [BSW_SWS_EcuMf_00002] */
   /* Check if the wake up source parameter is a single bit mask, in a valid range, and the corresponding wake up event was set before */
   /* polyspace +5 RTE:UNR [Not a defect:Unset] "Code is reached when the received wakeup source that shall be validated is not valid" */
   if ((((EcuM_WakeupSourceType) 0u) != (((source) - ((EcuM_WakeupSourceType) 1u)) & source))
            || ((source) >= (1u << ECUM_NO_OF_WAKEUP_SOURCES))
            || (ECUM_WKSOURCE_NONE == (EcuM_PendingWakeups & source))
   )
   {
      /* ignore the request because the wake up source is not known */
      Det_ReportErrorStatus(EventId,ECUM_E_UNKNOWN_WAKEUP_SOURCE);
   }
   else
#endif
   {
      ECUM_DISABLE_ALL_INTERRUPTS();
      /* mark that the wake up event was validated */
      EcuM_ValidatedWakeups |= source;
      /* remove the pending wake up event */
      EcuM_PendingWakeups &= (EcuM_WakeupSourceType) (~source);
      /* [SWS_EcuM_02710] */
      /* stop the wake up validation timer if all the wake up events were validated */
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "Condition is evaluated to FALSE in case there are pending wakeups that shall be validated" */
      if (ECUM_WKSOURCE_NONE == EcuM_PendingWakeups)
      {
         ECUM_SET_TIMER(EcuM_U16_ValidationTimer,ECUM_U16_TIMER_EXPIRED);
      }
      ECUM_ENABLE_ALL_INTERRUPTS();
   }
#else
   ECUM_DISABLE_ALL_INTERRUPTS();
   /* mark that the wake up event was validated */
   EcuM_ValidatedWakeups |= source;
   ECUM_ENABLE_ALL_INTERRUPTS();
#endif

#if (ECUM_INCLUDE_COMM_CFG == STD_ON)
   /* [SWS_EcuM_00480], [SWS_EcuM_02645], [SWS_EcuM_00495] */
   /* check if the wake up source is a communication channel */
   for (A_Index_U8 = 0u; (A_Index_U8 < ECUM_NO_OF_WAKEUP_SOURCES) && (FALSE == A_WakeupSourceFound_BO); A_Index_U8++)
   {
      if (EcuM_WkpSourceValidation[A_Index_U8].EcuM_WkpSource == source)
      {
         /* polyspace +2 RTE:UNR [Not a defect:Unset] "Condition is evaluated to TRUE in case the validated wakeup event is an ComM channel" */
         if (ECUM_UNDEFINED_COMM_CHANNEL != EcuM_WkpSourceValidation[A_Index_U8].EcuM_ComMChannelRef)
         {
            /* inform ComM that the wakeup source was a communication channel */
            ComM_EcuM_WakeUpIndication(EcuM_WkpSourceValidation[A_Index_U8].EcuM_ComMChannelRef);
         }
         A_WakeupSourceFound_BO = TRUE;
      }
   }
#endif /* #if (ECUM_INCLUDE_COMM_CFG == STD_ON) */
}

/* [BSW_SWS_EcuMf_00008] */
/*!
 ******************************************************************************
 * \brief
 * This function shall be called into infinite loop from main() function so when
 * all tasks are stopped, EcuM can still execute code until Sleep state is entered.
 *
 * \details
 *
 ******************************************************************************
 *
 * \sync
 * \reent
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
void EcuM_LowPowerManager(void)
{
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "Code is reached when EcuM is entering into GO SLEEP state" */
   if (ECUM_TRUE == EcuM_EnableLowPowerManager)
   {
      EcuM_MainFunction();
   }
}

/* [BSW_SWS_EcuMf_00009] */
/*!
 ******************************************************************************
 * \brief
 * Returns EcuM current mode.
 *
 * \details
 * The returned values could be: ECUM_UNINITIALIZED, ECUM_POST_RUN, ECUM_RUN, ECUM_SHUTDOWN,
 * ECUM_SLEEP, ECUM_STARTUP, ECUM_WAKE_SLEEP.
 *
 ******************************************************************************
 *
 * \sync
 * \reent
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       EcuM_ModeType - current mode
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 * State ECUM_WAKE_SLEEP is not implemented for this release.
 ******************************************************************************/
EcuM_ModeType EcuM_GetCurrentMode(void)
{
   return EcuM_CurrentMode;
}

/* -------- Private functions implementation ---------- */

/* [SWS_EcuM_02838] */
/*!
 ******************************************************************************
 * \brief
 * Implements the STARTUP II state.
 *
 * \details
 *
 *
 ******************************************************************************
 *
 * \sync
 * \reent
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
static void EcuM_StartupTwo(void)
{
   /* [SWS_EcuM_02411] */
   EcuM_State = ECUM_STATE_STARTUP_TWO;
#if(ECUM_CALLOUT_DRIVER_INIT_TWO == STD_ON)
   EcuM_AL_DriverInitTwo(&EcuM_Config_Set);
#endif
#if(ECUM_CALLOUT_DRIVER_INIT_THREE == STD_ON)
   EcuM_AL_DriverInitThree(&EcuM_Config_Set);
#endif
}

/*!
 ******************************************************************************
 * \brief
 * State machine of ECU Manager
 *
 * \details
 *
 *
 ******************************************************************************
 *
 * \sync
 * \reent
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       void
 *
 ******************************************************************************
 *
 * \author        PES-SWPS
 * \version       1.1
 * \date          12.05.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
static void EcuM_StateMachine(void)
{
#if (ECUM_INCLUDE_COMM_CFG == STD_ON)
#if (ECUM_NO_OF_COMM_CHANNELS != 0u)
   U8 A_Index_U8;
   ComM_StateType A_ComMState_UT = COMM_NO_COM_NO_PENDING_REQUEST;
   BOOL A_ComMCommunicationRequest_BO = FALSE;
#endif /* #if (ECUM_NO_OF_COMM_CHANNELS != 0u) */
#endif /* #if (ECUM_INCLUDE_COMM_CFG == STD_ON) */

   /* on state */
   switch(EcuM_State)
   {
      case ECUM_STATE_STARTUP_TWO:
         break;

      case ECUM_STATE_APP_RUN:
      {
         EcuM_Internal_App_Run();
      }
      break;

      /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached if RUN state is released" */
      case ECUM_STATE_APP_POST_RUN:
      {
#if (ECUM_INCLUDE_COMM_CFG == STD_ON)
#if (ECUM_NO_OF_COMM_CHANNELS != 0u)
         /* if at least one channel returns ComM_GetState with COMM_NO_COM_REQUEST_PENDING,
          * EcuM must return to RUN state  */
         for (A_Index_U8 = 0u; (A_Index_U8 < ECUM_NO_OF_COMM_CHANNELS) && (FALSE == A_ComMCommunicationRequest_BO); A_Index_U8++)
         {
            (void)ComM_GetState(EcuM_ComMChannels[A_Index_U8], &A_ComMState_UT);
            if (COMM_NO_COM_REQUEST_PENDING == A_ComMState_UT)
            {
               A_ComMCommunicationRequest_BO = TRUE;
            }
         }
#endif /* #if (ECUM_NO_OF_COMM_CHANNELS != 0u) */
#endif /* #if (ECUM_INCLUDE_COMM_CFG == STD_ON) */

         /* [SWS_EcuMf_00025] */
         /* polyspace +1 RTE:UNR [Not a defect:Unset] "Condition is evaluated to TRUE in case a POST RUN state request is done by integration code" */
         if (ECUM_NO_POST_RUN_REQUESTS == EcuM_U32_PostRunRequests)
         {
            /* [SWS_EcuM_00761] */
            EcuM_NextState = ECUM_STATE_PREP_SHUTDOWN;
         }

         if ((ECUM_NO_RUN_REQUESTS != EcuM_U32_RunRequests)
#if (ECUM_INCLUDE_COMM_CFG == STD_ON)
#if (ECUM_NO_OF_COMM_CHANNELS != 0u)
                  || (TRUE == A_ComMCommunicationRequest_BO)
#endif /* #if (ECUM_NO_OF_COMM_CHANNELS != 0u) */
#endif /* #if (ECUM_INCLUDE_COMM_CFG == STD_ON) */
         )
            /* polyspace +1 RTE:UNR [Not a defect:Unset] "Code is reached when there a pending RUN requests or ComM still need to communicate" */
         {
            /* [SWS_EcuM_00866] */
            EcuM_NextState = ECUM_STATE_APP_RUN;
         }
      }
      break;

      /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached if RUN and POST RUN states are released" */
      case ECUM_STATE_PREP_SHUTDOWN:
      {
         /* polyspace +7 RTE:UNR [Not a defect:Unset] "Condition is TRUE when selected shudown target is SLEEP and FALSE when selected shutdown target is different than SLEEP" */
         if (ECUM_STATE_SLEEP == EcuM_ShutdownTarget)
         {
            /* Transit to Go Sleep */
            EcuM_NextState = ECUM_STATE_GO_SLEEP;
         }
         else
         {
            /* [SWS_EcuM_00288] */
            /* Transit to Go Off */
            EcuM_NextState = ECUM_STATE_GO_OFF_ONE;
         }
      }
      break;

      /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached if RUN and POST RUN states are released and SLEEP is selected as shutdown target" */
      case ECUM_STATE_GO_SLEEP:
      {
         EcuM_Internal_Go_Sleep();
      }

      break;

      /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached if RUN and POST RUN states are released and OFF or RESET are selected as shutdown target" */
      case ECUM_STATE_GO_OFF_ONE:
      {
         EcuM_Internal_Go_Off_One();
      }
      break;

      /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached if RUN and POST RUN states are released and SLEEP is selected as shutdown target" */
      case ECUM_STATE_SLEEP:
      {
         EcuM_Internal_Sleep();
      }
      break;

      /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached when a wakeup validation is necessary" */
      case ECUM_STATE_WAKEUP_VALIDATION:
      {
#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
         /* [SWS_EcuM_02479] */
         EcuM_Internal_Wakeup_Validation();
#else
         EcuM_NextState = ECUM_STATE_WAKEUP_REACTION;
#endif

      }
      break;

      /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached after a wakeup validation and is part of the wakeup procedure" */
      case ECUM_STATE_WAKEUP_REACTION:
      {
#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
         EcuM_Internal_Wakeup_Reaction();
#else
         EcuM_NextState = ECUM_STATE_WAKEUP_TWO;
#endif
      }
      break;

      /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached after a wakeup reaction state and is part of the wakeup procedure" */
      case ECUM_STATE_WAKEUP_TWO:
      {
         /* [BSW_SWS_EcuMf_00001] */
#if(ECUM_CALLOUT_DRIVER_INIT_THREE == STD_ON)
         EcuM_AL_DriverInitThree(&EcuM_Config_Set);
#endif /* #if(ECUM_CALLOUT_DRIVER_INIT_THREE == STD_ON) */
         EcuM_NextState = ECUM_STATE_APP_RUN;
      }
      break;

      /* polyspace +1 RTE:UNR [Not a defect:Unset] "Default switch shall not be reached into normal usage" */
      default:
      {
         /* do nothing */
      }
      break;
   }

   if(EcuM_State != EcuM_NextState )
   {
      /* On exit of the state */
      switch(EcuM_State)
      {
         case ECUM_STATE_STARTUP_TWO:
         {
            /* do nothing */
         }
         break;

         /* polyspace+5 MISRA-C3:2.2 [Not a defect:Low] "Case is reached if RUN state is released" */
         /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached if RUN state is released" */
         case ECUM_STATE_APP_RUN:
         {
            /* [SWS_EcuM_00865] */
            EcuM_OnExitRun();
         }
         break;

         /* polyspace+5 MISRA-C3:2.2 [Not a defect:Low] "Case is reached if RUN state is released" */
         /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached if RUN state is released" */
         case ECUM_STATE_APP_POST_RUN:
         {
            /* [SWS_EcuM_00761] */
            EcuM_OnExitPostRun();
         }
         break;

         /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached if RUN and POST RUN states are released" */
         case ECUM_STATE_PREP_SHUTDOWN:
         {
            /* do nothing */
         }
         break;

         /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached if RUN and POST RUN states are released and SLEEP is selected as shutdown target" */
         case ECUM_STATE_GO_SLEEP:
         {
            /* do nothing */
         }
         break;

         /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached if RUN and POST RUN states are released and SLEEP is selected as shutdown target" */
         case ECUM_STATE_SLEEP:
         {
            /* do nothing */
         }
         break;

         /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached when a wakeup validation is necessary" */
         case ECUM_STATE_WAKEUP_VALIDATION:
         {
            /* do nothing */
         }
         break;

         /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached after a wakeup validation and is part of the wakeup procedure" */
         case ECUM_STATE_WAKEUP_REACTION:
         {
            /* do nothing */
         }
         break;

         /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached after a wakeup reaction state and is part of the wakeup procedure" */
         case ECUM_STATE_WAKEUP_TWO:
         {
            /* do nothing */
         }
         break;

         /* polyspace +1 RTE:UNR [Not a defect:Unset] "Default switch shall not be reached into normal usage" */
         default:
         {
            /* do nothing */
         }
         break;
      }

      /* On entry in the state */
      switch(EcuM_NextState)
      {
         case ECUM_STATE_APP_RUN:
         {
            /* [SWS_EcuM_00308] */
            EcuM_OnEnterRun();

#if (ECUM_INCLUDE_COMM_CFG == STD_ON)
#if (ECUM_NO_OF_COMM_CHANNELS != 0u)
            /* inform all configured ComM channels that communication is allowed */
            /* [SWS_EcuMf_00008], [SWS_EcuMf_00018], [SWS_EcuMf_00019] */
            for (A_Index_U8 = 0u; A_Index_U8 < ECUM_NO_OF_COMM_CHANNELS; A_Index_U8++)
            {
               ComM_CommunicationAllowed(EcuM_ComMChannels[A_Index_U8], TRUE);
            }
#endif /* #if (ECUM_NO_OF_COMM_CHANNELS != 0u) */
#endif /* #if (ECUM_INCLUDE_COMM_CFG == STD_ON) */

            /* [SWS_EcuM_00310] */
            /* start timer for minimum duration to stay in RUN state */
            ECUM_SET_TIMER(EcuM_U16_Timer,ECUM_RUN_TIMEOUT_VALUE - 1);

            /* [SWS_EcuM_00749] */
            EcuM_CurrentMode = ECUM_RUN;
#if (ECUM_CURRENT_MODE_CALLOUT == STD_ON)
            /* [SWS_EcuM_00750] */
            EcuM_OnModeChange(EcuM_CurrentMode);
#endif
         }
         break;

         /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached if RUN state is released" */
         case ECUM_STATE_APP_POST_RUN:
         {
            /* [SWS_EcuM_00749] */
            EcuM_CurrentMode = ECUM_POST_RUN;
#if (ECUM_CURRENT_MODE_CALLOUT == STD_ON)
            /* [SWS_EcuM_00750] */
            EcuM_OnModeChange(EcuM_CurrentMode);
#endif
         }
         break;

         /* polyspace+4 MISRA-C3:2.2 [Justified:Low] "Case is reached if RUN and POST RUN states are released" */
         /* polyspace +3 RTE:UNR [Not a defect:Unset] "Case is reached if RUN and POST RUN states are released" */
         case ECUM_STATE_PREP_SHUTDOWN:
         {
            EcuM_OnPrepShutdown();
         }
         break;

         /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached if RUN and POST RUN states are released and SLEEP is selected as shutdown target" */
         case ECUM_STATE_GO_SLEEP:
         {
            /* [SWS_EcuM_00749] */
            EcuM_CurrentMode = ECUM_SLEEP;
#if (ECUM_CURRENT_MODE_CALLOUT == STD_ON)
            /* [SWS_EcuM_00750] */
            EcuM_OnModeChange(EcuM_CurrentMode);
#endif
            EcuM_OnGoSleep();
#if (ECUM_NVM_WRITE_ALL_ENABLED == STD_ON)
            /* write all data into NVM */
            NvM_WriteAll();
            /* start timer for NVM write all */
            ECUM_SET_TIMER(EcuM_U16_Timer,ECUM_NVM_WRITE_ALL_TIMEOUT_VALUE - 1);
#endif/*(ECUM_NVM_WRITE_ALL_ENABLED == STD_ON)*/
         }
         break;

         /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached if RUN and POST RUN states are released and OFF or RESET are selected as shutdown target" */
         case ECUM_STATE_GO_OFF_ONE:
         {
            /* [SWS_EcuM_00749] */
            EcuM_CurrentMode = ECUM_SHUTDOWN;
#if (ECUM_CURRENT_MODE_CALLOUT == STD_ON)
            /* [SWS_EcuM_00750] */
            EcuM_OnModeChange(EcuM_CurrentMode);
#endif
            EcuM_OnGoOffOne();
#if (ECUM_INCLUDE_COMM_CFG == STD_ON)
            ComM_DeInit();
#endif /* #if (ECUM_INCLUDE_COMM_CFG == STD_ON) */
#if (ECUM_NVM_WRITE_ALL_ENABLED == STD_ON)
            /* write all data into NVM */
            NvM_WriteAll();
            /* start timer for NVM write all */
            ECUM_SET_TIMER(EcuM_U16_Timer,ECUM_NVM_WRITE_ALL_TIMEOUT_VALUE - 1);
#endif/*(ECUM_NVM_WRITE_ALL_ENABLED == STD_ON)*/
         }
         break;

         /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached if RUN and POST RUN states are released and SLEEP is selected as shutdown target" */
         case ECUM_STATE_SLEEP:
         {
            /* do nothing */
         }
         break;

         /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached when a wakeup validation is necessary" */
         case ECUM_STATE_WAKEUP_VALIDATION:
         {
#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
            if(ECUM_SLEEP != EcuM_CurrentMode)
            {
               /* in this case wake up validation is accessed from startup phase */
               /* [SWS_EcuM_00749] */
               EcuM_CurrentMode = ECUM_SLEEP;
#if (ECUM_CURRENT_MODE_CALLOUT == STD_ON)
               /* [SWS_EcuM_00750] */
               EcuM_OnModeChange(EcuM_CurrentMode);
#endif
            }
#endif
         }
         break;

         /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached after a wakeup validation and is part of the wakeup procedure" */
         case ECUM_STATE_WAKEUP_REACTION:
         {
            /* do nothing */
         }
         break;

         /* polyspace +1 RTE:UNR [Not a defect:Unset] "Case is reached after a wakeup reaction state and is part of the wakeup procedure" */
         case ECUM_STATE_WAKEUP_TWO:
         {
            /* do nothing */
         }
         break;

         /* polyspace +1 RTE:UNR [Not a defect:Unset] "Default switch shall not be reached into normal usage" */
         default:
         {
            /* do nothing */
         }
         break;
      }
      EcuM_State = EcuM_NextState;
   }
}

/*!
 ******************************************************************************
 * \brief
 * This function is executed while EcuM is in ECUM_STATE_APP_RUN state
 *
 * \details
 *
 *
 ******************************************************************************
 *
 * \sync
 * \reent
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       void
 *
 ******************************************************************************
 *
 * \author        PES-SWPS
 * \version       1.1
 * \date          12.05.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
static void EcuM_Internal_App_Run(void)
{
#if (ECUM_INCLUDE_COMM_CFG == STD_ON)
#if (ECUM_NO_OF_COMM_CHANNELS != 0u)
   U8 A_Index_U8;
   ComM_StateType A_ComMState_UT = COMM_NO_COM_NO_PENDING_REQUEST;
   BOOL A_ComMNoCommunication_BO = FALSE; /* Keep System up */
#endif /* #if (ECUM_NO_OF_COMM_CHANNELS != 0u) */
#endif /* #if (ECUM_INCLUDE_COMM_CFG == STD_ON) */

#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
   ECUM_DISABLE_ALL_INTERRUPTS();
   if ( ECUM_WKSOURCE_NONE != EcuM_PendingStartWakeups)
   {
      /* all the wakeup sources which have set a wakeup event to EcuM shall be started */
      EcuM_StartWakeupSources(EcuM_PendingStartWakeups);
      EcuM_PendingStartWakeups = ECUM_WKSOURCE_NONE;
   }
   else
   {
      /* do nothing */
   }

   /* [SWS_EcuMf_00027] */
   if (ECUM_WKSOURCE_NONE != EcuM_PendingWakeups)
   {
      if (ECUM_U16_TIMER_EXPIRED < ECUM_GET_TIMER(EcuM_U16_ValidationTimer))
      {
         EcuM_CheckValidation(EcuM_PendingWakeups);
      }
      else
      {
         /* timer has expired and are still remained wake up events to be validated */
         EcuM_StopWakeupSources(EcuM_PendingWakeups);
         EcuM_ExpiredWakeups |=  EcuM_PendingWakeups;
         EcuM_PendingWakeups = ECUM_WKSOURCE_NONE;
      }
   }
   ECUM_ENABLE_ALL_INTERRUPTS();
#endif
   if (ECUM_U16_TIMER_EXPIRED < ECUM_GET_TIMER(EcuM_U16_Timer))
   {
      /* polyspace +1 RTE:OVFL MISRA-C3:D4.1 [Not a defect:Unset] "Before decrementing the variable is checked to be greater than 0, no overflow is possible" */
      ECUM_DECREMENT_TIMER(EcuM_U16_Timer);
   }
   else /* minimum duration of RUN state expired */
   {
#if (ECUM_INCLUDE_COMM_CFG == STD_ON)
#if (ECUM_NO_OF_COMM_CHANNELS != 0u)
      /* It's only allowed to leave RUN state if for all channels ComM returns
         ComM_GetState with COMM_NO_COM_NO_PENDING_REQUEST */
      for (A_Index_U8 = 0u; (A_Index_U8 < ECUM_NO_OF_COMM_CHANNELS) && (TRUE == A_ComMNoCommunication_BO); A_Index_U8++)
      {
         (void)ComM_GetState(EcuM_ComMChannels[A_Index_U8], &A_ComMState_UT);
         if (COMM_NO_COM_NO_PENDING_REQUEST != A_ComMState_UT)
         {
            A_ComMNoCommunication_BO = FALSE;
         }
      }
#endif /* #if (ECUM_NO_OF_COMM_CHANNELS != 0u) */
#endif /* #if (ECUM_INCLUDE_COMM_CFG == STD_ON) */

      ECUM_DISABLE_ALL_INTERRUPTS();
      /* [SWS_EcuM_00311] */
      /* polyspace +11 RTE:UNR [Not a defect:Unset] "Code is reached when no RUN requests are done and ComM is not requesting communication" */
      if ((ECUM_NO_RUN_REQUESTS == EcuM_U32_RunRequests)
#if (ECUM_INCLUDE_COMM_CFG == STD_ON)
#if (ECUM_NO_OF_COMM_CHANNELS != 0u)
               && (TRUE == A_ComMNoCommunication_BO)
#endif /* #if (ECUM_NO_OF_COMM_CHANNELS != 0u) */
#endif /* #if (ECUM_INCLUDE_COMM_CFG == STD_ON) */
#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
               && (ECUM_WKSOURCE_NONE == EcuM_PendingWakeups)
#endif /* #if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON) */
      )
      {
         EcuM_ClearWakeupEvent(ECUM_WKSOURCE_ALL_SOURCES);
         ECUM_ENABLE_ALL_INTERRUPTS();
#if (ECUM_INCLUDE_COMM_CFG == STD_ON)
#if (ECUM_NO_OF_COMM_CHANNELS != 0u)
         /* inform all configured ComM channels that communication is not allowed */
         /* [SWS_EcuMf_00008], [SWS_EcuMf_00018], [SWS_EcuMf_00020] */
         for (A_Index_U8 = 0u; A_Index_U8 < ECUM_NO_OF_COMM_CHANNELS; A_Index_U8++)
         {
            ComM_CommunicationAllowed(EcuM_ComMChannels[A_Index_U8], FALSE);
         }
#endif /* #if (ECUM_NO_OF_COMM_CHANNELS != 0u) */
#endif /* #if (ECUM_INCLUDE_COMM_CFG == STD_ON) */

         /* [SWS_EcuM_00865] */
         /* all RUN requests were released */
         EcuM_NextState = ECUM_STATE_APP_POST_RUN;
      }
      else
      {
         ECUM_ENABLE_ALL_INTERRUPTS();
      }
   }
}

/*!
 ******************************************************************************
 * \brief
 * This function is executed while EcuM is in ECUM_STATE_GO_SLEEP state
 *
 * \details
 *
 *
 ******************************************************************************
 *
 * \sync
 * \reent
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
static void EcuM_Internal_Go_Sleep(void)
{
#if (ECUM_NVM_WRITE_ALL_ENABLED == STD_ON)
   NvM_RequestResultType ET_NvM_result;
#endif/*(ECUM_NVM_WRITE_ALL_ENABLED == STD_ON)*/

   /* [SWS_EcuM_02188] */
   if ((ECUM_WKSOURCE_NONE != EcuM_ValidatedWakeups)
#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
            || (ECUM_WKSOURCE_NONE != EcuM_PendingWakeups)
#endif
   )
   {
#if (ECUM_NVM_WRITE_ALL_ENABLED == STD_ON)
      /*a wakeup event is signaled, EcuM will go the Wakeup Validation state; cancel the NvM WriteAll request*/
      NvM_CancelWriteAll();
      ECUM_SET_TIMER(EcuM_U16_Timer, ECUM_U16_TIMER_EXPIRED);
#endif /*(ECUM_NVM_WRITE_ALL_ENABLED == STD_ON)*/

      EcuM_NextState = ECUM_STATE_WAKEUP_VALIDATION;
   }
   else /* no wake up event */
   {

#if (ECUM_NVM_WRITE_ALL_ENABLED == STD_ON)
      /*Get the WriteAll status*/
      (void)NvM_GetErrorStatus( NVM_MULTI_BLOCK, &ET_NvM_result );
      /*Even if the WriteAll was canceled, the NvM status will be NVM_REQ_PENDING until all underlying modules will finish the processing*/
      if ((ECUM_U16_TIMER_EXPIRED < ECUM_GET_TIMER(EcuM_U16_Timer)) &&
               (NVM_REQ_PENDING == ET_NvM_result) )
      {
         /* polyspace +1 RTE:OVFL MISRA-C3:D4.1 [Not a defect:Unset] "Before decrementing the variable is checked to be greater than 0, no overflow is possible" */
         ECUM_DECREMENT_TIMER(EcuM_U16_Timer);
      }
      else 
      {
         if (ECUM_U16_TIMER_EXPIRED == ECUM_GET_TIMER(EcuM_U16_Timer))
         {
            /*SWS_NvM_00234: if the WriteAll was already canceled, this call has no effect*/
            NvM_CancelWriteAll();
         }
         else
         {
            /*timer expired but NvM is still pending; do nothing, wait for NvM to finish*/
         }
      }
      if (NVM_REQ_PENDING != ET_NvM_result) /* NvMWriteAll finished, it's safe to go to sleep*/
#endif /*(ECUM_NVM_WRITE_ALL_ENABLED == STD_ON)*/
      {
         /* disable the wake up sources that were activated into last sleep mode and are not active in actual target sleep mode */
         /* polyspace +11 RTE:OBAI,UNR MISRA-C3:D4.1,18.1 [Not a defect:Unset] "Value of EcuM_ShudownMode is set in the ranges of ECUM_NO_OF_SLEEP_MODES if EcuM_ShutdownTarget is ECUM_STATE_SLEEP" */
         /* polyspace +4 MISRA-C3:2.2 [Not a defect:Low] "Value of EcuM_ShudownMode is set in the ranges of ECUM_NO_OF_SLEEP_MODES if EcuM_ShutdownTarget is ECUM_STATE_SLEEP" */
         if (0u != (EcuM_EnabledWakeups & (~(EcuM_S_SleepModeSet[EcuM_ShutdownMode].EcuM_WkpSources))))
         {
            EcuM_DisableWakeupSources(EcuM_EnabledWakeups & (~(EcuM_S_SleepModeSet[EcuM_ShutdownMode].EcuM_WkpSources)));
         }

         /* [SWS_EcuM_02389] */
         /* [SWS_EcuMf_00026] */
         /* enable the wake up sources that are active in actual target sleep mode and are not already activated */
         /* polyspace+1 MISRA-C3:2.2 [Not a defect:Low] "This callout is called into GO SLEEP state for enabling the wake up sources" */
         EcuM_EnableWakeupSources(EcuM_S_SleepModeSet[EcuM_ShutdownMode].EcuM_WkpSources & (~EcuM_EnabledWakeups));
         EcuM_EnabledWakeups = EcuM_S_SleepModeSet[EcuM_ShutdownMode].EcuM_WkpSources;

         ECUM_LOCK_SCHEDULER(); /* Prevent other tasks from running in SLEEP state */
         EcuM_NextState = ECUM_STATE_SLEEP;
         EcuM_EnableLowPowerManager = ECUM_TRUE;
      }
   }
}

/*!
 ******************************************************************************
 * \brief
 * This function is executed while EcuM is in ECUM_STATE_SLEEP state
 *
 * \details
 *
 *
 ******************************************************************************
 *
 * \sync
 * \reent
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
static void EcuM_Internal_Sleep(void)
{
   /* polyspace +3 RTE:OBAI MISRA-C3:D4.1,18.1 [Not a defect:Unset] "Value of EcuM_ShudownMode is set in the ranges of ECUM_NO_OF_SLEEP_MODES if EcuM_ShutdownTarget is ECUM_STATE_SLEEP" */
   /* polyspace +2 RTE:UNR MISRA-C3:2.1,14.3 [Not a defect:Unset] "The value of the condition depends on the configuration, user can configure a sleep mode where execution of code is suspended or not" */
   if (STD_ON == EcuM_S_SleepModeSet[EcuM_ShutdownMode].EcuM_SleepModeSuspended)
   {
      /* Sleep Sequence I - is executed in sleep modes that halt the microcontroller. In these sleep modes no code is executed. */
      ECUM_DISABLE_ALL_INTERRUPTS();
      if ((ECUM_WKSOURCE_NONE != EcuM_ValidatedWakeups)
#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
               || (ECUM_WKSOURCE_NONE != EcuM_PendingWakeups)
#endif
      )
      {
         /* wake up occurred just before going to sleep, continue with ECUM_STATE_WAKEUP_ONE */
      }
      else /* no wake up event */
      {
         /* [SWS_EcuM_02157] */
         /*  Save the value of the current shutdown target for usage after sleep */
         EcuM_LastShutdownTarget = EcuM_ShutdownTarget;
         EcuM_LastShutdownMode = EcuM_ShutdownMode;
         /* after Mcu_SetMode call the microcontroller is halt and no code is executed until a wake up source is generating an interrupt */
         EcuM_McuSetMode(EcuM_ShutdownMode);
         /* [SWS_EcuM_00600] */
         EcuM_BO_KillAllRunRequestsInProgress = ECUM_FALSE;
         /* [SWS_EcuMf_00103] */
         EcuM_BO_KillAllPostRunRequestsInProgress = ECUM_FALSE;
      }
      /* In case of an occurred wake up event, continue with the wake up restart sequence */
      ECUM_ENABLE_ALL_INTERRUPTS();
   }
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "The value of the condition depends on the configuration, user can configure a sleep mode where execution of code is suspended or not" */
   else
   {
      /* [SWS_EcuM_02157] */
      /*  Save the value of the current shutdown target for usage after sleep */
      EcuM_LastShutdownTarget = EcuM_ShutdownTarget;
      EcuM_LastShutdownMode = EcuM_ShutdownMode;
      /* [SWS_EcuM_02962] */
      /* Sleep Sequence II - execute the Poll Sequence in sleep modes that reduce the power consumption of the microcontroller but still execute code */
      ECUM_DISABLE_ALL_INTERRUPTS();
      EcuM_McuSetMode(ECUM_POLLING_MODE);
      ECUM_ENABLE_ALL_INTERRUPTS();
      /* [BSW_SWS_EcuM_03020] */
      /* polyspace +1 RTE:NTL [Not a defect:Unset] "Loop will be exited in case a valid wakeup from SLEEP state will occur" */
      while ((ECUM_WKSOURCE_NONE == EcuM_ValidatedWakeups)
#if (ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
               && (ECUM_WKSOURCE_NONE == EcuM_PendingWakeups)
#endif
      )
      {
         EcuM_SleepActivity();
#if (ECUM_WAKEUP_SOURCES_ON_POLLING == STD_ON)
         /* not implemented */
#endif
      }
      /* [SWS_EcuM_00600] */
      EcuM_BO_KillAllRunRequestsInProgress = ECUM_FALSE;
      /* [SWS_EcuMf_00103] */
      EcuM_BO_KillAllPostRunRequestsInProgress = ECUM_FALSE;
   }
   EcuM_NextState = ECUM_STATE_WAKEUP_ONE;
   /* added this call here so Wakeup One state be entered without the need of calling EcuM_MainFunction() through
    * EcuM_LowPowerManager() - it is useful for the situation when OS Background task is active for making sure
    * that when exiting from SLEEP MCU is set to HPM and the Background task is executed with HPM clock */
   EcuM_Internal_Wakeup_One();
}

/*!
 ******************************************************************************
 * \brief
 * This function is executed while EcuM is in ECUM_STATE_GO_OFF_ONE state
 *
 * \details
 *
 *
 ******************************************************************************
 *
 * \sync
 * \reent
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
static void EcuM_Internal_Go_Off_One(void)
{
#if (ECUM_NVM_WRITE_ALL_ENABLED == STD_ON)
   NvM_RequestResultType ET_NvM_result;
#endif /*(ECUM_NVM_WRITE_ALL_ENABLED == STD_ON)*/

   if ((ECUM_WKSOURCE_NONE != EcuM_ValidatedWakeups)
#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
            || (ECUM_WKSOURCE_NONE != EcuM_PendingWakeups)
#endif
   )
   {
#if (ECUM_NVM_WRITE_ALL_ENABLED == STD_ON)
      /*a wakeup event is signalled, cancel the NvM WriteAll request to process the wake-up*/
      NvM_CancelWriteAll();
      ECUM_SET_TIMER(EcuM_U16_Timer, ECUM_U16_TIMER_EXPIRED);

#endif /*(ECUM_NVM_WRITE_ALL_ENABLED == STD_ON)*/
      /* [SWS_EcuM_02756] */
      /* wake up events were detected during shutdown so select RESET as shutdown target */
      EcuM_ShutdownTarget = ECUM_STATE_RESET;
      EcuM_ShutdownMode = ECUM_UNUSED_SLEEP_MODE;
   }
#if (ECUM_NVM_WRITE_ALL_ENABLED == STD_ON)
   /*Get the WriteAll status*/
   ( void)NvM_GetErrorStatus( NVM_MULTI_BLOCK, &ET_NvM_result );
   /*Even if the WriteAll was canceled, the NvM status will be NVM_REQ_PENDING until all underlying modules will finish the processing*/
   if ( (ECUM_U16_TIMER_EXPIRED < ECUM_GET_TIMER(EcuM_U16_Timer)) &&
            (NVM_REQ_PENDING == ET_NvM_result) )
   {
      /* polyspace +1 RTE:OVFL MISRA-C3:D4.1 [Not a defect:Unset] "Before decrementing the variable is checked to be greater than 0, no overflow is possible" */
      ECUM_DECREMENT_TIMER(EcuM_U16_Timer);
   }
   else 
   {
      if (ECUM_U16_TIMER_EXPIRED == ECUM_GET_TIMER(EcuM_U16_Timer))
      {
         /*SWS_NvM_00234: if the WriteAll was already canceled, this call has no effect*/
         NvM_CancelWriteAll();
      }
      else
      {
         /*timer expired but NvM is still pending; do nothing, wait for NvM to finish*/
      }
   }
   if ( NVM_REQ_PENDING != ET_NvM_result)/* NvMWriteAll finished, it's safe to go to reset/shutdown*/
#endif /*(ECUM_NVM_WRITE_ALL_ENABLED == STD_ON)*/
      /* [SWS_EcuM_00328] */
      /* next step will be OS Shutdown and the execution shall continue with EcuM_Shutdown() to reach the shutdown target */
   {
      ECUM_SHUTDOWN_OS();
   }

}

/*!
 ******************************************************************************
 * \brief
 * This function is executed while EcuM is in ECUM_STATE_WAKEUP_ONE state
 *
 * \details
 *
 *
 ******************************************************************************
 *
 * \sync
 * \reent
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
static void EcuM_Internal_Wakeup_One(void)
{
   ECUM_DISABLE_ALL_INTERRUPTS();
   /* Restore MCU normal mode */
   EcuM_McuSetMode(ECUM_NORMAL_MCU_MODE);
   /* disable currently validated and/or pending wake up source and leave the others armed so that later wake ups are possible */
   /* polyspace+4 MISRA-C3:2.2 [Justified:Low] "Code is reached when when at least one of the enabled wakeup events was validated" */
   /* polyspace +4 RTE:UNR [Not a defect:Unset] "Code is reached when when at least one of the enabled wakeup events was validated" */
   if (0 != (EcuM_EnabledWakeups & EcuM_ValidatedWakeups))
   {
      EcuM_DisableWakeupSources((EcuM_WakeupSourceType)(EcuM_EnabledWakeups & EcuM_ValidatedWakeups));
      EcuM_EnabledWakeups &= (~EcuM_ValidatedWakeups);
   }
#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "Code is reached when when at least one of the enabled wakeup events are pending for validation" */
   if (0 != (EcuM_EnabledWakeups & EcuM_PendingWakeups))
   {
      EcuM_DisableWakeupSources((EcuM_WakeupSourceType)(EcuM_EnabledWakeups & EcuM_PendingWakeups));
      EcuM_EnabledWakeups &= (~EcuM_PendingWakeups);
   }
#endif
   ECUM_ENABLE_ALL_INTERRUPTS();
   /* polyspace+1 MISRA-C3:2.2 [Not a defect:Low] "Code is reached when enabled wakeup events was not validated" */
   EcuM_AL_DriverRestart(&EcuM_Config_Set);
   ECUM_UNLOCK_SCHEDULER(); /* From this point on, all other tasks may run again */
   EcuM_NextState = ECUM_STATE_WAKEUP_VALIDATION;
   EcuM_EnableLowPowerManager = ECUM_FALSE;
}

#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
/*!
 ******************************************************************************
 * \brief
 * This function is executed while EcuM is in ECUM_STATE_WAKEUP_VALIDATION state
 *
 * \details
 *
 *
 ******************************************************************************
 *
 * \sync
 * \reent
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
static void EcuM_Internal_Wakeup_Validation(void)
{
   ECUM_DISABLE_ALL_INTERRUPTS();
   if ( ECUM_WKSOURCE_NONE != EcuM_PendingStartWakeups)
   {
      /* all the wakeup sources which have set a wakeup event to EcuM shall be started */
      EcuM_StartWakeupSources(EcuM_PendingStartWakeups);
      EcuM_PendingStartWakeups = ECUM_WKSOURCE_NONE;
   }
   else
   {
      /* do nothing */
   }
   /* check validation timeout */
   if (ECUM_U16_TIMER_EXPIRED < ECUM_GET_TIMER(EcuM_U16_ValidationTimer))
   {
      EcuM_CheckValidation(EcuM_PendingWakeups);
      if (ECUM_WKSOURCE_NONE != EcuM_ValidatedWakeups)
      {
         /* [SWS_EcuM_00568] */
         /* [SWS_EcuMf_00044] */
         /* at least one wake up event was validated */
         EcuM_NextState = ECUM_STATE_WAKEUP_REACTION;
      }
   }
   else
   {
      /* timer has expired and no wake up event was validated */
      /* [SWS_EcuM_00567] */
      /* [SWS_EcuM_00711] */
      EcuM_StopWakeupSources(EcuM_PendingWakeups);
      EcuM_ExpiredWakeups |=  EcuM_PendingWakeups;
      EcuM_PendingWakeups = ECUM_WKSOURCE_NONE;
      EcuM_NextState = ECUM_STATE_WAKEUP_REACTION;
   }
   ECUM_ENABLE_ALL_INTERRUPTS();
}
#endif

#if(ECUM_VALIDATION_TIMEOUT_ENABLED == STD_ON)
/*!
 ******************************************************************************
 * \brief
 * This function is executed while EcuM is in ECUM_STATE_WAKEUP_REACTION state
 *
 * \details
 *
 *
 ******************************************************************************
 *
 * \sync
 * \reent
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
static void EcuM_Internal_Wakeup_Reaction(void)
{
   EcuM_WakeupReactionType EcuM_ComputedWakeupReaction;
   EcuM_WakeupReactionType EcuM_ResultedWakeupReaction;

#if(ECUM_TTII_ENABLED == STD_OFF)
   if (ECUM_WKSOURCE_NONE != EcuM_ValidatedWakeups)
   {
      EcuM_ComputedWakeupReaction = ECUM_WKACT_RUN;
   }
   else /* the validation has failed */
   {
      EcuM_ComputedWakeupReaction = ECUM_WKACT_SHUTDOWN;
   }

   /* get the wake up reaction decided by user */
   EcuM_ResultedWakeupReaction = EcuM_OnWakeupReaction(EcuM_ComputedWakeupReaction);

#if (ECUM_DEV_ERROR_DETECT_ENABLED == STD_ON)
   /* [BSW_SWS_EcuMf_00002] */
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "Code is reached in case the wakeup reaction received from integration code is not RUN or SHUTDOWN" */
   if ((ECUM_WKACT_RUN != EcuM_ResultedWakeupReaction) && (ECUM_WKACT_SHUTDOWN != EcuM_ResultedWakeupReaction))
   {
      Det_ReportErrorStatus(EventId,ECUM_E_UNKNOWN_WAKEUP_REACTION);
      EcuM_ResultedWakeupReaction = EcuM_ComputedWakeupReaction; /* ignore the wake up reaction decided by user and use the computed one */
   }
#endif
   /* polyspace +8 RTE:UNR [Not a defect:Unset] "Code is reached depending of the received wakeup reaction from the integration code" */
   if (ECUM_WKACT_RUN == EcuM_ResultedWakeupReaction)
   {
      EcuM_NextState = ECUM_STATE_WAKEUP_TWO;
   }
   else
   {
      if (ECUM_WKACT_SHUTDOWN == EcuM_ComputedWakeupReaction)
      {
         /* after a failed wake up validation the EcuM shall put the ECU into the same state as before the wake up event which failed */
         EcuM_ShutdownTarget = EcuM_LastShutdownTarget;
         EcuM_ShutdownMode = EcuM_LastShutdownMode;
      }
      /* polyspace +6 RTE:UNR [Not a defect:Unset] "Code is reached based on the current shurdown target" */
      if (ECUM_STATE_SLEEP == EcuM_ShutdownTarget)
      {
         EcuM_NextState = ECUM_STATE_GO_SLEEP;
      }
      else
      {
         EcuM_NextState = ECUM_STATE_GO_OFF_ONE;
      }
   }
#endif
}
#endif
/* polyspace-end MISRA-C3:5.1 [Justified:Unset] "C99 standard is used to compile, Autosar naming convention." */

/*! \} */

U32 EcuM_GetRunRequests(void)
{
   return EcuM_U32_RunRequests;
}


/*!
 \defgroup module_group_int Integration instructions
 \ingroup module_group
 \{

 1. Module parameters / compiler switches
 ========================================

 1.1 Module parameters
 ---------------------

 1.2 Compiler switches
 ---------------------


 2. Operating system integration
 ===============================


 3. General directions
 =====================


 \}
 */


/* %PCMS_HEADER_SUBSTITUTION_START:%
 ******************************************************************************
 * Document Management Information Log (generated by Dimensions CM)
 *
 *  Description:
 *  %PD:%
 *
 *  Used by Baselines:
 *  %PIRB:%
 *
 *  Used by Dimensions CM Projects:
 *  %PIRW:%
 *
 *  Change History:
 *  %PL:%
 *
 * %PCMS_HEADER_SUBSTITUTION_END:%
 */
