using System;
using System.Text;
using System.Collections.Generic;
using SiriusConfigurator.DataLayer;
using SiriusConfigurator.StatusHandler;
using System.Xml.Linq;
using System.Linq;
using SRXml = SiriusConfigurator.BusinessLayer.BEntities.Xml;

namespace SiriusConfigurator
{
    public class ScriptClass
    {
        StringBuilder EcuM_Cbk_GenerationStream;
        StringBuilder EcuM_Cfg_GenerationStream;
        StringBuilder EcuM_Generated_Types_GenerationStream;
        StringBuilder EcuM_Lcfg_GenerationStream;
        StringBuilder EcuM_MemMap_GenerationStream;
        StringBuilder EcuM_PBCfg_GenerationStream;

		public string Dynamic(NodeExt node, SRXml.AttributesXml attribute)
     	{
            DL_Component siriusApp = new DL_Component();
            if ("EcuMFixedGeneral" == node.Name)
            {
                /* Check to see if NvMWriteALL is needed */
                if (("EcuMIncludeNvramWriteall" == attribute.Attribute) && ("false" == attribute.Value))
                {
                    /* Disable all fields that are related to NvMWriteALL configuration */
                    SRXml.AttributesXml EcuMNvramWriteallTimeout = node.Attributes.Find(x => x.Attribute == "EcuMNvramWriteallTimeout");
                    siriusApp.SetEnable(node, EcuMNvramWriteallTimeout, false);


                }
                else if (("EcuMIncludeNvramWriteall" == attribute.Attribute) && ("true" == attribute.Value))
                {
                    /* Enable all fields that are related to NvMWriteALL configuration */
                    SRXml.AttributesXml EcuMNvramWriteallTimeout = node.Attributes.Find(x => x.Attribute == "EcuMNvramWriteallTimeout");
                    siriusApp.SetEnable(node, EcuMNvramWriteallTimeout, true);

                }
            }
            return "OK";
	    }
        
        private void CompleteFile()
        {
            string path_Cbk = @"..\..\Sirius\GenFiles\Source\EcuM_Cbk.h";
            string path_Cfg = @"..\..\Sirius\GenFiles\Source\EcuM_Cfg.h";
            string path_GenTypes = @"..\..\Sirius\GenFiles\Source\EcuM_Generated_Types.h";
            string path_Lcfg = @"..\..\Sirius\GenFiles\Source\EcuM_Lcfg.c";
            string path_MemMap = @"..\..\Sirius\GenFiles\Source\EcuM_MemMap.h";
            string path_PBcfg = @"..\..\Sirius\GenFiles\Source\EcuM_PBcfg.c";
            System.IO.File.WriteAllText(path_Cbk, EcuM_Cbk_GenerationStream.ToString());
            System.IO.File.WriteAllText(path_Cfg, EcuM_Cfg_GenerationStream.ToString());
            System.IO.File.WriteAllText(path_GenTypes, EcuM_Generated_Types_GenerationStream.ToString());
            System.IO.File.WriteAllText(path_Lcfg, EcuM_Lcfg_GenerationStream.ToString());
            System.IO.File.WriteAllText(path_MemMap, EcuM_MemMap_GenerationStream.ToString());
            System.IO.File.WriteAllText(path_PBcfg, EcuM_PBCfg_GenerationStream.ToString());
        }

        public void Generate_EcuM_Cbk()
        {
            string FILE_HEADER_ECUM_CBK = @"/*
 ******************************************************************************
 * \image html ""Kopf_oZusatz_A4hoch_4C.jpg""
 *
 * \par Module Owner:
 *  Huf Huelsbeck & Fuerst GmbH & Co.KG \n
 *  Steeger Str. 17 \n
 *  42551 Velbert \n
 *  Department PDE-S
 *
******************************************************************************
 *  \par Description:
 *  Generated header file for Ecu Manager callback functions
 *  Implementation based on Autosar 4.2 specifications   \n
 *
 * %PCMS_HEADER_SUBSTITUTION_START:%
 ******************************************************************************
 * Document Management Information Log(generated by Dimensions CM)
 *
 *
 *  CM Item:   %PID:%
 *  Itemname:  %PM:%
 *  Location:  %ARCHIVE:%
 *  Revision:  %PR:%
 *  Date:      %DATE:%
 *  Author:    %AUTHOR:%
 *
 * %PCMS_HEADER_SUBSTITUTION_END:%
 *
 ******************************************************************************/";
            EcuM_Cbk_GenerationStream.Append(FILE_HEADER_ECUM_CBK);
            EcuM_Cbk_GenerationStream.AppendLine();
            EcuM_Cbk_GenerationStream.AppendLine("/* [SWS_EcuM_02677] */");
            EcuM_Cbk_GenerationStream.AppendLine();
            EcuM_Cbk_GenerationStream.AppendLine("#ifndef  ECUM_CBK_H_             /* To avoid double inclusion */");
            EcuM_Cbk_GenerationStream.AppendLine("#define  ECUM_CBK_H_");
            EcuM_Cbk_GenerationStream.AppendLine();
			EcuM_Cbk_GenerationStream.AppendLine("#include \"Std_Types.h\"");

            DL_Component siriusApp = new DL_Component();
            List<NodeExt> EcuMModuleToBeInitialized = siriusApp.GetNode("EcuMModuleToBeInitialized");
            int i = 0;
            if (EcuMModuleToBeInitialized.Count != 0)
            {
                /*add includes*/
                for (i = 0; i < EcuMModuleToBeInitialized.Count; i++)
                {
                    switch (EcuMModuleToBeInitialized[i].GetAttribute("ModuleName"))
                    {
                        case "MOD_ECUAL_FEE":
                            EcuM_Cbk_GenerationStream.AppendLine("#include \"Fee.h\"");
                            break;

                        case "MOD_MCAL_ADC":
                            EcuM_Cbk_GenerationStream.AppendLine("#include \"Adc.h\"");
                            break;

                        case "MOD_MCAL_GPT":
                            EcuM_Cbk_GenerationStream.AppendLine("#include \"Gpt.h\"");
                            break;

                        case "MOD_MCAL_MCU":
                            EcuM_Cbk_GenerationStream.AppendLine("#include \"Mcu.h\"");
                            break;

                        case "MOD_MCAL_PORT":
                            EcuM_Cbk_GenerationStream.AppendLine("#include \"Port.h\"");
                            break;

                        case "MOD_MCAL_PWM":
                            EcuM_Cbk_GenerationStream.AppendLine("#include \"Pwm.h\"");
                            break;

                        case "MOD_MCAL_SPI":
                            EcuM_Cbk_GenerationStream.AppendLine("#include \"Spi.h\"");
                            break;

                        case "MOD_MCAL_WDG":
                            EcuM_Cbk_GenerationStream.AppendLine("#include \"Wdg.h\"");
                            break;

                        case "MOD_SERV_NVM_MNG":
                            EcuM_Cbk_GenerationStream.AppendLine("#include \"NvM.h\"");
                            break;

                        case "MOD_SERV_WDG_MNG":
                            EcuM_Cbk_GenerationStream.AppendLine("#include \"WdgM.h\"");
                            break;

                        default:
                            break;
                    }
                }
            }
                
            EcuM_Cbk_GenerationStream.AppendLine("");
            EcuM_Cbk_GenerationStream.AppendLine("/* [SWS_EcuMf_00049]  */");
            EcuM_Cbk_GenerationStream.AppendLine("typedef U32 EcuM_WakeupSourceType;");
            EcuM_Cbk_GenerationStream.AppendLine("");
            EcuM_Cbk_GenerationStream.AppendLine("/* [SWS_EcuM_02810] */");
            EcuM_Cbk_GenerationStream.AppendLine("/* [SWS_EcuMf_00046] */");
            EcuM_Cbk_GenerationStream.AppendLine("/* holds the post-build configuration parameters for the ECU State Manager Fixed module");
            EcuM_Cbk_GenerationStream.AppendLine(" * as well as pointers to all ConfigType structures of modules that are initialized by the ECU State Manager */");
            
			EcuM_Cbk_GenerationStream.AppendLine("/* polyspace +2 MISRA-C3:D4.8 [Justified:Unset] \"No impact on functionality, just code encapsulation related.\" */ ");
            if(EcuMModuleToBeInitialized.Count != 0)
            { 
    		EcuM_Cbk_GenerationStream.AppendLine("typedef struct");
            EcuM_Cbk_GenerationStream.AppendLine("{");
            for (i = 0; i < EcuMModuleToBeInitialized.Count; i++)
            {
                switch (EcuMModuleToBeInitialized[i].GetAttribute("ModuleName"))
                {
                    case "MOD_ECUAL_FEE":
                        EcuM_Cbk_GenerationStream.AppendLine("     const Fee_ConfigType  *Fee_ConfigSettings;");
                        break;

                    case "MOD_MCAL_ADC":
                        EcuM_Cbk_GenerationStream.AppendLine("     const Adc_ConfigType  *Adc_ConfigSettings;");
                        break;

                    case "MOD_MCAL_GPT":
                        EcuM_Cbk_GenerationStream.AppendLine("     const Gpt_ConfigType  *Gpt_ConfigSettings;");
                        break;

                    case "MOD_MCAL_MCU":
                        EcuM_Cbk_GenerationStream.AppendLine("     const Mcu_ConfigType  *Mcu_ConfigSettings;");
                        break;

                    case "MOD_MCAL_PORT":
                        EcuM_Cbk_GenerationStream.AppendLine("     const Port_ConfigType  *Port_ConfigSettings;");
                        break;

                    case "MOD_MCAL_PWM":
                        EcuM_Cbk_GenerationStream.AppendLine("     const Pwm_ConfigType  *Pwm_ConfigSettings;");
                        break;

                    case "MOD_MCAL_SPI":
                        EcuM_Cbk_GenerationStream.AppendLine("     const Spi_ConfigType  *Spi_ConfigSettings;");
                        break;

                    case "MOD_MCAL_WDG":
                        EcuM_Cbk_GenerationStream.AppendLine("     const Wdg_ConfigType  *Wdg_ConfigSettings;");
                        break;

                    case "MOD_SERV_NVM_MNG":
                        EcuM_Cbk_GenerationStream.AppendLine("     const NvM_ConfigType  *NvM_ConfigSettings;");
                        break;

                    case "MOD_SERV_WDG_MNG":
                        EcuM_Cbk_GenerationStream.AppendLine("     const WdgM_ConfigType  *WdgM_ConfigSettings;");
                        break;

                    default:
                        break;
                }
            }
            EcuM_Cbk_GenerationStream.AppendLine("}EcuM_ConfigType;");
            }
            else
            {
			    EcuM_Cbk_GenerationStream.AppendLine("typedef struct");
                EcuM_Cbk_GenerationStream.AppendLine("{");
                EcuM_Cbk_GenerationStream.AppendLine("     const U8  *EcuM_UndefinedConfigSettings;");
                EcuM_Cbk_GenerationStream.AppendLine("}EcuM_ConfigType;");
            }
            EcuM_Cbk_GenerationStream.AppendLine("");
            EcuM_Cbk_GenerationStream.AppendLine("extern const EcuM_ConfigType EcuM_Config_Set;");
            EcuM_Cbk_GenerationStream.AppendLine("/* polyspace-begin MISRA-C3:5.1 [Justified:Unset] \"C99 standard is used to compile, Autosar naming convention.\" */");
            string EcuM_Cbk_h_invariable_code = @"
/*!
 ******************************************************************************
 * \brief
 * This callout is called by the EcuM to poll a wake up source.
 *
 * \details
 * It shall also be called by the ISR of a wake up source to set up the PLL
 * and check other wake up sources that may be connected to the same interrupt.
 *
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      wakeupSource – wakeup source(s) bit field(s) that needs to be checked
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 * This function is not called for this release because polling on wake up sources
 * is not implemented. Wake up sources do not need to call this function when a wake up occurs,
 * it is sufficient to call only EcuM_SetWakeupEvent.
 ******************************************************************************/
extern void EcuM_CheckWakeup(EcuM_WakeupSourceType wakeupSource);

/*!
 ******************************************************************************
 * \brief
 * Callback used to set a wake up event.
 *
 * \details
 * If the wake up event is not a single bit mask, in the valid range and in the
 * selected sleep mode then the wake up event is ignored and ECUM_E_UNKNOWN_WAKEUP_SOURCE
 * error is send to DET.
 * If the wake up event was already set in the actual session it will be ignored.
 * If the wake up event has passed the above filters and it needs validation,
 * the validation timer will be started/prolonged if already started with the validation
 * timeout of the wake up source established into the configuration.
 * If the wake up event does not need validation it will be automatically validated by calling EcuM_ValidateWakeupEvent.
 * Non interruptible function
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     sources – wake up source id
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_SetWakeupEvent(EcuM_WakeupSourceType sources);

/*!
 ******************************************************************************
 * \brief
 * Callback used to validate a wake up event.
 *
 * \details
 * After wake up, the ECU State Manager will stop the process during the
 * WAKEUP VALIDATION state/sequence to wait for validation of the wake up event.
 * This API service is used to indicate to the ECU Manager module that the wake up
 * event indicated in the sources parameter has been validated.
 * If the wake up event is not a single bit mask, in the valid range and the
 * corresponding wake up was not set before then the wake up event is ignored
 * and ECUM_E_UNKNOWN_WAKEUP_SOURCE error is send to DET.
 * If ComM is integrated and validation is successful, ComM will be informed about the
 * wakeup event if the wakeup source was a communication channel
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]    void
 * \param[in]     sources – event that have been validated
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns       void
 *
 ******************************************************************************
 *
 * \author        PES-SWPS
 * \version       1.1
 * \date          12.05.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_ValidateWakeupEvent(EcuM_WakeupSourceType source);

/*!
 ******************************************************************************
 * \brief
 * This callout shall provide driver initialization and other hardware-related
 * startup activities for loading the post-build configuration data.
 *
 * \details
 * Beware: Here only pre-compile and link-time configurable modules which do not
 * use post-build configuration parameters may be used.
 * Usually this function is used to initialize DET module.
 * This function is active only if ECUM_CALLOUT_DRIVER_INIT_ZERO is set to ECUM_TRUE.
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_AL_DriverInitZero(void);

/*!
 ******************************************************************************
 * \brief
 * This callout shall provide driver initialization and other hardware-related
 * startup activities in case of a power on reset.
 *
 * \details
 * This function is active only if ECUM_CALLOUT_DRIVER_INIT_ONE is set to ECUM_TRUE.
 * Usually this function is used to initialize MCU, PORT, DEM pre-initialization,
 * GPT, Watchdog Driver (internal watchdogs only, external ones may need SPI),
 * WDG Manager, SchM, BswM, ADC Driver, ICU Driver, PWM Driver, OCU Driver modules and
 * to start DET.
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      ConfigPtr - Pointer to the EcuM post-build configuration which
 *                 contains pointers to all other BSW module post-build configurations.
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_AL_DriverInitOne(const EcuM_ConfigType* ConfigPtr);

/*!
 ******************************************************************************
 * \brief
 * This callout shall provide driver initialization of drivers which need OS
 * and do not need to wait for the NvM_ReadAll job to finish.
 *
 * \details
 * This function is active only if ECUM_CALLOUT_DRIVER_INIT_TWO is set to ECUM_TRUE.
 * Usually this function is used to initialize communication drivers, EEPROM Driver,
 * Flash Driver, NVRAM Manager (initialization and run NvM_ReadAll job).
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      ConfigPtr - Pointer to the EcuM post-build configuration which
 *                 contains pointers to all other BSW module post-build configurations.
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_AL_DriverInitTwo(const EcuM_ConfigType* ConfigPtr);

/*!
 ******************************************************************************
 * \brief
 * This callout shall provide driver initialization of drivers which need OS
 * and need to wait for the NvM_ReadAll job to finish.
 *
 * \details
 * This function is called at startup only if ECUM_CALLOUT_DRIVER_INIT_THREE is set to ECUM_TRUE.
 * Usually this function is used to initialize Comunication Manager, Network Management,
 * DEM full initialization, Huf timing system.
 * This function is called into the Wakeup Two state too.
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      ConfigPtr - Pointer to the EcuM post-build configuration which
 *                 contains pointers to all other BSW module post-build configurations.
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_AL_DriverInitThree(const EcuM_ConfigType* ConfigPtr);

/*!
 ******************************************************************************
 * \brief
 * This callout is called just after the startup when entering to RUN state.
 *
 * \details
 * This callout allows the system designer to notify that RUN state has been reached,
 * so please add the project specific code manually.
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_OnEnterRun(void);

/*!
 ******************************************************************************
 * \brief
 * This callout is called just before the RUN state is left.
 *
 * \details
 * This callout allows the system designer to notify that RUN state is about to be
 * left, so please add the project specific code manually.
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_OnExitRun(void);

/*!
 ******************************************************************************
 * \brief
 * This callout is called just before the POST RUN state is left.
 *
 * \details
 * This callout allows the system designer to notify that POST RUN state is about to be
 * left, so please add the project specific code manually.
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_OnExitPostRun(void);

/*!
 ******************************************************************************
 * \brief
 * This callout is called when entering to PREP SHUTODOWN state
 *
 * \details
 * This callout allows the system designer to notify that PREP SHUTDOWN state is
 * about to be entered, so please add the project specific code manually.
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_OnPrepShutdown(void);

/*!
 ******************************************************************************
 * \brief
 * This callout is called when entering to GO SLEEP state
 *
 * \details
 * This callout allows the system designer to notify that GO SLEEP state is about
 * to be entered, so please add the project specific code manually.
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_OnGoSleep(void);

/*!
 ******************************************************************************
 * \brief
 * This callout is called when entering to GO OFF I state
 *
 * \details
 * This callout allows the system designer to notify that GO OFF I state is about
 * to be entered, so please add the project specific code manually.
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_OnGoOffOne(void);

/*!
 ******************************************************************************
 * \brief
 * This callout is called when entering to GO OFF II state
 *
 * \details
 * This callout allows the system designer to notify that GO OFF II state is about
 * to be entered, so please add the project specific code manually.
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_OnGoOffTwo(void);

/*!
 ******************************************************************************
 * \brief
 * This callout is called into GO SLEEP state for enabling the wake up sources
 *
 * \details
 * The ECU Manager Module calls EcuM_EnableWakeupSource to allow the system designer
 * to notify wake up sources defined in the wakeupSource bit field that SLEEP will
 * be entered and to adjust their source accordingly, so please add the project specific
 * code manually. EcuM enables only wakeup sources that are active in actual target sleep
 * mode provided by EcuM_S_SleepModeSet.
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      wakeupSource – wakeup source(s) bit field(s) that will be enabled
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_EnableWakeupSources(EcuM_WakeupSourceType wakeupSource);

/*!
 ******************************************************************************
 * \brief
 * This callout shall switch off the ECU
 *
 * \details
 * This callout shall contain the code for shutting off the power supply of the ECU.
 * If the ECU cannot unpower itself, a reset may be an adequate reaction.
 * Please make sure that this function never returns.

 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_AL_SwitchOff(void);

/*!
 ******************************************************************************
 * \brief
 * This callout is called to disable the wake up sources
 *
 * \details
 * The ECU Manager Module calls EcuM_DisableWakeupSource to set the wake up source(s)
 * defined in the parameter bit field so that they are not able to wake up the Ecu.
 * The function is called into the Wakeup One state and are disabled only wake up sources
 * that waked up the Ecu and the others are left armed so that later wake ups are possible.
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      wakeupSource – wakeup source(s) bit field(s) that will be disabled
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_DisableWakeupSources(EcuM_WakeupSourceType wakeupSource);

/*!
 ******************************************************************************
 * \brief
 * This callout shall provide driver initialization and other hardware-related
 * startup activities in the wake up case.
 *
 * \details
 * It is called into Wakeup One state after restoring MCU to normal mode and just
 * before starting the tasks again.
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      ConfigPtr - Pointer to the EcuM post-build configuration which
 *                 contains pointers to all other BSW module post-build configurations.
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_AL_DriverRestart(const EcuM_ConfigType* ConfigPtr);

/*!
 ******************************************************************************
 * \brief
 * This callout shall start the given wake up source(s) so that they are ready
 * to perform wake up validation.
 *
 * \details
 *
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      wakeupSource – wakeup source(s) bit field(s) that will be started
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_StartWakeupSources(EcuM_WakeupSourceType wakeupSource);

/*!
 ******************************************************************************
 * \brief
 * This callout is called by EcuM to validate a wakeup source.
 *
 * \details
 * If a valid wakeup has been detected, it shall be reported to EcuM via EcuM_ValidateWakeupEvent.
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      wakeupSource – wake up source(s) bit field(s) that will be checked
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_CheckValidation(EcuM_WakeupSourceType wakeupSource);

/*!
 ******************************************************************************
 * \brief
 * This callout shall stop the given wake up source(s) after unsuccessful wake up validation.
 *
 * \details
 *
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      wakeupSource – wake up source(s) bit field(s) that will be stopped
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_StopWakeupSources(EcuM_WakeupSourceType wakeupSource);

/*!
 ******************************************************************************
 * \brief
 * This callout is invoked periodically in all reduced clock sleep modes.
 *
 * \details
 * It is explicitly allowed to poll wakeup sources from this callout and to call
 * wakeup notification functions to indicate the end of the sleep state to the ECU State Manager.
 * This function is called, when Sleep Sequence II is executing, into a while loop
 * until a wakeup occurs. For activating Sleep Sequence II the selected sleep mode shall
 * have EcuM_SleepModeSuspended parameter set to ECUM_FALSE. Into this function user can
 * add project specific code where can put the Ecu into sleep again if it is needed.
 *
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_SleepActivity(void);

/*!
 ******************************************************************************
 * \brief
 * This callout is called by the EcuM to set MCU to a needed configuration.
 *
 * \details
 * Usually MCU mode and clock need to be set.
 * It is mandatory to implement modes:
 * - ECUM_NORMAL_MCU_MODE -it is invoked by EcuM into Wakeup One state just after
 *   waking up from sleep, usually here the clock is re-initialized for high power mode
 * - ECUM_POLLING_MODE -it is invoked just before going to Sleep state when
 *   Sleep Sequence II is active, usually here the clock is initialized for low power mode
 * - all the sleep modes provided by EcuM that can be invoked and which are listed into
 *   EcuM_Cfg.h sleep modes list -EcuM_McuSetMode with active shutdown mode send as
 *   parameter is called just before going to Sleep state when Sleep Sequence I is active,
 *   usually here the clock is set to low power mode and MCU is set with corresponding sleep mode
 * Please use the provided function and adapt it to the project requirements.
 * Before entering into low/high power mode and after exiting from low/high power mode callout
 * functions are called where user can add project specific code.
 *
 *
 ******************************************************************************
 *
 * \sync          synchronous (function done in one pass)
 * \reent         non reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]     void
 * \param[in]      EcuM_Mode_U8 – mode that needs to be set
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \returns        void
 *
 ******************************************************************************
 *
 * \author        nmicule, PDES-BSW
 * \version       1.0
 * \date          12.01.2018
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 12.01.2018, nmicule:
 *       - initial revision
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
extern void EcuM_McuSetMode(U8 EcuM_Mode_U8);
/* polyspace-end MISRA-C3:5.1 [Justified:Unset] ""C99 standard is used to compile, Autosar naming convention."" */

#endif   /* ECUM_CBK_H_ */


/* %PCMS_HEADER_SUBSTITUTION_START:%
 ******************************************************************************
 * Document Management Information Log (generated by Dimensions CM)
 *
 *  Description:
 *  %PD:%
 *
 *  Used by Baselines:
 *  %PIRB:%
 *
 *  Used by Dimensions CM Projects:
 *  %PIRW:%
 *
 *  Change History:
 *  %PL:%
 *
 * %PCMS_HEADER_SUBSTITUTION_END:%
 */";

            EcuM_Cbk_GenerationStream.AppendLine(EcuM_Cbk_h_invariable_code);

        }

        public void Generate_EcuM_Cfg()
        {

            string FILE_HEADER_EcuM_Cfg = @"/*
 ******************************************************************************
 * \image html ""Kopf_oZusatz_A4hoch_4C.jpg""
 *
 * \par Module Owner:
 * Huf Huelsbeck & Fuerst GmbH & Co.KG \n
 * Steeger Str. 17 \n
 * 42551 Velbert \n
 * Department PDE - S
 *
 ******************************************************************************
 * \par Description:
 * Generated configuration file for EcuM
 * Implementation based on Autosar 4.2 specifications   \n
 *
 * % PCMS_HEADER_SUBSTITUTION_START:%
 ******************************************************************************
 *Document Management Information Log(generated by Dimensions CM)
 *
 *
 *CM Item:   % PID:%
 *Itemname:  % PM:%
 *Location:  % ARCHIVE:%
 *Revision:  % PR:%
 *Date:      % DATE:%
 *Author:    % AUTHOR:%
 *
 * % PCMS_HEADER_SUBSTITUTION_END:%
 *
 ******************************************************************************/ ";


            EcuM_Cfg_GenerationStream.AppendLine(FILE_HEADER_EcuM_Cfg);
            EcuM_Cfg_GenerationStream.AppendLine("");
            EcuM_Cfg_GenerationStream.AppendLine("#ifndef  ECUM_CFG_H_         /* To avoid double inclusion */");
            EcuM_Cfg_GenerationStream.AppendLine("#define  ECUM_CFG_H_");
            EcuM_Cfg_GenerationStream.AppendLine("");
            EcuM_Cfg_GenerationStream.AppendLine("/* EcuMGeneral */");

            DL_Component siriusApp = new DL_Component();
            List<NodeExt> EcuMFixedGeneral = siriusApp.GetNode("EcuMFixedGeneral");
	
	        EcuM_Cfg_GenerationStream.AppendLine ("/* polyspace-begin MISRA-C3:2.5 [Not a defect:Unset] \"Macros used into integration code or defined for future implementation\" */");
            if(EcuMFixedGeneral[0].GetAttribute("EcuMDevErrorDetect") == "true")
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_DEV_ERROR_DETECT_ENABLED     STD_ON");
            }
            else
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_DEV_ERROR_DETECT_ENABLED     STD_OFF");
            }
            if (EcuMFixedGeneral[0].GetAttribute("EcuMIncludeDet") == "true")
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_INCLUDE_DET                  STD_ON");
            }
            else
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_INCLUDE_DET                  STD_OFF /* this parameter must be set to STD_OFF - for the moment DET is not automatically initialized by EcuM, user can initialize it if needed into the callout functions */");
            }

            EcuM_Cfg_GenerationStream.AppendLine("/* [SWS_EcuM_00594] */");
            EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_MAIN_FUNCTION_PERIOD         (U8)"+ EcuMFixedGeneral[0].GetAttribute("EcuMMainFunctionPeriod") + "      /* ms */ ");

            if (EcuMFixedGeneral[0].GetAttribute("EcuMVersionInfoApi") == "true")
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_VERSION_INFO_API_ENABLED     STD_ON");
            }
            else
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_VERSION_INFO_API_ENABLED     STD_OFF");
            }

            EcuM_Cfg_GenerationStream.AppendLine("");
            EcuM_Cfg_GenerationStream.AppendLine("/* EcuMFixedGeneral */");

            if (EcuMFixedGeneral[0].GetAttribute("EcuMIncludeComM") == "true")
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_INCLUDE_COMM_CFG             STD_ON ");
            }
            else
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_INCLUDE_COMM_CFG             STD_OFF ");
            }
            if (EcuMFixedGeneral[0].GetAttribute("EcuMTTIIEnabled") == "true")
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_TTII_ENABLED                 STD_ON*/");
            }
            else
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_TTII_ENABLED                 STD_OFF /* this parameter must be set to STD_OFF because TTII is not supported by EcuM */");
            }

            EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_TTII_WAKEUP_SOURCE           "+ EcuMFixedGeneral[0].GetAttribute("EcuMTTIIWakeupSource") + "/* this parameter must be set to ECUM_WKSOURCE_NONE because TTII is not supported */");
            EcuM_Cfg_GenerationStream.AppendLine("");

            EcuM_Cfg_GenerationStream.AppendLine("/* EcuMFixedConfiguration */");

            if (EcuMFixedGeneral[0].GetAttribute("EcuMIncludeNvramWriteall") == "true")
            {

                Int32 iEcuMNvramWriteallTimeout = Convert.ToInt32(EcuMFixedGeneral[0].GetAttribute("EcuMNvramWriteallTimeout"));
                Int32 iEcuMMainFunctionPeriod = Convert.ToInt32(EcuMFixedGeneral[0].GetAttribute("EcuMMainFunctionPeriod"));

                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_NVM_WRITE_ALL_ENABLED        STD_ON   /*EcuM calls NvM WriteAll before Sleep or Shutdown */");
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_NVM_WRITE_ALL_TIMEOUT_VALUE  (U16)(" + iEcuMNvramWriteallTimeout / iEcuMMainFunctionPeriod + ")  /*number of EcuM main function calls for which EcuM will wait until it considers a WriteAll job on the NVM as failed */");
            }
            else
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_NVM_WRITE_ALL_ENABLED        STD_OFF   /*EcuM doesn't call NvM WriteAll before Sleep or Shutdown */");
            }

            EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_RUN_MINIMUM_DURATION         (U16)"+ EcuMFixedGeneral[0].GetAttribute("EcuMRunMinimumDuration") + "    /* ms */ /* Duration for which the ECU State Manager will stay in RUN state even when no one requests RUN. This duration should be long at least as long as a SW-Cs needs to request RUN */");
            EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_RUN_TIMEOUT_VALUE            (U16)(ECUM_RUN_MINIMUM_DURATION/ECUM_MAIN_FUNCTION_PERIOD)");
            EcuM_Cfg_GenerationStream.AppendLine("");
            EcuM_Cfg_GenerationStream.AppendLine("/* [SWS_EcuM_00232] */");

            List<NodeExt> EcuMDefaultShutdownTarget = siriusApp.GetNode("EcuMDefaultShutdownTarget");
            EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_DEFAULT_SHUTDOWN_TARGET        "+ EcuMDefaultShutdownTarget[0].GetAttribute("EcuMDefaultState"));
            List<NodeExt> EcuMSleepMode = siriusApp.GetNode("EcuMSleepMode");
            if (EcuMDefaultShutdownTarget[0].GetAttribute("EcuMDefaultState") != "ECUM_STATE_SLEEP")
            { /*if sleep state not chosen*/
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_DEFAULT_SHUTDOWN_MODE          ECUM_UNUSED_SLEEP_MODE");
            }
            else
            { /*set the default shutdown mode*/
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_DEFAULT_SHUTDOWN_MODE          "+ EcuMDefaultShutdownTarget[0].GetAttribute("EcuMDefaultSleepModeRef"));
            }

            EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_NORMAL_MCU_MODE                0xFF");
            EcuM_Cfg_GenerationStream.AppendLine("");

            if(EcuMFixedGeneral[0].GetAttribute("EcuMEnableResetReasonDetection") == "true")
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_RESET_REASON_OF_WAKEUP_ENABLE  STD_ON /* STD_ON - activates the handle for detecting the reset reason after reset into the startup phase");
            }
            else
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_RESET_REASON_OF_WAKEUP_ENABLE  STD_OFF /* STD_ON - activates the handle for detecting the reset reason after reset into the startup phase");
            }
            EcuM_Cfg_GenerationStream.AppendLine("                                                         STD_OFF - the reset reason is not detected, it will always return ECUM_WKSOURCE_RESET");
            EcuM_Cfg_GenerationStream.AppendLine("                                                         This parameter must be set to STD_ON if the project contains wake up sources with integrated power control */");


            List<NodeExt> EcuMWakeupSources = siriusApp.GetNode("EcuMWakeupSources");
            
                List<NodeExt> ECUM_WKSOURCE_POWER = siriusApp.GetNode("ECUM_WKSOURCE_POWER");
                List<NodeExt> ECUM_WKSOURCE_RESET = siriusApp.GetNode("ECUM_WKSOURCE_RESET");
                List<NodeExt> ECUM_WKSOURCE_INTERNAL_RESET = siriusApp.GetNode("ECUM_WKSOURCE_INTERNAL_RESET");
                List<NodeExt> ECUM_WKSOURCE_INTERNAL_WDG = siriusApp.GetNode("ECUM_WKSOURCE_INTERNAL_WDG");
                List<NodeExt> ECUM_WKSOURCE_EXTERNAL_WDG = siriusApp.GetNode("ECUM_WKSOURCE_EXTERNAL_WDG");
                List<NodeExt> EcuMWakeupSource = siriusApp.GetNode("EcuMWakeupSource");
                bool flag_enableValidation = false;
                int i = 0;
                for (i = 0; i < EcuMWakeupSource.Count; i++)
                {
                    if(Int32.Parse(EcuMWakeupSource[i].GetAttribute("EcuMValidationTimeout")) != 0)
                    {
                        flag_enableValidation = true;
                        i = EcuMWakeupSource.Count;
                    }
                }
                if(flag_enableValidation == true)
                {
                    EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_VALIDATION_TIMEOUT_ENABLED     STD_ON /* STD_ON - activates the wake up validation protocol, it shall be enabled when at least one wake up source needs validation");
                }
                else
                {
                    EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_VALIDATION_TIMEOUT_ENABLED     STD_OFF /* STD_ON - activates the wake up validation protocol, it shall be enabled when at least one wake up source needs validation");
                }
                EcuM_Cfg_GenerationStream.AppendLine("															STD_OFF - wake up validation protocol is not active, all the wake ups are considered valid */");
                EcuM_Cfg_GenerationStream.AppendLine("");
            


            if(EcuMFixedGeneral[0].GetAttribute("EcuMCalloutDriverInitZero") == "true")
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_CALLOUT_DRIVER_INIT_ZERO       STD_ON    /* STD_ON - EcuM_AL_DriverInitZero is active and called by EcuM at startup");
            }
            else
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_CALLOUT_DRIVER_INIT_ZERO       STD_OFF    /* STD_ON - EcuM_AL_DriverInitZero is active and called by EcuM at startup");
            }
            EcuM_Cfg_GenerationStream.AppendLine("                                                            STD_OFF - EcuM_AL_DriverInitZero is not active  */");

            if (EcuMFixedGeneral[0].GetAttribute("EcuMCalloutDriverInitOne") == "true")
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_CALLOUT_DRIVER_INIT_ONE        STD_ON    /* STD_ON - EcuM_AL_DriverInitOne is active and called by EcuM at startup");
            }
            else
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_CALLOUT_DRIVER_INIT_ONE        STD_OFF    /* STD_ON - EcuM_AL_DriverInitOne is active and called by EcuM at startup");
            }
            EcuM_Cfg_GenerationStream.AppendLine("                                                            STD_OFF - EcuM_AL_DriverInitOne is not active  */");

            if (EcuMFixedGeneral[0].GetAttribute("EcuMCalloutDriverInitTwo") == "true")
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_CALLOUT_DRIVER_INIT_TWO        STD_ON    /* STD_ON - EcuM_AL_DriverInitTwo is active and called by EcuM at startup");
            }
            else
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_CALLOUT_DRIVER_INIT_TWO        STD_OFF    /* STD_ON - EcuM_AL_DriverInitTwo is active and called by EcuM at startup");
            }
            EcuM_Cfg_GenerationStream.AppendLine("                                                            STD_OFF - EcuM_AL_DriverInitTwo is not active  */");

            if (EcuMFixedGeneral[0].GetAttribute("EcuMCalloutDriverInitThree") == "true")
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_CALLOUT_DRIVER_INIT_THREE      STD_ON    /* STD_ON - EcuM_AL_DriverInitThree is active and called by EcuM at startup");
            }
            else
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_CALLOUT_DRIVER_INIT_THREE      STD_OFF    /* STD_ON - EcuM_AL_DriverInitThree is active and called by EcuM at startup");
            }
            EcuM_Cfg_GenerationStream.AppendLine("                                                            STD_OFF - EcuM_AL_DriverInitThree is not active  */");
            EcuM_Cfg_GenerationStream.AppendLine("");   /*empty line*/

            EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_WAKEUP_SOURCES_ON_POLLING      STD_OFF   /* this parameter shall be set to STD_OFF - polling wake up sources is not supported */");   /*hardcoded: feature not supported*/
            EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_POLLING_MODE                   0xFE         /* this parameter is used to configure MCU clock when entering into SLEEP II if it is necessary */");

            if(EcuMFixedGeneral[0].GetAttribute("EcuMCalloutOnModeChange") == "true")
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_CURRENT_MODE_CALLOUT           STD_ON   /* STD_ON - an callout will be called when EcuM mode is changed");
            }
            else
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_CURRENT_MODE_CALLOUT           STD_OFF  /* STD_ON - an callout will be called when EcuM mode is changed");
            }
            EcuM_Cfg_GenerationStream.AppendLine("                                                            STD_OFF - the callout is not called */");

			List<NodeExt> EcuWakeupSource = siriusApp.GetNode("EcuMWakeupSource");

            EcuM_Cfg_GenerationStream.AppendLine("/* [SWS_EcuM_02165] */");
            EcuM_Cfg_GenerationStream.AppendLine("/* [SWS_EcuM_02166] */");
            EcuM_Cfg_GenerationStream.AppendLine("/* [SWS_EcuMf_00002] */");
            EcuM_Cfg_GenerationStream.AppendLine("/* Range of EcuM_WakeupSourceType */");
            EcuM_Cfg_GenerationStream.AppendLine("/* The list can be extended here with new wake up sources using bits 5 up to 31 */");
            EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_WKSOURCE_NONE                          (EcuM_WakeupSourceType)(0x00000000UL)");
            EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_WKSOURCE_ALL_SOURCES                   (EcuM_WakeupSourceType)("+ Convert.ToString((1<<(EcuWakeupSource.Count + 5))-1) +"UL)");
            EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_WKSOURCE_POWER                         (EcuM_WakeupSourceType)(1UL)");
            EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_WKSOURCE_RESET                         (EcuM_WakeupSourceType)(2UL)");
            EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_WKSOURCE_INTERNAL_RESET                (EcuM_WakeupSourceType)(4UL)");
            EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_WKSOURCE_INTERNAL_WDG                  (EcuM_WakeupSourceType)(8UL)");
            EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_WKSOURCE_EXTERNAL_WDG                  (EcuM_WakeupSourceType)(16UL)");
            /*generate macros for user-defined wakeup sources*/
            
            int k = 0;
            int index = 5;
            for(k = 0; k < EcuWakeupSource.Count; k++)
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define "+ EcuWakeupSource[k].GetAttribute("EcuMWakeupSourceId") + "                  (EcuM_WakeupSourceType)("+ Convert.ToString(1<<index) +"UL)");
                index++;
            }

            EcuM_Cfg_GenerationStream.AppendLine("");
            EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_NO_OF_WAKEUP_SOURCES    (U8)("+ Convert.ToString(5 + EcuWakeupSource.Count) +"u)");
            EcuM_Cfg_GenerationStream.AppendLine("");
            EcuM_Cfg_GenerationStream.AppendLine("/* SWR_673 */");
            EcuM_Cfg_GenerationStream.AppendLine("/* sleep modes - are set according to the corresponding MCU modes */");
            for (k = 0; k < EcuMSleepMode.Count; k++)
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define " + EcuMSleepMode[k].GetAttribute("EcuMSleepModeId") + "            (EcuM_SleepModeType)("+ k +"u)");
            }
            EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_UNUSED_SLEEP_MODE    (EcuM_SleepModeType)(0xFFu)");
            EcuM_Cfg_GenerationStream.AppendLine("");
            
            EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_NO_OF_SLEEP_MODES       (EcuM_SleepModeType)(" + Convert.ToString(EcuMSleepMode.Count) + "u)");
            if (siriusApp.GetNode("EcuMFixedGeneral")[0].GetAttribute("EcuMEnableResetReasonDetection") == "true")
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_NO_OF_RESET_REASONS     (U8)(" + siriusApp.GetNode("EcuMResetReasonRef").Count + "u) /* value is set according to MCU number of reset reasons */");
            }
            EcuM_Cfg_GenerationStream.AppendLine("");

            EcuM_Cfg_GenerationStream.AppendLine("/* Unique value for each user, the list can be extended here */");
            EcuM_Cfg_GenerationStream.AppendLine("/* [SWS_EcuM_00487] */");
            List<NodeExt> EcuMFixedUser = siriusApp.GetNode("EcuMFixedUser");
            for (k = 0; k < EcuMFixedUser.Count; k++)
            {
                EcuM_Cfg_GenerationStream.AppendLine("#define "+ EcuMFixedUser[k].GetAttribute("UserName") + "                 (EcuM_UserType)("+ k +"u)");
            }
            EcuM_Cfg_GenerationStream.AppendLine("");
            EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_NO_OF_USERS             (EcuM_UserType)("+ Convert.ToString(EcuMFixedUser.Count) + "u)");
			EcuM_Cfg_GenerationStream.AppendLine("");
			if (EcuMFixedGeneral[0].GetAttribute("EcuMIncludeComM") == "true")
			{
			    EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_NO_OF_COMM_CHANNELS     ("+ siriusApp.GetNode("ComMChannels").Count + "u)");
				EcuM_Cfg_GenerationStream.AppendLine("#define ECUM_UNDEFINED_COMM_CHANNEL  0XFFu");
			}
			EcuM_Cfg_GenerationStream.AppendLine ("/* polyspace-end MISRA-C3:2.5 [Not a defect:Unset] \"Macros used into integration code or defined for future implementation\" */");
            EcuM_Cfg_GenerationStream.AppendLine("");
            EcuM_Cfg_GenerationStream.AppendLine("#endif   /* ECUM_CFG_H_ */");
            EcuM_Cfg_GenerationStream.AppendLine("");
            EcuM_Cfg_GenerationStream.AppendLine("");

            string file_footer = @"
/* %PCMS_HEADER_SUBSTITUTION_START:%
 ******************************************************************************
 * Document Management Information Log (generated by Dimensions CM)
 *
 *  Description:
 *  %PD:%
 *
 *  Used by Baselines:
 *  %PIRB:%
 *
 *  Used by Dimensions CM Projects:
 *  %PIRW:%
 *
 *  Change History:
 *  %PL:%
 *
 * %PCMS_HEADER_SUBSTITUTION_END:%
 */";
            EcuM_Cfg_GenerationStream.AppendLine(file_footer);

        }


        public void Generate_EcuM_Generated_Types()
        {
            string file_header = @"/*
******************************************************************************
* \image html ""Kopf_oZusatz_A4hoch_4C.jpg""
*
* \par Module Owner:
* Huf Huelsbeck & Fuerst GmbH & Co.KG \n
* Steeger Str. 17 \n
* 42551 Velbert \n
* Department PDE - S
*
******************************************************************************
* \par Description:
*Generated header file for generated types used by EcuM
* Implementation based on Autosar 4.2 specifications   \n
*
* % PCMS_HEADER_SUBSTITUTION_START:%
******************************************************************************
*Document Management Information Log(generated by Dimensions CM)
*
*
*CM Item:   % PID:%
*Itemname:  % PM:%
*Location:  % ARCHIVE:%
*Revision:  % PR:%
*Date:      % DATE:%
*Author:    % AUTHOR:%
*
* % PCMS_HEADER_SUBSTITUTION_END:%
*
******************************************************************************/ ";

            EcuM_Generated_Types_GenerationStream.AppendLine(file_header);
            EcuM_Generated_Types_GenerationStream.AppendLine("");
            EcuM_Generated_Types_GenerationStream.AppendLine("/* [SWS_EcuM_02992] */");
            EcuM_Generated_Types_GenerationStream.AppendLine("");
            EcuM_Generated_Types_GenerationStream.AppendLine("#ifndef  ECUM_GENERATED_TYPES_H_                /* To avoid double inclusion */");
            EcuM_Generated_Types_GenerationStream.AppendLine("#define  ECUM_GENERATED_TYPES_H_");
            EcuM_Generated_Types_GenerationStream.AppendLine("");
            EcuM_Generated_Types_GenerationStream.AppendLine("#include \"Std_Types.h\"");

            DL_Component siriusApp = new DL_Component();
            List<NodeExt> EcuMFixedGeneral = siriusApp.GetNode("EcuMFixedGeneral");
			EcuM_Generated_Types_GenerationStream.AppendLine("#include \""+ EcuMFixedGeneral[0].GetAttribute("EcuM_IncludeHeader")+ "\"");
			EcuM_Generated_Types_GenerationStream.AppendLine("#include \""+ EcuMFixedGeneral[0].GetAttribute("EcuM_IncludeDefineHeader")+ "\"");
			EcuM_Generated_Types_GenerationStream.AppendLine("");
            EcuM_Generated_Types_GenerationStream.AppendLine("/* [SWS_EcuMf_00048] */");
            EcuM_Generated_Types_GenerationStream.AppendLine("typedef U8 EcuM_UserType;");
			if ("true" == EcuMFixedGeneral[0].GetAttribute("EcuMIncludeComM"))
			{
			   EcuM_Generated_Types_GenerationStream.AppendLine("typedef U8 ECUM_COMMCHANNELS_TYPE;");
			}
            EcuM_Generated_Types_GenerationStream.AppendLine("");

            string typedef1 = @"
typedef struct
{
      Mcu_ModeType          EcuM_MCUSleepMode;       /* corresponding MCU mode for the sleep mode */
      EcuM_WakeupSourceType EcuM_WkpSources;         /* masks the wake up sources that shall be enabled for this sleep mode, each bit represents a wake up source */
      BOOL                  EcuM_SleepModeSuspended; /* ECUM_TRUE  if the CPU is suspended, halted, or powered off in the sleep mode
                                                        ECUM_FALSE if the CPU keeps running in this sleep mode */
}EcuM_SleepModeSettingsType;";

            string typedef2 = @"
typedef struct
{
      Mcu_ResetType         EcuM_ResetReason;    /* Reset reason of the wakeup source */
      EcuM_WakeupSourceType EcuM_WkpSource;      /* Name of the wakeup source */
}EcuM_ResetReasonSettingType;";

            string typedef3 = @"
typedef struct
{
      EcuM_WakeupSourceType    EcuM_WkpSource;         /* Name of the wakeup source */
      U16                      EcuM_ValidationTimeout; /* Contains the value of validation timeout for each wake up source.
                                                       If the wake up source does not need validation the value shall be ECUM_NO_VALIDATION_TIMEOUT */";

			EcuM_Generated_Types_GenerationStream.AppendLine("/* [BSW_SWS_EcuMf_00005] */");
            EcuM_Generated_Types_GenerationStream.AppendLine(typedef1);
			if (siriusApp.GetNode("EcuMFixedGeneral")[0].GetAttribute("EcuMEnableResetReasonDetection") == "true")
			{
				EcuM_Generated_Types_GenerationStream.AppendLine(" ");
				EcuM_Generated_Types_GenerationStream.AppendLine("/* [BSW_SWS_EcuMf_00006] */");
				EcuM_Generated_Types_GenerationStream.AppendLine(typedef2);
			}
			EcuM_Generated_Types_GenerationStream.AppendLine(" ");
			EcuM_Generated_Types_GenerationStream.AppendLine("/* [BSW_SWS_EcuMf_00007] */");
            EcuM_Generated_Types_GenerationStream.AppendLine(typedef3);
			if ("true" == EcuMFixedGeneral[0].GetAttribute("EcuMIncludeComM"))
			{
				EcuM_Generated_Types_GenerationStream.AppendLine("      ECUM_COMMCHANNELS_TYPE   EcuM_ComMChannelRef; /* ComM channel reference. If the wakeup source is not a communication channel value is ECUM_UNDEFINED_COMM_CHANNEL */");
			}
			EcuM_Generated_Types_GenerationStream.AppendLine("}EcuM_WakeupSourceValidationType;");
            EcuM_Generated_Types_GenerationStream.AppendLine("");
            EcuM_Generated_Types_GenerationStream.AppendLine("/* [SWS_EcuMf_00119] */");
            EcuM_Generated_Types_GenerationStream.AppendLine("typedef U8 EcuM_SleepModeType;");
            EcuM_Generated_Types_GenerationStream.AppendLine("");
            if(siriusApp.GetNode("EcuMSleepMode").Count != 0)
            {
                EcuM_Generated_Types_GenerationStream.AppendLine("extern const EcuM_SleepModeSettingsType EcuM_S_SleepModeSet[ECUM_NO_OF_SLEEP_MODES]; /* contains a list with all wake up sources enabled into each sleep mode */");
            }
            else
            {
                EcuM_Generated_Types_GenerationStream.AppendLine("extern const EcuM_SleepModeSettingsType EcuM_S_SleepModeSet[]; /* contains a list with all wake up sources enabled into each sleep mode */");
            }
            if (siriusApp.GetNode("EcuMFixedGeneral")[0].GetAttribute("EcuMEnableResetReasonDetection") == "true")
            {
                EcuM_Generated_Types_GenerationStream.AppendLine("extern const EcuM_ResetReasonSettingType EcuM_ResetReasonWkpSources[ECUM_NO_OF_RESET_REASONS];   /* contains a list with all wake up sources related to each reset reason */");
            }
			
			EcuM_Generated_Types_GenerationStream.AppendLine("extern const EcuM_WakeupSourceValidationType EcuM_WkpSourceValidation[ECUM_NO_OF_WAKEUP_SOURCES]; /* contains a list with the validation timeouts for all the wake up sources */");
            
			if (("true" == EcuMFixedGeneral[0].GetAttribute("EcuMIncludeComM")) && (0 != siriusApp.GetNode("ComMChannels").Count))
			{
		    	EcuM_Generated_Types_GenerationStream.AppendLine("extern const ECUM_COMMCHANNELS_TYPE EcuM_ComMChannels[ECUM_NO_OF_COMM_CHANNELS]; /* contains a list with all configured ComM channels for which EcuM has to call ComM_CommunicationAllowed */");
			}
			
			EcuM_Generated_Types_GenerationStream.AppendLine("");
            EcuM_Generated_Types_GenerationStream.AppendLine("/* polyspace-begin MISRA-C3:D4.9 [Not a defect:Unset] \"Macro used to facilitate easier configuration.\" */");
            EcuM_Generated_Types_GenerationStream.AppendLine("#define ECUM_DISABLE_ALL_INTERRUPTS()"+"\t\t"+EcuMFixedGeneral[0].GetAttribute("ECUM_DISABLE_ALL_INTERRUPTS"));
            EcuM_Generated_Types_GenerationStream.AppendLine("#define ECUM_ENABLE_ALL_INTERRUPTS()"+"\t\t"+EcuMFixedGeneral[0].GetAttribute("ECUM_ENABLE_ALL_INTERRUPTS"));
            EcuM_Generated_Types_GenerationStream.AppendLine("/* [SWS_EcuMf_00010] */");
            EcuM_Generated_Types_GenerationStream.AppendLine("#define ECUM_START_OS()"+"\t\t\t\t\t\t\t"+EcuMFixedGeneral[0].GetAttribute("ECUM_START_OS"));
            EcuM_Generated_Types_GenerationStream.AppendLine("#define ECUM_SHUTDOWN_OS()"+"\t\t\t\t\t\t"+EcuMFixedGeneral[0].GetAttribute("ECUM_SHUTDOWN_OS"));
            EcuM_Generated_Types_GenerationStream.AppendLine("#define ECUM_LOCK_SCHEDULER()"+"\t\t\t\t\t"+EcuMFixedGeneral[0].GetAttribute("ECUM_LOCK_SCHEDULER"));
            EcuM_Generated_Types_GenerationStream.AppendLine("#define ECUM_UNLOCK_SCHEDULER()"+"\t\t\t\t"+EcuMFixedGeneral[0].GetAttribute("ECUM_UNLOCK_SCHEDULER"));
			EcuM_Generated_Types_GenerationStream.AppendLine("/* polyspace-end MISRA-C3:D4.9 [Not a defect:Unset] \"Macro used to facilitate easier configuration.\" */");
            EcuM_Generated_Types_GenerationStream.AppendLine("");
            EcuM_Generated_Types_GenerationStream.AppendLine("#endif   /* ECUM_GENERATED_TYPES_H_ */");
            EcuM_Generated_Types_GenerationStream.AppendLine("");
            EcuM_Generated_Types_GenerationStream.AppendLine("");

            string file_footer = @"
/* %PCMS_HEADER_SUBSTITUTION_START:%
 ******************************************************************************
 * Document Management Information Log (generated by Dimensions CM)
 *
 *  Description:
 *  %PD:%
 *
 *  Used by Baselines:
 *  %PIRB:%
 *
 *  Used by Dimensions CM Projects:
 *  %PIRW:%
 *
 *  Change History:
 *  %PL:%
 *
 * %PCMS_HEADER_SUBSTITUTION_END:%
 */";
            EcuM_Generated_Types_GenerationStream.AppendLine(file_footer);
        }



        public void Generate_EcuM_Lcfg()
        {
            string file_header = @"/*
*!
* \defgroup <module_group (MOD_) Module purpose>
* \{
******************************************************************************
* \image html ""Kopf_oZusatz_A4hoch_4C.jpg""
*
* \par Module Owner:
* Huf Huelsbeck & Fuerst GmbH & Co.KG \n
* Steeger Str. 17 \n
* 42551 Velbert \n
* Department PDE - S
*
******************************************************************************
*
* \par Purpose:
* Linktime configuration file for EcuM
* Service Layer(AUTOSAR 4.2)
*
* \par Compiler:

*IAR
*
* \par Controller:

*Independent
*
* \par Resources:

*    | Resource     | Amount    | Remarks|
*    | -------------| ----------| -------|
*    | ROM          | x Byte    |        |
*    | CODE         | x Byte    |        |
*    | RAM          | x Byte    |        |
*    | EEPROM       | x Byte    |        |
*    | Runtime Init | X ms      |        |
*    | Runtime Task | X ms      |        |
*
* \par Quality:

*    | Factor            | Excl  | Good  | Fair  | Poor  |
*    | ----------------- | ----: | ----: | ----: | ----: |
*    | _Maintainability_ | 0 %   | 0 %   | 0 %   | 0 %   |  
*    | Analyzability     | 0 %   | 0 %   | 0 %   | 0 %   |
*    | Changeability     | 0 %   | 0 %   | 0 %   | 0 %   |
*    | Stability         | 0 %   | 0 %   | 0 %   | 0 %   |
*    | Testability       | 0 %   | 0 %   | 0 %   | 0 %   |
*
* \par MISRA rules violations:

*     \li none
*
******************************************************************************
*
* \attention
*   \li This file is generated from the configuration tool
*
******************************************************************************
* % PCMS_HEADER_SUBSTITUTION_START:%
*
*Document Management Information Log(generated by Dimensions CM)
*
*
*CM Item:   % PID:%
*Itemname:  % PM:%
*Location:  % ARCHIVE:%
*Revision:  % PR:%
*Date:      % DATE:%
*Author:    % AUTHOR:%
*
* % PCMS_HEADER_SUBSTITUTION_END:%
*
******************************************************************************/

/*!
 \defgroup module_group_det Details
 \ingroup module_group
 \{
*/";
            EcuM_Lcfg_GenerationStream.AppendLine(file_header);
            EcuM_Lcfg_GenerationStream.AppendLine("");
            EcuM_Lcfg_GenerationStream.AppendLine("#include \"EcuM.h\"");
			
			DL_Component siriusApp = new DL_Component();
			List<NodeExt> EcuMComMChannels = siriusApp.GetNode("ComMChannels");
			string 	EcuMIncludeComM = siriusApp.GetNode("EcuMFixedGeneral")[0].GetAttribute("EcuMIncludeComM");
			if("true" == EcuMIncludeComM)
			{
			    EcuM_Lcfg_GenerationStream.AppendLine("#include \"ComM.h\"");
			}
            EcuM_Lcfg_GenerationStream.AppendLine("");
            EcuM_Lcfg_GenerationStream.AppendLine("/* SWR_667 */");

            int i = 0;
            List<NodeExt> EcuMSleepMode = siriusApp.GetNode("EcuMSleepMode");
            List<NodeExt> ECUM_WKSOURCE_POWER = siriusApp.GetNode("ECUM_WKSOURCE_POWER");
            List<NodeExt> ECUM_WKSOURCE_RESET = siriusApp.GetNode("ECUM_WKSOURCE_RESET");
            List<NodeExt> ECUM_WKSOURCE_INTERNAL_RESET = siriusApp.GetNode("ECUM_WKSOURCE_INTERNAL_RESET");
            List<NodeExt> ECUM_WKSOURCE_INTERNAL_WDG = siriusApp.GetNode("ECUM_WKSOURCE_INTERNAL_WDG");
            List<NodeExt> ECUM_WKSOURCE_EXTERNAL_WDG = siriusApp.GetNode("ECUM_WKSOURCE_EXTERNAL_WDG");
            if (EcuMSleepMode.Count != 0)
            {
                EcuM_Lcfg_GenerationStream.AppendLine("const EcuM_SleepModeSettingsType EcuM_S_SleepModeSet[ECUM_NO_OF_SLEEP_MODES] = {");
                for (i = 0; i < EcuMSleepMode.Count; i++)
                {
                    EcuM_Lcfg_GenerationStream.AppendLine("     /* " + EcuMSleepMode[i].GetAttribute("EcuMSleepModeId") + " */");
                    EcuM_Lcfg_GenerationStream.AppendLine("      {");

                    if (EcuMSleepMode[i].GetAttribute("EcuMSleepModeMcuModeRef") != "")
                    {
                        EcuM_Lcfg_GenerationStream.AppendLine("            " + EcuMSleepMode[i].GetAttribute("EcuMSleepModeMcuModeRef") + ",");
                    }

                    string[] WakeupSourcesPerSleepMode = new string[255];
                    int k = 0;
                    if (EcuMSleepMode[i].GetAttribute("EcuMPredefinedWakeUp_POWER") == "true")
                    {/*if POWER wake up source can trigger the escape from this sleep mode*/
                        WakeupSourcesPerSleepMode[k] = ECUM_WKSOURCE_POWER[0].GetAttribute("EcuMWakeupSourceId");
                        k++;
                    }
                    if (EcuMSleepMode[i].GetAttribute("EcuMPredefinedWakeUp_RESET") == "true")
                    {/*if POWER wake up source can trigger the escape from this sleep mode*/
                        WakeupSourcesPerSleepMode[k] = ECUM_WKSOURCE_RESET[0].GetAttribute("EcuMWakeupSourceId");
                        k++;
                    }
                    if (EcuMSleepMode[i].GetAttribute("EcuMPredefinedWakeUp_INTERNAL_RESET") == "true")
                    {/*if POWER wake up source can trigger the escape from this sleep mode*/
                        WakeupSourcesPerSleepMode[k] = ECUM_WKSOURCE_INTERNAL_RESET[0].GetAttribute("EcuMWakeupSourceId");
                        k++;
                    }
                    if (EcuMSleepMode[i].GetAttribute("EcuMPredefinedWakeUp_INTERNAL_WDG") == "true")
                    {/*if POWER wake up source can trigger the escape from this sleep mode*/
                        WakeupSourcesPerSleepMode[k] = ECUM_WKSOURCE_INTERNAL_WDG[0].GetAttribute("EcuMWakeupSourceId");
                        k++;
                    }
                    if (EcuMSleepMode[i].GetAttribute("EcuMPredefinedWakeUp_EXTERNAL_WDG") == "true")
                    {/*if POWER wake up source can trigger the escape from this sleep mode*/
                        WakeupSourcesPerSleepMode[k] = ECUM_WKSOURCE_EXTERNAL_WDG[0].GetAttribute("EcuMWakeupSourceId");
                        k++;
                    }

					List<NodeExt> EcuM_UserDependent_WakeupSource = EcuMSleepMode[i].GetChildren("EcuM_UserDependent_WakeupSource");
                    int l = 0;
                    for (l = 0; l < EcuM_UserDependent_WakeupSource.Count; l++)
                    {
                        WakeupSourcesPerSleepMode[k] = EcuM_UserDependent_WakeupSource[l].GetAttribute("EcuMWakeupSourceMask");
                        k++;
                    }
					
                    /*write wake up source (|) operations */
                    int m = 0;
                    EcuM_Lcfg_GenerationStream.Append("            "); /*align*/
                    for (m = 0; m < 255; m++)
                    {
                        EcuM_Lcfg_GenerationStream.Append(WakeupSourcesPerSleepMode[m] + " ");
                        if (string.IsNullOrEmpty(WakeupSourcesPerSleepMode[m + 1]))
                        {
                            /*if next position is empty - do not write OR operator*/
                            m = 255; /*force exit of for loop*/
                        }
                        else
                        {
                            EcuM_Lcfg_GenerationStream.Append("| ");
                        }
                    }

                    if ((EcuMSleepMode[i].GetAttribute("EcuMPredefinedWakeUp_POWER") == "false") &&
                        (EcuMSleepMode[i].GetAttribute("EcuMPredefinedWakeUp_RESET") == "false") &&
                        (EcuMSleepMode[i].GetAttribute("EcuMPredefinedWakeUp_INTERNAL_RESET") == "false") &&
                        (EcuMSleepMode[i].GetAttribute("EcuMPredefinedWakeUp_INTERNAL_WDG") == "false") &&
                        (EcuMSleepMode[i].GetAttribute("EcuMPredefinedWakeUp_EXTERNAL_WDG") == "false") &&
                        (EcuM_UserDependent_WakeupSource.Count == 0))
                    {
                        EcuM_Lcfg_GenerationStream.Append("ECUM_WKSOURCE_NONE");
                    }

                    EcuM_Lcfg_GenerationStream.AppendLine(",");

                    if (EcuMSleepMode[i].GetAttribute("EcuMSleepModeSuspend") == "true")
                    {
                        EcuM_Lcfg_GenerationStream.AppendLine("            STD_ON");
                    }
                    else
                    {
                        EcuM_Lcfg_GenerationStream.AppendLine("            STD_OFF");
                    }

                    EcuM_Lcfg_GenerationStream.AppendLine("      },");

                }/*end of sleep modes loop*/
                EcuM_Lcfg_GenerationStream.AppendLine("};");
            }
            else
            {
                EcuM_Lcfg_GenerationStream.AppendLine("const EcuM_SleepModeSettingsType EcuM_S_SleepModeSet[];");
            }
            EcuM_Lcfg_GenerationStream.AppendLine("");

            /*complete EcuM_ResetReasonWkpSources structure in case it is enabled*/
            if(siriusApp.GetNode("EcuMFixedGeneral")[0].GetAttribute("EcuMEnableResetReasonDetection") == "true")
            {
                EcuM_Lcfg_GenerationStream.AppendLine("const EcuM_ResetReasonSettingType EcuM_ResetReasonWkpSources[ECUM_NO_OF_RESET_REASONS] = {");

                if (ECUM_WKSOURCE_POWER[0].GetChildren("EcuMResetReasonRef").Count != 0)
                {
                    List<NodeExt> EcuMResetReasonRef = ECUM_WKSOURCE_POWER[0].GetChildren("EcuMResetReasonRef");
                    int index = 0;
                    for (index = 0; index < EcuMResetReasonRef.Count; index++)
                    {
                        EcuM_Lcfg_GenerationStream.AppendLine("      { " + EcuMResetReasonRef[index].GetAttribute("EcuMResetReasonRef") + ",                " + ECUM_WKSOURCE_POWER[0].GetAttribute("EcuMWakeupSourceId") + "},");
                    }
                }
                if (ECUM_WKSOURCE_RESET[0].GetChildren("EcuMResetReasonRef").Count != 0)
                {
                    List<NodeExt> EcuMResetReasonRef = ECUM_WKSOURCE_RESET[0].GetChildren("EcuMResetReasonRef");
                    int index = 0;
                    for (index = 0; index < EcuMResetReasonRef.Count; index++)
                    {
                        EcuM_Lcfg_GenerationStream.AppendLine("      { " + EcuMResetReasonRef[index].GetAttribute("EcuMResetReasonRef") + ",                " + ECUM_WKSOURCE_RESET[0].GetAttribute("EcuMWakeupSourceId") + "},");
                    }
                }
                if (ECUM_WKSOURCE_INTERNAL_RESET[0].GetChildren("EcuMResetReasonRef").Count != 0)
                {
                    List<NodeExt> EcuMResetReasonRef = ECUM_WKSOURCE_INTERNAL_RESET[0].GetChildren("EcuMResetReasonRef");
                    int index = 0;
                    for (index = 0; index < EcuMResetReasonRef.Count; index++)
                    {
                            EcuM_Lcfg_GenerationStream.AppendLine("      { " + EcuMResetReasonRef[index].GetAttribute("EcuMResetReasonRef") + ",                " + ECUM_WKSOURCE_INTERNAL_RESET[0].GetAttribute("EcuMWakeupSourceId") + "},");
                    }
                }
                if (ECUM_WKSOURCE_INTERNAL_WDG[0].GetChildren("EcuMResetReasonRef").Count != 0)
                {
                    List<NodeExt> EcuMResetReasonRef = ECUM_WKSOURCE_INTERNAL_WDG[0].GetChildren("EcuMResetReasonRef");
                    int index = 0;
                    for (index = 0; index < EcuMResetReasonRef.Count; index++)
                    {
                       EcuM_Lcfg_GenerationStream.AppendLine("      { " + EcuMResetReasonRef[index].GetAttribute("EcuMResetReasonRef") + ",                " + ECUM_WKSOURCE_INTERNAL_WDG[0].GetAttribute("EcuMWakeupSourceId") + "},");
                    }
                }
                if (ECUM_WKSOURCE_EXTERNAL_WDG[0].GetChildren("EcuMResetReasonRef").Count != 0)
                {
                    List<NodeExt> EcuMResetReasonRef = ECUM_WKSOURCE_EXTERNAL_WDG[0].GetChildren("EcuMResetReasonRef");
                    int index = 0;
                    for (index = 0; index < EcuMResetReasonRef.Count; index++)
                    {
                        EcuM_Lcfg_GenerationStream.AppendLine("      { " + EcuMResetReasonRef[index].GetAttribute("EcuMResetReasonRef") + ",                " + ECUM_WKSOURCE_EXTERNAL_WDG[0].GetAttribute("EcuMWakeupSourceId") + "},");
                    }
                }

                if (siriusApp.GetNode("EcuMWakeupSource").Count != 0)
                {
                    int index_i = 0, index_j = 0;
                    List<NodeExt> EcuMWakeupSource2 = siriusApp.GetNode("EcuMWakeupSource");
                    for (index_i = 0; index_i < siriusApp.GetNode("EcuMWakeupSource").Count; index_i++)
                    {
                        List<NodeExt> EcuMResetReasonRef = EcuMWakeupSource2[index_i].GetChildren("EcuMResetReasonRef");
                        for (index_j = 0; index_j < EcuMResetReasonRef.Count; index_j++)
                        {
                            EcuM_Lcfg_GenerationStream.AppendLine("      { " + EcuMResetReasonRef[index_j].GetAttribute("EcuMResetReasonRef") + ",                " + EcuMWakeupSource2[index_i].GetAttribute("EcuMWakeupSourceId") + "},");
                        }
                    }
                }

                EcuM_Lcfg_GenerationStream.AppendLine("};");
                /*end of EcuM_ResetReasonWkpSources structure*/
            }
            else
            {
                /*do not generate nothing*/
            }
            

            EcuM_Lcfg_GenerationStream.AppendLine("");
            EcuM_Lcfg_GenerationStream.AppendLine("/* [SWS_EcuM_02625] */");
            EcuM_Lcfg_GenerationStream.AppendLine("const EcuM_WakeupSourceValidationType EcuM_WkpSourceValidation[ECUM_NO_OF_WAKEUP_SOURCES] = {");
            if(ECUM_WKSOURCE_POWER[0].GetAttribute("EcuMValidationTimeout") != Convert.ToString(0))
            {
                EcuM_Lcfg_GenerationStream.Append("      {ECUM_WKSOURCE_POWER,                 "+ ECUM_WKSOURCE_POWER[0].GetAttribute("EcuMValidationTimeout") + "U");
	        }
            else
            {
                EcuM_Lcfg_GenerationStream.Append("      {ECUM_WKSOURCE_POWER,                 ECUM_NO_VALIDATION_TIMEOUT");
            }
			if ("true" == EcuMIncludeComM)
			{
				EcuM_Lcfg_GenerationStream.Append(",   ECUM_UNDEFINED_COMM_CHANNEL");	
			}
			EcuM_Lcfg_GenerationStream.Append("},");
			EcuM_Lcfg_GenerationStream.AppendLine();
            if (ECUM_WKSOURCE_RESET[0].GetAttribute("EcuMValidationTimeout") != Convert.ToString(0))
            {
                EcuM_Lcfg_GenerationStream.Append("      {ECUM_WKSOURCE_RESET,                 " + ECUM_WKSOURCE_RESET[0].GetAttribute("EcuMValidationTimeout") + "U");
            }
            else
            {
                EcuM_Lcfg_GenerationStream.Append("      {ECUM_WKSOURCE_RESET,                 ECUM_NO_VALIDATION_TIMEOUT");
			}
			if ("true" == EcuMIncludeComM)
			{
				EcuM_Lcfg_GenerationStream.Append(",   ECUM_UNDEFINED_COMM_CHANNEL");	
			}
			EcuM_Lcfg_GenerationStream.Append("},");
			EcuM_Lcfg_GenerationStream.AppendLine();
            if (ECUM_WKSOURCE_INTERNAL_RESET[0].GetAttribute("EcuMValidationTimeout") != Convert.ToString(0))
            {
                EcuM_Lcfg_GenerationStream.Append("      {ECUM_WKSOURCE_INTERNAL_RESET,        " + ECUM_WKSOURCE_INTERNAL_RESET[0].GetAttribute("EcuMValidationTimeout") + "U");
            }
            else
            {
                EcuM_Lcfg_GenerationStream.Append("      {ECUM_WKSOURCE_INTERNAL_RESET,        ECUM_NO_VALIDATION_TIMEOUT");
            }
			if ("true" == EcuMIncludeComM)
			{
				EcuM_Lcfg_GenerationStream.Append(",   ECUM_UNDEFINED_COMM_CHANNEL");	
			}
			EcuM_Lcfg_GenerationStream.Append("},");
			EcuM_Lcfg_GenerationStream.AppendLine();
            if (ECUM_WKSOURCE_INTERNAL_WDG[0].GetAttribute("EcuMValidationTimeout") != Convert.ToString(0))
            {
                EcuM_Lcfg_GenerationStream.Append("      {ECUM_WKSOURCE_INTERNAL_WDG,          " + ECUM_WKSOURCE_INTERNAL_WDG[0].GetAttribute("EcuMValidationTimeout") + "U");
            }
            else
            {
                EcuM_Lcfg_GenerationStream.Append("      {ECUM_WKSOURCE_INTERNAL_WDG,          ECUM_NO_VALIDATION_TIMEOUT");
            }
			if ("true" == EcuMIncludeComM)
			{
				EcuM_Lcfg_GenerationStream.Append(",   ECUM_UNDEFINED_COMM_CHANNEL");	
			}
			EcuM_Lcfg_GenerationStream.Append("},");
			EcuM_Lcfg_GenerationStream.AppendLine();
            if (ECUM_WKSOURCE_EXTERNAL_WDG[0].GetAttribute("EcuMValidationTimeout") != Convert.ToString(0))
            {
                EcuM_Lcfg_GenerationStream.Append("      {ECUM_WKSOURCE_EXTERNAL_WDG,          " + ECUM_WKSOURCE_EXTERNAL_WDG[0].GetAttribute("EcuMValidationTimeout") + "U");
            }
            else
            {
                EcuM_Lcfg_GenerationStream.Append("      {ECUM_WKSOURCE_EXTERNAL_WDG,          ECUM_NO_VALIDATION_TIMEOUT");
            }
			if ("true" == EcuMIncludeComM)
			{
				EcuM_Lcfg_GenerationStream.Append(",   ECUM_UNDEFINED_COMM_CHANNEL");	
			}
			EcuM_Lcfg_GenerationStream.Append("},");
            EcuM_Lcfg_GenerationStream.AppendLine();
			
            List<NodeExt> EcuMWakeupSource = siriusApp.GetNode("EcuMWakeupSource");
            for (i = 0; i < EcuMWakeupSource.Count; i++)
            {
                if(EcuMWakeupSource[i].GetAttribute("EcuMValidationTimeout") != Convert.ToString(0))
                {
                    EcuM_Lcfg_GenerationStream.Append("      {"+ EcuMWakeupSource[i].GetAttribute("EcuMWakeupSourceId") + ",          "+ EcuMWakeupSource[i].GetAttribute("EcuMValidationTimeout") + "U");
                } 
                else
                {
                    EcuM_Lcfg_GenerationStream.Append("      {" + EcuMWakeupSource[i].GetAttribute("EcuMWakeupSourceId") + ",          ECUM_NO_VALIDATION_TIMEOUT");
                }
				if ("true" == EcuMIncludeComM)
				{
					if ("" != EcuMWakeupSource[i].GetAttribute("EcuComMChannelRef").Trim())
					{
						EcuM_Lcfg_GenerationStream.Append(",   " + EcuMWakeupSource[i].GetAttribute("EcuComMChannelRef"));
					}
					else
					{
						EcuM_Lcfg_GenerationStream.Append(",   ECUM_UNDEFINED_COMM_CHANNEL");
					}
				}
				if (i < (EcuMWakeupSource.Count - 1))
				{
			    	EcuM_Lcfg_GenerationStream.Append("},");
				}
				else
				{
					EcuM_Lcfg_GenerationStream.Append("}");
				}
				EcuM_Lcfg_GenerationStream.AppendLine();
            }
            EcuM_Lcfg_GenerationStream.AppendLine("};");
            EcuM_Lcfg_GenerationStream.AppendLine("");
			
			if (("true" == EcuMIncludeComM) && (0 != EcuMComMChannels.Count))
			{
		        EcuM_Lcfg_GenerationStream.Append("const ECUM_COMMCHANNELS_TYPE EcuM_ComMChannels[ECUM_NO_OF_COMM_CHANNELS] = {");
		        for (i = 0; i< EcuMComMChannels.Count; i++)
		        {
			        if (i < (EcuMComMChannels.Count - 1))
			        {
			            EcuM_Lcfg_GenerationStream.Append( EcuMComMChannels[i].GetAttribute("ComMChannelRef") + ",");
			        }
			        else
			        {
			            EcuM_Lcfg_GenerationStream.Append( EcuMComMChannels[i].GetAttribute("ComMChannelRef")+ "};");
			        }
	            }
			}
			  
            EcuM_Lcfg_GenerationStream.AppendLine("");

            string file_footer = @"
/* %PCMS_HEADER_SUBSTITUTION_START:%
 ******************************************************************************
 * Document Management Information Log (generated by Dimensions CM)
 *
 *  Description:
 *  %PD:%
 *
 *  Used by Baselines:
 *  %PIRB:%
 *
 *  Used by Dimensions CM Projects:
 *  %PIRW:%
 *
 *  Change History:
 *  %PL:%
 *
 * %PCMS_HEADER_SUBSTITUTION_END:%
 */";

            EcuM_Lcfg_GenerationStream.AppendLine(file_footer);
        }



        public void Generate_EcuM_MemMap()
        {
            string all_text = @" /* polyspace MISRA-C3:D4.10 [Not a defect:Unset] ""Module included just by EcuM, it is part of memory mapping strategy"" */
/*******************************************************************************
* \image html ""Kopf_oZusatz_A4hoch_4C.jpg""
*
* \par Module Owner:
* Huf Huelsbeck & Fuerst GmbH & Co.KG \n
* Steeger Str. 17 \n
* 42551 Velbert \n
* Department PDE - S
*
******************************************************************************
* \par Description:
* Generated memory map file for EcuM
* Implementation based on Autosar 4.2 specifications   \n
*
* % PCMS_HEADER_SUBSTITUTION_START:%
******************************************************************************
*Document Management Information Log(generated by Dimensions CM)
*
*
*CM Item:   % PID:%
*Itemname:  % PM:%
*Location:  % ARCHIVE:%
*Revision:  % PR:%
*Date:      % DATE:%
*Author:    % AUTHOR:%
*
* % PCMS_HEADER_SUBSTITUTION_END:%
*
******************************************************************************/

#define ECUM_MEMMAP_ERROR

/* polyspace-begin MISRA-C3:20.5 [Not a defect:Unset] ""#undef is part of the memory mapping strategy, undefined macro is not necessary anymore"" */
#if defined( ECUM_LAST_SHUTDOWN_TARGET_START_SEC_VAR )
/* #pragma <enter your compiler specific pragma> */
/* polyspace +1 MISRA-C3:D1.1 [Not a defect:Unset] ""pragma used to place a variable into a no init area"" */
#pragma object_attribute=__no_init
# undef ECUM_LAST_SHUTDOWN_TARGET_START_SEC_VAR
# undef ECUM_MEMMAP_ERROR

#endif

#if defined( ECUM_LAST_SHUTDOWN_TARGET_STOP_SEC_VAR )
   /* #pragma <enter your compiler specific pragma> */
# undef ECUM_LAST_SHUTDOWN_TARGET_STOP_SEC_VAR
# undef ECUM_MEMMAP_ERROR

#endif

#if defined( ECUM_LAST_SHUTDOWN_MODE_START_SEC_VAR )
/* #pragma <enter your compiler specific pragma> */
/* polyspace +1 MISRA-C3:D1.1 [Not a defect:Unset] ""pragma used to place a variable into a no init area"" */
#pragma object_attribute=__no_init
# undef ECUM_LAST_SHUTDOWN_MODE_START_SEC_VAR
# undef ECUM_MEMMAP_ERROR

#endif

#if defined( ECUM_LAST_SHUTDOWN_MODE_STOP_SEC_VAR )
   /* #pragma <enter your compiler specific pragma> */
# undef ECUM_LAST_SHUTDOWN_MODE_STOP_SEC_VAR
# undef ECUM_MEMMAP_ERROR

#endif

#if defined( ECUM_INTENDED_RESTART_FLAG_START_SEC_VAR )
/* #pragma <enter your compiler specific pragma> */
/* polyspace +1 MISRA-C3:D1.1 [Not a defect:Unset] ""pragma used to place a variable into a no init area"" */
#pragma object_attribute=__no_init
# undef ECUM_INTENDED_RESTART_FLAG_START_SEC_VAR
# undef ECUM_MEMMAP_ERROR

#endif

#if defined( ECUM_INTENDED_RESTART_FLAG_STOP_SEC_VAR )
   /* #pragma <enter your compiler specific pragma> */
# undef ECUM_INTENDED_RESTART_FLAG_STOP_SEC_VAR
# undef ECUM_MEMMAP_ERROR

#endif
/* polyspace-end MISRA-C3:20.5 [Not a defect:Unset] ""#undef is part of the memory mapping strategy, undefined macro is not necessary anymore"" */

#if defined( ECUM_MEMMAP_ERROR )
# error ""Error in MemMap.h: MemMap section is not included!""
#endif


 /* %PCMS_HEADER_SUBSTITUTION_START:%
  ******************************************************************************
  * Document Management Information Log (generated by Dimensions CM)
  *
  *  Description:
  *  %PD:%
  *
  *  Used by Baselines:
  *  %PIRB:%
  *
  *  Used by Dimensions CM Projects:
  *  %PIRW:%
  *
  *  Change History:
  *  %PL:%
  *
  * %PCMS_HEADER_SUBSTITUTION_END:%
  */";
            EcuM_MemMap_GenerationStream.Append(all_text);
        }


        public void Generate_EcuM_PBcfg()
        {
            string file_header = @"/*
*!
* \defgroup <module_group (MOD_) Module purpose>
* \{
******************************************************************************
* \image html ""Kopf_oZusatz_A4hoch_4C.jpg""
*
* \par Module Owner:
* Huf Huelsbeck & Fuerst GmbH & Co.KG \n
* Steeger Str. 17 \n
* 42551 Velbert \n
* Department PDE - S
*
******************************************************************************
*
* \par Purpose:
* Post build configuration file for EcuM
* Service Layer(AUTOSAR 4.2)
*
* \par Compiler:

*IAR
*
* \par Controller:

*Independent
*
* \par Resources:

*    | Resource     | Amount    | Remarks|
*    | -------------| ----------| -------|
*    | ROM          | x Byte    |        |
*    | CODE         | x Byte    |        |
*    | RAM          | x Byte    |        |
*    | EEPROM       | x Byte    |        |
*    | Runtime Init | X ms      |        |
*    | Runtime Task | X ms      |        |
*
* \par Quality:

*    | Factor            | Excl  | Good  | Fair  | Poor  |
*    | ----------------- | ----: | ----: | ----: | ----: |
*    | _Maintainability_ | 0 %   | 0 %   | 0 %   | 0 %   |  
*    | Analyzability     | 0 %   | 0 %   | 0 %   | 0 %   |
*    | Changeability     | 0 %   | 0 %   | 0 %   | 0 %   |
*    | Stability         | 0 %   | 0 %   | 0 %   | 0 %   |
*    | Testability       | 0 %   | 0 %   | 0 %   | 0 %   |
*
* \par MISRA rules violations:

*     \li none
*
******************************************************************************
*
* \attention
*   \li This file is generated from the configuration tool and needs to be adapted
* according to project specification
*
******************************************************************************
* % PCMS_HEADER_SUBSTITUTION_START:%
*
*Document Management Information Log(generated by Dimensions CM)
*
*
*CM Item:   % PID:%
*Itemname:  % PM:%
*Location:  % ARCHIVE:%
*Revision:  % PR:%
*Date:      % DATE:%
*Author:    % AUTHOR:%
*
* % PCMS_HEADER_SUBSTITUTION_END:%
*
******************************************************************************/

/*!
 \defgroup module_group_det Details
 \ingroup module_group
 \{
*/

";
            EcuM_PBCfg_GenerationStream.AppendLine(file_header);
            EcuM_PBCfg_GenerationStream.AppendLine("#include \"EcuM_Cbk.h\"");
            EcuM_PBCfg_GenerationStream.AppendLine("");
            EcuM_PBCfg_GenerationStream.AppendLine("/* [SWS_EcuM_02801] */");
            EcuM_PBCfg_GenerationStream.AppendLine("/* [SWS_EcuM_00800] */");
            EcuM_PBCfg_GenerationStream.AppendLine("/* [SWS_EcuM_00793] */");
			EcuM_PBCfg_GenerationStream.Append("const EcuM_ConfigType EcuM_Config_Set = {");

            DL_Component siriusApp = new DL_Component();
            List<NodeExt> EcuMModuleToBeInitialized = siriusApp.GetNode("EcuMModuleToBeInitialized");

            if (EcuMModuleToBeInitialized.Count != 0)
            { 
            int i = 0;

            for (i = 0; i < EcuMModuleToBeInitialized.Count; i++)
            {
                switch (EcuMModuleToBeInitialized[i].GetAttribute("ModuleName"))
                {
                    case "MOD_ECUAL_FEE":
                        EcuM_PBCfg_GenerationStream.Append("NULL, ");
                        break;

                    case "MOD_MCAL_ADC":
                        EcuM_PBCfg_GenerationStream.Append("&AdcConfigSet, ");
                        break;

                    case "MOD_MCAL_GPT":
                        EcuM_PBCfg_GenerationStream.Append("&GptChannelConfigSet, ");
                        break;

                    case "MOD_MCAL_MCU":
                        EcuM_PBCfg_GenerationStream.Append("&Mcu_S_ConfigSet, ");
                        break;

                    case "MOD_MCAL_PORT":
                        EcuM_PBCfg_GenerationStream.Append("&PortConfigSet[0], ");
                        break;

                    case "MOD_MCAL_PWM":
                        EcuM_PBCfg_GenerationStream.Append("&Pwm_ConfigSet, ");
                        break;

                    case "MOD_MCAL_SPI":
                        EcuM_PBCfg_GenerationStream.Append("&Spi_ConfigSet, ");
                        break;

                    case "MOD_MCAL_WDG":
                        EcuM_PBCfg_GenerationStream.Append("&Wdg_S_ConfigSet, ");
                        break;

                    case "MOD_SERV_NVM_MNG":
                        EcuM_PBCfg_GenerationStream.Append("NULL, ");
                        break;

                    case "MOD_SERV_WDG_MNG":
                        EcuM_PBCfg_GenerationStream.Append("&WdgM_S_InitConfigSetMode, ");
                        break;

                    default:
                        break;
                }
            }
			EcuM_PBCfg_GenerationStream.Remove(EcuM_PBCfg_GenerationStream.Length - 2, 2);
            EcuM_PBCfg_GenerationStream.Append(" };");
            }
            else
            {
                EcuM_PBCfg_GenerationStream.Append("NULL };");
            }
            EcuM_PBCfg_GenerationStream.AppendLine("");
            EcuM_PBCfg_GenerationStream.AppendLine("");

            string file_footer = @"
/* %PCMS_HEADER_SUBSTITUTION_START:%
 ******************************************************************************
 * Document Management Information Log (generated by Dimensions CM)
 *
 *  Description:
 *  %PD:%
 *
 *  Used by Baselines:
 *  %PIRB:%
 *
 *  Used by Dimensions CM Projects:
 *  %PIRW:%
 *
 *  Change History:
 *  %PL:%
 *
 * %PCMS_HEADER_SUBSTITUTION_END:%
 */";
            EcuM_PBCfg_GenerationStream.AppendLine(file_footer);
        }


        public string Generate()
        {

            EcuM_Cbk_GenerationStream = new StringBuilder();
            EcuM_Cfg_GenerationStream = new StringBuilder();
            EcuM_Generated_Types_GenerationStream = new StringBuilder();
            EcuM_Lcfg_GenerationStream = new StringBuilder();
            EcuM_MemMap_GenerationStream = new StringBuilder();
            EcuM_PBCfg_GenerationStream = new StringBuilder();

            /*add code in EcuM_Cbk.h file*/
            Generate_EcuM_Cbk();
            /*add code in EcuM_Cfg.h file*/
            Generate_EcuM_Cfg();
            /*add code in EcuM_Generated_Types.h file*/
            Generate_EcuM_Generated_Types();
            /*add code in EcuM_Lcfg.c file*/
            Generate_EcuM_Lcfg();
            /*add code in EcuM_MemMap.h file*/
            Generate_EcuM_MemMap();
            /*add code in EcuM_PBcfg.c file*/
            Generate_EcuM_PBcfg();

            CompleteFile();

            return "OK";
        }

        public string Validate()
        {
			string retVal = "OK";
            DL_Component siriusApp = new DL_Component();
            List<NodeExt> EcuMWakeupSource = siriusApp.GetNode("EcuMWakeupSource");
			
            /*reset reasons have to be unique through wake up sources*/
            if (siriusApp.GetNode("EcuMResetReasonRef").Count != 0)
            {
                List<NodeExt> EcuMResetReasonRef = siriusApp.GetNode("EcuMResetReasonRef");
                int i = 0, j = 0;
                for(i = 0; i < EcuMResetReasonRef.Count - 1; i++)
                {
                    for (j = i + 1; j < EcuMResetReasonRef.Count; j++)
                    {
                         if(EcuMResetReasonRef[i].GetAttribute("EcuMResetReasonRef") == EcuMResetReasonRef[j].GetAttribute("EcuMResetReasonRef"))
                        {
                            MessageHandler.SetLog(MessageHandler.ActionTypes.ERROR, "Reset reasons shall be unique throughout the defined wakeup sources. Please see the parameters EcuMResetReasonRef under each EcuMResetReasonRef container.");
                            retVal = "ERROR";
						}
                    }
                }


                /*error in case the user does not complete the fields: "EcuMResetReasonRef"*/
                for (i = 0; i < EcuMResetReasonRef.Count; i++)
                {
                    if ((EcuMResetReasonRef[i].GetAttribute("EcuMResetReasonRef") == ""))
                    {
                        MessageHandler.SetLog(MessageHandler.ActionTypes.ERROR, "The reset reason that shall be detected for each wake-up source must be completed. Parameters \"EcuMResetReasonRef\"  shall be completed.");
                        retVal = "ERROR";
					}
                }
            }

            /*warning in case no wakeup source is assigned to a defined sleep mode*/
            List<NodeExt> EcuMSleepMode = siriusApp.GetNode("EcuMSleepMode");
            
            if (siriusApp.GetNode("EcuMSleepModes").Count != 0)
            {
                int i = 0;
                for (i = 0; i < EcuMSleepMode.Count; i++)
                {
                    List<NodeExt> EcuM_UserDependent_WakeupSource = EcuMSleepMode[i].GetChildren("EcuM_UserDependent_WakeupSource");
                    if ((EcuMSleepMode[i].GetAttribute("EcuMPredefinedWakeUp_POWER") == "false") &&
                        (EcuMSleepMode[i].GetAttribute("EcuMPredefinedWakeUp_RESET") == "false") &&
                        (EcuMSleepMode[i].GetAttribute("EcuMPredefinedWakeUp_INTERNAL_RESET") == "false") &&
                        (EcuMSleepMode[i].GetAttribute("EcuMPredefinedWakeUp_INTERNAL_WDG") == "false") &&
                        (EcuMSleepMode[i].GetAttribute("EcuMPredefinedWakeUp_EXTERNAL_WDG") == "false") &&
                        (EcuM_UserDependent_WakeupSource.Count == 0))
                    {
                        MessageHandler.SetLog(MessageHandler.ActionTypes.WARNING, "No wake-up source was assigned for a defined sleep mode. See sleep mode with ID: "+ EcuMSleepMode[i].GetAttribute("EcuMSleepModeId"));
                        retVal = "WARNING";
					}

                    /*error in case no one of the next parameters are completed by user: "EcuMSleepModeMcuModeRef" */
                    if ((EcuMSleepMode[i].GetAttribute("EcuMSleepModeMcuModeRef") == ""))
                    {
                        MessageHandler.SetLog(MessageHandler.ActionTypes.ERROR, "The following parameter shall be completed: \"EcuMSleepModeMcuModeRef\". See container EcuMSleepMode with ID: \"" + EcuMSleepMode[i].GetAttribute("EcuMSleepModeId") + "\"");
                        retVal = "ERROR";
					}
                }
            }

            /*validate existence of reset reasons*/
            if(siriusApp.GetNode("EcuMFixedGeneral")[0].GetAttribute("EcuMEnableResetReasonDetection") == "true")
            {
                if(siriusApp.GetNode("EcuMResetReasonRef").Count == 0)
                {
                    MessageHandler.SetLog(MessageHandler.ActionTypes.ERROR, "At least one reset reason shall be defined under one wake-up source. If no wake-up reason shall be defined then please uncheck the box \"EcuMEnableResetReasonDetection\" under the container \"EcuMFixedGeneral\".");
                    retVal = "ERROR";
				}
            }
            else
            {
                if (siriusApp.GetNode("EcuMResetReasonRef").Count != 0)
                {
                    MessageHandler.SetLog(MessageHandler.ActionTypes.WARNING, "Reset reasons are defined although the feature is not enabled from the box \"EcuMEnableResetReasonDetection\" under the container \"EcuMFixedGeneral\".");
                    retVal = "WARNING";
				}
            }

            /*check sleep modes in case shutdown target is set to SLEEP*/
            if(siriusApp.GetNode("EcuMDefaultShutdownTarget")[0].GetAttribute("EcuMDefaultState") == "ECUM_STATE_SLEEP")
            {
                if(siriusApp.GetNode("EcuMSleepMode").Count == 0)
                {
                    MessageHandler.SetLog(MessageHandler.ActionTypes.ERROR, "Default shutdown target is set to \"ECUM_STATE_SLEEP\". At least one sleep mode shall be defined (container named \"EcuMSleepMode\").");
                    retVal = "ERROR";
				}
            }
            
            Int32 EcuMNvramWriteallTimeout = Convert.ToInt32(siriusApp.GetNode("EcuMFixedGeneral")[0].GetAttribute("EcuMNvramWriteallTimeout"));
            Int32 EcuMMainFunctionPeriod = Convert.ToInt32(siriusApp.GetNode("EcuMFixedGeneral")[0].GetAttribute("EcuMMainFunctionPeriod"));
            
            /*Validate EcuMNvramWriteallTimeout*/
            if ((EcuMNvramWriteallTimeout % EcuMMainFunctionPeriod)!= 0)
            {
            	MessageHandler.SetLog(MessageHandler.ActionTypes.ERROR, "EcuMNvramWriteallTimeout must be a multiple of EcuMMainFunctionPeriod");
				retVal = "ERROR";
            }
			
			/* validated communication channels*/
			if (("false" == siriusApp.GetNode("EcuMFixedGeneral")[0].GetAttribute("EcuMIncludeComM")) && (0 != siriusApp.GetNode("ComMChannels").Count))
            {
                MessageHandler.SetLog(MessageHandler.ActionTypes.WARNING, "Communication channels are defined although the feature is not enabled from the box \"EcuMIncludeComM\" under the container \"EcuMFixedGeneral\".");
                retVal = "WARNING";
			} 
			
			int ComMChannelConfigured = 0;
			int index;
			for (index = 0; index < EcuMWakeupSource.Count; index++)
			{
				if ("" != EcuMWakeupSource[index].GetAttribute("EcuComMChannelRef").Trim())
				{
					ComMChannelConfigured = 1;
					break;
				}
			}
            if ("false" == (siriusApp.GetNode("EcuMFixedGeneral")[0].GetAttribute("EcuMIncludeComM")) && (1 == ComMChannelConfigured))
                {
                    MessageHandler.SetLog(MessageHandler.ActionTypes.WARNING, "Communication channels are defined for wakeup sources although the feature is not enabled from the box \"EcuMIncludeComM\" under the container \"EcuMFixedGeneral\".");
                    retVal = "WARNING";
  			    }   
            return retVal;				
        }

        bool AttributeExists(NodeExt node, string name)
        {
            for (int i = 0; i < node.Attributes.Count; i++)
            {
                if (node.Attributes[i].Attribute == name)
                    return true;
            }
            return false;
        }
    }
}