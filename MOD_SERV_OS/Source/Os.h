/*!
 * \defgroup MOD_SERV_OS (Os.h)
 * \{
 ******************************************************************************
 * \image html "Kopf_oZusatz_A4hoch_4C.jpg"
 *
 * \par Module Owner:
 * Huf Group
 *
 * \par Initial Project:
 * 1656.001 BSW
 *
 ******************************************************************************
 * \par Description:
 * Header file for OS module. Contains API definition.
 *
 ******************************************************************************
 *
 * %PCMS_HEADER_SUBSTITUTION_START:%
 *
 * Configuration Management Information Log (generated by Dimensions CM)
 *
 *
 * CM Item: %PID:%
 * Item name: %PM:%
 * Location: %ARCHIVE:%
 * Revision: %PR:%
 * Date: %DATE:%
 * Author: %AUTHOR:%
 *
 * %PCMS_HEADER_SUBSTITUTION_END:% *
 ******************************************************************************
 *
 * \par Layer:
 * Operating System, Service Layer
 *
 * \par Compiler dialect:
 * C99
 *
 * \par Controller:
 * Independent
 *
 * \par Estimated resources:
 * | Resource | Amount   | Remarks         |
 * | ---------| -------- | ----------------|
 * | ROM      | x Byte   | on x controller |
 * | RAM      | y Byte   | on x controller |
 * | NVRAM    | z Byte   | on x controller |
 * | Runtime Init | X ms |                 |
 * | Runtime Task | X ms |                 |
 *
 ******************************************************************************/
#ifndef OS_H_							/* To avoid double inclusion */
#define OS_H_

/*[SWPS_SWS_SERVOS_00001]*/
#include "Os_Types.h"
#include "Os_Cfg.h"

/* If background task is OFF there is no preemption, Os_Main is called from main */
/* polyspace-begin MISRA-C3:D4.9 [Not a defect:Unset] "Macros used to facilitate an easier adaptation" */
#if(OS_ENABLE_BACKGROUND_TASK == STD_OFF)
/* Define main function for OS*/
#define OS_MAIN() Os_AlarmsEvaluation()
#else
#define OS_MAIN() Os_BackgroundTask()
#endif

/* added here old interrupt related macros for compatibility with old modules */
/* polyspace-begin MISRA-C3:2.5 [Not a defect:Unset] "The macros can be used into integration project" */
#if(OS_ENABLE_NOT_NESTABLE_INT_API == STD_ON)
#define DISABLE_INTERRUPT()  DisableAllInterrupts()
#define ENABLE_INTERRUPT()   EnableAllInterrupts()
#endif /* #if (OS_ENABLE_NOT_NESTABLE_INT_API == STD_ON) */
#define DISABLE_ALL_INTERRUPTS()  SuspendAllInterrupts()
#define ENABLE_ALL_INTERRUPTS()   ResumeAllInterrupts()
/* polyspace-end MISRA-C3:D4.9 [Not a defect:Unset] "Macros used to facilitate an easier adaptation" */
/* polyspace-end MISRA-C3:2.5 [Not a defect:Unset] "The macros can be used into integration project" */

/*
SchM_Deinit is used to finalize Basic Software Scheduler part of the RTE
of the core on which it is called.
This service releases all system resources allocated by the Basic Software
Scheduler part on that core.
[constr_9057] SchM_Deinit shall be called before shut down of BSW d
SchM_Deinit shall be called by the EcuStateManager before the basic software modules
required by Basic Software Scheduler part are shut down.
 */

/*#define SchM_Deinit()  Os_StopScheduler()*/

#if(OS_ENABLE_BACKGROUND_TASK == STD_OFF)

/*!
 ****************************************************************************
 * \brief
 *  Evaluate/update cyclic and single alarms
 *
 * \details
 *  This function checks all the running single and cyclic alarms and update them in case they expired.
 *  It calls the scheduler if it is not currently running.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_CyclicAlarmsRunData, Os_TickCounter, Os_AlarmsStarted, Os_SchedulerRunning, Os_CyclicAlarmCfgData
 *
 * \parblock
 * __Read:__
 * Os_TickCounter        - OS tick counter is checked
 * Os_AlarmsStarted      - Alarms started flag is checked
 * Os_SchedulerRunning   - Os scheduler running flag is checked
 * Os_CyclicAlarmCfgData - Alarm configuration data is checked
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * Os_CyclicAlarmsRunData - (write) counter values are stored
 *                        - (read)  counter values are checked
 *
 * \endparblock
 *
 * \par Called functions:
 *  SuspendAllInterrupts, ResumeAllInterrupts, Os_Scheduler, lOs_checkSingleAlarms
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
extern void Os_AlarmsEvaluation(void);
#else
/*!
 ****************************************************************************
 * \brief
 *  Background task
 *
 * \details
 * If enabled this task is executed each time other tasks are not running
 ****************************************************************************
 *
 * \par Reentrance:
 *  Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  None
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  OS_BACKGROUND_TASK_FUNC()
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
extern void Os_BackgroundTask(void);
#endif

#if(OS_ENABLE_NOT_NESTABLE_INT_API == STD_ON)
/*!
 ****************************************************************************
 * \brief
 *  Disable all interrupts
 *
 * \details
 * This service disables all interrupts for which the hardware supports disabling.
 * The state before is saved for the EnableAllInterrupts call.
 * The service may be called from an ISR category 1 and category 2 and from the task level, but not from hook routines.
 * This service is intended to start a critical section of the code.
 * This section shall be finished by calling the EnableAllInterrupts service.
 * No API service calls are allowed within this critical section.
 * Note that this service does not support nesting. If nesting is needed for critical sections
 * e.g. for libraries SuspendOSInterrupts/ResumeOSInterrupts or SuspendAllInterrupt/ResumeAllInterrupts should be used.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  None
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  OS_DISABLE_INTERRUPT()
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
extern void DisableAllInterrupts(void);

/*!
 ****************************************************************************
 * \brief
 *  Enable all interrupts
 *
 * \details
 * This service restores the state saved by DisableAllInterrupts.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  None
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  OS_ENABLE_INTERRUPT()
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
extern void EnableAllInterrupts(void);
#endif /*(OS_ENABLE_NOT_NESTABLE_INT_API == STD_ON)*/

/*!
 ****************************************************************************
 * \brief
 *  Resume all interrupts
 *
 * \details
 * This service restores the recognition status of all interrupts saved by the SuspendAllInterrupts service.
 * This service is the counterpart of SuspendAllInterrupts service, which has to have been called before,
 * and its aim is the completion of the critical section of code.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_u8InterruptSuspCnt
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * Os_u8InterruptSuspCnt
 *
 * \endparblock
 *
 * \par Called functions:
 *  OS_ENABLE_INTERRUPT()
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
extern void ResumeAllInterrupts(void);

/*!
 ****************************************************************************
 * \brief
 *  Suspend all interrupts
 *
 * \details
 * This service saves the recognition status of all interrupts and disables all
 * interrupts for which the hardware supports disabling.
 * The service may be called from an ISR category 1 and category 2, from alarm-callbacks and from the task level,
 * but not from all hook routines. This service is intended to protect a critical section of code from
 * interruptions of any kind. This section shall be finished by calling the ResumeAllInterrupts service.
 * No API service calls beside SuspendAllInterrupts/ResumeAllInterrupts pairs
 * are allowed within this critical section.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_u8InterruptSuspCnt
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * Os_u8InterruptSuspCnt
 *
 * \endparblock
 *
 * \par Called functions:
 *  OS_DISABLE_INTERRUPT()
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
extern void SuspendAllInterrupts(void);

/*!
 ****************************************************************************
 * \brief
 *  Start OS
 *
 * \details
 * The user shall call this system service to start the operating system.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     AppMode - Application Mode, for the moment the param
 *                          is not used, it is added just for compatibility
 *                          with OSEK
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_AlarmsStarted
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * Os_AlarmsStarted - set its value to TRUE(alarms are started)
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  Os_Init, Os_SetTickStatus, ResumeAllInterrupts
 *  StartupHook() routine is called by the operating system at the end of the operating
 *  system initialization and before the scheduler is running. At this time the application
 *  can initialize device drivers etc.
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
extern void StartOS(AppModeType AppMode);

/*!
 ****************************************************************************
 * \brief
 *  Shutdown OS
 *
 * \details
 * The user can call this system service to abort the overall system (e.g. emergency off).
 * The operating system also calls this function internally, if it has reached an undefined internal state
 * and is no longer ready to run.
 * This function calls the ShutdownHook and then enters an endless loop.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     Error - error code
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  None
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  ShutdownHook(), OS_DISABLE_INTERRUPT
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
/* polyspace +1 MISRA-C3:5.1 [Not a defect:Unset] "OSEK naming convention" */
extern void ShutdownOS(Os_StatusType Error);

#if(OS_ENABLE_NON_CYCLIC_TASKS == STD_ON)
/*!
 ****************************************************************************
 * \brief
 *  Activate task
 *
 * \details
 * The task <TaskID> is transferred from the suspended state into the ready state.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None

 * \param[IN]     TaskID - task ID
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  None
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  None
 *
 * \returns
 *  Os_StatusType
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
/*extern Os_StatusType ActivateTask (TaskType TaskID);*/
#endif /*(OS_ENABLE_NON_CYCLIC_TASKS == STD_ON)*/

/*!
 ****************************************************************************
 * \brief
 * Terminate task. The user shall call this system service at the end of each task.
 *
 * \details
 * This service causes the termination of the calling task.
 * The calling task is transferred from the running state into the suspended state
 * In case of tasks with multiple activation requests, terminating the current instance
 * of the task automatically puts the next instance of the same task into the ready state.
 * If the service TerminateTask is called successfully, it enforces a rescheduling.
 * Ending a task function without call to TerminateTask or ChainTask is strictly forbidden
 * and may leave the system in an undefined state.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_AlarmsStarted, Os_TaskRunData, Os_CurrentRunningTask
 *
 * \parblock
 * __Read:__
 * Os_AlarmsStarted - used to check if alarms are not stopped
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * Os_TaskRunData - (read)  used to check if task has multiple activation requests
 *                - (write) task state is set
 * Os_CurrentRunningTask - (read)  used to access data of the current running task
 *                       - (write) current running task is set to OS_TASK_ID_Idle
 *
 * \endparblock
 *
 * \par Called functions:
 *  PostTaskHook, GetTaskID, SuspendAllInterrupts, ResumeAllInterrupts
 *
 * \returns
 *  Os_StatusType - status E_OK
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
extern Os_StatusType TerminateTask(void);

#if(OS_ENABLE_NON_CYCLIC_TASKS == STD_ON)
/*!
 ****************************************************************************
 * \brief
 * Chain task
 * \details
 * This service causes the termination of the calling task. After termination of
 * the calling task a succeeding task <TaskID> is activated.
 * Using this service, it ensures that the succeeding task starts to run at the
 * earliest after the calling task has been terminated.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  All must be initialized
 *
 * \param[IN]     TaskID - task ID
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  None
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  None
 *
 * \returns
 *  Os_StatusType
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
/*extern Os_StatusType ChainTask ( TaskType TaskID );*/
#endif /* (OS_ENABLE_NON_CYCLIC_TASKS == STD_ON) */


/*!
 ****************************************************************************
 * \brief
 * Get task ID
 *
 * \details
 * GetTaskID returns the information about the TaskID of the task which is currently running.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    OsTaskID - task ID
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_CurrentRunningTask
 *
 * \parblock
 * __Read:__
 * Os_CurrentRunningTask
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  None
 *
 * \returns
 *  Os_StatusType - INVALID_TASK the current running task is idle
 *                - E_OK the current running task is valid
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
/* polyspace +1 MISRA-C3:5.1,8.7 [Not a defect:Unset] "OSEK naming convention; the function can be used in other modules" */
extern Os_StatusType GetTaskID(TaskRefType OsTaskID);

/*!
 ****************************************************************************
 * \brief
 * Get task state
 *
 * \details
 * Returns the state of a task (running, ready, waiting, suspended) at the time of calling GetTaskState.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     OsTaskID - task ID
 * \param[OUT]    OsTaskState - state of the task with <TaskID>
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_TaskRunData
 *
 * \parblock
 * __Read:__
 * Os_TaskRunData
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  None
 *
 * \returns
 *  Os_StatusType - status E_OK - task ID is valid
 *                         E_OS_ID - task ID is not valid
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
/* polyspace +1 MISRA-C3:5.1 [Not a defect:Unset] "OSEK naming convention" */
extern Os_StatusType GetTaskState(TaskType OsTaskID, TaskStateRefType OsTaskState);

#if(OS_GET_ELAPSED_VAL_API == STD_ON)
/*!
 ****************************************************************************
 * \brief
 * This service gets the number of ticks between the current tick value and a previously read tick value.
 *
 * \details
 * This service gets the number of ticks between the current tick value and a previously read tick value.
 * Caveats of GetElapsedValue():If the timer already passed the
 * <TickValue> value a second (or multiple) time, the result returned is wrong.
 * The reason is that the service can not detect such a relative overflow.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     CounterID - not used for the moment, OS has only one counter
 * \param[OUT]    ElapsedValue  - The difference to the previous read value
 * \param[IN/OUT] TickValue : IN - the previously read tick value of the counter
 *                            OUT - the current tick value of the counter
 *
 * \par Used global variables:
 *  Os_TickCounter
 *
 * \parblock
 * __Read:__
 * Os_TickCounter - returns the current value of the OS tick counter
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  ErrorHook, SuspendAllInterrupts, ResumeAllInterrupts
 *
 * \returns
 *  Os_StatusType - E_OK: No errors
 *                  E_OS_PARAM_POINTER: A null pointer was given as argument
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
extern Os_StatusType GetElapsedValue(CounterType CounterID, TickRefType TickValue, TickRefType ElapsedValue );
#endif /* #if (OS_GET_ELAPSED_VAL_API == STD_ON)*/

#if(OS_GET_COUNTER_VAL_API == STD_ON)
/*!
 ****************************************************************************
 * \brief
 * This service reads the current count value of a counter.
 *
 * \details
 *
 ****************************************************************************
 *
 * \par Reentrance:
 *  Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     CounterID - The Counter which tick value should be read
 * \param[OUT]    OsTickValue - Contains the current tick value of the counter
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_TickCounter
 *
 * \parblock
 * __Read:__
 * Os_TickCounter - returns the current value of the OS tick counter
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  ErrorHook, SuspendAllInterrupts, ResumeAllInterrupts
 *
 * \returns
 *  Os_StatusType - E_OK: No errors
 *                  E_OS_ID: The <CounterID> was not valid
 *                  E_OS_PARAM_POINTER: A null pointer was given as argument
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
extern Os_StatusType GetCounterValue(CounterType CounterID, TickRefType OsTickValue);
#endif /*(OS_GET_COUNTER_VAL_API == STD_ON)*/

#if(OS_GET_RELEASE_RESOURCE_API == STD_ON)
/*!
 ****************************************************************************
 * \brief
 * Acquire a resource
 *
 * \details
 * This call serves to enter critical sections in the code that are assigned to the
 * resource referenced by ResourceId. A critical section shall always be left using ReleaseResource.
 * In case single alarms are used and GetResource is called, the running single alarms will be stopped.
 * For the moment resources are not configurable and only
 * RES_SCHEDULER resource is implemented. This resource is used to acquire
 * the scheduler so no task be executed.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     ResourceId - ID of the resource which is acquired
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_AlarmsStarted
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * Os_AlarmsStarted - variable is set to FALSE
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  ErrorHook, Os_SetTickStatus, SuspendAllInterrupts, ResumeAllInterrupts
 *
 * \returns
 *  Os_StatusType - E_OK: No errors
 *                  E_OS_ID: An error occurred, ResourceId was not configured
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
extern Os_StatusType GetResource(ResourceType ResourceId);
#endif /* if (OS_GET_RELEASE_RESOURCE_API == STD_ON) */

#if(OS_GET_RELEASE_RESOURCE_API == STD_ON)
/*!
 ****************************************************************************
 * \brief
 * Releases a resource
 *
 * \details
 * ReleaseResource is the counterpart of GetResource and serves to leave critical
 * sections in the code that are assigned to the resource referenced by ResourceId.
 * If single alarms were running before calling GetResource, by calling ReleaseResource
 * the single alarms won't be started. It is up to the user to start the alarms again,
 * if necessary. For the moment resources are not configurable and only
 * RES_SCHEDULER resource is implemented. With this service the resource RES_SCHEDULER
 * is released and tasks can be executed again.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     ResourceId - ID of the resource which is released
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_AlarmsStarted
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * Os_AlarmsStarted - variable is set to TRUE
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  ErrorHook, Os_SetTickStatus, SuspendAllInterrupts, ResumeAllInterrupts
 *
 * \returns
 *  Os_StatusType - E_OK: No errors
 *                  E_OS_ID: An error occurred, ResourceId was not configured
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
extern Os_StatusType ReleaseResource(ResourceType ResourceId);
#endif /* if(OS_GET_RELEASE_RESOURCE_API == STD_ON) */


#if(OS_SINGLE_ALARMS_ENABLED_CFG == STD_ON)
/*!
 ****************************************************************************
 * \brief
 * The system service GetAlarm gets the relative value in ticks before the alarm AlarmID expires.
 *
 * \details
 *
 ****************************************************************************
 *
 * \par Reentrance:
 *  Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  All must be initialized
 *
 * \param[IN]     AlarmID - Reference to an alarm
 * \param[OUT]    Tick - Relative value in ticks before the alarm AlarmID expires
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_SingleAlarmRunData
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * Os_SingleAlarmRunData - (read)  check if the alarms is running
 *                       - (write) reads the value of the single alarm's expiration time in ticks
 *
 * \endparblock
 *
 * \par Called functions:
 *  ErrorHook, SuspendAllInterrupts, ResumeAllInterrupts
 *
 * \returns
 *  Os_StatusType - E_OK - No error
 *                  E_OS_NOFUNC - Alarm <AlarmID> is not used
 *                  E_OS_ID - Alarm <AlarmID> is invalid
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
extern Os_StatusType GetAlarm(OS_AlarmType AlarmID, TickRefType Tick);

/*!
 ****************************************************************************
 * \brief
 * The system service activates/starts the alarm <AlarmID> element and assigns to it
 * <increment> ticks until it expires.
 * In the current implementation, only callback routines are available when the alarm expires.
 * \details
 * In the current implementation, <cycle> parameter must be equal to 0.
 * To change values of alarms already in use the alarm shall be cancelled first.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  All must be initialized
 *
 * \param[IN]     AlarmID - Reference to an alarm
 *                increment - Relative value in ticks. The macro OS_MS_TO_TICKS(timeInMs) can be used to convert the time from milliseconds to ticks.
 *                cycle - Cycle value in case of cyclic alarm. In case of single alarms, cycle shall be zero. In the current implementation, cycle parameter must be 0
 * \param[OUT]    None
 * \param[IN/OUT] None
 * \par Used global variables:
 *  Os_SingleAlarmRunData, Os_SingleAlarmCfgData
 *
 * \parblock
 * __Read:__
 * Os_SingleAlarmCfgData - reads the value of the single alarm's counter reference
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * Os_SingleAlarmRunData - (read) check if the alarms is running
 *                       - (write) initializes the alarm's parameters in order to start it
 *
 * \endparblock
 *
 * \par Called functions:
 *  ErrorHook, SuspendAllInterrupts, ResumeAllInterrupts
 *
 * \returns
 *  Os_StatusType - E_OK - No error
 *                  E_OS_STATE - Alarm AlarmID is already in use
 *                  E_OS_ID - Invalid ID
 *                  E_OS_VALUE - <increment> value equal to 0
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
extern Os_StatusType SetRelAlarm(OS_AlarmType AlarmID, TickType increment, TickType cycle);

/*!
 ****************************************************************************
 * \brief
 * The system service cancels the alarm <AlarmID>.
 * \details
 * Allowed on task level and in ISR, but not in hook routines
 ****************************************************************************
 *
 * \par Reentrance:
 *  Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  All must be initialized
 *
 * \param[IN]     AlarmID - Reference to an alarm
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_SingleAlarmRunData
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * Os_SingleAlarmRunData - (read) check if the alarms is running
 *                       - (write) initializes the alarm's parameters in order to cancel it
 *
 * \endparblock
 *
 * \par Called functions:
 *  ErrorHook, SuspendAllInterrupts, ResumeAllInterrupts
 *
 * \returns
 *  Os_StatusType - E_OK - No error
 *                  E_OS_NOFUNC - Alarm <AlarmID> not in use
 *                  E_OS_ID - Alarm <AlarmID> is invalid
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
extern Os_StatusType CancelAlarm(OS_AlarmType AlarmID);
#endif /*OS_SINGLE_ALARMS_ENABLED_CFG*/
#endif /* OS_H_ */

/* %PCMS_HEADER_SUBSTITUTION_START:%
 ******************************************************************************
 * Document Management Information Log (generated by Dimensions CM)
 *
 * Description:
 * %PD:%
 *
 * Used by Baselines:
 * %PIRB:%
 *
 * Used by Dimensions CM Projects:
 * %PIRW:%
 *
 * Change History:
 * %PL:%
 *
 * %PCMS_HEADER_SUBSTITUTION_END:%
 */
