/* polyspace MISRA-C3:1.1 [Justified:Low] "The defined macros are controller specific macros from registers header file" */
/*!
 * \defgroup MOD_SERV_OS (Os.c)
 * \{
 ******************************************************************************
 * \image html "Kopf_oZusatz_A4hoch_4C.jpg"
 *
 * \par Module Owner:
 * Huf Group
 *
 * \par Initial Project:
 * 1656.001 BSW
 *
 ******************************************************************************
 * \par Description:
 * This is the source file of the Operating System module.
 *
 ******************************************************************************
 *
 * %PCMS_HEADER_SUBSTITUTION_START:%
 *
 * Configuration Management Information Log (generated by Dimensions CM)
 *
 *
 * CM Item: %PID:%
 * Item name: %PM:%
 * Location: %ARCHIVE:%
 * Revision: %PR:%
 * Date: %DATE:%
 * Author: %AUTHOR:%
 *
 * %PCMS_HEADER_SUBSTITUTION_END:% *
 ******************************************************************************
 *
 * \par Layer:
 * Operating System, Service Layer
 *
 * \par Compiler dialect:
 * C99
 *
 * \par Controller:
 * Independent
 *
 * \par Estimated resources:
 * | Resource | Amount   | Remarks         |
 * | ---------| -------- | ----------------|
 * | ROM      | x Byte   | on x controller |
 * | RAM      | y Byte   | on x controller |
 * | NVRAM    | z Byte   | on x controller |
 * | Runtime Init | X ms |                 |
 * | Runtime Task | X ms |                 |
 *
 ******************************************************************************/

/* Provide interface */
/* ----------------- */
/*[SWPS_SWS_SERVOS_00001]*/
#include "Os.h"
#include "Os_Private.h"
/* polyspace-begin MISRA-C3:D4.9 [Not a defect:Unset] "Macros used to facilitate an easier adaptation" */
/* Private function macros, types and data */
#define OS_INIT_QUEUES() Os_InitQueues()

#if (OS_CONF_CLASS == BCC2)
#define OS_IS_QUEUE_EMPTY(prioIndex) Os_IsQueueEmpty(prioIndex)
#define OS_IS_QUEUE_FULL(prioIndex) Os_IsQueueFull(prioIndex)
#define OS_DEQUEUE_TASK(prioIndex, taskId) Os_DequeueTask(prioIndex, taskId)
#define OS_ENQUEUE_TASK(prioIndex, task) Os_EnqueueTask(prioIndex, task)
#else
#define OS_IS_QUEUE_EMPTY(prioIndex) ((INVALID_TASK == Os_TaskPrioQueues[(prioIndex)])?((boolean)TRUE):((boolean)FALSE))
#define OS_IS_QUEUE_FULL(prioIndex) ((INVALID_TASK == Os_TaskPrioQueues[(prioIndex)])?((boolean)FALSE):((boolean)TRUE))
#define OS_DEQUEUE_TASK(prioIndex, taskId)         \
         do                                        \
         {                                         \
            *(taskId) = Os_TaskPrioQueues[(prioIndex)];       \
            Os_TaskPrioQueues[(prioIndex)] = INVALID_TASK;    \
         }while(0u)

#define OS_ENQUEUE_TASK(prioIndex, task)           \
         do                                        \
         {                                         \
            Os_TaskPrioQueues[(prioIndex)] = task; \
         }while(0u)

#endif
/* polyspace-end MISRA-C3:D4.9 [Not a defect:Unset] "Macros used to facilitate an easier adaptation" */

/* Private data-types */
/* Variable definition */

/* Counts the number of calls to SuspendAllInterrupts
 * Initialized with 1 to force interrupts be disabled before StartOS  */
static U8 Os_u8InterruptSuspCnt = 1u;
/*Flag used to detect if the alarms are running or not*/
static boolean Os_AlarmsStarted = (boolean)FALSE;
/*Flag used to detect if the Os_Scheduler function is running*/
static boolean Os_SchedulerRunning = (boolean)FALSE;
/*Alarms data which is modified during runtime*/
static Os_CyclicAlarmRunDataType Os_CyclicAlarmsRunData[NUMBER_OF_CYCLIC_ALARMS];
/*Task data which is modified during runtime*/
static OS_TaskRunDataType Os_TaskRunData[OS_NO_OF_CYCLIC_TASKS];
#if(OS_SINGLE_ALARMS_ENABLED_CFG == STD_ON)
/*Alarms data which is modified during runtime*/
static Os_SingleAlarmRunDataType Os_SingleAlarmRunData[NUMBER_OF_SINGLE_ALARMS_CFG];
#endif
#if (OS_CONF_CLASS == BCC2)
/*For each priority there is a queue - highest priority has lowest index*/
static Os_TaskPrioQueueType Os_TaskPrioQueues[OS_NO_OF_PRIORITIES];
#else
/*For each priority there is a single task - highest priority has lowest index*/
static TaskType Os_TaskPrioQueues[OS_NO_OF_PRIORITIES];
#endif

/*The task which is currently running*/
static TaskType Os_CurrentRunningTask;

/* Private functions declaration */
static void Os_Init(void);
static void Os_UpdateTaskQueues(void);
static void Os_Scheduler(void);
static void Os_InitQueues(void);
#if(OS_SINGLE_ALARMS_ENABLED_CFG == STD_ON)
static void lOs_checkSingleAlarms(void);
#endif
#if (OS_CONF_CLASS == BCC2)
static boolean Os_IsQueueEmpty(U8 prioIndex);
static boolean Os_IsQueueFull (U8 prioIndex);
static void Os_DequeueTask( U8 prioIndex, TaskRefType DequeueTaskID);
static void Os_EnqueueTask( U8 prioIndex, TaskType EnqueueTaskID);
#endif

/*--------------------------------------------------------
-------------  FUNCTIONS IMPLEMENTATION  -----------------
--------------------------------------------------------*/

/* -------- Private functions implementation ---------- */

/*!
 ****************************************************************************
 * \brief
 * Initialize priority queues
 *
 * \details
 *
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_TaskPrioQueues
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * Os_TaskPrioQueues, Task priority queues is initialized with INVALID_TASK
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  None
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
static void Os_InitQueues(void) /*[SWPS_SWS_SERVOS_00138]*/
{
   /*[SWPS_SWS_SERVOS_00139]*/
   U8 prioIndex;
#if (OS_CONF_CLASS == BCC2)
   U8 taskIndex;
#endif

   for(prioIndex = 0u; prioIndex < OS_NO_OF_PRIORITIES; prioIndex++ )
   {
#if (OS_CONF_CLASS == BCC2)

      Os_TaskPrioQueues[prioIndex].count = 0u;
      Os_TaskPrioQueues[prioIndex].head = 0u;
      Os_TaskPrioQueues[prioIndex].tail = 0u;

      for(taskIndex = 0u; taskIndex < OS_PRIO_QUEUE_SIZE; taskIndex++ )
      {
         Os_TaskPrioQueues[prioIndex].taskID[taskIndex] = INVALID_TASK;
      }
#else
      Os_TaskPrioQueues[prioIndex] = INVALID_TASK;
#endif
   }
}

#if (OS_CONF_CLASS == BCC2)
/*!
 ****************************************************************************
 * \brief
 *  Determines whether or not the queue is empty
 *
 * \details
 *
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     prioIndex - priority index
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_TaskPrioQueues
 *
 * \parblock
 * __Read:__
 * Os_TaskPrioQueues - Task priority queues
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  None
 *
 * \returns
 *  boolean TRUE : queue is empty;
 *          FALSE: queue is not empty.
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
static boolean Os_IsQueueEmpty(U8 prioIndex) /*[SWPS_SWS_SERVOS_00149]*/
{
   /*[SWPS_SWS_SERVOS_00150]*/
   boolean retVal;

   if(0u == Os_TaskPrioQueues[prioIndex].count)
   {
      retVal = (boolean)TRUE;
   }
   else
   {
      retVal = (boolean)FALSE;
   }
   return retVal;
}

/*!
 ****************************************************************************
 * \brief
 *  Determines whether or not the queue is full
 *
 * \details
 *
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     prioIndex - priority index
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_TaskPrioQueues
 *
 * \parblock
 * __Read:__
 * Os_TaskPrioQueues - Task priority queues
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  None
 *
 * \returns
 *  boolean TRUE : queue is full;
 *          FALSE: queue is not full.
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
static boolean Os_IsQueueFull (U8 prioIndex) /*[SWPS_SWS_SERVOS_00151]*/
{
   /*[SWPS_SWS_SERVOS_00152]*/
   boolean retVal;

   if(OS_PRIO_QUEUE_SIZE <= Os_TaskPrioQueues[prioIndex].count)
   {
      retVal = (boolean)TRUE;
   }
   else
   {
      retVal = (boolean)FALSE;
   }
   return retVal;


}

/*!
 ****************************************************************************
 * \brief
 *  Dequeue task (head)
 *
 * \details
 *
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     prioIndex - priority index
 * \param[OUT]    DequeueTaskID - ID of the task which was dequeued
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_TaskPrioQueues
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * Os_TaskPrioQueues - Task priority queues
 *
 * \endparblock
 *
 * \par Called functions:
 *  None
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
static void Os_DequeueTask( U8 prioIndex, TaskRefType DequeueTaskID) /*[SWPS_SWS_SERVOS_00143]*/
{
   /*[SWPS_SWS_SERVOS_00144]*/
   Os_TaskPrioQueueType *queue = &Os_TaskPrioQueues[prioIndex];

   if(0u < queue->count)
   {
      *DequeueTaskID = queue->taskID[queue->head];
      queue->head = (queue->head + 1u)%OS_PRIO_QUEUE_SIZE;
      --(queue->count);
   }
   else
   {
      /*[SWPS_SWS_SERVOS_00145]*/
      *DequeueTaskID = INVALID_TASK;
   }
}

/*!
 ****************************************************************************
 * \brief
 *  Enqueue task (tail)
 *
 * \details
 *
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     prioIndex - priority index
 *                EnqueueTaskID - task to be enqueued
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_TaskPrioQueues
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * Os_TaskPrioQueues - Task priority queues
 *
 * \endparblock
 *
 * \par Called functions:
 *  None
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
static void Os_EnqueueTask(U8 prioIndex, TaskType EnqueueTaskID) /*[SWPS_SWS_SERVOS_00146]*/
{
   /*[SWPS_SWS_SERVOS_00147], [SWPS_SWS_SERVOS_00148]*/
   Os_TaskPrioQueueType *queue = &Os_TaskPrioQueues[prioIndex];

   if(OS_PRIO_QUEUE_SIZE > queue->count)
   {
      queue->taskID[queue->tail] = EnqueueTaskID;
      queue->tail = (queue->tail + 1u) %OS_PRIO_QUEUE_SIZE;
      ++(queue->count);
   }

}
#endif

#if(OS_SINGLE_ALARMS_ENABLED_CFG == STD_ON)
/*!
 ****************************************************************************
 * \brief
 * The function is used to check periodically if single alarms have expired or not.
 * If an alarm has expired, the callback routine associated to the alarm is called.
 * This function is called from Os_AlarmsEvaluation.
 *
 * \details
 *
 ****************************************************************************
 *
 * \par Reentrance:
 *  Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_SingleAlarmRunData, Os_SingleAlarmCfgData
 *
 * \parblock
 * __Read:__
 * Os_SingleAlarmCfgData
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * Os_SingleAlarmRunData
 *
 * \endparblock
 *
 * \par Called functions:
 *  Os_SingleAlarmCfgData[SingleAlarmID].AlarmCallback_PFUNC();
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
static void lOs_checkSingleAlarms(void) /*[SWPS_SWS_SERVOS_00140]*/
{
   /*[SWPS_SWS_SERVOS_00141]*/
   Os_CounterType A_Os_ElapsedValueInTicks_Os_CounterType;
   Os_CounterType A_Os_CurrentTick_Os_CounterType;
   OS_AlarmType A_Os_AlarmIndex_AlarmType;

   for(A_Os_AlarmIndex_AlarmType = 0u; A_Os_AlarmIndex_AlarmType < NUMBER_OF_SINGLE_ALARMS_CFG; A_Os_AlarmIndex_AlarmType++)
   {
      SuspendAllInterrupts();
      /*check if the alarm is running*/
      /* polyspace +2 RTE:UNR [Not a defect:Unset] "The code is reachable when at least one single alarm is running" */
      if((BOOL)(FALSE) != Os_SingleAlarmRunData[A_Os_AlarmIndex_AlarmType].AlarmIsRunning_BO)
      {
         /*obtain the remaining ticks until the alarm expires*/
         A_Os_CurrentTick_Os_CounterType =  *(Os_SingleAlarmCfgData[A_Os_AlarmIndex_AlarmType].AlarmCounterRef);
         /* polyspace +1 MISRA-C3:D4.1 RTE:OVFL [Not a defect:Unset] "The value is measured correctly even if overflow occurs" */
         A_Os_ElapsedValueInTicks_Os_CounterType = (Os_CounterType)(A_Os_CurrentTick_Os_CounterType - Os_SingleAlarmRunData[A_Os_AlarmIndex_AlarmType].counterPreviousVal);
         /*check if the current alarm has expired*/

         if(A_Os_ElapsedValueInTicks_Os_CounterType < Os_SingleAlarmRunData[A_Os_AlarmIndex_AlarmType].AlarmExpirationTimeInTicks)
         {
            Os_SingleAlarmRunData[A_Os_AlarmIndex_AlarmType].AlarmExpirationTimeInTicks = Os_SingleAlarmRunData[A_Os_AlarmIndex_AlarmType].AlarmExpirationTimeInTicks - A_Os_ElapsedValueInTicks_Os_CounterType;
            Os_SingleAlarmRunData[A_Os_AlarmIndex_AlarmType].counterPreviousVal = A_Os_CurrentTick_Os_CounterType;
            ResumeAllInterrupts(); /*[SWPS_SWS_SERVOS_00050]*/
         }
         else
         {
            Os_SingleAlarmRunData[A_Os_AlarmIndex_AlarmType].AlarmIsRunning_BO = (BOOL)(FALSE);
            Os_SingleAlarmRunData[A_Os_AlarmIndex_AlarmType].AlarmExpirationTimeInTicks = 0u;
            Os_SingleAlarmRunData[A_Os_AlarmIndex_AlarmType].counterPreviousVal = 0u;
            ResumeAllInterrupts(); /*[SWPS_SWS_SERVOS_00050]*/
            /* [SWPS_SWS_SERVOS_00142], [SWPS_SWS_SERVOS_00126]
             * the alarm has expired; call the callback routine(if any was configured) and stop the alarm*/
            if(NULL != Os_SingleAlarmCfgData[A_Os_AlarmIndex_AlarmType].AlarmCallback_PFUNC)
            {
               Os_SingleAlarmCfgData[A_Os_AlarmIndex_AlarmType].AlarmCallback_PFUNC();
            }
            else
               /* polyspace +1 RTE:UNR [Justified:Low] "Code is reached when the configured single alarm does not have a callback" */
            {
               /*do nothing; the alarm does not have a callback routine configured*/
            }

         }
      }
      else
      {
         ResumeAllInterrupts(); /*[SWPS_SWS_SERVOS_00050]*/
         /*the alarm has not started or has already expired*/
      }
   }
}
#endif

/*!
 ****************************************************************************
 * \brief
 * OS init function
 *
 * \details
 *
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_TaskRunData, Os_CyclicAlarmsRunData, Os_SingleAlarmRunData, Os_CurrentRunningTask
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * Os_TaskRunData, Os_CyclicAlarmsRunData, Os_SingleAlarmRunData, Os_CurrentRunningTask
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  OS_INIT_QUEUES(), Os_InitMcal
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
static void Os_Init(void) /*[SWPS_SWS_SERVOS_00127]*/
{
   /*[SWPS_SWS_SERVOS_00128], [SWPS_SWS_SERVOS_00129]*/
   U8 iterator;

   for(iterator = 0u; iterator< OS_NO_OF_CYCLIC_TASKS; iterator++)
   {
      Os_TaskRunData[iterator].taskState = SUSPENDED;
      Os_TaskRunData[iterator].queueEntryNo = 0u;
   }

   for(iterator = 0u; iterator < NUMBER_OF_CYCLIC_ALARMS; iterator++)
   {
      Os_CyclicAlarmsRunData[iterator].counterCurrentVal = 0u;
      Os_CyclicAlarmsRunData[iterator].counterPreviousVal = 0u;
      Os_CyclicAlarmsRunData[iterator].initialCyclePassed = FALSE;
      Os_CyclicAlarmsRunData[iterator].alarmExpirationCnt = 0u;
   }
#if(OS_SINGLE_ALARMS_ENABLED_CFG == STD_ON)
   /*Initialise run data for single alarms*/
   for(iterator = 0u; iterator < NUMBER_OF_SINGLE_ALARMS_CFG; iterator++)
   {
      Os_SingleAlarmRunData[iterator].AlarmExpirationTimeInTicks = 0u;
      Os_SingleAlarmRunData[iterator].counterPreviousVal = 0u;
      Os_SingleAlarmRunData[iterator].AlarmIsRunning_BO = FALSE;
   }
#endif

   Os_CurrentRunningTask = OS_TASK_ID_Idle;
   OS_INIT_QUEUES();
   /*[SWPS_SWS_SERVOS_00103]*/
   Os_InitMcal();
}

/*!
 ****************************************************************************
 * \brief
 *  Update task queues
 *
 * \details
 *  This function checks all cyclic alarms, in case their alarm expired,
 *  adds the task in queue and if it is suspended change its state to READY.
 *  In case queue is full it calls error hook with parameter E_OS_SYS_TSK_Q_FULL
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_CyclicAlarmsRunData, Os_CyclicAlarmCfgData, Os_TaskCfgData, Os_TaskRunData
 *
 * \parblock
 * __Read:__
 * Os_TaskCfgData        - used to check if queue is full and to enqueue tasks
 * Os_CyclicAlarmCfgData - used to get task IDs
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * Os_TaskRunData         - (write) tasks are added in queue and states are changed to READY
 *                        - (read)  used to check tasks states
 * Os_CyclicAlarmsRunData - (write) expired alarms are removed from the list
 *                        - (read)  used to check if there are expired alarms in the list
 * \endparblock
 *
 * \par Called functions:
 *  OS_IS_QUEUE_FULL(), OS_ENQUEUE_TASK(), ErrorHook
 *  SuspendAllInterrupts, ResumeAllInterrupts
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
static void Os_UpdateTaskQueues(void) /*[SWPS_SWS_SERVOS_00130]*/
{
   /*[SWPS_SWS_SERVOS_00131], [SWPS_SWS_SERVOS_00132]*/
   U8 alarmIndex;
   TaskType taskId;
   boolean queueFull;

   /*Update task states base on alarms*/
   for(alarmIndex = 0u; alarmIndex < NUMBER_OF_CYCLIC_ALARMS; alarmIndex++)
   {
      queueFull = (boolean)FALSE;

      while( ((boolean)FALSE == queueFull) && (Os_CyclicAlarmsRunData[alarmIndex].alarmExpirationCnt > 0u) )
      {
         taskId = Os_CyclicAlarmCfgData[alarmIndex].taskID;

         queueFull = OS_IS_QUEUE_FULL(Os_TaskCfgData[taskId].prioIndex);

         if( (boolean)FALSE == queueFull )
         {
            OS_ENQUEUE_TASK(Os_TaskCfgData[taskId].prioIndex, taskId);

            SuspendAllInterrupts();
            Os_CyclicAlarmsRunData[alarmIndex].alarmExpirationCnt--;
            /* polyspace +1 MISRA-C3:D4.1 RTE:OVFL [Not a defect:Unset] "This case is not possible because queue is checked not to be full and maximum size is 20" */
            Os_TaskRunData[taskId].queueEntryNo++;

            if(SUSPENDED == Os_TaskRunData[taskId].taskState)
            {
               /* task is READY*/
               Os_TaskRunData[taskId].taskState = READY;
            }
            ResumeAllInterrupts(); /*[SWPS_SWS_SERVOS_00050]*/
         }
         else
         {
            /* error queue is full
             * [SWPS_SWS_SERVOS_00024], [SWPS_SWS_SERVOS_00133] */
            ErrorHook(E_OS_SYS_TSK_Q_FULL);
         }
      }
   }
}

/*!
 ****************************************************************************
 * \brief
 *  OS Scheduler
 *
 * \details
 *  This function runs the task with the highest priority if no other task is
 *  running or background task is running AND Alarms are running.
 *  It checks if multiple tasks are activated and the error E_OS_SYS_MTA is reported
 *  to error hook
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_TaskCfgData, Os_AlarmsStarted, Os_TaskRunData, Os_SchedulerRunning, Os_CurrentRunningTask
 *
 * \parblock
 * __Read:__
 * Os_TaskCfgData   - used to check the no of allowed activations for one task and to run the configured task function
 * Os_AlarmsStarted - used to check if the alarms were not stopped
 *
 * __Write:__
 * Os_TaskRunData      - tasks are removed from queue and states are changed to RUNNING
 * Os_SchedulerRunning - it is set to TRUE at the beginning of the function and FALSE after scheduler is ready
 *
 * __Read/Write:__
 * Os_CurrentRunningTask - (read)  Current running task flag
 *                       - (write) Current running task id is added
 * \endparblock
 *
 * \par Called functions:
 *  Os_UpdateTaskQueues(), ErrorHook(), OS_IS_QUEUE_EMPTY(), OS_DEQUEUE_TASK()
 *  SuspendAllInterrupts, ResumeAllInterrupts, Os_TaskCfgData[taskId].functionPointer()
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
static void Os_Scheduler(void) /*[SWPS_SWS_SERVOS_00134]*/
{
   /*[SWPS_SWS_SERVOS_00135], [SWPS_SWS_SERVOS_00021]*/
   TaskType taskId;
   boolean rescheduling;
   U8 prioIndex;
   U8 taskIsRunning;

   Os_SchedulerRunning = (boolean)TRUE;

   Os_UpdateTaskQueues();

   /* Evaluate MTA */
   for(taskId = 0u; taskId < OS_NO_OF_CYCLIC_TASKS; taskId++)
   {
      taskIsRunning = 0u;
      if(Os_CurrentRunningTask == taskId)
      { /* polyspace RTE:UNR [Justified:Low] "Code is reached into normal usage, Os_CurrentRunningTask is updated at runtime with the current running task " */
         taskIsRunning = 1u;
      }

      if((Os_TaskRunData[taskId].queueEntryNo + taskIsRunning) > Os_TaskCfgData[taskId].noAllowedActivations)
      {
         /* Call Error hook with MTA - Multiple task activation
          * [SWPS_SWS_SERVOS_00024], [SWPS_SWS_SERVOS_00136]*/
         ErrorHook(E_OS_SYS_MTA);
      }
   }

   /* if no other task is running or background task is running AND Alarms are running */
   /* polyspace +1 RTE:UNR [Justified:Low] "Code is reached in case function is called when other task is running " */
   if((OS_TASK_ID_Idle == Os_CurrentRunningTask) && ((boolean)FALSE != Os_AlarmsStarted))
   {
      /* do while is used to implement a rescheduling after successful task termination */
      do
      {
         prioIndex = 0u;
         /*Find the priority queue which has at least one entry*/
         /* polyspace +2 RTE:UNR [Not a defect:Unset] "The code is reachable when the queue that contains the tasks is empty" */
         /* polyspace +1 MISRA-C3:13.5 [Not a defect:Unset] "No side effects possible" */
         while((prioIndex < OS_NO_OF_PRIORITIES) && ((boolean)TRUE == OS_IS_QUEUE_EMPTY(prioIndex)) )
         {
            prioIndex++;
         }

         if(prioIndex < OS_NO_OF_PRIORITIES)
         {
            /* At least one task is in queue*/
            /* Activate the task with the highest priority, first in queue*/
            OS_DEQUEUE_TASK(prioIndex, &taskId);

            /*Activate task*/
            SuspendAllInterrupts();
            /* polyspace +2 DEFECT:OUT_BOUND_ARRAY [Not a defect:Unset] "The value of taskId is always between the defined bounds. It is checked before using that there is a valid task available in the queue." */
            /* polyspace +1 MISRA-C3:D4.1,18.1 RTE:OBAI,OVFL [Not a defect:Unset] "This case is not possible because queue is checked not to be empty" */
            Os_TaskRunData[taskId].queueEntryNo--;
            Os_CurrentRunningTask = taskId;

            /* task is RUNNING*/
            Os_TaskRunData[Os_CurrentRunningTask].taskState = RUNNING;
            ResumeAllInterrupts(); /*[SWPS_SWS_SERVOS_00050]*/

#if (STD_ON == OS_ENABLE_TASK_HOOKS)
            PreTaskHook(); /*[SWPS_SWS_SERVOS_00137], [SWPS_SWS_SERVOS_00105]*/
#endif
            Os_TaskCfgData[taskId].functionPointer();

#if (STD_OFF != OS_ENABLE_BACKGROUND_TASK)
            if((OS_TASK_ID_Idle == Os_CurrentRunningTask) &&((boolean)FALSE != Os_AlarmsStarted))
            {
               /*scheduling point after task termination*/
               rescheduling = (boolean)TRUE;
               Os_UpdateTaskQueues();

               /* Evaluate MTA */
               for(taskId = 0u; taskId < OS_NO_OF_CYCLIC_TASKS; taskId++)
               {
                  taskIsRunning = 0u;
                  /* polyspace +1 DEFECT:DEAD_CODE MISRA-C3:14.3 MISRA-C3:2.1 [Not a defect:Unset] "No defect. The condition is TRUE when the Os_CurrentRunningTask is equal to taskId. In normal condition, the value of Os_CurrentRunningTask is always between bounds." */
                  if(Os_CurrentRunningTask == taskId)
                  {
                     taskIsRunning = 1u;
                  }

                  if((Os_TaskRunData[taskId].queueEntryNo + taskIsRunning) > Os_TaskCfgData[taskId].noAllowedActivations)
                  {
                     /* Call Error hook with MTA - Multiple task activation
                      * [SWPS_SWS_SERVOS_00024] */
                     ErrorHook(E_OS_SYS_MTA);
                  }
               }
            }
            else
            {
               /* TerminateTask() was not called at the end of the previous running task or alarms were stopped by calling Os_StopScheduler() */
               rescheduling = (boolean)FALSE;/*Shutdown*/
            }
#else
            /* Scheduling will be triggered from main to allow the update of alarms, maybe a higher priority task becomes ready*/
            rescheduling = (boolean)FALSE;
#endif
         }
         else
         {
            /* No tasks are ready */
            rescheduling = (boolean)FALSE;
         }
      }
      while((boolean)TRUE == rescheduling);/* while there is at least 1 entry in one queue*/
   }

   Os_SchedulerRunning = (boolean)FALSE;

}

/*!
 ****************************************************************************
 * \brief
 *  Evaluate/update cyclic and single alarms
 *
 * \details
 *  This function checks all the running single and cyclic alarms and update them in case they expired.
 *  It calls the scheduler if it is not currently running.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_CyclicAlarmsRunData, Os_TickCounter, Os_AlarmsStarted, Os_SchedulerRunning, Os_CyclicAlarmCfgData
 *
 * \parblock
 * __Read:__
 * Os_TickCounter        - OS tick counter is checked
 * Os_AlarmsStarted      - Alarms started flag is checked
 * Os_SchedulerRunning   - Os scheduler running flag is checked
 * Os_CyclicAlarmCfgData - Alarm configuration data is checked
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * Os_CyclicAlarmsRunData - (write) counter values are stored
 *                        - (read)  counter values are checked
 *
 * \endparblock
 *
 * \par Called functions:
 *  SuspendAllInterrupts, ResumeAllInterrupts, Os_Scheduler, lOs_checkSingleAlarms
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
void Os_AlarmsEvaluation(void) /*[SWPS_SWS_SERVOS_00076]*/
{
   U8 alarmIndex;
   Os_AlarmExpirationType cycleTime;
   Os_CounterType elapsedTime;
#if (STD_OFF == OS_ENABLE_BACKGROUND_TASK)
   Os_CounterType TickCounterCopy;
   /*Previous tick counter value, used to identify the counter value when the alarms were last evaluated*/
   static Os_CounterType Os_PrevTickCounter = 0u;
#endif
   /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable when the alarms have started" */
   if((boolean)FALSE != Os_AlarmsStarted)
   { /*[SWPS_SWS_SERVOS_00077]*/
#if (STD_OFF == OS_ENABLE_BACKGROUND_TASK)
      TickCounterCopy = Os_TickCounter; /*[SWPS_SWS_SERVOS_00104]*/
      if(TickCounterCopy != Os_PrevTickCounter)
      {
         /*[SWPS_SWS_SERVOS_00079]*/
         Os_PrevTickCounter = TickCounterCopy;
#endif        /* (STD_OFF == OS_ENABLE_BACKGROUND_TASK)*/

         for(alarmIndex = 0u; alarmIndex < NUMBER_OF_CYCLIC_ALARMS; alarmIndex++)
         {
            SuspendAllInterrupts();
            /* According to OSEK, multiple counters can be defined, therefore each alarm could reference a different counter.
             * In current implementation a single counter is used. The implementation is done to easily integrate multiple counters
             * in the future (if desired) */
            Os_CyclicAlarmsRunData[alarmIndex].counterCurrentVal = *(Os_CyclicAlarmCfgData[alarmIndex].counterRef);

            if(FALSE == Os_CyclicAlarmsRunData[alarmIndex].initialCyclePassed)
            {
               cycleTime = Os_CyclicAlarmCfgData[alarmIndex].initialCycleTime;
            }
            else
            {
               cycleTime = Os_CyclicAlarmCfgData[alarmIndex].cycleTime;
            }

            /* polyspace +1 MISRA-C3:D4.1 RTE:OVFL [Not a defect:Unset] "Elapsed time is measured correctly even if overflow occurs" */
            elapsedTime = (Os_CounterType)(Os_CyclicAlarmsRunData[alarmIndex].counterCurrentVal -
                     Os_CyclicAlarmsRunData[alarmIndex].counterPreviousVal);

            if( elapsedTime >= cycleTime)
            {
               while(elapsedTime >= cycleTime)
               {
                  /* polyspace +1 MISRA-C3:D4.1 RTE:OVFL [Not a defect:Unset]  "No overflow possible in correct OS usage and configuration" */
                  Os_CyclicAlarmsRunData[alarmIndex].alarmExpirationCnt++;
                  elapsedTime -= cycleTime;
               }

               if(FALSE == Os_CyclicAlarmsRunData[alarmIndex].initialCyclePassed)
               {
                  Os_CyclicAlarmsRunData[alarmIndex].initialCyclePassed = TRUE;
               }

               Os_CyclicAlarmsRunData[alarmIndex].counterPreviousVal = Os_CyclicAlarmsRunData[alarmIndex].counterCurrentVal;
            }
            ResumeAllInterrupts(); /*[SWPS_SWS_SERVOS_00050]*/
         }

#if (STD_OFF == OS_ENABLE_BACKGROUND_TASK)
      }
      else
      {
         /* do nothing - [SWPS_SWS_SERVOS_00080] */
      }
#endif        /* (STD_OFF == OS_ENABLE_BACKGROUND_TASK)*/
      /* polyspace +1 RTE:UNR [Justified:Low] "Code is reached in case function is called while the scheduler is still running" */
      if( (boolean)FALSE == Os_SchedulerRunning)
      {
         /*[SWPS_SWS_SERVOS_00081]*/
         Os_Scheduler();
#if(OS_SINGLE_ALARMS_ENABLED_CFG == STD_ON)
         lOs_checkSingleAlarms();
#endif
      }
   }
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "Code is reacheable when the alarms have not started" */
   else
   {
      /*do nothing; the alarms have not started - [SWPS_SWS_SERVOS_00078]*/
   }
}

/* -------- External functions implementation ------------ */

/*!
 ****************************************************************************
 * \brief
 *  Background task
 *
 * \details
 * If enabled this task is executed each time other tasks are not running
 ****************************************************************************
 *
 * \par Reentrance:
 *  Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  None
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  OS_BACKGROUND_TASK_FUNC()
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
#if (STD_OFF != OS_ENABLE_BACKGROUND_TASK)
void Os_BackgroundTask(void) /*[SWPS_SWS_SERVOS_00075]*/
{
   /*[SWPS_SWS_SERVOS_00154],[SWPS_SWS_SERVOS_00008], [SWPS_SWS_SERVOS_00009], [SWPS_SWS_SERVOS_00010], [SWPS_SWS_SERVOS_00011], [SWPS_SWS_SERVOS_00012], [SWPS_SWS_SERVOS_00013]*/
   while((boolean)TRUE)
   {
      OS_BACKGROUND_TASK_FUNC();
   }
}
#endif

#if (STD_ON == OS_ENABLE_NOT_NESTABLE_INT_API)
/*!
 ****************************************************************************
 * \brief
 *  Disable all interrupts
 *
 * \details
 * This service disables all interrupts for which the hardware supports disabling.
 * The state before is saved for the EnableAllInterrupts call.
 * The service may be called from an ISR category 1 and category 2 and from the task level, but not from hook routines.
 * This service is intended to start a critical section of the code.
 * This section shall be finished by calling the EnableAllInterrupts service.
 * No API service calls are allowed within this critical section.
 * Note that this service does not support nesting. If nesting is needed for critical sections
 * e.g. for libraries SuspendOSInterrupts/ResumeOSInterrupts or SuspendAllInterrupt/ResumeAllInterrupts should be used.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  None
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  OS_DISABLE_INTERRUPT()
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
void DisableAllInterrupts(void) /*[SWPS_SWS_SERVOS_00044]*/
{
   /*[SWPS_SWS_SERVOS_00045]*/
   OS_DISABLE_INTERRUPT();
}

/*!
 ****************************************************************************
 * \brief
 *  Enable all interrupts
 *
 * \details
 * This service restores the state saved by DisableAllInterrupts.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  None
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  OS_ENABLE_INTERRUPT()
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
void EnableAllInterrupts(void) /*[SWPS_SWS_SERVOS_00046]*/
{
   /*[SWPS_SWS_SERVOS_00047]*/
   OS_ENABLE_INTERRUPT();
}
#endif /*(STD_ON == OS_ENABLE_NOT_NESTABLE_INT_API)*/

/*!
 ****************************************************************************
 * \brief
 *  Resume all interrupts
 *
 * \details
 * This service restores the recognition status of all interrupts saved by the SuspendAllInterrupts service.
 * This service is the counterpart of SuspendAllInterrupts service, which has to have been called before,
 * and its aim is the completion of the critical section of code.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_u8InterruptSuspCnt
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * Os_u8InterruptSuspCnt
 *
 * \endparblock
 *
 * \par Called functions:
 *  OS_ENABLE_INTERRUPT()
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
void ResumeAllInterrupts(void) /*[SWPS_SWS_SERVOS_00051]*/
{
   /*[SWPS_SWS_SERVOS_00052]*/
   /* polyspace +8 RTE:UNR [Justified:Low] "Implementation is done for nested interrupts" */
   if (Os_u8InterruptSuspCnt != 0u)
   {
      /* polyspace +1 MISRA-C3:D4.1 RTE:OVFL [Not a defect:Unset] "Underflow is not possible. In normal operation, the variable Os_u8InterruptSuspCnt will always be increased first on ResumeAllInterrupts function and there is also an if condition before that checks if the variable is different than 0." */
      Os_u8InterruptSuspCnt--;
      if (0u == Os_u8InterruptSuspCnt)
      {
         OS_ENABLE_INTERRUPT();
      }
   }
   /*
   else
   {
      No action needed, see [SWPS_SWS_Os_00092]
   }*/
}

/*!
 ****************************************************************************
 * \brief
 *  Suspend all interrupts
 *
 * \details
 * This service saves the recognition status of all interrupts and disables all
 * interrupts for which the hardware supports disabling.
 * The service may be called from an ISR category 1 and category 2, from alarm-callbacks and from the task level,
 * but not from all hook routines. This service is intended to protect a critical section of code from
 * interruptions of any kind. This section shall be finished by calling the ResumeAllInterrupts service.
 * No API service calls beside SuspendAllInterrupts/ResumeAllInterrupts pairs
 * are allowed within this critical section.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_u8InterruptSuspCnt
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * Os_u8InterruptSuspCnt
 *
 * \endparblock
 *
 * \par Called functions:
 *  OS_DISABLE_INTERRUPT()
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
void SuspendAllInterrupts(void) /*[SWPS_SWS_SERVOS_00048]*/
{
   /*[SWPS_SWS_SERVOS_00049]*/
   /* polyspace +5 RTE:UNR [Justified:Low] "Implementation is done for nested interrupts" */
   if(0u == Os_u8InterruptSuspCnt)
   {
      OS_DISABLE_INTERRUPT();
   }
   /* polyspace +1 MISRA-C3:D4.1 RTE:OVFL [Not a defect:Unset] "Overflow is not possible. The variable Os_u8InterruptSuspCnt will always be decreased on ResumeAllInterrupts function." */
   Os_u8InterruptSuspCnt++;
}

/*!
 ****************************************************************************
 * \brief
 *  Start OS
 *
 * \details
 * The user shall call this system service to start the operating system.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     AppMode - Application Mode, for the moment the param
 *                          is not used, it is added just for compatibility
 *                          with OSEK
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_AlarmsStarted
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * Os_AlarmsStarted - set its value to TRUE(alarms are started)
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  Os_Init, Os_SetTickStatus, ResumeAllInterrupts
 *  StartupHook() routine is called by the operating system at the end of the operating
 *  system initialization and before the scheduler is running. At this time the application
 *  can initialize device drivers etc.
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
/* polyspace +1 MISRA-C3:2.7 [Not a defect:Unset] "AppMode is ignored because no application modes are supported for the moment, parameter added for compatibility with OSEK." */
void StartOS(AppModeType AppMode) /*[SWPS_SWS_SERVOS_00053]*/
{
   /*[SWPS_SWS_SERVOS_00054]*/
   Os_Init();

#if(STD_ON == OS_ENABLE_STARTUP_HOOK)
   StartupHook(); /*[SWPS_SWS_SERVOS_00055]*/
#endif

   /* According to OSEK OS, the operating system enables user interrupts and starts the scheduling activity after StartupHook() */
   /*  start the autostarted alarms. In current OS implementation all tasks(excepting background task) are attached to cyclic autostart alarms */
   Os_AlarmsStarted = (boolean)TRUE;
   Os_SetTickStatus(Os_AlarmsStarted);
   ResumeAllInterrupts(); /*[SWPS_SWS_SERVOS_00056]*/
}

/*!
 ****************************************************************************
 * \brief
 *  Shutdown OS
 *
 * \details
 * The user can call this system service to abort the overall system (e.g. emergency off).
 * The operating system also calls this function internally, if it has reached an undefined internal state
 * and is no longer ready to run.
 * This function calls the ShutdownHook and then enters an endless loop.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     Error - error code
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  None
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  ShutdownHook(), OS_DISABLE_INTERRUPT
 *
 * \returns
 *  void
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
void ShutdownOS(Os_StatusType Error) /*[SWPS_SWS_SERVOS_00057]*/
{
   /*[SWPS_SWS_SERVOS_00058], [SWPS_SWS_SERVOS_00059]*/
   ShutdownHook(Error);

   /*[SWS_Os_00425]*/
   OS_DISABLE_INTERRUPT();
   while(1)
   {
   }
}

#if (STD_ON == OS_ENABLE_NON_CYCLIC_TASKS)
/*!
 ****************************************************************************
 * \brief
 *  Activate task
 *
 * \details
 * The task <TaskID> is transferred from the suspended state into the ready state.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None

 * \param[IN]     TaskID - task ID
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  None
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  None
 *
 * \returns
 *  Os_StatusType
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
/*Os_StatusType ActivateTask(TaskType TaskID);*/
#endif /*(STD_ON == OS_ENABLE_NON_CYCLIC_TASKS)*/

/*!
 ****************************************************************************
 * \brief
 * Terminate task. The user shall call this system service at the end of each task.
 *
 * \details
 * This service causes the termination of the calling task.
 * The calling task is transferred from the running state into the suspended state
 * In case of tasks with multiple activation requests, terminating the current instance
 * of the task automatically puts the next instance of the same task into the ready state.
 * If the service TerminateTask is called successfully, it enforces a rescheduling.
 * Ending a task function without call to TerminateTask or ChainTask is strictly forbidden
 * and may leave the system in an undefined state.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_AlarmsStarted, Os_TaskRunData, Os_CurrentRunningTask
 *
 * \parblock
 * __Read:__
 * Os_AlarmsStarted - used to check if alarms are not stopped
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * Os_TaskRunData - (read)  used to check if task has multiple activation requests
 *                - (write) task state is set
 * Os_CurrentRunningTask - (read)  used to access data of the current running task
 *                       - (write) current running task is set to OS_TASK_ID_Idle
 *
 * \endparblock
 *
 * \par Called functions:
 *  PostTaskHook, GetTaskID, SuspendAllInterrupts, ResumeAllInterrupts
 *
 * \returns
 *  Os_StatusType - status E_OK
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
Os_StatusType TerminateTask(void) /*[SWPS_SWS_SERVOS_00060]*/
{
   TaskType taskId;
   Os_StatusType status;
#if (STD_ON == OS_ENABLE_TASK_HOOKS)
   PostTaskHook(); /*[SWPS_SWS_SERVOS_00064], [SWPS_SWS_SERVOS_00105]*/
#endif

   status = GetTaskID( &taskId);
   /* polyspace +1 DEFECT:USELESS_IF MISRA-C3:14.3 [Not a defect:Unset] "In normal operation, when the module is integrated correctly, the value of status is E_OK." */
   if (E_OK == status)
   {
      SuspendAllInterrupts();
      /*check also Os_AlarmsStarted, in case GetResource() was called*/
      /* polyspace +2 DEFECT:OUT_BOUND_ARRAY MISRA-C3:D4.1 MISRA-C3:18.1 [Not a defect:Unset] "The value of taskId is always between the defined bounds. If no task is running, the function GetTaskID would return INVALID_TASK and the code would enter the else branch ( this should not happen in normal operation)." */
      /* polyspace +1 RTE:UNR [Justified:Low] "Code is reached in case another task instance is still in queue" */
      if( ((boolean)FALSE != Os_AlarmsStarted) || (0u != Os_TaskRunData[taskId].queueEntryNo) )
      {
         /* task is SUSPENDED - [SWPS_SWS_SERVOS_00061]*/
         /* polyspace +1 DEFECT:OUT_BOUND_ARRAY MISRA-C3:D4.1 MISRA-C3:18.1 [Not a defect:Unset] "The value of taskId is always between the defined bounds. If no task is running, the function GetTaskID would return INVALID_TASK and the code would enter the else branch ( this should not happen in normal operation)." */
         Os_TaskRunData[Os_CurrentRunningTask].taskState = SUSPENDED;
      }
      else
      {  /* polyspace RTE:UNR [Justified:Low] "Code is reached in case TerminateTask() is called when alarms are stopped or task is not in queue." */
         /* task is READY - [SWPS_SWS_SERVOS_00062]*/
         /* polyspace +1 DEFECT:OUT_BOUND_ARRAY MISRA-C3:D4.1 MISRA-C3:18.1 [Not a defect:Unset] "The value of taskId is always between the defined bounds. If no task is running, the function GetTaskID would return INVALID_TASK and the code would enter the else branch ( this should not happen in normal operation)." */
         Os_TaskRunData[Os_CurrentRunningTask].taskState = READY;
      }
      Os_CurrentRunningTask = OS_TASK_ID_Idle;
      ResumeAllInterrupts(); /*[SWPS_SWS_SERVOS_00050]*/
   }
   else
   {  /* polyspace RTE:UNR [Justified:Low] "Case shall not occur. Else was added just for CSpec conformance." */
      /*should not occur*/
   }

   return (Os_StatusType)E_OK; /*[SWPS_SWS_SERVOS_00063]*/
}

#if (STD_ON == OS_ENABLE_NON_CYCLIC_TASKS)
/*!
 ****************************************************************************
 * \brief
 * Chain task
 * \details
 * This service causes the termination of the calling task. After termination of
 * the calling task a succeeding task <TaskID> is activated.
 * Using this service, it ensures that the succeeding task starts to run at the
 * earliest after the calling task has been terminated.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  All must be initialized
 *
 * \param[IN]     TaskID - task ID
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  None
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  None
 *
 * \returns
 *  Os_StatusType
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
/*Os_StatusType ChainTask(TaskType TaskID)
{
   return E_OK;
}*/
#endif


/*!
 ****************************************************************************
 * \brief
 * Get task ID
 *
 * \details
 * GetTaskID returns the information about the TaskID of the task which is currently running.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     None
 * \param[OUT]    OsTaskID - task ID
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_CurrentRunningTask
 *
 * \parblock
 * __Read:__
 * Os_CurrentRunningTask
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  None
 *
 * \returns
 *  Os_StatusType - INVALID_TASK the current running task is idle
 *                - E_OK the current running task is valid
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
/* polyspace +1 MISRA-C3:5.1,8.7 [Not a defect:Unset] "OSEK naming convention; the function can be used in other modules" */
Os_StatusType GetTaskID(TaskRefType OsTaskID) /*[SWPS_SWS_SERVOS_00065]*/
{
   Os_StatusType retVal = E_OK;

#if (STD_OFF == OS_ENABLE_BACKGROUND_TASK)
   if(Os_CurrentRunningTask == OS_TASK_ID_Idle)
   {  /* polyspace RTE:UNR [Justified:Low] "Code is reached in case function is called when no task is running" */
      retVal = INVALID_TASK; /*[SWPS_SWS_SERVOS_00066]*/
   }

   /* polyspace +1 RTE:UNR [Justified:Low] "Code is reached in case function is called when no task is running" */
   if(retVal != INVALID_TASK )
#endif
   {
      *OsTaskID = Os_CurrentRunningTask; /*[SWPS_SWS_SERVOS_00067]*/
   }

   return retVal;
}

/*!
 ****************************************************************************
 * \brief
 * Get task state
 *
 * \details
 * Returns the state of a task (running, ready, waiting, suspended) at the time of calling GetTaskState.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     OsTaskID - task ID
 * \param[OUT]    OsTaskState - state of the task with <TaskID>
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_TaskRunData
 *
 * \parblock
 * __Read:__
 * Os_TaskRunData
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  None
 *
 * \returns
 *  Os_StatusType - status E_OK - task ID is valid
 *                         E_OS_ID - task ID is not valid
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
/* polyspace +1 MISRA-C3:5.1 [Not a defect:Unset] "OSEK naming convention" */
Os_StatusType GetTaskState(TaskType OsTaskID, TaskStateRefType OsTaskState) /*[SWPS_SWS_SERVOS_00068]*/
{
   Os_StatusType retVal;

   if(OsTaskID >= OS_NO_OF_CYCLIC_TASKS)
   { /* polyspace RTE:UNR [Justified:Low] "Code is reached in case function is called with wrong parameter" */
      retVal = E_OS_ID; /*[SWPS_SWS_SERVOS_00069]*/
   }
   else
   {
      /*[SWPS_SWS_SERVOS_00070]*/
      *OsTaskState = Os_TaskRunData[OsTaskID].taskState;
      retVal = E_OK;
   }

   return retVal;
}

#if (OS_GET_ELAPSED_VAL_API == STD_ON)
/*!
 ****************************************************************************
 * \brief
 * This service gets the number of ticks between the current tick value and a previously read tick value.
 *
 * \details
 * This service gets the number of ticks between the current tick value and a previously read tick value.
 * Caveats of GetElapsedValue():If the timer already passed the
 * <TickValue> value a second (or multiple) time, the result returned is wrong.
 * The reason is that the service can not detect such a relative overflow.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     CounterID - not used for the moment, OS has only one counter
 * \param[OUT]    ElapsedValue  - The difference to the previous read value
 * \param[IN/OUT] TickValue : IN - the previously read tick value of the counter
 *                            OUT - the current tick value of the counter
 *
 * \par Used global variables:
 *  Os_TickCounter
 *
 * \parblock
 * __Read:__
 * Os_TickCounter - returns the current value of the OS tick counter
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  ErrorHook, SuspendAllInterrupts, ResumeAllInterrupts
 *
 * \returns
 *  Os_StatusType - E_OK: No errors
 *                  E_OS_PARAM_POINTER: A null pointer was given as argument
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
/* polyspace +1 MISRA-C3:2.7 [Not a defect:Unset] "CounterID is ignored because a single tick counter is supported." */
Os_StatusType GetElapsedValue(CounterType CounterID, TickRefType TickValue, TickRefType ElapsedValue) /*[SWPS_SWS_SERVOS_00071], [SWS_Os_00533]*/
{
   Os_StatusType A_Os_RetVal_UT;
   Os_CounterType currentTick;

   /* polyspace +2 RTE:UNR [Not a defect:Unset] "The code is reachable when a NULL pointer is passed as argument" */
   if((NULL == TickValue) || (NULL == ElapsedValue))
   {
      /*[SWPS_SWS_SERVOS_00074], [SWPS_SWS_SERVOS_00024], [SWPS_SWS_SERVOS_00072] */
      ErrorHook(E_OS_PARAM_POINTER);
      A_Os_RetVal_UT = E_OS_PARAM_POINTER;
   }
   else
   {
      SuspendAllInterrupts();
      currentTick = Os_TickCounter; /*[SWPS_SWS_SERVOS_00104]*/
      ResumeAllInterrupts(); /*[SWPS_SWS_SERVOS_00050]*/

      /* polyspace +1 MISRA-C3:D4.1 RTE:OVFL [Not a defect:Unset] "intended behavior in case of overflow, it correctly calculates the elapsed time" */
      *ElapsedValue = (Os_CounterType)(currentTick - *TickValue); /*[SWS_Os_00382]*/
      *TickValue = currentTick; /*[SWS_Os_00460]*/
      A_Os_RetVal_UT = E_OK;
   }

   return A_Os_RetVal_UT;
}
#endif /* #if (OS_GET_ELAPSED_VAL_API == STD_ON)*/

#if (OS_GET_COUNTER_VAL_API == STD_ON)
/*!
 ****************************************************************************
 * \brief
 * This service reads the current count value of a counter.
 *
 * \details
 *
 ****************************************************************************
 *
 * \par Reentrance:
 *  Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     CounterID - The Counter which tick value should be read
 * \param[OUT]    OsTickValue - Contains the current tick value of the counter
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_TickCounter
 *
 * \parblock
 * __Read:__
 * Os_TickCounter - returns the current value of the OS tick counter
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  ErrorHook, SuspendAllInterrupts, ResumeAllInterrupts
 *
 * \returns
 *  Os_StatusType - E_OK: No errors
 *                  E_OS_ID: The <CounterID> was not valid
 *                  E_OS_PARAM_POINTER: A null pointer was given as argument
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
Os_StatusType GetCounterValue(CounterType CounterID, TickRefType OsTickValue) /*[SWPS_SWS_SERVOS_00073]*/
{
   Os_StatusType A_Os_RetVal_UT = E_OK;

   /*check if the CounterID parameter has a valid value*/
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "The code is reachable when the parameter CounterID is different than SystemTimer." */
   if(CounterID != SystemTimer)
   {
      /*raise error
       * [SWPS_SWS_SERVOS_00024], [SWS_Os_00376]*/
      ErrorHook(E_OS_ID);
      A_Os_RetVal_UT = E_OS_ID;
   }
   else
   {
      /* polyspace +2 RTE:UNR [Not a defect:Unset] "The code is reachable when the parameter OsTickValue is NULL." */
      if(OsTickValue == NULL)
      {
         /*[SWPS_SWS_SERVOS_00024], [SWPS_SWS_SERVOS_00074]*/
         ErrorHook(E_OS_PARAM_POINTER);
         A_Os_RetVal_UT = E_OS_PARAM_POINTER;
      }
      else
      {
         SuspendAllInterrupts();
         *OsTickValue = Os_TickCounter; /*get current tick value [SWS_Os_00377], [SWPS_SWS_SERVOS_00104]*/
         ResumeAllInterrupts(); /*[SWPS_SWS_SERVOS_00050]*/
      }
   }

   return A_Os_RetVal_UT;
}
#endif /* #if (OS_GET_COUNTER_VAL_API == STD_ON)*/

#if (OS_GET_RELEASE_RESOURCE_API == STD_ON)
/*!
 ****************************************************************************
 * \brief
 * Acquire a resource
 *
 * \details
 * This call serves to enter critical sections in the code that are assigned to the
 * resource referenced by ResourceId. A critical section shall always be left using ReleaseResource.
 * In case single alarms are used and GetResource is called, the running single alarms will be stopped.
 * For the moment resources are not configurable and only
 * RES_SCHEDULER resource is implemented. This resource is used to acquire
 * the scheduler so no task be executed.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     ResourceId - ID of the resource which is acquired
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_AlarmsStarted
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * Os_AlarmsStarted - variable is set to FALSE
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  ErrorHook, Os_SetTickStatus, SuspendAllInterrupts, ResumeAllInterrupts
 *
 * \returns
 *  Os_StatusType - E_OK: No errors
 *                  E_OS_ID: An error occurred, ResourceId was not configured
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
Os_StatusType GetResource(ResourceType ResourceId)/*[SWPS_SWS_SERVOS_00082]*/
{
   /*[SWPS_SWS_SERVOS_00083]*/
   Os_StatusType retVal = E_OK;

   if (RES_SCHEDULER == ResourceId)
   {
      /*[SWPS_SWS_SERVOS_00085]*/
      /*  Stop the alarms and therefore the execution of the cyclic tasks */
      SuspendAllInterrupts();
      Os_AlarmsStarted = (boolean)FALSE;
      Os_SetTickStatus(Os_AlarmsStarted);
      ResumeAllInterrupts(); /*[SWPS_SWS_SERVOS_00050]*/
      /* once the alarms are stopped, all the cyclic tasks and single alarms are suspended
       * so when ReleaseResource(RES_SCHEDULER) will be called tasks will start executing
       * again taking into consideration the offsets, cyclicality and priorities configured
       * by user and ignoring old pending tasks if exists */
      Os_Init();
   }
   else
   {  /* polyspace RTE:UNR [Justified:Low] "Code is reached in case function is called with wrong parameter" */
      ErrorHook(E_OS_ID); /*[SWPS_SWS_SERVOS_00024], [SWPS_SWS_SERVOS_00084]*/
      retVal = E_OS_ID;
   }


   return retVal;
}
#endif /* if (OS_GET_RELEASE_RESOURCE_API == STD_ON) */

#if (OS_GET_RELEASE_RESOURCE_API == STD_ON)
/*!
 ****************************************************************************
 * \brief
 * Releases a resource
 *
 * \details
 * ReleaseResource is the counterpart of GetResource and serves to leave critical
 * sections in the code that are assigned to the resource referenced by ResourceId.
 * If single alarms were running before calling GetResource, by calling ReleaseResource
 * the single alarms won't be started. It is up to the user to start the alarms again,
 * if necessary. For the moment resources are not configurable and only
 * RES_SCHEDULER resource is implemented. With this service the resource RES_SCHEDULER
 * is released and tasks can be executed again.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  None
 *
 * \param[IN]     ResourceId - ID of the resource which is released
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_AlarmsStarted
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * Os_AlarmsStarted - variable is set to TRUE
 *
 * __Read/Write:__
 * None
 *
 * \endparblock
 *
 * \par Called functions:
 *  ErrorHook, Os_SetTickStatus, SuspendAllInterrupts, ResumeAllInterrupts
 *
 * \returns
 *  Os_StatusType - E_OK: No errors
 *                  E_OS_ID: An error occurred, ResourceId was not configured
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
Os_StatusType ReleaseResource(ResourceType ResourceId) /*[SWPS_SWS_SERVOS_00086]*/
{
   /*[SWPS_SWS_SERVOS_00087]*/
   Os_StatusType retVal = E_OK;

   if (RES_SCHEDULER == ResourceId)
   {
      /*[SWPS_SWS_SERVOS_00089]*/
      /* Start the alarms and therefore the execution of the cyclic tasks */
      SuspendAllInterrupts();
      Os_AlarmsStarted = (boolean)TRUE;
      Os_SetTickStatus(Os_AlarmsStarted);
      ResumeAllInterrupts(); /*[SWPS_SWS_SERVOS_00050]*/
   }
   else
   {     /* polyspace RTE:UNR [Justified:Low] "Code is reached in case function is called with wrong parameter" */
      ErrorHook(E_OS_ID); /*[SWPS_SWS_SERVOS_00024], [SWPS_SWS_SERVOS_00088]*/
      retVal = E_OS_ID;
   }

   return retVal;
}
#endif /* if (OS_GET_RELEASE_RESOURCE_API == STD_ON) */


#if(OS_SINGLE_ALARMS_ENABLED_CFG == STD_ON)
/*!
 ****************************************************************************
 * \brief
 * The system service GetAlarm gets the relative value in ticks before the alarm AlarmID expires.
 *
 * \details
 *
 ****************************************************************************
 *
 * \par Reentrance:
 *  Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  All must be initialized
 *
 * \param[IN]     AlarmID - Reference to an alarm
 * \param[OUT]    Tick - Relative value in ticks before the alarm AlarmID expires
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_SingleAlarmRunData
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * Os_SingleAlarmRunData - (read)  check if the alarms is running
 *                       - (write) reads the value of the single alarm's expiration time in ticks
 *
 * \endparblock
 *
 * \par Called functions:
 *  ErrorHook, SuspendAllInterrupts, ResumeAllInterrupts
 *
 * \returns
 *  Os_StatusType - E_OK - No error
 *                  E_OS_NOFUNC - Alarm <AlarmID> is not used
 *                  E_OS_ID - Alarm <AlarmID> is invalid
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
Os_StatusType GetAlarm (OS_AlarmType AlarmID, TickRefType Tick) /*[SWPS_SWS_SERVOS_00090]*/
{
   Os_StatusType A_Os_ReturnVal_Os_StatusType = E_OK;
   /* polyspace-begin RTE:UNR [Not a defect:Unset] "The code is reachable when certain conditions are met(the alarm ID is invalid or the alarm is stopped" */
   /*check if the parameter <AlarmID> is valid and if not, report/return with the corresponding error ID*/
   if(NUMBER_OF_SINGLE_ALARMS_CFG <= AlarmID)
   {
      /*[SWPS_SWS_SERVOS_00024], [SWPS_SWS_SERVOS_00092]*/
      A_Os_ReturnVal_Os_StatusType = E_OS_ID;
      ErrorHook(E_OS_ID);
   }
   else
   {
      /*check if the <AlarmID> alarm is running and if not, report/return with the corresponding error ID*/
      if((BOOL)(FALSE) ==  Os_SingleAlarmRunData[AlarmID].AlarmIsRunning_BO)
      {
         /*[SWPS_SWS_SERVOS_00024], [SWPS_SWS_SERVOS_00093]*/
         A_Os_ReturnVal_Os_StatusType = E_OS_NOFUNC;
         ErrorHook(E_OS_NOFUNC);
      }
      /* polyspace-end RTE:UNR [Not a defect:Unset] "The code is reachable when certain conditions are met(the alarm ID is invalid or the alarm is stopped" */
      else
      {
         /*[SWPS_SWS_SERVOS_00091]
          * all the parameters are ok; return the value in ticks until the alarm expires */
         SuspendAllInterrupts();
         *Tick = Os_SingleAlarmRunData[AlarmID].AlarmExpirationTimeInTicks;
         ResumeAllInterrupts(); /*[SWPS_SWS_SERVOS_00050]*/
      }
   }

   return A_Os_ReturnVal_Os_StatusType;
}

/*!
 ****************************************************************************
 * \brief
 * The system service activates/starts the alarm <AlarmID> element and assigns to it
 * <increment> ticks until it expires.
 * In the current implementation, only callback routines are available when the alarm expires.
 * \details
 * In the current implementation, <cycle> parameter must be equal to 0.
 * To change values of alarms already in use the alarm shall be cancelled first.
 ****************************************************************************
 *
 * \par Reentrance:
 *  Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  All must be initialized
 *
 * \param[IN]     AlarmID - Reference to an alarm
 *                increment - Relative value in ticks. The macro OS_MS_TO_TICKS(timeInMs) can be used to convert the time from milliseconds to ticks.
 *                cycle - Cycle value in case of cyclic alarm. In case of single alarms, cycle shall be zero. In the current implementation, cycle parameter must be 0
 * \param[OUT]    None
 * \param[IN/OUT] None
 * \par Used global variables:
 *  Os_SingleAlarmRunData, Os_SingleAlarmCfgData
 *
 * \parblock
 * __Read:__
 * Os_SingleAlarmCfgData - reads the value of the single alarm's counter reference
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * Os_SingleAlarmRunData - (read) check if the alarms is running
 *                       - (write) initializes the alarm's parameters in order to start it
 *
 * \endparblock
 *
 * \par Called functions:
 *  ErrorHook, SuspendAllInterrupts, ResumeAllInterrupts
 *
 * \returns
 *  Os_StatusType - E_OK - No error
 *                  E_OS_STATE - Alarm AlarmID is already in use
 *                  E_OS_ID - Invalid ID
 *                  E_OS_VALUE - <increment> value equal to 0
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
/* polyspace +1 MISRA-C3:2.7 [Not a defect:Unset] "cycle parameter is intended to not be used. It will remain for future development purpose." */
Os_StatusType SetRelAlarm (OS_AlarmType AlarmID, TickType increment, TickType cycle) /*[SWPS_SWS_SERVOS_00094]*/
{
   Os_StatusType A_Os_ReturnVal_Os_StatusType = E_OK;

   /* polyspace-begin RTE:UNR [Not a defect:Unset] "The code is reachable when certain conditions are met(the alarm ID is invalid, the alarm is already running or the value of increment parameter is 0. " */
   /*check if the parameter <AlarmID> is valid and if not, report/return with the corresponding error ID*/
   if(NUMBER_OF_SINGLE_ALARMS_CFG <= AlarmID)
   {
      /*[SWPS_SWS_SERVOS_00024], [SWPS_SWS_SERVOS_00096]*/
      A_Os_ReturnVal_Os_StatusType = E_OS_ID;
      ErrorHook(E_OS_ID);
   }
   else
   {
      /*check if the current alarm is already running and if it is, report/return with the corresponding error ID*/
      if((BOOL)(FALSE) != Os_SingleAlarmRunData[AlarmID].AlarmIsRunning_BO)
      {
         /*[SWPS_SWS_SERVOS_00024], [SWPS_SWS_SERVOS_00097]*/
         A_Os_ReturnVal_Os_StatusType = E_OS_STATE;
         ErrorHook(E_OS_STATE);
      }
      else
      {
         /*check if <increment> parameter is equal to 0 and if it is, report/return with the corresponding error IDs*/
         if(0 == increment)
         {
            /*[SWPS_SWS_SERVOS_00024], [SWPS_SWS_SERVOS_00098]*/
            A_Os_ReturnVal_Os_StatusType = E_OS_VALUE;
            ErrorHook(E_OS_VALUE);
         }
         /* polyspace-end RTE:UNR [Not a defect:Unset] "The code is reachable when certain conditions are met(the alarm ID is invalid, the alarm is already running or the value of increment parameter is 0. " */
         else
         {
            /*[SWPS_SWS_SERVOS_00095]
             * all the parameters are ok, the alarm can be started*/
            SuspendAllInterrupts();
            Os_SingleAlarmRunData[AlarmID].AlarmIsRunning_BO = (BOOL)(TRUE);
            Os_SingleAlarmRunData[AlarmID].AlarmExpirationTimeInTicks = increment;
            Os_SingleAlarmRunData[AlarmID].counterPreviousVal = *(Os_SingleAlarmCfgData[AlarmID].AlarmCounterRef);
            ResumeAllInterrupts(); /*[SWPS_SWS_SERVOS_00050]*/
         }
      }
   }

   return A_Os_ReturnVal_Os_StatusType;
}

/*!
 ****************************************************************************
 * \brief
 * The system service cancels the alarm <AlarmID>.
 * \details
 * Allowed on task level and in ISR, but not in hook routines
 ****************************************************************************
 *
 * \par Reentrance:
 *  Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  All must be initialized
 *
 * \param[IN]     AlarmID - Reference to an alarm
 * \param[OUT]    None
 * \param[IN/OUT] None
 *
 * \par Used global variables:
 *  Os_SingleAlarmRunData
 *
 * \parblock
 * __Read:__
 * None
 *
 * __Write:__
 * None
 *
 * __Read/Write:__
 * Os_SingleAlarmRunData - (read) check if the alarms is running
 *                       - (write) initializes the alarm's parameters in order to cancel it
 *
 * \endparblock
 *
 * \par Called functions:
 *  ErrorHook, SuspendAllInterrupts, ResumeAllInterrupts
 *
 * \returns
 *  Os_StatusType - E_OK - No error
 *                  E_OS_NOFUNC - Alarm <AlarmID> not in use
 *                  E_OS_ID - Alarm <AlarmID> is invalid
 *
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/
Os_StatusType CancelAlarm (OS_AlarmType AlarmID)/*[SWPS_SWS_SERVOS_00099]*/
{
   Os_StatusType A_Os_ReturnVal_Os_StatusType = E_OK;
   /* polyspace-begin RTE:UNR [Not a defect:Unset] "The code is reachable when certain conditions are met(the alarm ID is invalid or the alarm is already stopped" */
   /*check if the parameter <AlarmID> is valid and if not, report/return with the corresponding error ID*/
   if(NUMBER_OF_SINGLE_ALARMS_CFG <= AlarmID)
   {
      /*[SWPS_SWS_SERVOS_00024], [SWPS_SWS_SERVOS_00101]*/
      A_Os_ReturnVal_Os_StatusType = E_OS_ID;
      ErrorHook(E_OS_ID);
   }
   else
   {
      /*check if the <AlarmID> alarm is running and if not, report/return with the corresponding error ID*/
      if((BOOL)(FALSE) ==  Os_SingleAlarmRunData[AlarmID].AlarmIsRunning_BO)
      {
         /*[SWPS_SWS_SERVOS_00024], [SWPS_SWS_SERVOS_00102]*/
         A_Os_ReturnVal_Os_StatusType = E_OS_NOFUNC;
         ErrorHook(E_OS_NOFUNC);
      }
      /* polyspace-end RTE:UNR [Not a defect:Unset] "The code is reachable when certain conditions are met(the alarm ID is invalid or the alarm is already stopped" */
      else
         /* polyspace +1 RTE:UNR [Not a defect:Unset] "Code is reachable in normal conditions(when the function is called and the conditions before are not satisfied)" */
      {
         SuspendAllInterrupts();
         /* [SWPS_SWS_SERVOS_00100]
          * all the parameters are ok, the alarm can be stopped*/
         Os_SingleAlarmRunData[AlarmID].AlarmIsRunning_BO = (BOOL)(FALSE);
         Os_SingleAlarmRunData[AlarmID].AlarmExpirationTimeInTicks = 0u;
         Os_SingleAlarmRunData[AlarmID].counterPreviousVal = 0u;
         ResumeAllInterrupts(); /*[SWPS_SWS_SERVOS_00050]*/
      }
   }

   return A_Os_ReturnVal_Os_StatusType;
}

#endif

/* %PCMS_HEADER_SUBSTITUTION_START:%
 ******************************************************************************
 * Document Management Information Log (generated by Dimensions CM)
 *
 * Description:
 * %PD:%
 *
 * Used by Baselines:
 * %PIRB:%
 *
 * Used by Dimensions CM Projects:
 * %PIRW:%
 *
 * Change History:
 * %PL:%
 *
 * %PCMS_HEADER_SUBSTITUTION_END:%
 */
