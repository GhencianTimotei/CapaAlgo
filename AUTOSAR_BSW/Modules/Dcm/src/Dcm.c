/**********************************************************************************************************************
 *  COPYRIGHT
 *  -------------------------------------------------------------------------------------------------------------------
 *  \verbatim
 *  Copyright (c) 2021 by Vector Informatik GmbH.                                                  All rights reserved.
 *
 *                This software is copyright protected and proprietary to Vector Informatik GmbH.
 *                Vector Informatik GmbH grants to you only those rights as set out in the license conditions.
 *                All other rights remain with Vector Informatik GmbH.
 *  \endverbatim
 *  -------------------------------------------------------------------------------------------------------------------
 *  FILE DESCRIPTION
 *  -----------------------------------------------------------------------------------------------------------------*/
/**        \file  Dcm.c
 *        \brief  Implementation of DCM core
 *
 *      \details  MICROSAR DCM based on AR 4.0.3
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 *  REVISION HISTORY
 *  -------------------------------------------------------------------------------------------------------------------
 *  Refer to the module's header file.
 *
 *  FILE VERSION
 *  -------------------------------------------------------------------------------------------------------------------
 *  Refer to the module's header file.
 *********************************************************************************************************************/
#define DCM_SOURCE

#ifdef __PRQA__                                                                                                                                      /* COV_DCM_UNSUPPORTED XF */
# pragma PRQA_MACRO_MESSAGES_OFF "Dcm_UtiGetReqData" 2985 /* MD_Dcm_Redundant_2985 */
# pragma PRQA_MACRO_MESSAGES_OFF "Dcm_UtiGetResData" 2985 /* MD_Dcm_Redundant_2985 */
                                                                                                                                                     /* PRQA S 2991 EOF */ /* MD_Dcm_ConstExpr */
                                                                                                                                                     /* PRQA S 2992 EOF */ /* MD_Dcm_ConstExpr */
                                                                                                                                                     /* PRQA S 2995 EOF */ /* MD_Dcm_ConstExpr */
                                                                                                                                                     /* PRQA S 2996 EOF */ /* MD_Dcm_ConstExpr */
#endif
/**********************************************************************************************************************
 *  INCLUDES
 *********************************************************************************************************************/
#include "Dcm.h"
#include "Rte_Dcm.h"
#if (DCM_SVC_2C_NVRAM_SUPPORT_ENABLED == STD_ON)
# include "NvM.h"
#endif /* (DCM_SVC_2C_NVRAM_SUPPORT_ENABLED == STD_ON) */
#include "PduR_Dcm.h"
#include "ComM_Dcm.h"
#if ((DCM_DIAG_NOTIF_BSWM_APPL_UPDATED_ENABLED == STD_ON) || \
    (DCM_SVC_28_SUPPORT_ENABLED == STD_ON))
# include "BswM_Dcm.h"
#endif /* ((DCM_DIAG_NOTIF_BSWM_APPL_UPDATED_ENABLED == STD_ON) || \
 (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)) */
#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
# include "EcuM_Error.h"
#endif /* (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON) */
#include "Dcm_Int.h"

/**********************************************************************************************************************
 *  VERSION CHECK
 *********************************************************************************************************************/
#if ((DCM_SW_MAJOR_VERSION != 15u) || \
    (DCM_SW_MINOR_VERSION !=  8u) || \
    (DCM_SW_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm.h are inconsistent"
#endif
#if ((DCM_CFG_MAJOR_VERSION != 15u) || \
    (DCM_CFG_MINOR_VERSION !=  8u) || \
    (DCM_CFG_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Cfg.h are inconsistent"
#endif
#if ((DCM_LCFG_MAJOR_VERSION != 15u) || \
    (DCM_LCFG_MINOR_VERSION !=  8u) || \
    (DCM_LCFG_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Lcfg.h are inconsistent"
#endif
#if ((DCM_PBCFG_MAJOR_VERSION != 15u) || \
    (DCM_PBCFG_MINOR_VERSION !=  8u) || \
    (DCM_PBCFG_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_PBcfg.h are inconsistent"
#endif

/**********************************************************************************************************************
 *  LOCAL CONSTANT MACROS
 *********************************************************************************************************************/
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
/* Verify consistency between DCM and DEM configurations.
 * In case of error, please refer to the DCM technical reference (search for the error text) for more information and solution.
 */
# if defined(DEM_CFG_SUPPORT_DTR)                                                                                                                    /* COV_DCM_UNSUPPORTED_ERROR_DETECTION XF */
#  if (DEM_CFG_SUPPORT_DTR == STD_ON)
#   if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DCM_ENABLED == STD_ON)
#    error "DCM configured to handle OBD DID MIDs via DCM configuration, but MID handling is done by DEM."
#   endif
#  else
#   if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
#    error "DCM configured to handle OBD DID MIDs via DEM configuration, but no MID handling is done by DEM."
#   endif
#  endif
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON)
/*! Specifies whether at least one diagnostic service needs the request parser utility */
# if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) || \
     (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) || \
     (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)
#  define DCM_OBDIDMGR_REQ_PARSER_ENABLED                            STD_ON
# else
#  define DCM_OBDIDMGR_REQ_PARSER_ENABLED                            STD_OFF
# endif
#endif /* (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
/*! Authentication memory selection access rights validation support */
# if (DCM_SVC_19_17_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_19_18_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_19_19_SUPPORT_ENABLED == STD_ON)
#  define DCM_AUTHMGR_MEM_CHECK_ENABLED                              STD_ON
# else
#  define DCM_AUTHMGR_MEM_CHECK_ENABLED                              STD_OFF
# endif

/*! Authentication RID access rights validation support */
# if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)
#  define DCM_AUTHMGR_RID_CHECK_ENABLED                              STD_ON
# else
#  define DCM_AUTHMGR_RID_CHECK_ENABLED                              STD_OFF
# endif

/*! Authentication DID access rights validation support */
# if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
#  define DCM_AUTHMGR_DID_CHECK_ENABLED                              STD_ON
# else
#  define DCM_AUTHMGR_DID_CHECK_ENABLED                              STD_OFF
# endif
#endif /* (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
# define DCM_NET_CONN_LOCK_ENABLED                                   STD_ON
#else
# define DCM_NET_CONN_LOCK_ENABLED                                   STD_OFF
#endif

#if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON) || \
    (DCM_SVC_10_RESET_AFTER_RESPONSE == STD_ON) || \
    (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
# define DCM_NET_RX_BLOCKING_ENABLED                                 STD_ON
#else
# define DCM_NET_RX_BLOCKING_ENABLED                                 STD_OFF
#endif
/* derive reentrant scheduling from split task */
#define DCM_TSK_REENTRANT_SCHEDULER_ENABLED                          DCM_SPLIT_TASKS_ENABLED

#if (DCM_TSK_REENTRANT_SCHEDULER_ENABLED == STD_ON)
# define DCM_TSK_TASK_COMPLEX_KILL_ENABLED                           STD_ON
#else
# define DCM_TSK_TASK_COMPLEX_KILL_ENABLED                           STD_OFF
#endif

#define DCM_TSK_TASK_FLAG_SUPPORT_ENABLED                            DCM_TSK_TASK_COMPLEX_KILL_ENABLED

#if (DCM_DEV_ERROR_DETECT == STD_ON) && \
    (DCM_STATE_SECURITY_EXT_SETTER_ENABLED == STD_ON)                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TF tx tf */
# define DCM_TSK_TRACING_ENABLED                                     STD_ON
#else
# define DCM_TSK_TRACING_ENABLED                                     STD_OFF
#endif
/*! Specifies whether at least one diagnostic service needs global data storage.
    Extend this list if needed when adding a new diagnostic service with post-request memory */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)
# define DCM_DIAG_SVC_CONTEXT_ENABLED                                STD_ON
#else
# define DCM_DIAG_SVC_CONTEXT_ENABLED                                STD_OFF
#endif

#define DCM_DIAG_SF_ONLY_SERVICE_ENABLED                             STD_ON

/*! Specifies whether the sequence check for services with sub-functions is active */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
# define DCM_DIAG_SF_SEQUENCE_CHECK_SUPPORT_ENABLED                  STD_ON
#else
# define DCM_DIAG_SF_SEQUENCE_CHECK_SUPPORT_ENABLED                  STD_OFF
#endif

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON) || \
    (DCM_DIAG_SVC_CONTEXT_ENABLED == STD_ON) || \
    (DCM_DIAG_SPECIFIC_CAUSE_CODE_ENABLED == STD_ON)
# define DCM_DIAG_CONTEXT_ENABLED                                    STD_ON
#else
# define DCM_DIAG_CONTEXT_ENABLED                                    STD_OFF
#endif
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/* Verify consistency between DCM and DEM configurations.
 * In case of error, please refer to the DCM technical reference (search for the error text) for more information and solution.
 */
# if defined(DEM_CFG_SUPPORT_DTR)                                                                                                                    /* COV_DCM_UNSUPPORTED_ERROR_DETECTION XF */
#  if (DEM_CFG_SUPPORT_DTR == STD_OFF)
#   error "DCM configured to handle OBD MIDs via DEM configuration, but no MID handling is done by DEM."
#  endif
# endif
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)
/* Verify consistency between DCM and DEM configurations.
 * In case of error, please refer to the DCM technical reference (search for the error text) for more information and solution.
 */
# if defined(DEM_CFG_SUPPORT_DTR)                                                                                                                    /* COV_DCM_UNSUPPORTED_ERROR_DETECTION XF */
#  if (DEM_CFG_SUPPORT_DTR == STD_ON)
#   error "DCM configured to handle OBD MIDs via DCM configuration, but MID handling is done by DEM."
#  endif
# endif
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_19_03_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_GETNEXTFILTEREDDTC_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED  == STD_ON ) || \
     (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON ) || \
     (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON )
#  define DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED                   STD_ON
# else
#  define DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED                   STD_OFF
# endif

# if (DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED == STD_ON) && \
     (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_OFF)
#  define DCM_SVC_19_COPY_LINEAR_DATA_ENABLED                        STD_ON
# else
#  define DCM_SVC_19_COPY_LINEAR_DATA_ENABLED                        STD_OFF
# endif

# if (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED  == STD_ON) || \
     (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON)
#  define DCM_SVC_19_RECORD_ITER_ENABLED                             STD_ON
# else
#  define DCM_SVC_19_RECORD_ITER_ENABLED                             STD_OFF
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_OCCUR_TIME_ENABLED       == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED  == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED      == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED   == STD_ON) || \
     (DCM_SVC_19_05_SUPPORT_ENABLED                   == STD_ON) || \
     (DCM_SVC_19_08_SUPPORT_ENABLED                   == STD_ON) || \
     (DCM_SVC_19_09_SUPPORT_ENABLED                   == STD_ON) || \
     (DCM_SVC_19_14_SUPPORT_ENABLED                   == STD_ON) || \
     (DCM_SVC_19_1A_SUPPORT_ENABLED                   == STD_ON) || \
     (DCM_SVC_19_42_SUPPORT_ENABLED                   == STD_ON) || \
     (DCM_SVC_19_55_SUPPORT_ENABLED                   == STD_ON) || \
     (DCM_SVC_19_56_SUPPORT_ENABLED                   == STD_ON)
#  define DCM_SVC_19_CHAINING_ENABLED                                STD_ON

#  if (DCM_DEMAPI_SVC_19_READ_DTC_BY_OCCUR_TIME_ENABLED == STD_ON) || \
      (DCM_SVC_19_05_SUPPORT_ENABLED             == STD_ON) || \
      (DCM_SVC_19_09_SUPPORT_ENABLED             == STD_ON)
#   define DCM_SVC_19_CHAIN_END_ENABLED                              STD_ON
#  else
#   define DCM_SVC_19_CHAIN_END_ENABLED                              STD_OFF
#  endif
# else
#  define DCM_SVC_19_CHAINING_ENABLED                                STD_OFF
#  define DCM_SVC_19_CHAIN_END_ENABLED                               STD_OFF
# endif

# if ((DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)) && \
     (DCM_DEM_API_421_ENABLED == STD_ON)
#  define DCM_SVC_19_ABSTRACT_RECORD_ITER_ENABLED                    STD_ON
# else
#  define DCM_SVC_19_ABSTRACT_RECORD_ITER_ENABLED                    STD_OFF
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/* Consistent configuration checks */
# if (DCM_NET_PERIODIC_TX_ENABLED == STD_OFF)
#  error "Service 0x2A is enabled, but no periodic messages have been configured for Dcm. Please, refer to the Dcm TechRef for SID 0x2A configuration aspect."
# endif
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
#  define DCM_SVC_2C_RACE_CONDITION_READ_ENABLED                     STD_ON
# else
#  define DCM_SVC_2C_RACE_CONDITION_READ_ENABLED                     STD_OFF
# endif

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
#  error "Service 0x2C is not allowed when any paged DID is configured!"
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */

#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)
/*! Memory manager operations function prototype descriptors */
# define DCM_MEMMGR_OP_READ                                          ((Dcm_MemMgrMemoryOpType)0u)
# if (DCM_MEMMGR_MEMOP_READ_ENABLED == STD_ON)
#  define DCM_MEMMGR_OP_WRITE                                        ((Dcm_MemMgrMemoryOpType)(DCM_MEMMGR_OP_READ + 1u))
# else
#  define DCM_MEMMGR_OP_WRITE                                        ((Dcm_MemMgrMemoryOpType)(DCM_MEMMGR_OP_READ + 0u))
# endif
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_FBLMGR_SUPPORT_ENABLED == STD_ON)
# define DCM_FBL_DOWNLOAD_STATE_IDLE                                 ((Dcm_FblMgrDownloadStateType)0x00u) /*!< Setup download */
# define DCM_FBL_DOWNLOAD_STATE_TRANSFER_DATA                        ((Dcm_FblMgrDownloadStateType)0x01u) /*!< Transfer and write the data to the memory */
#endif /* (DCM_FBLMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON)
# define DCM_OBDIDMGR_MAX_NUMBER_OF_IDS                              (6u) /*!< Maximum number of requested IDs */
#endif /* (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON) */
/*! ComM notification allowance states */
#define DCM_NET_COMM_ACTIVE                                          ((Dcm_NetActiveDiagnosticType)TRUE)  /*!< Do notify ComM for ActiveDiagnostics (default state) */
#define DCM_NET_COMM_NOT_ACTIVE                                      ((Dcm_NetActiveDiagnosticType)FALSE) /*!< Do NOT notify ComM for ActiveDiagnostics (sleep prevention by DCM is inhibited by application) */

/*! Network variant/non-variant configuration abstraction */
#define Dcm_PbCfgNetNumRxPduIds                                      (Dcm_NetCfgGetNumRxPduIds(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumTxPduIds                                      (Dcm_NetCfgGetNumTxPduIds(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetCanTpRxPduIdMin                                  (Dcm_NetCfgGetMinCanTpRxPduId(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetCanTpRxPduIdMax                                  (Dcm_NetCfgGetMaxCanTpRxPduId(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumCanRxPduIds                                   (Dcm_NetCfgGetNumCanRxPduIds(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumPerTxObjects                                  (Dcm_NetCfgGetNumPerTxObjects(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumConnections                                   (Dcm_NetCfgGetNumConnections(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumProtocols                                     (Dcm_NetCfgGetNumProtocols(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumComMChannels                                  (Dcm_NetCfgGetNumComMChannels(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumBuffers                                       (Dcm_NetCfgGetNumBuffers(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumTransportObjects                              (Dcm_NetCfgGetNumTranspObjects(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumAllComMChannels                               (Dcm_NetCfgGetNumAllComMChannels(DCM_VARMGR_ACTIVE_COMVAR))

#define Dcm_PbCfgNetRxPduInfo                                        (Dcm_NetCfgGetRxPduInfo(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetConnectionInfo                                   (Dcm_NetCfgGetConnectionInfo(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetProtocolInfo                                     (Dcm_NetCfgGetProtocolInfo(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetConnComMChannelMap                               (Dcm_NetCfgGetNetConnComMChannelMap(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNetworkHdlLookUp                                 (Dcm_NetCfgGetNetworkHdlLookUp(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetTxPdu2ConnMap                                    (Dcm_NetCfgGetTxPdu2ConnMap(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetPerTxPdu2RsrsMap                                 (Dcm_NetCfgGetPerTxPdu2RsrsMap(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetPerTxPduIdInfo                                   (Dcm_NetCfgGetPerTxPduIdInfo(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetComCtrlChannelListAll                            (Dcm_NetCfgGetComCtrlChannelListAll(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetAllComMChannelMap                                (Dcm_NetCfgGetNetAllComMChannelMap(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetCanTp2DcmRxPduIdMap                              (Dcm_NetCfgGetCanTp2DcmRxPduIdMap(DCM_VARMGR_ACTIVE_COMVAR))

#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
# define Dcm_PbRamNetBufferContext                                   (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.BufferContexts)
# define Dcm_PbRamNetTransportObject                                 (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.TranspObjects)
# define Dcm_PbRamNetComMContext                                     (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.ComMContexts)
# define Dcm_PbRamNetPeriodicTxObject                                (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.PeriodicTxObjects)
# define Dcm_PbRamNetConnHdl2TObjMap                                 (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.ConnHdl2TObjIdMap)
# define Dcm_PbRamNetComCtrlChannels                                 (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.ComCtrlChannels)
# define Dcm_PbCfgNetBufferInfo                                      (DCM_VARMGR_ACTIVE_ROMVAR.NetworkRom.BufferInfo)
#else
# define Dcm_PbRamNetBufferContext                                   (Dcm_SingletonContext.Network.BufferContext)
# define Dcm_PbRamNetTransportObject                                 (Dcm_SingletonContext.Network.TransportObject)
# define Dcm_PbRamNetComMContext                                     (Dcm_SingletonContext.Network.ComMContext)
# define Dcm_PbRamNetPeriodicTxObject                                (Dcm_SingletonContext.Network.PeriodicTxContext.TxObject)
# define Dcm_PbRamNetConnHdl2TObjMap                                 (Dcm_SingletonContext.Network.ConnHdl2TObjIdMap)
# define Dcm_PbRamNetComCtrlChannels                                 (Dcm_SingletonContext.Network.ComCtrlChannels)
# define Dcm_PbCfgNetBufferInfo                                      Dcm_CfgNetBufferInfo
#endif

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/*! Converts a Dcm related CanTp PduID to its corresponding DcmRxPduId */
# define Dcm_NetGetDcmRxPduIdOfCanTpPduId(canTpPduId)                (Dcm_PbCfgNetCanTp2DcmRxPduIdMap[(canTpPduId)-Dcm_PbCfgNetCanTpRxPduIdMin])     /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#else
# define Dcm_NetGetDcmRxPduIdOfCanTpPduId(canTpPduId)                /* not used */
#endif

/*! Retrieves diagnostic protocol specific P2 time justification */
#define Dcm_NetGetP2AdjTime(protocolIdx)                             (Dcm_NetGetProtObjOfProtId(protocolIdx)->SrvAdjTime.P2)                         /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Retrieves diagnostic protocol specific P2* time justification */
#define Dcm_NetGetP2StarAdjTime(protocolIdx)                         (Dcm_NetGetProtObjOfProtId(protocolIdx)->SrvAdjTime.P2Star)                     /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

/*! USDT transport object states */
#define DCM_NET_TOBJ_STATE_FREE                                      ((Dcm_NetTransportObjectStateType)0x00u)  /*!< Free to be used */
#define DCM_NET_TOBJ_STATE_ONRX                                      ((Dcm_NetTransportObjectStateType)0x01u)  /*!< USDT reception in progress */
#define DCM_NET_TOBJ_STATE_RX_END                                    ((Dcm_NetTransportObjectStateType)0x02u)  /*!< USDT reception already finished */
#define DCM_NET_TOBJ_STATE_PREPTX                                    ((Dcm_NetTransportObjectStateType)0x04u)  /*!< Ready for USDT transmission */
#define DCM_NET_TOBJ_STATE_ONTX                                      ((Dcm_NetTransportObjectStateType)0x08u)  /*!< USDT transmission in progress */
#define DCM_NET_TOBJ_STATE_READY                                     ((Dcm_NetTransportObjectStateType)0x10u)  /*!< Transmission (Rx/Tx) finished but transport object still in use */
#define DCM_NET_TOBJ_STATE_RESERVED                                  ((Dcm_NetTransportObjectStateType)0x20u)  /*!< Transport object is allocated, but not yet in use (transmission) */

/*! USDT transport object flags */
#define DCM_NET_TOBJ_FLAG_NONE                                       ((Dcm_NetTransportObjectFlagType)0x0000u)  /*!< No flags set */
#define DCM_NET_TOBJ_FLAG_INTERNAL                                   ((Dcm_NetTransportObjectFlagType)0x0001u)  /*!< The transport object is used for internal (virtual) request (e.g. RoE) */
#define DCM_NET_TOBJ_FLAG_COPYHEAD                                   ((Dcm_NetTransportObjectFlagType)0x0002u)  /*!< The diagnostic request head shall be copied into a temporary buffer */
#define DCM_NET_TOBJ_FLAG_BUSY                                       ((Dcm_NetTransportObjectFlagType)0x0004u)  /*!< Current diagnostic request reception is a pseudo-parallel one */
#define DCM_NET_TOBJ_FLAG_CANCELED                                   ((Dcm_NetTransportObjectFlagType)0x0008u)  /*!< Current message transmission (Rx/Tx) was canceled */
#define DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ                               ((Dcm_NetTransportObjectFlagType)0x0010u)  /*!< RCR-RP state: just requested to be sent */
#define DCM_NET_TOBJ_FLAG_RCRRP_ON_TX                                ((Dcm_NetTransportObjectFlagType)0x0020u)  /*!< RCR-RP state: currently on transmission */
#define DCM_NET_TOBJ_FLAG_RCRRP_SENT                                 ((Dcm_NetTransportObjectFlagType)0x0040u)  /*!< RCR-RP state: at least once has been sent */
#define DCM_NET_TOBJ_FLAG_RCRRP_TYPE_APPL                            ((Dcm_NetTransportObjectFlagType)0x0080u)  /*!< RCR-RP state: current one was triggered by the application */
#define DCM_NET_TOBJ_FLAG_OBSOLETE                                   ((Dcm_NetTransportObjectFlagType)0x0100u)  /*!< Transport object is obsolete and shall be canceled at later time. The difference to FLAG_CANCELED is that the ongoing transmission is not affected */
#define DCM_NET_TOBJ_FLAG_IGNORE                                     ((Dcm_NetTransportObjectFlagType)0x0200u)  /*!< Transport object shall not restart S3 and Keep-Alive Timers */

/*! USDT transport object response types */
#define DCM_NET_TOBJ_RESTYPE_NONE                                    ((Dcm_NetResponseType)0u)  /*!< No response is ongoing */
#define DCM_NET_TOBJ_RESTYPE_LINEAR                                  ((Dcm_NetResponseType)1u)  /*!< Final response (linear buffer) */
#define DCM_NET_TOBJ_RESTYPE_PAGED                                   ((Dcm_NetResponseType)2u)  /*!< Final response (paged-buffer) */
#define DCM_NET_TOBJ_RESTYPE_RCRRP                                   ((Dcm_NetResponseType)3u)  /*!< RCR-RP response */
#define DCM_NET_TOBJ_RESTYPE_UNSOLICITED                             ((Dcm_NetResponseType)4u)  /*!< Unsolicited (response without request) (e.g. FBL final response after power on/reset) */
#define DCM_NET_TOBJ_RESTYPE_SIMPLE                                  ((Dcm_NetResponseType)5u)  /*!< Simply respond (without processing) e.g. final negative response NRC 0x21 for pseudo parallel client handling or protocol switch rejection */

/*! Diagnostic client USDT connection properties */
#define DCM_NET_CONN_PROP_NONE                                       ((Dcm_CfgNetConnPropertiesType)0x00u)  /*!< Nothing special */
#define DCM_NET_CONN_PROP_TX_ON_FUNC_RX                              ((Dcm_CfgNetConnPropertiesType)0x01u)  /*!< No response to be sent on functional requests over this connection */
#define DCM_NET_CONN_PROP_NO_MAIN_TX                                 ((Dcm_CfgNetConnPropertiesType)0x02u)  /*!< The USDT connection does not contain a PduRTxPduId */

#define DCM_NET_INVALID_CONNHDL                                      ((Dcm_CfgNetNetIdRefMemType)Dcm_PbCfgNetNumConnections)
#define DCM_NET_INVALID_TOBJID                                       ((Dcm_CfgNetTObjHandleMemType)Dcm_PbCfgNetNumTransportObjects)
#define DCM_NET_INVALID_PROTID                                       ((Dcm_NetProtRefMemType)Dcm_PbCfgNetNumProtocols)

/*! State definitions for periodic transport object */
#define DCM_NET_PERIODIC_TX_STATE_FREE                               ((Dcm_NetPerTxObjStateMemType)0)
#define DCM_NET_PERIODIC_TX_STATE_RESERVED                           ((Dcm_NetPerTxObjStateMemType)1)
#define DCM_NET_PERIODIC_TX_STATE_QUEUED                             ((Dcm_NetPerTxObjStateMemType)2)
#define DCM_NET_PERIODIC_TX_STATE_ONTX                               ((Dcm_NetPerTxObjStateMemType)3)

#define DCM_NET_INVALID_PTXOBJ_HANDLE                                ((Dcm_CfgNetPTxObjHandleMemType)Dcm_PbCfgNetNumPerTxObjects)

/*! AR 4.1.2+ PduR API argument values adaption */
#define DCM_NET_ARENV_NTFRSLT_OK                                     E_OK
#define DCM_NET_ARENV_NTFRSLT_NOT_OK                                 E_NOT_OK
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
# define DCM_PAGEDBUFFER_STATE_INACTIVE                              (Dcm_PagedBufferStateType)0x00u /*!< No paged-buffer transmission in progress */
# define DCM_PAGEDBUFFER_STATE_ACTIVATED                             (Dcm_PagedBufferStateType)0x01u /*!< Paged-buffer transmission activated, but not yet passed to the PduR */
# define DCM_PAGEDBUFFER_STATE_CANCELED                              (Dcm_PagedBufferStateType)0x02u /*!< Paged-buffer transmission terminated prior passing it to the PduR */
# define DCM_PAGEDBUFFER_STATE_ONTX                                  (Dcm_PagedBufferStateType)0x03u /*!< Paged-buffer transmission ongoing (passed to the PduR) */

# define DCM_PAGEDBUFFER_ALL_DATA_PROVIDED                           (Dcm_PagedBufferDataProvisionStateType)0x00u /*!< All data provided */
# define DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED                          (Dcm_PagedBufferDataProvisionStateType)0x01u /*!< Already some data provided */
# define DCM_PAGEDBUFFER_WAIT_FOR_DATA                               (Dcm_PagedBufferDataProvisionStateType)0x02u /*!< Waiting for data provision */
#endif /* (DCM_PAGED_BUFFER_ENABLED == STD_ON) */
#define DCM_REPEATER_USER_NONE                                       ((Dcm_RepeaterUserType)0)
#define DCM_REPEATER_USER_DEM                                        ((Dcm_RepeaterUserType)1)
#define DCM_REPEATER_USER_DIDMGR                                     ((Dcm_RepeaterUserType)2)
#define DCM_REPEATER_USER_AUTHENTICATION                             ((Dcm_RepeaterUserType)3)
/*! Timer thread ability types */
#define DCM_TMR_ATR_THREAD_SINGLE                                    ((Dcm_TmrTimerAttributeType)0x00u) /*!< Timer does not support multi threading */
#define DCM_TMR_ATR_THREAD_MULTI                                     ((Dcm_TmrTimerAttributeType)0x01u) /*!< Timer supports multi threading */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
# define DCM_DIDMGR_RANGELOOKUPRSLT_NOMATCH                          ((Dcm_DidMgrRangeLookUpResultType)0x00)
# define DCM_DIDMGR_RANGELOOKUPRSLT_MATCHED_SUPPORTED                ((Dcm_DidMgrRangeLookUpResultType)0x01)
# define DCM_DIDMGR_RANGELOOKUPRSLT_MATCHED_UNSUPPORTED              ((Dcm_DidMgrRangeLookUpResultType)0x02)
# define DCM_DIDMGR_RANGELOOKUPRSLT_MATCHED_ANY                      ((Dcm_DidMgrRangeLookUpResultType)(DCM_DIDMGR_RANGELOOKUPRSLT_MATCHED_SUPPORTED | DCM_DIDMGR_RANGELOOKUPRSLT_MATCHED_UNSUPPORTED))
# define DCM_DIDMGR_RANGELOOKUPRSLT_PENDING                          ((Dcm_DidMgrRangeLookUpResultType)0x04)

/*! DID Service types */
# define DCM_DIDMGR_SVC_NONE                                         (0x00u)
# define DCM_DIDMGR_SVC_READ                                         (0x22u)
# define DCM_DIDMGR_SVC_WRITE                                        (0x2Eu)
# define DCM_DIDMGR_SVC_IOCTRL                                       (0x2Fu)
# define DCM_DIDMGR_SVC_SCALING                                      (0x24u)
# define DCM_DIDMGR_SVC_DEFINE                                       (0x2Cu)

/* Service port operation classes */
# define DCM_DIDMGR_OPCLS_READ_RANGE                                 ((Dcm_DidMgrOpClassType)0x0000)
# define DCM_DIDMGR_OPCLS_READ_SYNC                                  ((Dcm_DidMgrOpClassType)0x0001)
# define DCM_DIDMGR_OPCLS_READ_ASYNC                                 ((Dcm_DidMgrOpClassType)0x0002)
# define DCM_DIDMGR_OPCLS_READ_PAGED                                 ((Dcm_DidMgrOpClassType)0x0003)
# define DCM_DIDMGR_OPCLS_READ_VID                                   ((Dcm_DidMgrOpClassType)0x0004)
# define DCM_DIDMGR_OPCLS_READ_SR                                    ((Dcm_DidMgrOpClassType)0x0005)
# define DCM_DIDMGR_OPCLS_READ_GAP                                   ((Dcm_DidMgrOpClassType)0x0006)
# define DCM_DIDMGR_OPCLS_READ_WRAPPER_ASYNC                         ((Dcm_DidMgrOpClassType)0x0007)
# define DCM_DIDMGR_OPCLS_READ_WRAPPER_SYNC                          ((Dcm_DidMgrOpClassType)0x0008)

# define DCM_DIDMGR_OPCLS_READLENGTH_RANGE                           ((Dcm_DidMgrOpClassType)0x0100)
# define DCM_DIDMGR_OPCLS_READLENGTH_SYNC                            ((Dcm_DidMgrOpClassType)0x0101)
# define DCM_DIDMGR_OPCLS_READLENGTH_ASYNC                           ((Dcm_DidMgrOpClassType)0x0102)

# define DCM_DIDMGR_OPCLS_READCHK_COND_SYNC                          ((Dcm_DidMgrOpClassType)0x0200)
# define DCM_DIDMGR_OPCLS_READCHK_COND_ASYNC                         ((Dcm_DidMgrOpClassType)0x0201)

# define DCM_DIDMGR_OPCLS_WRITE_RANGE                                ((Dcm_DidMgrOpClassType)0x1000)
# define DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_ERROR                 ((Dcm_DidMgrOpClassType)0x1001)
# define DCM_DIDMGR_OPCLS_WRITE_NLEN_ASYNC_NRES_ERROR                ((Dcm_DidMgrOpClassType)0x1002)
# define DCM_DIDMGR_OPCLS_WRITE_LEN_SYNC_NRES_ERROR                  ((Dcm_DidMgrOpClassType)0x1003)
# define DCM_DIDMGR_OPCLS_WRITE_LEN_ASYNC_NRES_ERROR                 ((Dcm_DidMgrOpClassType)0x1004)
# define DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_NERROR                ((Dcm_DidMgrOpClassType)0x1005)
# define DCM_DIDMGR_OPCLS_WRITE_GAP                                  ((Dcm_DidMgrOpClassType)0x1006)

# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_NCEMR_ERROR         ((Dcm_DidMgrOpClassType)0x2000)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_NCEMR_ERROR          ((Dcm_DidMgrOpClassType)0x2001)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_NCEMR_ERROR           ((Dcm_DidMgrOpClassType)0x2002)
# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_NCEMR_ERROR        ((Dcm_DidMgrOpClassType)0x2003)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_NCEMR_ERROR         ((Dcm_DidMgrOpClassType)0x2004)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_NCEMR_ERROR          ((Dcm_DidMgrOpClassType)0x2005)

# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR8_ERROR         ((Dcm_DidMgrOpClassType)0x2006)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR8_ERROR          ((Dcm_DidMgrOpClassType)0x2007)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR8_ERROR           ((Dcm_DidMgrOpClassType)0x2008)
# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR8_ERROR        ((Dcm_DidMgrOpClassType)0x2009)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR8_ERROR         ((Dcm_DidMgrOpClassType)0x200A)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR8_ERROR          ((Dcm_DidMgrOpClassType)0x200B)

# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR16_ERROR        ((Dcm_DidMgrOpClassType)0x200C)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR16_ERROR         ((Dcm_DidMgrOpClassType)0x200D)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR16_ERROR          ((Dcm_DidMgrOpClassType)0x200E)
# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR16_ERROR       ((Dcm_DidMgrOpClassType)0x200F)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR16_ERROR        ((Dcm_DidMgrOpClassType)0x2010)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR16_ERROR         ((Dcm_DidMgrOpClassType)0x2011)

# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR32_ERROR        ((Dcm_DidMgrOpClassType)0x2012)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR32_ERROR         ((Dcm_DidMgrOpClassType)0x2013)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR32_ERROR          ((Dcm_DidMgrOpClassType)0x2014)
# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR32_ERROR       ((Dcm_DidMgrOpClassType)0x2015)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR32_ERROR        ((Dcm_DidMgrOpClassType)0x2016)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR32_ERROR         ((Dcm_DidMgrOpClassType)0x2017)

# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMRN_ERROR         ((Dcm_DidMgrOpClassType)0x2018)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMRN_ERROR          ((Dcm_DidMgrOpClassType)0x2019)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMRN_ERROR           ((Dcm_DidMgrOpClassType)0x201A)
# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMRN_ERROR        ((Dcm_DidMgrOpClassType)0x201B)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMRN_ERROR         ((Dcm_DidMgrOpClassType)0x201C)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMRN_ERROR          ((Dcm_DidMgrOpClassType)0x201D)

# define DCM_DIDMGR_OPCLS_IO_GAP                                     ((Dcm_DidMgrOpClassType)0x201E)

# define DCM_DIDMGR_OPCLS_GETSCALING_SYNC                            ((Dcm_DidMgrOpClassType)0x3000)
# define DCM_DIDMGR_OPCLS_GETSCALING_ASYNC                           ((Dcm_DidMgrOpClassType)0x3001)

# define DCM_DIDMGR_OPCLS_DEFINE                                     ((Dcm_DidMgrOpClassType)0x4000)

# define DCM_DIDMGR_OPCLS_ISDIDAVAILABLE                             ((Dcm_DidMgrOpClassType)0x5400)

# define DCM_DIDMGR_IO_CEMR_HANDLING_NO                              ((Dcm_DidMgrIoDidCemrHandlingType)0)
# define DCM_DIDMGR_IO_CEMR_HANDLING_INTERNAL                        ((Dcm_DidMgrIoDidCemrHandlingType)1)
# define DCM_DIDMGR_IO_CEMR_HANDLING_EXTERNAL                        ((Dcm_DidMgrIoDidCemrHandlingType)2)

# define DCM_DIDMGR_LOOKUP_STATE_DIDRANGE                            ((Dcm_DidMgrDidLookUpStateType)0)
# define DCM_DIDMGR_LOOKUP_STATE_CONCRETEDID                         ((Dcm_DidMgrDidLookUpStateType)1)
# define DCM_DIDMGR_LOOKUP_STATE_DIDFILTER_EXTERN                    ((Dcm_DidMgrDidLookUpStateType)2)
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)
/*! RID operation types */
# define DCM_RIDMGR_OP_NONE                                          ((Dcm_RidMgrOpType)0x00u)
# define DCM_RIDMGR_OP_START                                         ((Dcm_RidMgrOpType)0x01u)
# define DCM_RIDMGR_OP_STOP                                          ((Dcm_RidMgrOpType)0x02u)
# define DCM_RIDMGR_OP_REQRSLTS                                      ((Dcm_RidMgrOpType)0x04u)

/*! Routine operations function prototype descriptors */
# define DCM_RIDMGR_OPTYPE_NONE                                      ((Dcm_RidMgrOpCallType)0u)
# define DCM_RIDMGR_OPTYPE_REQ                                       ((Dcm_RidMgrOpCallType)1u)
# define DCM_RIDMGR_OPTYPE_REQ_RES                                   ((Dcm_RidMgrOpCallType)2u)
# define DCM_RIDMGR_OPTYPE_RES                                       ((Dcm_RidMgrOpCallType)3u)
# define DCM_RIDMGR_OPTYPE_REQ_DYNLEN                                ((Dcm_RidMgrOpCallType)4u)
# define DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES                            ((Dcm_RidMgrOpCallType)5u)
# define DCM_RIDMGR_OPTYPE_RES_DYNLEN                                ((Dcm_RidMgrOpCallType)6u)
# define DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES_DYNLEN                     ((Dcm_RidMgrOpCallType)7u)
# define DCM_RIDMGR_OPTYPE_REQ_RES_DYNLEN                            ((Dcm_RidMgrOpCallType)8u)
# define DCM_RIDMGR_OPTYPE_WRAPPER                                   ((Dcm_RidMgrOpCallType)9u)

# define DCM_RIDMGR_ROUTINEINFOBYTE_IDX                              ((Dcm_DiagBufferIndexType)3u) /*!< Index of routine info byte in response message (skip SF and RID) */

/*! Routine input and output parameter integrity descriptors */
# define DCM_RIDMGR_INTEGRITY_NONE                                   ((Dcm_RidMgrParamIntegrityType)0u)
# define DCM_RIDMGR_INTEGRITY_IN                                     ((Dcm_RidMgrParamIntegrityType)1u)
# define DCM_RIDMGR_INTEGRITY_OUT                                    ((Dcm_RidMgrParamIntegrityType)2u)
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)
/*! OBD DTC manager processing steps */
# define DCM_OBDDTCMGR_PROGRESS_INITAL                               ((Dcm_RepeaterProgressType)0)
# define DCM_OBDDTCMGR_PROGRESS_GETNUMFLTRDDTC                       ((Dcm_RepeaterProgressType)1)
# define DCM_OBDDTCMGR_PROGRESS_COPYLINEARDATA                       ((Dcm_RepeaterProgressType)2)
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
/*! Task priorities */
#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
# define DCM_TSK_PRIO_NONE                                           /* must not be used */       /*!< Always use a concrete priority! */
# define DCM_TSK_PRIO_LOW                                            ((Dcm_TskTaskPrioMemType)0)  /*!< Low priority - can be interrupted by higher priority tasks and ISRs */
# define DCM_TSK_PRIO_HIGH                                           ((Dcm_TskTaskPrioMemType)1)  /*!< High priority - cannot be interrupted by any other tasks, only ISRs */
# define DCM_TSK_NUM_PRIOS                                           ((Dcm_TskTaskPrioMemType)2)  /*!< The number of different task priorities */
#else
# define DCM_TSK_PRIO_NONE                                           ((Dcm_TskTaskPrioMemType)0)  /*!< Default priority - to be used only in case no task-splitting is used */
# define DCM_TSK_PRIO_LOW                                            DCM_TSK_PRIO_NONE            /*!< Low priority - can be interrupted by ISRs */
# define DCM_TSK_PRIO_HIGH                                           DCM_TSK_PRIO_NONE            /*!< High priority - shares the same priority as low */
# define DCM_TSK_NUM_PRIOS                                           ((Dcm_TskTaskPrioMemType)1)  /*!< The number of different task priorities */
#endif

/*! Task event representing that no events are available */
#define DCM_TSK_EV_NONE                                              ((Dcm_TskTaskEvMemType)0x00u)

/* Task setup informations */
/*! Task execution types */
#define DCM_TSK_ATR_EXEC_ONCE                                        ((Dcm_TskTaskAttributeType)0x00u)  /*!< Task will be executed only once per Dcm_MainFunction() call */
#define DCM_TSK_ATR_EXEC_MULTI                                       ((Dcm_TskTaskAttributeType)0x01u)  /*!< Task can be executed multiple times per Dcm_MainFunction() call if still has any active events */

/*! Task termination ability types */
#define DCM_TSK_ATR_KILL_NEVER                                       ((Dcm_TskTaskAttributeType)0x00u)  /*!< Task can never be terminated on a kill-task signal */
#define DCM_TSK_ATR_KILL_ALWAYS                                      ((Dcm_TskTaskAttributeType)0x02u)  /*!< Task will be terminated on a kill task signal */

/*! Task thread ability types */
#define DCM_TSK_ATR_THREAD_SINGLE                                    ((Dcm_TskTaskAttributeType)0x00u) /*!< Task can not support multi threading */
#define DCM_TSK_ATR_THREAD_MULTI                                     ((Dcm_TskTaskAttributeType)0x04u) /*!< Task can support multi threading */

/*! Task runtime status flags */
#define DCM_TSK_TASK_FLAG_NONE                                       ((Dcm_TskTaskFlagType)0x00u) /*!< Task is in normal mode (running) */
#define DCM_TSK_TASK_FLAG_KILLED                                     ((Dcm_TskTaskFlagType)0x01u) /*!< Task is in terminated mode (no more events can be set) */
/*! Network to diagnostic variant bridge abstraction */
#if (DCM_VARMGR_MODE_POSTBUILD_ANY_ENABLED == STD_ON) && (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
# define Dcm_PbCfgDiagSvcId2ProtMap                                  (DCM_VARMGR_ACTIVE_BRIDGEVAR.Svc2ProtocolMap)
#else
# define Dcm_PbCfgDiagSvcId2ProtMap                                  Dcm_CfgDiagSvcId2ProtMap
#endif

/*! Diagnostic entity evaluation level */
#define DCM_DIAG_CHK_LVL_SERVICE_ID                                  ((Dcm_DiagCheckLvlType)0u) /*!< Evaluation on diagnostic service ID level */
#define DCM_DIAG_CHK_LVL_PARAMETER                                   ((Dcm_DiagCheckLvlType)1u) /*!< Evaluation on diagnostic parameter ID level */
#define DCM_DIAG_CHK_LVL_SUBFUNC                                     ((Dcm_DiagCheckLvlType)2u) /*!< Evaluation on diagnostic sub-function ID level */

/*! Total number of diagnostic entities that can be verified (use always the one with highest ID as reference) */
#define DCM_DIAG_NUM_CHK_LVLS                                        (DCM_DIAG_CHK_LVL_SUBFUNC + 1u)

/*! Bitmap encoding for the enumerator values below (used to build the AR standard confirmation status values e.g. DCM_RES_POS_OK !) */
#define DCM_DIAG_RES_ANY_OK                                          ((Dcm_ConfirmationStatusType)0x00u) /*!< The response (positive/negative) was successfully sent */
#define DCM_DIAG_RES_ANY_NOT_OK                                      ((Dcm_ConfirmationStatusType)0x01u) /*!< The response (positive/negative) transmission failed */
#define DCM_DIAG_RES_POS_ANY                                         ((Dcm_ConfirmationStatusType)0x00u) /*!< It is a positive response */
#define DCM_DIAG_RES_NEG_ANY                                         ((Dcm_ConfirmationStatusType)0x02u) /*!< It is a negative response */

/*! Diagnostic kernel application notification levels reached during diagnostic service processing.
    This levels are used to determine which finalization callouts shall be performed later (e.g. service execution confirmation, post-handlers etc.) */
#define DCM_DIAG_APPL_NOTIFICATION_NONE                              ((Dcm_DiagApplNotificationType)0x00u) /*!< No application call was made */
#define DCM_DIAG_APPL_NOTIFICATION_OEM                               ((Dcm_DiagApplNotificationType)0x01u) /*!< Manufacturer specific request indication(s) reached (Xxx_Indication()) */
#define DCM_DIAG_APPL_NOTIFICATION_SYS                               ((Dcm_DiagApplNotificationType)0x02u) /*!< System supplier specific request indication(s) reached (Xxx_Indication()) */
#define DCM_DIAG_APPL_NOTIFICATION_CONFIRMATION                      ((Dcm_DiagApplNotificationType)0x04u) /*!< Call the DCM confirmation after service processing */
#define DCM_DIAG_APPL_NOTIFICATION_POSTPROCESSOR                     ((Dcm_DiagApplNotificationType)0x08u) /*!< Call the post processor function */
#define DCM_DIAG_APPL_NOTIFICATION_FASTPOSTPROCESSOR                 ((Dcm_DiagApplNotificationType)0x10u) /*!< Call the fast post processor function */


/*! Diagnostic kernel request queued flags. These are used to keep track of any overlapping diagnostic request in processing with a new one just won a request prioritization
    Especially in case of split-task this mechanism provides a look-ahead whether a new request is already queue to be processed within the low-priority Dcm_DiagTaskWorker() */
#define DCM_DIAG_QUEUE_FLAG_NONE                                     ((Dcm_DiagProcessorFlagType)0x00u) /*!< There is no diagnostic request queued to be processed */
#define DCM_DIAG_QUEUE_FLAG_IS_WAITING                               ((Dcm_DiagProcessorFlagType)0x01u) /*!< There is already a diagnostic request queued (waiting) to be processed */
#define DCM_DIAG_QUEUE_FLAG_IS_ACTIVE                                ((Dcm_DiagProcessorFlagType)0x02u) /*!< There diagnostic request in started processing */
#define DCM_DIAG_QUEUE_FLAG_IS_CANCELING                             ((Dcm_DiagProcessorFlagType)0x04u) /*!< There is a protocol change in progress */

/*! Diagnostic service specific properties */
#define DCM_DIAG_SVC_CFG_PROP_HAS_SUBFUNC                            ((DcmCfg_DiagServicePropertiesType)0x01u) /*!< Has a sub-function parameter */
#define DCM_DIAG_SVC_CFG_PROP_CALL_POST_HDLR_ALWAYS                  ((DcmCfg_DiagServicePropertiesType)0x02u) /*!< Requires the post-handler (Dcm_ServiceXXPostHandler()) to be called always once the service evaluation has started */
#define DCM_DIAG_SVC_CFG_PROP_CALL_SVC_DISPATCHER                    ((DcmCfg_DiagServicePropertiesType)0x04u) /*!< Requires a service dispatching (internal and external service processing) */

/*! Getter for the diagnostic session specific P2 timings */
#define Dcm_DiagGetP2Time(sesStateIdx)                               (Dcm_CfgStateSessionInfo[(sesStateIdx)].P2ServerTime.P2)                        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_DiagGetP2StarTime(sesStateIdx)                           (Dcm_CfgStateSessionInfo[(sesStateIdx)].P2ServerTime.P2Star)                    /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

/*! Specifies the maximum buffer size required for the final unsolicited response (i.e. after ECU re-programming)
  Note: Currently the longest possible response is for SID 0x10, that has: SID*1 + SF*1 + P2*2 + P2Ex*2 = 6 Bytes */
#define DCM_DIAG_START_UP_FBL_RES_SIZE                               6u

#define Dcm_DiagGetDemClientId(protocolIdx)                          (Dcm_NetGetProtObjOfProtId(protocolIdx)->DemClientId)                           /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Variant management optimization abstraction */
#define DCM_VARMGR_ACTIVE_COMVAR                                     (Dcm_SingletonContext.VarMgr.ActiveComVariant)      /*!< Substitution for COM-criteria storage */
#define DCM_VARMGR_ACTIVE_BRIDGEVAR                                  (Dcm_SingletonContext.VarMgr.ActiveBridgeVariant)   /*!< Substitution for COM-to-CFG bridge storage */
#define DCM_VARMGR_ACTIVE_RAMVAR                                     (Dcm_SingletonContext.VarMgr.ActiveRamVariant)      /*!< Substitution for PBL RAM storage */
#define DCM_VARMGR_ACTIVE_ROMVAR                                     (Dcm_SingletonContext.VarMgr.ActiveRomVariant)      /*!< Substitution for PBL ROM storage */
#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
# define Dcm_PbCfgVarMgrDiagVariantFilter                            (DCM_VARMGR_ACTIVE_ROMVAR.DiagRom.VariantFilter)
#else
# define Dcm_PbCfgVarMgrDiagVariantFilter                            Dcm_CfgVarMgrVariantTable
#endif
#if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC01_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
#endif /* (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)
/*! Service 0x02 processing steps */
# define DCM_SVC02_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
#endif /* (DCM_SVC_02_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_03_SUPPORT_ENABLED == STD_ON)
/*! Service 0x03 processing steps */
# define DCM_SVC03_PROGRESS_SETDTCFILTER                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC03_PROGRESS_READDTCBYSTATUSMASK                      ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
#endif /* (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)
/*! Service 0x04 processing steps */
# define DCM_SVC04_PROGRESS_REPEATERPROXY_SELECT_DTC                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC04_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/*! Service 0x06 processing step */
# define DCM_SVC06_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)
# define DCM_SVC06_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_07_SUPPORT_ENABLED == STD_ON)
/*! Service 0x07 processing steps */
# define DCM_SVC07_PROGRESS_SETDTCFILTER                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC07_PROGRESS_READDTCBYSTATUSMASK                      ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
#endif /* (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_08_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC08_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
#endif /* (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC09_PROGRESS_CHECKACCESS                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC09_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON)
/*! Service 0x0A processing steps */
# define DCM_SVC0A_PROGRESS_SETDTCFILTER                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC0A_PROGRESS_READDTCBYSTATUSMASK                      ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
#endif /* (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) */
/*! Service 0x10 processing steps */
#define DCM_SVC10_PROGRESS_CHECK_ACCESS                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
#define DCM_SVC10_PROGRESS_TRIGGER_RESET                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
#define DCM_SVC10_PROGRESS_WAIT_RESET_ACK                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2u))
#define DCM_SVC10_PROGRESS_WAIT_RCRRP_ACK                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3u))
#define DCM_SVC10_PROGRESS_SET_PRGCOND                               ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 4u))
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
/*! Service 0x11 processing steps */
# define DCM_SVC11_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC11_PROGRESS_ECURST_WAITFORACK                        ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
# define DCM_SVC11_RAPPWRDWN_WAITFORACK                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2u))
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
/*! Service 0x14 processing steps */
# define DCM_SVC14_PROGRESS_REPEATERPROXY_SELECT_DTC                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC14_PROGRESS_REPEATERPROXY_CHECK_SELECTION_RESULT     ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
# define DCM_SVC14_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2u))
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/*! Service 0x19 processing steps */
# define DCM_SVC19_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC19_PROGRESS_UTI_COPYLINEARDATA                       ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))

# define DCM_SVC19_PROGRESS_DEMCHAIN_SELECT_DTC                      ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 10u))
# define DCM_SVC19_PROGRESS_DEMCHAIN_DISABLERECORDUPDATE             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 11u))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETSTATUSOFDTC                  ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 12u))
# define DCM_SVC19_PROGRESS_DEMCHAIN_SELECTFFREC                     ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 13u))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETSIZEOFFFREC                  ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 14u))
# define DCM_SVC19_PROGRESS_DEMCHAIN_SELECTEXTDATAREC                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 15u))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETSIZEOFEXTDATAREC             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 16u))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC                  ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 17u))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDSEVERITY            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 18u))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETSEVERITYOFDTC                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 19u))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETFUNCUNITOFDTC                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 20u))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDDTC                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 21u))
# define DCM_SVC19_PROGRESS_DEMCHAIN_PUTNUMFLTRDDTC                  ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 22u))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDFDC                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 23u))
# define DCM_SVC19_PROGRESS_DEMCHAIN_WWHOBD_GETNEXTFLTRDSEVERITY     ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 24u))

# define DCM_SVC19_PROGRESS_CHAIN_END                                DCM_REPEATER_PROGRESS_USERS_LAST /*!< Service 0x19 final processing step */

/*! Service 0x19 paged-buffer updater dispatching items IDs */
# define DCM_SVC_19_UPDATE_GET_NXT_FLTRD_RECORD                      ((Dcm_Svc19SubUpdaterType)0u)
# define DCM_SVC_19_UPDATE_GET_NXT_FLTRD_SEVERITY                    ((Dcm_Svc19SubUpdaterType)1u)
# define DCM_SVC_19_UPDATE_GET_NXT_FLTRD_FDC                         ((Dcm_Svc19SubUpdaterType)2u)
# define DCM_SVC_19_UPDATE_GET_NXT_FLTRD_SEVERITY_WWHOBD             ((Dcm_Svc19SubUpdaterType)3u)
# define DCM_SVC_19_UPDATE_GET_NXT_FLTRD_DTC                         ((Dcm_Svc19SubUpdaterType)4u)
# define DCM_SVC_19_UPDATE_GET_EXT_RECORD                            ((Dcm_Svc19SubUpdaterType)5u)
# define DCM_SVC_19_UPDATE_SELECT_FF_RECORD                          ((Dcm_Svc19SubUpdaterType)6u)
# define DCM_SVC_19_UPDATE_GET_FF_RECORD                             ((Dcm_Svc19SubUpdaterType)7u)
# define DCM_SVC_19_UPDATE_GET_NXT_FLTRD_EXT_RECORD                  ((Dcm_Svc19SubUpdaterType)8u)
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/*! List of DEM filter configurations */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_01                           ((Dcm_Svc19DemSetFilterClassType)0u) /*!< For SF 0x01, 0x02, 0x14, 0x0A */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_02                           ((Dcm_Svc19DemSetFilterClassType)1u) /*!< For SF 0x07, 0x08 */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_03                           ((Dcm_Svc19DemSetFilterClassType)2u) /*!< For SF 0x11, 0x0F */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_04                           ((Dcm_Svc19DemSetFilterClassType)3u) /*!< For SF 0x12, 0x13 */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_05                           ((Dcm_Svc19DemSetFilterClassType)4u) /*!< For SF 0x15, 0x55 */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_06                           ((Dcm_Svc19DemSetFilterClassType)5u) /*!< For SF 0x17 */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_07                           ((Dcm_Svc19DemSetFilterClassType)6u) /*!< For SF 0x42 */

/*! Total number of DEM filter configurations */
# define DCM_SVC_19_DEM_SETFILTER_NUM_CLASSES                        (DCM_SVC_19_DEM_SETFILTER_CLASS_07+1u)

/*! API Dcm_Svc19UtiReportDtcByStatusMaskData DTC status mask usage parametrization */
# define DCM_SVC_19_USE_MASK_REQ                                     ((Dcm_Svc19DemSetFilterMaskUsageType)0u) /*!< Extract and use the mask from request data */
# define DCM_SVC_19_USE_MASK_ALL                                     ((Dcm_Svc19DemSetFilterMaskUsageType)1u) /*!< Do report all supported DTCs */

/*! DTC extended record number wildcard types */
# define DCM_SVC_19_RECNUM_ALL                                       ((uint8)0xFFu) /*!< All supported extended data records */
# define DCM_SVC_19_RECNUM_OBD_ALL                                   ((uint8)0xFEu) /*!< Report only OBD related extended data records */
/*! DTC (extended/freeze frame) record list end marker (0xFF is not a valid single record ID) */
# define DCM_SVC_19_RECLIST_END                                      ((uint8)0xFFu)

/*! Abstract DTC record iterator result values */
# define DCM_SVC19_UTI_REC_ITER_RSLT_OK                              ((Dcm_Svc19UtiRecordIterResultType)0) /*!< Next DTC record found and can be used */
# define DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS                 ((Dcm_Svc19UtiRecordIterResultType)1) /*!< Iteration ends here */

/*! Additional DTCOriginType */
# define DCM_DEM_DTC_ORIGIN_USER_MEMORY                              ((uint8)0xFFu) /*!< User defined memory DTCOrigin from request */

/*! Vector DCM to Vector DEM Interface check */
# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
#  if ( defined(DCM_SVC_19_NUM_EXTDATA_RECID) && !defined (DCM_SVC_19_LST_EXTDATA_RECID)) || \
      (!defined(DCM_SVC_19_NUM_EXTDATA_RECID) &&  defined (DCM_SVC_19_LST_EXTDATA_RECID))
#   error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#  else
#   if (defined(DCM_SVC_19_NUM_EXTDATA_RECID) && defined (DCM_SVC_19_LST_EXTDATA_RECID))                                                             /* COV_DCM_UNSUPPORTED XF xf xf */
/* the DCM knows the extended data records of the DEM */
#   else
#    if ( defined(DEM_DCM_NUM_EXTDATA_RECID) && !defined (DEM_DCM_LST_EXTDATA_RECID)) || \
        (!defined(DEM_DCM_NUM_EXTDATA_RECID) &&  defined (DEM_DCM_LST_EXTDATA_RECID))
#     error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#    else
#     if (defined(DEM_DCM_NUM_EXTDATA_RECID) && defined (DEM_DCM_LST_EXTDATA_RECID))
/* use the information provided by DEM */
#      define DCM_SVC_19_NUM_EXTDATA_RECID                           DEM_DCM_NUM_EXTDATA_RECID
#      define DCM_SVC_19_LST_EXTDATA_RECID                           DEM_DCM_LST_EXTDATA_RECID
#     else
#      define DCM_SVC_19_NUM_EXTDATA_RECID                           0
#      define DCM_SVC_19_LST_EXTDATA_RECID                           /* empty */
#      if (DCM_DEM_API_421_ENABLED == STD_ON)
#       error "Missing information for the supported DTC Extended Data Records! See DCM TechRef!"
#      endif
#     endif
#    endif
#   endif
#  endif
/*! Actual complete extended data record list sizes */
#  define DCM_SVC_19_EXTDATA_RECID_SIZE                              (DCM_SVC_19_NUM_EXTDATA_RECID     + 1)
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
#  if ( defined(DCM_SVC_19_NUM_OBD_EXTDATA_RECID) && !defined (DCM_SVC_19_LST_OBD_EXTDATA_RECID)) || \
      (!defined(DCM_SVC_19_NUM_OBD_EXTDATA_RECID) &&  defined (DCM_SVC_19_LST_OBD_EXTDATA_RECID))
#   error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#  else
#   if (defined(DCM_SVC_19_NUM_OBD_EXTDATA_RECID) && defined (DCM_SVC_19_LST_OBD_EXTDATA_RECID))                                                     /* COV_DCM_UNSUPPORTED XF xf xf */
/* the DCM knows the OBD extended data records of the DEM */
#   else
#    if ( defined(DEM_DCM_NUM_OBD_EXTDATA_RECID) && !defined (DEM_DCM_LST_OBD_EXTDATA_RECID)) || \
        (!defined(DEM_DCM_NUM_OBD_EXTDATA_RECID) &&  defined (DEM_DCM_LST_OBD_EXTDATA_RECID))
#     error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#    else
#     if ( defined(DEM_DCM_NUM_OBD_EXTDATA_RECID) && defined (DEM_DCM_LST_OBD_EXTDATA_RECID))                                                        /* COV_DCM_SUPPORT_WITH_MSR_DEM TX tx tx */
/* use the information provided by DEM */
#      define DCM_SVC_19_NUM_OBD_EXTDATA_RECID                       DEM_DCM_NUM_OBD_EXTDATA_RECID
#      define DCM_SVC_19_LST_OBD_EXTDATA_RECID                       DEM_DCM_LST_OBD_EXTDATA_RECID
#     else
#      define DCM_SVC_19_NUM_OBD_EXTDATA_RECID                       0
#      define DCM_SVC_19_LST_OBD_EXTDATA_RECID                       /* empty */
#     endif
#    endif
#   endif
#  endif
/*! Actual OBD extended data record list sizes */
#  define DCM_SVC_19_OBD_EXTDATA_RECID_SIZE                          (DCM_SVC_19_NUM_OBD_EXTDATA_RECID + 1)

#  if (DCM_SVC_19_NUM_OBD_EXTDATA_RECID > 0u)                                                                                                        /* COV_DCM_UNSUPPORTED XF */
#   define DCM_SVC_19_OBD_EXT_RECORD_ENABLED                         STD_ON
#  endif
# endif

# if defined(DCM_SVC_19_OBD_EXT_RECORD_ENABLED)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/* already set */
# else
#  define DCM_SVC_19_OBD_EXT_RECORD_ENABLED                          STD_OFF
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON)
#  if ( defined(DCM_SVC_19_NUM_FRZFRAME_RECID) && !defined (DCM_SVC_19_LST_FRZFRAME_RECID)) || \
      (!defined(DCM_SVC_19_NUM_FRZFRAME_RECID) &&  defined (DCM_SVC_19_LST_FRZFRAME_RECID))
#   error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#  else
#   if (defined(DCM_SVC_19_NUM_FRZFRAME_RECID) && defined (DCM_SVC_19_LST_FRZFRAME_RECID))                                                           /* COV_DCM_UNSUPPORTED XF xf xf */
/* the DCM knows the OBD extended data records of the DEM */
#   else
#    if ( defined(DEM_DCM_NUM_FRZFRAME_RECID) && !defined (DEM_DCM_LST_FRZFRAME_RECID)) || \
        (!defined(DEM_DCM_NUM_FRZFRAME_RECID) &&  defined (DEM_DCM_LST_FRZFRAME_RECID))
#     error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#    else
#     if ( defined(DEM_DCM_NUM_FRZFRAME_RECID) && defined (DEM_DCM_LST_FRZFRAME_RECID))
/* use the information provided by DEM */
#      define DCM_SVC_19_NUM_FRZFRAME_RECID                          DEM_DCM_NUM_FRZFRAME_RECID
#      define DCM_SVC_19_LST_FRZFRAME_RECID                          DEM_DCM_LST_FRZFRAME_RECID
#     else
#      define DCM_SVC_19_NUM_FRZFRAME_RECID                          0
#      define DCM_SVC_19_LST_FRZFRAME_RECID                          /* empty */
#      if (DCM_DEM_API_421_ENABLED == STD_ON)
#       error "Missing information for the supported DTC Freeze Frame Records! See DCM TechRef!"
#      endif
#     endif
#    endif
#   endif
#  endif
/*! Actual complete freeze frame data record list sizes */
#  define DCM_SVC_19_FRZFRAME_RECID_SIZE                             (DCM_SVC_19_NUM_FRZFRAME_RECID    + 1)
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC22_PROGRESS_DIDLOOKUP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC22_PROGRESS_CHECKCONDITION                           ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
# define DCM_SVC22_PROGRESS_GETLENGTH                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2u))
# define DCM_SVC22_PROGRESS_READDATA                                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3u))
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)
/*! Service 0x23 processing steps */
# define DCM_SVC23_PROGRESS_CHECKACCESS                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC23_PROGRESS_READMEMORY                               ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
#endif /* (DCM_SVC_23_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC24_PROGRESS_DIDLOOKUP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC24_PROGRESS_EXECUTEOP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/*! Service 0x27 processing steps */
# define DCM_SVC27_PROGRESS_SEEDPROCESSOR                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC27_PROGRESS_KEYPROCESSOR                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
# define DCM_SVC27_PROGRESS_SETATTEMPTCNTR                           ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2u))
# define DCM_SVC27_PROGRESS_SEEDREPEATER                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3u))
# define DCM_SVC27_PROGRESS_KEYREPEATER                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 4u))
# define DCM_SVC27_PROGRESS_CHECKATTEMPTSEXCEEDED                    ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 5u))

/*! Get-Seed port operation classes  */
# define DCM_SVC27_OPCLS_SEED_WITHOUT_ADR                            ((Dcm_Svc27OpClassType)0)
# define DCM_SVC27_OPCLS_SEED_WITH_ADR                               ((Dcm_Svc27OpClassType)1)
# define DCM_SVC_27_LEVEL_MASK                                       (Dcm_UtiGetMaskFromXintType(uint32, DCM_STATE_SECURITY_NUM_LEVELS))
# define DCM_SVC_27_SEED_LVL_INVALID                                 ((uint8)0x00u)
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/*! Service 0x28 processing steps */
# define DCM_SVC28_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))

# define DCM_SVC_28_CTRL_OP_MASK                                     (0x03u)/*!< Leaves the relevant bits for the conversion function "sub-function id -> operation type" since only sub-functions 0x00-0x03 are handled in DCM */
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
/*! Service 0x29 processing steps */
# define DCM_SVC29_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC29_PROGRESS_WAITCERTVERIFY                           ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
# define DCM_SVC29_PROGRESS_CERTVERIFIED                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2u))
# define DCM_SVC29_PROGRESS_WAITCHALLENGEGEN                         ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3u))
# define DCM_SVC29_PROGRESS_CHALLENGEGEN                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 4u))
# define DCM_SVC29_PROGRESS_SUBFUNC02_WAITCHALLENGESIGNED            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 5u))
# define DCM_SVC29_PROGRESS_SUBFUNC02_CHALLENGESIGNED                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 6u))
# define DCM_SVC29_PROGRESS_SUBFUNC03_WAITSIGVERIFY                  ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 7u))
# define DCM_SVC29_PROGRESS_SUBFUNC03_ROLEREAD                       ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 8u))
# define DCM_SVC29_PROGRESS_SUBFUNC03_SERVICEWHITELISTREAD           ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 9u))
# define DCM_SVC29_PROGRESS_SUBFUNC03_DIDWHITELISTREAD               ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 10u))
# define DCM_SVC29_PROGRESS_SUBFUNC03_RIDWHITELISTREAD               ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 11u))
# define DCM_SVC29_PROGRESS_SUBFUNC03_MEMWHITELISTREAD               ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 12u))
# define DCM_SVC29_PROGRESS_PERSIST_AUTHENTICATION                   ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 13u))

/*! Service 0x29 UDS AuthenticationReturnParameter */
# define DCM_SVC29_AUTH_CONFIG_APCE                                  ((uint8)0x02u)
# define DCM_SVC29_DEAUTH_SUCCESSFUL                                 ((uint8)0x10u)
# define DCM_SVC29_OWNERSHIP_VERIFICATION_NECESSARY                  ((uint8)0x11u)
# define DCM_SVC29_OWNERSHIP_VERIFIED_AUTHENTICATION_COMPLETE        ((uint8)0x12u)

/*! Service 0x29 subfunction references */
# define DCM_SVC29_SUBFUNC_DEAUTHENTICATE                            ((uint8)0x00u)
# define DCM_SVC29_SUBFUNC_VERIFY_CERT_UNIDIR                        ((uint8)0x01u)
# define DCM_SVC29_SUBFUNC_VERIFY_CERT_BIDIR                         ((uint8)0x02u)
# define DCM_SVC29_SUBFUNC_PROOF_OF_OWNERSHIP                        ((uint8)0x03u)

/*! Service 0x29 A_Data fields byte length */
# define DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN                          ((uint32)0x02u)
# define DCM_SVC29_CHALLENGE_LEN_INDEX                               (0x01u)
# define DCM_SVC29_CHALLENGE_DATA_START_INDEX                        (0x03u)

/*! Service 0x29 processing states for asynchronous callback handling */
# define DCM_SVC29_CBK_PROC_STATE_IDLE                               ((Dcm_Svc29ProcessingState)0x00u)
# define DCM_SVC29_CBK_PROC_STATE_CSM_CANCELLED                      ((Dcm_Svc29ProcessingState)0x01u)
# define DCM_SVC29_CBK_PROC_STATE_KEYM_CANCELLED                     ((Dcm_Svc29ProcessingState)0x02u)
# define DCM_SVC29_CBK_PROC_STATE_VERIFY_CERT                        ((Dcm_Svc29ProcessingState)0x03u)
# define DCM_SVC29_CBK_PROC_STATE_VERIFY_CERT_DONE                   ((Dcm_Svc29ProcessingState)0x04u)
# define DCM_SVC29_CBK_PROC_STATE_GENERATE_CHALLENGE                 ((Dcm_Svc29ProcessingState)0x05u)
# define DCM_SVC29_CBK_PROC_STATE_GENERATE_CHALLENGE_DONE            ((Dcm_Svc29ProcessingState)0x06u)
# define DCM_SVC29_CBK_PROC_STATE_SIGN_CHALLENGE                     ((Dcm_Svc29ProcessingState)0x07u)
# define DCM_SVC29_CBK_PROC_STATE_SIGN_CHALLENGE_DONE                ((Dcm_Svc29ProcessingState)0x08u)
# define DCM_SVC29_CBK_PROC_STATE_VERIFY_POOW                        ((Dcm_Svc29ProcessingState)0x09u)
# define DCM_SVC29_CBK_PROC_STATE_VERIFY_POOW_DONE                   ((Dcm_Svc29ProcessingState)0x0Au)
#endif /* (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC2A_RATE_TYPE_SLOW                                    ((Dcm_Svc2ASchedRateMemType)0)
# define DCM_SVC2A_RATE_TYPE_MED                                     ((Dcm_Svc2ASchedRateMemType)1)
# define DCM_SVC2A_RATE_TYPE_FAST                                    ((Dcm_Svc2ASchedRateMemType)2)

# define DCM_SVC2A_RATE_TYPE_MASK                                    ((Dcm_Svc2ASchedRateMemType)0x03u)

# define DCM_SVC2A_RATE_TYPE_STOPPED                                 ((Dcm_Svc2ASchedRateMemType)0x10u)
# define DCM_SVC2A_RATE_TYPE_RESERVED                                ((Dcm_Svc2ASchedRateMemType)0x40u)
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC2A_PROGRESS_SCHEDULEDDID_LOOKUP                      ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u)) /*!< Look up DIDs */
# define DCM_SVC2A_PROGRESS_DID_CHECKCONDITION                       ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u)) /*!< Check conditions */
# define DCM_SVC2A_PROGRESS_DID_GETLENGTH                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2u)) /*!< Obtain total length of the DID */
# define DCM_SVC2A_PROGRESS_STOPPED_DID_LOOKUP                       ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3u)) /*!< Loop up DIDs and stop periodic transmission */

/*! Service 0x2A transmissionMode parameter */
# define DCM_SVC_2A_SEND_AT_SLOW_RATE                                ((Dcm_Svc2ATransmissionModeType)0x01u)  /*!< Server shall transmit at a slow rate */
# define DCM_SVC_2A_SEND_AT_MEDIUM_RATE                              ((Dcm_Svc2ATransmissionModeType)0x02u)  /*!< Server shall transmit at a medium rate */
# define DCM_SVC_2A_SEND_AT_FAST_RATE                                ((Dcm_Svc2ATransmissionModeType)0x03u)  /*!< Server shall transmit at a fast rate */
# define DCM_SVC_2A_STOP_SENDING                                     ((Dcm_Svc2ATransmissionModeType)0x04u)  /*!< Server stops transmitting periodically/repeatedly */
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC2C_INVALID_DYNDID_HDL                                (Dcm_UtiMaxValueOfUintType(Dcm_CfgDidMgrDynDidHandleMemType))

# define DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED                        0u

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON) && \
     (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_COND_ENABLED == STD_ON)
#  define DCM_SVC_2C_NUM_PROCESS_CONTEXTS                            2u
#  define DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY                     1u
# else
#  define DCM_SVC_2C_NUM_PROCESS_CONTEXTS                            1u
#  define DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY                     0u
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC2C_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC2C_PROGRESS_01SRC_DIDLOOKUP                          ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
# define DCM_SVC2C_PROGRESS_01SRC_DIDCHECKCONDITIONS                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2u))
# define DCM_SVC2C_PROGRESS_01SRC_DIDGETLENGTH                       ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3u))
# define DCM_SVC2C_PROGRESS_03_DIDLOOKUP                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 4u))
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC2E_PROGRESS_CHECKACCESS                              ((Dcm_RepeaterProgressType)1u)
# define DCM_SVC2E_PROGRESS_WRITEDATA                                ((Dcm_RepeaterProgressType)2u)
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC2F_PROGRESS_CHECKACCESS                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC2F_PROGRESS_EXECUTEOP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
# define DCM_SVC2F_PROGRESS_GETLENGTH                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2u))
# define DCM_SVC2F_PROGRESS_READDATA                                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3u))
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)
/*! Service 0x31 processing steps */
# define DCM_SVC31_PROGRESS_EXECUTEOP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_34_SUPPORT_ENABLED == STD_ON)
/*! Service 0x34 processing steps */
# define DCM_SVC34_PROGRESS_EXECUTEOP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
#endif /* (DCM_SVC_34_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_36_SUPPORT_ENABLED == STD_ON)
/*! Service 0x36 processing steps */
# define DCM_SVC36_PROGRESS_EXECUTEOP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
#endif /* (DCM_SVC_36_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_37_SUPPORT_ENABLED == STD_ON)
/*! Service 0x37 processing steps */
# define DCM_SVC37_PROGRESS_EXECUTEOP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
#endif /* (DCM_SVC_37_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC3D_PROGRESS_CHECKACCESS                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC3D_PROGRESS_WRITEMEMORY                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
#endif /* (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/*! Service 0x85 processing steps */
# define DCM_SVC85_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC86_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */

/**********************************************************************************************************************
 *  LOCAL FUNCTION MACROS
 *********************************************************************************************************************/
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)
/*! Extract the information length from the format BYTE */
# define Dcm_MemMgrGetMemBlockInfoLength(formatByte)                 ((uint8)(Dcm_UtiGetMemBlockAddrSize(formatByte) + Dcm_UtiGetMemBlockLenSize(formatByte))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
/* Check if it is an available ID at all: (id MOD 0x20) == 0 */
# define Dcm_ObdIdMgrIsAvailabilityId(obdId)                         (((obdId) & 0x1Fu) == 0u)                                                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_ObdIdMgrGetObdIdMaskBit(obdId)                          ((uint32)(0x01UL << (31u - (((obdId)-1u) & 0x1Fu))))                            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_ObdIdMgrIsIdSupported(availMask, obdId)                 (Dcm_UtiBitOpTest(uint32, (availMask), Dcm_ObdIdMgrGetObdIdMaskBit(obdId)))     /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_ObdIdMgrGetAvailabilityIdIdx(obdId)                     ((uint8)(((uint8)(obdId)) >> 5u))                                               /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_ObdIdMgrGetAvailabilityId(id)                           ((uint8)((id) & 0xE0))                                                          /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_ObdIdMgrGetMaskValue(obdAidId, pMaskData)               ((pMaskData)[Dcm_ObdIdMgrGetAvailabilityIdIdx(obdAidId)])                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
# define Dcm_AuthMgrGetAuthInfoRef(pMsgContext)                      (Dcm_PbCfgNetConnectionInfo[Dcm_NetGetConnHdlOfRxPduId((pMsgContext)->rxPduId)].AuthInfoRef) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

/*! Authentication session timers */
# define Dcm_AuthMgrGetTimerIdx(authInfoRef)                         (authInfoRef)                                                                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_AuthMgrTimerGet(authInfoRef)                            (Dcm_SingletonContext.AuthMgr.DelayTime[Dcm_AuthMgrGetTimerIdx((authInfoRef))]) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_AuthMgrTimerReset(authInfoRef)                          (Dcm_AuthMgrTimerSet((authInfoRef), 0u))                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_AuthMgrTimerActive(authInfoRef)                         ((boolean)(Dcm_AuthMgrTimerGet((authInfoRef)) != 0u))                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_AuthMgrTimerExpireMaskReset()                           (Dcm_SingletonContext.AuthMgr.TimerExpiredMask = 0u)                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_AuthMgrTimerExpireMaskGet()                             (Dcm_SingletonContext.AuthMgr.TimerExpiredMask)                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_AuthMgrAnyTimerExpired()                                (Dcm_SingletonContext.AuthMgr.TimerExpiredMask != 0u)
# define Dcm_AuthMgrTimerExpireMaskSetBit(authInfoRef)               ((Dcm_UtiBitOpSet(Dcm_AuthMgrTimerExpiredMaskType, Dcm_SingletonContext.AuthMgr.TimerExpiredMask, Dcm_UtiGetBitFromIndex(uint8_least, Dcm_AuthMgrGetTimerIdx((authInfoRef)))))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Authentication state check */
# define Dcm_AuthMgrAuthenticationState(authInfoRef)                 (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.AuthState)                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Authentication role */
# define Dcm_AuthMgrActiveRole(authInfoRef)                          (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.ActiveRole)                      /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Service white list operations */
# if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
#  define Dcm_AuthMgrIsGlobalAccessGranted()                         (Dcm_SingletonContext.AuthMgr.GrantGlobalAccess == TRUE)                        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSetGlobalAccess(value)                          (Dcm_SingletonContext.AuthMgr.GrantGlobalAccess = (value))                      /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrNumSvcWLElements(authInfoRef)                   (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.WLContext.WLServiceContext.NumServiceWLElements) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSvcWLElemLen(authInfoRef, iter)                 (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.WLContext.WLServiceContext.WLServiceElement[iter].WLEntryLength) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSvcWLElemDataAt(authInfoRef, iter, pos)         (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.WLContext.WLServiceContext.WLServiceElement[iter].WLData[pos]) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSvcWLElemIsSID(authInfoRef, iter, sid)          (Dcm_AuthMgrSvcWLElemDataAt((authInfoRef), (iter), 0u) == (sid))                /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSvcWLElemIs22(authInfoRef, iter)                (Dcm_AuthMgrSvcWLElemIsSID((authInfoRef), (iter), DCM_DIDMGR_SVC_READ))         /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSvcWLElemIs2E(authInfoRef, iter)                (Dcm_AuthMgrSvcWLElemIsSID((authInfoRef), (iter), DCM_DIDMGR_SVC_WRITE))        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSvcWLElemIs2F(authInfoRef, iter)                (Dcm_AuthMgrSvcWLElemIsSID((authInfoRef), (iter), DCM_DIDMGR_SVC_IOCTRL))       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSvcWLElemIsDIDWRIO(authInfoRef, iter)           ((Dcm_AuthMgrSvcWLElemLen((authInfoRef), (iter)) == 3u) && (Dcm_AuthMgrSvcWLElemIs22((authInfoRef), (iter)) || Dcm_AuthMgrSvcWLElemIs2E((authInfoRef), (iter)) || Dcm_AuthMgrSvcWLElemIs2F((authInfoRef), (iter)))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSvcWLElemIs31(authInfoRef, iter)                (Dcm_AuthMgrSvcWLElemIsSID((authInfoRef), (iter), 0x31u))                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSvcWLElemIsRID(authInfoRef, iter)               ((Dcm_AuthMgrSvcWLElemLen((authInfoRef), (iter)) == 4u) && Dcm_AuthMgrSvcWLElemIs31((authInfoRef), (iter))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSvcWLElemIsDSP(authInfoRef, iter)               (Dcm_AuthMgrSvcWLElemIsDIDWRIO((authInfoRef), (iter)) || Dcm_AuthMgrSvcWLElemIsRID((authInfoRef), (iter))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# endif
/*! DID white list operations */
# if (DCM_AUTHMGR_WHITELIST_DID_ENABLED == STD_ON)
#  define Dcm_AuthMgrNumDIDWLElements(authInfoRef)                   (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.WLContext.WLDidContext.NumDidWLElements) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrDidWLElem(authInfoRef, iter)                    (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.WLContext.WLDidContext.WLDidElement[(iter)]) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# endif
/*! RID white list operations */
# if (DCM_AUTHMGR_WHITELIST_RID_ENABLED == STD_ON)
#  define Dcm_AuthMgrNumRIDWLElements(authInfoRef)                   (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.WLContext.WLRidContext.NumRidWLElements) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrRidWLElem(authInfoRef, iter)                    (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.WLContext.WLRidContext.WLRidElement[(iter)]) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# endif
/*! MEM white list operations */
# if (DCM_AUTHMGR_WHITELIST_MEM_ENABLED == STD_ON)
#  define Dcm_AuthMgrNumMemWLElements(authInfoRef)                   (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.WLContext.WLMemContext.NumMemWLElements) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrMemWLElem(authInfoRef, iter)                    (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.WLContext.WLMemContext.WLMemElement[(iter)]) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# endif
#endif /* (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON) */
/*! USDT buffer management */
#define Dcm_NetBufferIsFree(pBufferContext)                          ((pBufferContext)->IsInUseCnt == 0u)                                            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetBufferLock(pBufferContext)                            ((pBufferContext)->IsInUseCnt=1u)                                               /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetBufferRelease(pBufferContext)                         ((pBufferContext)->IsInUseCnt--)                                                /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetBufferUsageEnter(pBufferContext)                      ((pBufferContext)->IsInUseCnt++)                                                /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetBufferUsageLeave(pBufferContext)                      (Dcm_NetBufferRelease(pBufferContext))                                          /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#define Dcm_NetGetConnHdlOfRxPduId(rxPduId)                          (Dcm_NetCfgGetConnHdlOfRxPduId(DCM_VARMGR_ACTIVE_COMVAR, (rxPduId)))            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#if(DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
# define Dcm_NetIsGenericConnection(connHdl)                         (Dcm_NetCfgIsGenericConnection(DCM_VARMGR_ACTIVE_COMVAR, (connHdl)))            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif
#define Dcm_NetGetNodeAddress(connHdl)                               (Dcm_NetCfgGetEcuAddressOfConnHdl(DCM_VARMGR_ACTIVE_COMVAR, (connHdl)))         /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetTesterAddress(connHdl)                             (Dcm_NetCfgGetTesterAddressOfConnHdl(DCM_VARMGR_ACTIVE_COMVAR, (connHdl)))      /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetConnHdlOfTxPduId(txPduId)                          (Dcm_PbCfgNetTxPdu2ConnMap[(txPduId)])                                          /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#define Dcm_NetGetProtIdOfActiveProtocol()                           (Dcm_SingletonContext.Network.ActiveProtocol)                                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetProtIdOfConnection(connHdl)                        (Dcm_PbCfgNetConnectionInfo[(connHdl)].ProtRef)                                 /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetProtIdOfTranspObj(pTranspObj)                      (Dcm_NetGetProtIdOfConnection((pTranspObj)->ConnHdl))                           /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetProtIdOfMsgContext(pMsgContext)                    (Dcm_NetGetProtIdOfConnection(Dcm_NetGetConnHdlOfRxPduId((pMsgContext)->rxPduId))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#define Dcm_NetGetProtObjOfProtId(protId)                            (&Dcm_PbCfgNetProtocolInfo[(protId)])                                           /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetProtObjOfConnection(connHdl)                       (Dcm_NetGetProtObjOfProtId(Dcm_NetGetProtIdOfConnection(connHdl)))              /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetProtObjOfTranspObj(pTranspObj)                     (Dcm_NetGetProtObjOfConnection((pTranspObj)->ConnHdl))                          /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#define Dcm_NetGetThreadIdOfTranspObj(pTranspObj)                    (Dcm_NetGetProtObjOfTranspObj((pTranspObj))->ThreadId)                          /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
# define Dcm_NetPeriodicMsgGetTxPduIdByConn(connHdl, txObjIdx)       (Dcm_PbCfgNetPerTxPduIdInfo[Dcm_PbCfgNetConnectionInfo[(connHdl)].PeriodicTxRef + (txObjIdx)]) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_NetPeriodicMsgGetNumMsgsFor(connHdl)                    (Dcm_PbCfgNetConnectionInfo[(connHdl)].NumPeriodicTxPduIds)                     /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# define Dcm_NetPeriodicMsgGetTxPduIdCurrConn(txObjIdx)              (Dcm_NetPeriodicMsgGetTxPduIdByConn(Dcm_NetPeriodicMsgGetConnection(),(txObjIdx))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# define Dcm_NetPeriodicMsgSetConnection(connHdl)                    (Dcm_SingletonContext.Network.PeriodicTxContext.ConnHdlInUse = (connHdl))       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_NetPeriodicMsgGetConnection()                           (Dcm_SingletonContext.Network.PeriodicTxContext.ConnHdlInUse)                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_NetPeriodicMsgSupportedFor(connHdl)                     (Dcm_NetPeriodicMsgGetNumMsgsFor(connHdl) != 0u)                                /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# define Dcm_NetPeriodicMsgNumMsgsCurrConnection()                   (Dcm_NetPeriodicMsgGetNumMsgsFor(Dcm_NetPeriodicMsgGetConnection()))            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId)             ((Dcm_CfgNetPTxObjHandleOptType)(Dcm_PbCfgNetPerTxPdu2RsrsMap[txPduId]))        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# define Dcm_NetPeriodicMsgGetNextMsgHdl()                           (Dcm_SingletonContext.Network.PeriodicTxContext.NextTxObjectHdl)                /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_NetPeriodicMsgResetNextMsgHdl()                         (Dcm_SingletonContext.Network.PeriodicTxContext.NextTxObjectHdl = 0u)           /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_NetPeriodicMsgIncNextMsgHdl()                           (++Dcm_SingletonContext.Network.PeriodicTxContext.NextTxObjectHdl)              /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# define Dcm_NetPeriodicMsgGetTxObjectSentCntr()                     (Dcm_SingletonContext.Network.PeriodicTxContext.TxObjectSentCntr)               /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_NetPeriodicMsgResetTxObjectSentCntr()                   (Dcm_SingletonContext.Network.PeriodicTxContext.TxObjectSentCntr = 0u)          /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_NetPeriodicMsgIncTxObjectSentCntr()                     (++Dcm_SingletonContext.Network.PeriodicTxContext.TxObjectSentCntr)             /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# define Dcm_NetPeriodicMsgSetClientSrcAddr(clientSrcAddr)           (Dcm_SingletonContext.Network.PeriodicTxContext.ClientSrcAddr = (clientSrcAddr)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_NetPeriodicMsgGetClientSrcAddr()                        (Dcm_SingletonContext.Network.PeriodicTxContext.ClientSrcAddr)                  /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
#  define Dcm_NetPeriodicMsgGetDelayCntr()                           (Dcm_SingletonContext.Network.PeriodicTxContext.DelayCntr)                      /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_NetPeriodicMsgIncDelayCntr()                           (++Dcm_SingletonContext.Network.PeriodicTxContext.DelayCntr)                    /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_NetPeriodicMsgDecDelayCntr()                           (--Dcm_SingletonContext.Network.PeriodicTxContext.DelayCntr)                    /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_NetPeriodicMsgInitDelayCntr()                          (Dcm_SingletonContext.Network.PeriodicTxContext.DelayCntr = DCM_NET_DELAY_BULK_TRANSMISSION) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#  define Dcm_NetPeriodicMsgResetNextDelayTimer()                    (Dcm_SingletonContext.Network.PeriodicTxContext.NextDelayTimer = 0u)            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_NetPeriodicMsgGetNextDelayTimer()                      (Dcm_SingletonContext.Network.PeriodicTxContext.NextDelayTimer)                 /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#  define Dcm_NetPeriodicMsgGetFastestRate()                         (Dcm_SingletonContext.Network.PeriodicTxContext.FastestRate)                    /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_NetPeriodicMsgInitFastestRate()                        (Dcm_SingletonContext.Network.PeriodicTxContext.FastestRate = DCM_SVC2A_RATE_TYPE_SLOW) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#  define Dcm_NetGetPeriodicDelayTime(Rate)                          (Dcm_CfgNetPeriodicDelayTime[Rate])                                             /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# else
#  define Dcm_NetPeriodicMsgGetDelayCntr()                           0u
#  define Dcm_NetPeriodicMsgIncDelayCntr()                           /* not used */
#  define Dcm_NetPeriodicMsgDecDelayCntr()                           /* not used */
#  define Dcm_NetPeriodicMsgInitDelayCntr()                          /* not used */

#  define Dcm_NetPeriodicMsgGetFastestRate()                         DCM_SVC2A_RATE_TYPE_SLOW
#  define Dcm_NetPeriodicMsgInitFastestRate()                        /* not used */

#  define Dcm_NetGetPeriodicDelayTime(Rate)                          0u
# endif

# define Dcm_NetPTxObjTimerGet(pPeriodicTxObj)                       ((pPeriodicTxObj)->Timer)                                                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_NetPTxObjTimerExpired(pPeriodicTxObj)                   (Dcm_NetPTxObjTimerGet(pPeriodicTxObj) == 0u)                                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#endif /* (DCM_NET_PERIODIC_TX_ENABLED == STD_ON) */

#define Dcm_NetGetSessionConnection()                                (Dcm_SingletonContext.Network.SessionConnection)                                /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetSetSessionConnection(connHdl)                         (Dcm_SingletonContext.Network.SessionConnection = (connHdl))                    /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetSessionClientSrcAddr()                             (Dcm_SingletonContext.Network.SessionClientSrcAddr)                             /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetSetSessionClientSrcAddr(clientSrcAddress)             (Dcm_SingletonContext.Network.SessionClientSrcAddr = (clientSrcAddress))        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#define Dcm_NetGetComStateByChannelId(channelId)                     (Dcm_PbRamNetComMContext[(channelId)].ComState)                                 /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetComStateByConnection(connHdl)                      (Dcm_NetGetComStateByChannelId(Dcm_PbCfgNetConnectionInfo[(connHdl)].NetworkIdRef)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetComStateByRxPduId(rxPduId)                         (Dcm_NetGetComStateByConnection(Dcm_NetGetConnHdlOfRxPduId(rxPduId)))           /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetComStateByTranspObject(pTranspObj)                 (Dcm_NetGetComStateByConnection((pTranspObj)->ConnHdl))                         /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#define Dcm_NetGetProperties(pTranspObj)                             (Dcm_PbCfgNetConnectionInfo[(pTranspObj)->ConnHdl].Properties)                  /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetIsPropertieSet(pTranspObj, prop)                      (Dcm_UtiBitOpTest(Dcm_CfgNetConnPropertiesType, Dcm_NetGetProperties(pTranspObj), (prop))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
# define Dcm_NetGetAuthInfoRef(connHdl)                              (Dcm_PbCfgNetConnectionInfo[(connHdl)].AuthInfoRef)                             /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#else
# define Dcm_NetGetAuthInfoRef(connHdl)                              /* not used */
#endif
/*! Configuration dependent getter/setter access to the communication control state */
#if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
# define Dcm_ModeGetCommControlState(networkRef)                     (Dcm_PbRamNetComCtrlChannels[(networkRef)])                                     /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_ModeSetCommControlState(networkRef, mode)               (Dcm_NetSetComControlChannelState((networkRef), (mode)))                        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#else
# define Dcm_ModeGetCommControlState(networkRef)                     /* not used */
# define Dcm_ModeSetCommControlState(networkRef, mode)               /* not used */
#endif

/*! Configuration dependent getter/setter access to the DTC setting state */
#if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
# define Dcm_ModeGetControlDtcSettingMode()                          (Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.Mode)                              /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_ModeSetControlDtcSettingMode(newMode)                   (Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.Mode = (newMode))                  /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#else
# define Dcm_ModeGetControlDtcSettingMode()                          /* not used */
# define Dcm_ModeSetControlDtcSettingMode(newMode)                   /* not used */
#endif

/*! Configuration dependent getter/setter access to the DTC group associated to the already set DTC setting's state */
#if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON) && \
    (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
# define Dcm_ModeGetControlDtcSettingGroup()                         (Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.DTCGroup)                          /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_ModeSetControlDtcSettingGroup(newGroup)                 (Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.DTCGroup = (newGroup))             /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#else
# define Dcm_ModeGetControlDtcSettingGroup()                         /* not used */
# define Dcm_ModeSetControlDtcSettingGroup(newGroup)                 /* not used */
#endif
/*! Set the new (not yet finally committed, but probably "will become active") diagnostic session */
#define Dcm_StateSetPendingSession(session)                          (Dcm_SingletonContext.StateMgr.PendingSession = (session))                      /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Returns the new (not yet finally committed, but probably "will become active") diagnostic session */
#define Dcm_StateGetPendingSession()                                 (Dcm_SingletonContext.StateMgr.PendingSession)                                  /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Synchronizes both pending and committed (active) diagnostic session to have the same state (i.e. the pending session becomes the state of the last valid diagnostic session */
#define Dcm_StateSyncPendingSession()                                (Dcm_StateSetPendingSession(Dcm_SingletonContext.StateMgr.Preconditions.Session)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
/*! Returns TRUE if the authentication role pre-condition of a diagnostic entity is met */
# define Dcm_StateIsSupportedInRole(precondPckgRef, authInfoRef)     ((Dcm_AuthMgrActiveRole(authInfoRef) & (precondPckgRef).AuthRole) != 0u)        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif
/*! Returns the diagnostic state related pre-conditions of a diagnostic entity */
#define Dcm_StateGetPreconditionStates(precondPckgRef)               (Dcm_CfgStatePreconditions[(precondPckgRef)].States)                            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Returns the currently active (committed) diagnostic session state */
#define Dcm_StateGetSession()                                        (Dcm_SingletonContext.StateMgr.Preconditions.Session)                           /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Returns the diagnostic session pre-condition(s) of a diagnostic entity */
#define Dcm_StateGetPreconditionSession(precondPckgRef)              (Dcm_StateGetPreconditionStates(precondPckgRef).Session)                        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/*! Returns the currently active security access level related state */
# define Dcm_StateGetSecurity()                                      (Dcm_SingletonContext.StateMgr.Preconditions.Security)                          /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Returns the security access pre-condition(s) of a diagnostic entity */
# define Dcm_StateGetPreconditionSecurity(precondPckgRef)            (Dcm_StateGetPreconditionStates(precondPckgRef).Security)                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif
/*! Returns TRUE if current (committed) diagnostic session is the Default-Session. Otherwise returns FALSE */
#define Dcm_StateIsDefaultSessionActive()                            ((Dcm_StateGetSession() & DCM_STATE_VALUE_SESSION_INIT) != 0u)                  /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Returns TRUE if the diagnostic session precondition of a diagnostic entity is met */
#define Dcm_StateIsSupportedInSession(preconditionPackage)           ((Dcm_StateGetSession() & (preconditionPackage).Session) != 0u)                 /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Returns the diagnostic session ID of the diagnostic session state */
#define Dcm_StateGetSessionValue(stateIdx)                           (Dcm_CfgStateSessionInfo[stateIdx].Value)                                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/*! Returns TRUE if current security level is the Locked-Level. Otherwise returns FALSE */
# define Dcm_StateIsSecurityLocked()                                 ((Dcm_StateGetSecurity() & DCM_STATE_VALUE_SECURITY_INIT) != 0u)                /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Returns TRUE if the security access pre-condition of a diagnostic entity is met */
# define Dcm_StateIsSupportedInSecurityLevel(preconditionPackage)    ((Dcm_StateGetSecurity() & (preconditionPackage).Security) != 0u)               /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Returns the security access level ID of the security access state */
# define Dcm_StateGetSecurityValue(stateIdx)                         ((Dcm_SecLevelType)(((stateIdx) == 0u)?0u:Dcm_CfgStateSecurityInfo[(stateIdx)-1u].Value)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif

#if (DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)  &&  \
    (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
# if (DCM_STATE_MULTIPLE_SECURITYFIXEDBYTES_ENABLED == STD_ON)
#  define Dcm_StateGetVsgMaskInfoIdx(stateIdx)                       (Dcm_CfgStateVsgSecurityFixedByteInfo[(stateIdx)])                              /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_StateGetNumberOfVsgs(stateIdx)                         ((Dcm_VsgSizeType)(Dcm_CfgStateVsgSecurityFixedByteInfo[(stateIdx) + 1u]) - (Dcm_VsgSizeType)(Dcm_CfgStateVsgSecurityFixedByteInfo[(stateIdx) + 0u])) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# else
#  define Dcm_StateGetVsgMaskInfoIdx(stateIdx)                       (stateIdx)                                                                      /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_StateGetNumberOfVsgs(stateIdx)                         ((((Dcm_VsgSizeType)(Dcm_CfgStateSecurityFixedByteInfo[(stateIdx) + 1u]) - (Dcm_VsgSizeType)(Dcm_CfgStateSecurityFixedByteInfo[(stateIdx) + 0u])) > 0u)?1u:0u) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# endif
#endif
#define Dcm_TmrIsTimerRunning(timerId)                               ( Dcm_UtiBitOpTest(Dcm_TmrMaskMemType, Dcm_SingletonContext.TimerMgr.ControlMask, Dcm_UtiGetBitFromIndex(Dcm_TmrMaskMemType, (timerId))) ) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_TmrSetTimerStopped(timerId)                              ( Dcm_UtiBitOpClr (Dcm_TmrMaskMemType, Dcm_SingletonContext.TimerMgr.ControlMask, Dcm_UtiGetBitFromIndex(Dcm_TmrMaskMemType, (timerId))) ) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_TmrSetTimerRunning(timerId)                              ( Dcm_UtiBitOpSet (Dcm_TmrMaskMemType, Dcm_SingletonContext.TimerMgr.ControlMask, Dcm_UtiGetBitFromIndex(Dcm_TmrMaskMemType, (timerId))) ) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

/*! Returns the timer specific number of threads */
#define Dcm_TmrGetNumThreads(timerId)                                (((Dcm_TmrTimerInfo[(timerId)].Attributes & DCM_TMR_ATR_THREAD_MULTI) != 0u) ? DCM_NUM_THREADS : 1u) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_DIDMGR_DYNDID_DEEP_CHECK_ON_READ_ENABLED == STD_ON)
/* a real function is used for optimal code size */
# else
#  define Dcm_DidMgrDynDidStateCheck(connHdl, pDidInfoContext, pErroCode) (Dcm_DidMgrStaticDidStateCheck(connHdl, (pDidInfoContext)->Did, DCM_DIDMGR_OP_READ, Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext)->ExecCondRef, (pErroCode))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# endif

# define Dcm_DidMgrStaticDidStateCheck(connHdl, did, didOpMask, ExecCondRef, pErroCode) (Dcm_StateCheckDID((connHdl), (did), (didOpMask), (ExecCondRef), (pErroCode))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_DidMgrStaticDidNoAuthStateCheck(ExecCondRef, pErroCode) (Dcm_StateCheck((ExecCondRef), DCM_DIAG_CHK_LVL_PARAMETER, (pErroCode)))        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# define Dcm_DidMgrGetCtrlEnblMaskLength(pDidInfo)                   (Dcm_CfgDidMgrOpInfoIoControl[Dcm_DidMgrOpInfoRedirector((pDidInfo)->OpRef, OpRefIoControl)].CtrlEnblMaskLength) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_DidMgrGetCtrlEnblMaskHandling(pDidInfo)                 (Dcm_CfgDidMgrOpInfoIoControl[Dcm_DidMgrOpInfoRedirector((pDidInfo)->OpRef, OpRefIoControl)].CtrlEnblMaskHandling) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
#  define Dcm_DidMgrGetCtrlOpInfoRef(opRef)                          (Dcm_CfgDidMgrOpInfoIoControl[opRef].RetCtrlToEcuOpRef)                         /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# endif

# define Dcm_DidMgrGetCtrlOpExecCondRef(opRef)                       (Dcm_CfgDidMgrOpInfoIoControl[opRef].CtrlExecCondRef)                           /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# define Dcm_DidMgrGetDynDidSize(dynDidHandle)                       (Dcm_CfgDidMgrOpInfoDefine[(dynDidHandle)].NumItems)                            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle)            (Dcm_CfgDidMgrOpInfoDefine[(dynDidHandle)].SrcItemRef)                          /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# if (DCM_DIDMGR_DYNDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
#  define Dcm_DidMgrGetDynDidReadExecPrecond(dynDidHandle)           (Dcm_CfgDidMgrOpInfoDefine[(dynDidHandle)].ReadExecCondRef)                     /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# endif
# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
#  define Dcm_DidMgrGetDynDidIdFromHandle(dynDidHandle)              ((Dcm_CfgDidMgrOpInfoDefine[(dynDidHandle)].Did))                               /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)
/*! Converts sub-function ID to the internal routine operation value */
# define Dcm_RidMgrConvOpOfSubFunc(sf)                               ((Dcm_RidMgrOpType)(((sf) < 4u)?Dcm_RidMgrSubFunc2OpMap[(sf)]:0u))              /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

/*! Access abstraction for RID information table */
# define Dcm_CfgRidMgrRidInfoOpBaseIdx(idx)                          (Dcm_CfgRidMgrRidInfo[(idx)].OpBaseIdx)                                         /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_CfgRidMgrRidInfoExecCondRef(idx)                        (Dcm_CfgRidMgrRidInfo[(idx)].ExecCondRef)                                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_CfgRidMgrRidInfoOperations(idx)                         (Dcm_CfgRidMgrRidInfo[(idx)].Operations)                                        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_CfgRidMgrRidInfoRoutineInfoByte(idx)                    (Dcm_CfgRidMgrRidInfo[(idx)].RoutineInfoByte)                                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

/*! Access abstraction for RID operation information table */
# define Dcm_CfgRidMgrOpInfoOpFunc(idx)                              (Dcm_CfgRidMgrOpInfo[(idx)].OpFunc)                                             /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_CfgRidMgrOpInfoReqMinLength(idx)                        (Dcm_CfgRidMgrOpInfo[(idx)].ReqMinLength)                                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_CfgRidMgrOpInfoReqMaxLength(idx)                        (Dcm_CfgRidMgrOpInfo[(idx)].ReqMaxLength)                                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_CfgRidMgrOpInfoResMinLength(idx)                        (Dcm_CfgRidMgrOpInfo[(idx)].ResMinLength)                                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_CfgRidMgrOpInfoOpType(idx)                              (Dcm_CfgRidMgrOpInfo[(idx)].OpType)                                             /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_CfgRidMgrOpInfoParamIntegrity(idx)                      (Dcm_CfgRidMgrOpInfo[(idx)].ParamIntegrity)                                     /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
/*! Splittask related critical section management */
#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
# define Dcm_SplitTaskEnterCS()                                      Dcm_UtiEnterCriticalSection()                                                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_SplitTaskLeaveCS()                                      Dcm_UtiLeaveCriticalSection()                                                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#else
# define Dcm_SplitTaskEnterCS()                                      /* Not used */
# define Dcm_SplitTaskLeaveCS()                                      /* Not used */
#endif
/*! Returns the task specific number of threads */
#define Dcm_TskGetNumThreads(tskIter)                                (((Dcm_TskTaskInfo[(tskIter)].TskAtr & DCM_TSK_ATR_THREAD_MULTI) != 0u) ? DCM_NUM_THREADS : 1u) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

/*! Task runtime flag management abstraction */
#if (DCM_TSK_TASK_FLAG_SUPPORT_ENABLED == STD_ON)
# define Dcm_TskIsFlagSet(pTaskContext, flg)                         (Dcm_UtiBitOpTest(Dcm_TskTaskFlagType, (pTaskContext)->TaskFlags, (flg)))       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_TskSetFlag(pTaskContext, flg)                           (Dcm_UtiBitOpSet(Dcm_TskTaskFlagType, (pTaskContext)->TaskFlags, (flg)))        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_TskClrFlag(pTaskContext, flg)                           (Dcm_UtiBitOpClr(Dcm_TskTaskFlagType, (pTaskContext)->TaskFlags, (flg)))        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#else
# define Dcm_TskIsFlagSet(pTaskContext)                              /* not used */
# define Dcm_TskSetFlag(pTaskContext, flg)                           /* not used */
# define Dcm_TskClrFlag(pTaskContext, flg)                           /* not used */
#endif

/*! Task activation tracing utilities. Used to detect whether a function call (API) is performed while any or a specific task is (not) running */
#if (DCM_TSK_TRACING_ENABLED == STD_ON)
# define Dcm_TskTraceInit()                                          (Dcm_UtiStackInit(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack))           /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_TskTraceTskPush(taskId)                                 (Dcm_UtiStackPush(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack, (Dcm_TskMgrTraceStackBaseType)(taskId))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_TskTraceTskPop()                                        (Dcm_UtiStackPop(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack))            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_TskTraceIsFull()                                        (Dcm_UtiStackIsFull(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack, Dcm_TskMgrTraceStackBaseType)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_TskTraceIsEmpty()                                       (Dcm_UtiStackIsEmpty(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack))        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

/*! Returns the ID of the task currently executed */
# define Dcm_TskTraceGetCurrTskId()                                  (Dcm_UtiStackTop(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack))            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#else
# define Dcm_TskTraceInit()                                          /* not used */
# define Dcm_TskTraceTskPush(taskId)                                 /* not used */
# define Dcm_TskTraceTskPop()                                        /* not used */
# define Dcm_TskTraceIsFull()                                        /* not used */
# define Dcm_TskTraceIsEmpty()                                       /* not used */

# define Dcm_TskTraceGetCurrTskId()                                  /* not used */
#endif
/*! Getter/Setter of the transport object carrying the diagnostic request currently in processing */
#define Dcm_DiagGetTranspObj(pThreadContext)                         (Dcm_NetGetTransportObject(pThreadContext->Diag.TObjHdl))                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_DiagSetTranspObj(pThreadContext, tObjPtr)                (pThreadContext->Diag.TObjHdl = (tObjPtr)->Handle)                              /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

/*! Abstract interface of getter of the transport object carrying the diagnostic request to be processed at next Dcm_DiagTaskWorker() activation */
/*! Get/Set the queued transport object */
#define Dcm_DiagGetQueuedTranspObj(pThreadContext)                   (Dcm_NetGetTransportObject(pThreadContext->Diag.QueuedSet.TObjHdl))             /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Abstract interface of the RCR-RP limiter counter management */
#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
/*! Reset the RCR-RP limiter */
# define Dcm_DiagResetRcrRpLimiter(pContext)                         (pContext->Thread->Diag.NumRcrRpTimeouts = DCM_DIAG_RCRRP_LIMIT_COUNT)          /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Get current RCR-RP limiter value */
# define Dcm_DiagGetRcrRpLimiter(pContext)                           (pContext->Thread->Diag.NumRcrRpTimeouts)                                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Decrement by one RCR-RP limiter value */
# define Dcm_DiagDecrementRcrRpLimiter(pContext)                     (--(pContext->Thread->Diag.NumRcrRpTimeouts))                                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#else
# define Dcm_DiagResetRcrRpLimiter(pContext)                         /* not used */
# define Dcm_DiagGetRcrRpLimiter(pContext)                           /* not used */
# define Dcm_DiagDecrementRcrRpLimiter(pContext)                     /* not used */
#endif
/*! Variant bitmap access */
#define Dcm_VarMgrBitSetCalcSize(bits)                               (Dcm_UtiBitSetCalcSize(Dcm_CfgVarMgrBitSetBaseType, (bits)))                    /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_VarMgrBitSetTestBit(bitSet, bit)                         (Dcm_UtiBitSetTestBit(Dcm_CfgVarMgrBitSetBaseType, (bitSet), (bit)))            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_VarMgrBitSetSetBit(bitSet, bit)                          (Dcm_UtiBitSetSetBit(Dcm_CfgVarMgrBitSetBaseType, (bitSet), (bit)))             /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_VarMgrBitSetClrBit(bitSet, bit)                          (Dcm_UtiBitSetClrBit(Dcm_CfgVarMgrBitSetBaseType, (bitSet), (bit)))             /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

/*! EcuM notification for run-time variant initialization errors */
#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
# define Dcm_EcuMErrorNotification(errorCode)                        (EcuM_BswErrorHook((uint16) DCM_MODULE_ID, (uint8) (errorCode)))                /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#else
# define Dcm_EcuMErrorNotification(errorCode)                        /* not used */
#endif
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/*! Per default - all patching hooks of DTC status masks are not required */
# if !defined(Dcm_ExtSvc19UtiPatchDtcStatusInit)
#  define Dcm_ExtSvc19UtiPatchDtcStatusInit(pContext)                /* not used */
# endif
# if !defined(Dcm_ExtSvc19UtiPatchDtcStatusApplyByRequest)
#  define Dcm_ExtSvc19UtiPatchDtcStatusApplyByRequest(pContext, dtcStatusPtr) /* not used */
# endif
# if !defined(Dcm_ExtSvc19UtiPatchDtcStatusApplyByResult)
#  define Dcm_ExtSvc19UtiPatchDtcStatusApplyByResult(dtcStatusPtr)   /* not used */
# endif
# if !defined(Dcm_ExtSvc19UtiPatchDtcStatusSetForApply)
#  define Dcm_ExtSvc19UtiPatchDtcStatusSetForApply(pContext)         /* not used */
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
# define Dcm_Svc27OnStateChanged()                                   (Dcm_Svc27ResetSequence())                                                      /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc27ResetSequence()                                    (Dcm_SingletonContext.Diag.Services.Svc27.SeedLevel = DCM_SVC_27_SEED_LVL_INVALID) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc27IsKeyRequestExpected()                             ((boolean)(Dcm_SingletonContext.Diag.Services.Svc27.SeedLevel != DCM_SVC_27_SEED_LVL_INVALID)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc27GetSecLvlRef(subSvcRef)                            ((uint8)((subSvcRef) / 2u))                                                     /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc27IsSeedRequest(subSvcRef)                           ((boolean)(((subSvcRef) & 0x01u) == 0u)) /* Even subSvcRef means "request seed" request */ /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc27IsKeyRequest(subSvcRef)                            ((boolean)(Dcm_Svc27IsSeedRequest(subSvcRef) == FALSE)) /* Odd subSvcRef means "send key" request */ /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc27IsThisKeyRequestExpected(secLvlRef)                ((boolean)(Dcm_CfgStateSecurityInfo[secLvlRef].Value == Dcm_SingletonContext.Diag.Services.Svc27.SeedLevel)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# if (DCM_SVC_27_MULTI_ATTEMPT_COUNTER_ENABLED == STD_ON)
#  define Dcm_Svc27GetCounterIdx(secLvl)                             (secLvl)                                                                        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# else
#  define Dcm_Svc27GetCounterIdx(secLvl)                             0u
# endif

# if (DCM_SVC_27_MULTI_DELAY_TIMER_ENABLED == STD_ON)
#  define Dcm_Svc27GetTimerIdx(secLvl)                               (secLvl)                                                                        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# else
#  define Dcm_Svc27GetTimerIdx(secLvl)                               0u
# endif

# define Dcm_Svc27CounterGet(secLev)                                 (Dcm_SingletonContext.Diag.Services.Svc27.AttemptCount[Dcm_Svc27GetCounterIdx((secLev))]) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27CounterReset(secLev)                               (Dcm_Svc27CounterSet((secLev), 0u))                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27TimerGet(secLev)                                   (Dcm_SingletonContext.Diag.Services.Svc27.DelayTime[Dcm_Svc27GetTimerIdx((secLev))]) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27TimerReset(secLev)                                 (Dcm_Svc27TimerSet((secLev), 0u))                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27TimerActive(secLev)                                ((boolean)(Dcm_Svc27TimerGet((secLev)) != 0u))                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27TimerJustExpired(mask, secLev)                     ((boolean)(Dcm_UtiBitOpTest(uint32, (mask), Dcm_UtiGetBitFromIndex(uint32_least, Dcm_Svc27GetTimerIdx((secLev)))))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27ReloadReadFailedGet(secLev)                        (Dcm_UtiBitOpTest(uint32, Dcm_SingletonContext.Diag.Services.Svc27.ReloadMask, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, (secLev)))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27ReloadReadFailedSet(secLev)                        (Dcm_UtiBitOpSet(uint32, Dcm_SingletonContext.Diag.Services.Svc27.ReloadMask, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, (secLev)))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
# define Dcm_Svc29GetPendingKeyMCertId()                             (Dcm_SingletonContext.Diag.Services.Svc29.PendingKeyMCertId)                    /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29SetPendingKeyMCertId(certId)                       (Dcm_SingletonContext.Diag.Services.Svc29.PendingKeyMCertId = (certId))         /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29GetPendingCsmJobId()                               (Dcm_SingletonContext.Diag.Services.Svc29.PendingCsmJobId)                      /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29SetPendingCsmJobId(jobId)                          (Dcm_SingletonContext.Diag.Services.Svc29.PendingCsmJobId = (jobId))            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29GetSignatureVerifyResult()                         (Dcm_SingletonContext.Diag.Services.Svc29.SignatureVerifyResult)                /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29GetLengthAsyncCbk()                                (Dcm_SingletonContext.Diag.Services.Svc29.LengthAsyncCbk)                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29SetLengthAsyncCbk(length)                          (Dcm_SingletonContext.Diag.Services.Svc29.LengthAsyncCbk = (length))            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29GetLengthChallengeSwapBuffer()                     (Dcm_SingletonContext.Diag.Services.Svc29.LengthChallengeSwapBuffer)            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29SetLengthChallengeSwapBuffer(length)               (Dcm_SingletonContext.Diag.Services.Svc29.LengthChallengeSwapBuffer = (length)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29GetCbkProcessingState()                            (Dcm_SingletonContext.Diag.Services.Svc29.CbkProcessingState)                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29SetCbkProcessingState(state)                       (Dcm_SingletonContext.Diag.Services.Svc29.CbkProcessingState = (state))         /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29SetNextCbkProcessingState()                        (++Dcm_Svc29GetCbkProcessingState())                                            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29GetBufferHdl()                                     (Dcm_NetGetProtObjOfConnection(Dcm_NetGetConnHdlOfRxPduId(Dcm_Svc29GetRxPduId()))->RxTxBufferRef) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29GetRxPduId()                                       (Dcm_SingletonContext.Diag.Services.Svc29.RxPduId)                              /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29SetRxPduId(id)                                     (Dcm_SingletonContext.Diag.Services.Svc29.RxPduId = (id))                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# define Dcm_Svc29SetOwnershipRequestExpected()                      (Dcm_SingletonContext.Diag.Services.Svc29.OwnershipRequestExpected = TRUE)      /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29ResetSequence()                                    (Dcm_SingletonContext.Diag.Services.Svc29.OwnershipRequestExpected = FALSE)     /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29IsOwnershipRequestExpected()                       (Dcm_SingletonContext.Diag.Services.Svc29.OwnershipRequestExpected == TRUE)     /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# define Dcm_Svc29IsCbkStateActive(state)                            (Dcm_Svc29GetCbkProcessingState() == (state))                                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29IsAsyncCsmJobActive()                              (Dcm_Svc29IsCbkStateActive(DCM_SVC29_CBK_PROC_STATE_GENERATE_CHALLENGE) || Dcm_Svc29IsCbkStateActive(DCM_SVC29_CBK_PROC_STATE_SIGN_CHALLENGE) || Dcm_Svc29IsCbkStateActive(DCM_SVC29_CBK_PROC_STATE_VERIFY_POOW)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29IsAsyncKeyMJobActive()                             (Dcm_Svc29IsCbkStateActive(DCM_SVC29_CBK_PROC_STATE_VERIFY_CERT))               /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif /* (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
# define Dcm_Svc2ASchdGetFreeSpace()                                 ((Dcm_Svc2ASchdItemHandleMemType)(DCM_SVC_2A_SCHEDULER_SIZE - Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc2AGetSchedulingTimeOfEntry(pSchedTableEntry)         (Dcm_CfgSvc2ASchdRateTime[(pSchedTableEntry)->Rate & DCM_SVC2A_RATE_TYPE_MASK]) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
# define Dcm_Svc2AIsPeriodicDid(did)                                 ((((uint16)(did)) & 0xFF00u) == 0xF200u)                                        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc2AMakePeriodicDid(didLoByte)                         (Dcm_UtiMake16Bit((uint8)0xF2u, (didLoByte)))                                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc2AMakeSchdRateFromUdsRate(udsRate)                   (Dcm_Svc2ASchedRateMemType)((udsRate)-1u)                                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# define Dcm_Svc2CIsDidSrcItem(srcItemIdx)                           (Dcm_UtiGenericBitSetTestBit(Dcm_Svc2CNvMData.Sequencer,(srcItemIdx)))          /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc2CSetDidSrcItem(srcItemIdx)                          (Dcm_UtiGenericBitSetSetBit(Dcm_Svc2CNvMData.Sequencer,(srcItemIdx)))           /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc2CSetMemSrcItem(srcItemIdx)                          (Dcm_UtiGenericBitSetClrBit(Dcm_Svc2CNvMData.Sequencer,(srcItemIdx)))           /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# define Dcm_Svc2CGetSrcItemIndex(dynDidHandle, offset)              ((Dcm_CfgDidMgrDynDidSrcItemIdxMemType)(Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle) + (offset))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# define Dcm_Svc2CIsDynDidDefined(dynDidHandle)                      (Dcm_Svc2CGetItem(dynDidHandle)->Count != 0u)                                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc2CIsDidDefined(pDidInfo)                             ((!Dcm_DidMgrIsOpSupported((pDidInfo), DCM_DIDMGR_OP_DEFINE)) || Dcm_Svc2CIsDynDidDefined((Dcm_CfgDidMgrDynDidHandleMemType)((pDidInfo)->OpRef))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc2CGetNetBufferSize(pThreadContext)                   ((Dcm_NetGetBufferInfo(Dcm_DiagGetTranspObj(pThreadContext)->BufferHdl)->Size)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
# define Dcm_Svc2FSetDidActive(ioDidHdl)                             (Dcm_UtiGenericBitSetSetBit(Dcm_SingletonContext.Diag.Services.Svc2F.ActiveIoDids,(ioDidHdl))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_34_SUPPORT_ENABLED == STD_ON)
/*! ProcessRequestDownoad is called */
# define Dcm_Svc34ProcessRequestDownloadWrapper                      DCM_PROCESS_REQUEST_DOWNLOAD                                                    /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# define DCM_FBL_DATA_IDENTIFIER                                     (0x40u)   /* parameter maxNumberOfBlockLength in the response of service 0x34 always has a size of 4 bytes independent of the value*/
#endif /* (DCM_SVC_34_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_36_SUPPORT_ENABLED == STD_ON)
/*! ProcessRequestDownoad is called */
# define Dcm_Svc36ProcessTransferDataWriteWrapper                    DCM_PROCESS_TRANSFER_DATA_WRITE                                                 /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif /* (DCM_SVC_36_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_37_SUPPORT_ENABLED == STD_ON)
/*! ProcessRequestDownoad is called */
# define Dcm_Svc37ProcessRequestTransferExitWrapper                  DCM_PROCESS_REQUEST_TRANSFER_EXIT                                               /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif /* (DCM_SVC_37_SUPPORT_ENABLED == STD_ON) */

/**********************************************************************************************************************
 *  LOCAL DATA TYPES AND STRUCTURES
 *********************************************************************************************************************/
#if (DCM_FBLMGR_SUPPORT_ENABLED == STD_ON)
/*! Download control state */
struct DCM_FBLMGRCONTEXTTYPE_TAG
{
  Dcm_FblMgrMemBlockType              MemoryBlock;              /*! Address, length and MID */
  Dcm_FblMgrBlockLengthType           MaxBlockLength;           /*!< Maximum number of block length */
  Dcm_FblMgrBlockSequenceCounterType  BlockSequenceCounterOld;  /*!< Old block sequence counter */
  boolean                             Start;                    /*!< Specifies whether an Downoad waits for the first block) */
  Dcm_FblMgrDownloadStateType         DownloadState;            /*!< Current state of the download process */
};
typedef struct DCM_FBLMGRCONTEXTTYPE_TAG Dcm_FblMgrContextType;
#endif /* (DCM_FBLMGR_SUPPORT_ENABLED == STD_ON) */
typedef P2CONST(Dcm_CfgNetBufferInfoType, TYPEDEF, DCM_CONST_PBCFG) Dcm_PbCfgNetBufferInfoPtrType;
typedef boolean Dcm_NetActiveDiagnosticType;

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/*! Periodic message transmitter control states */
struct DCM_NETPERIODICTXCONTEXTTYPE_TAG
{
  DCM_PB_RAM_DATA_DECL(Dcm_NetPeriodicTxObjectType, TxObject, DCM_NET_MAX_NUM_PERIODIC_TX_OBJ) /*!< Periodic message control objects */
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  volatile Dcm_TmrTimerCntrMemType DelayTimer[DCM_NET_DELAY_BULK_TRANSMISSION]; /*!< Array of delay timers that assure gap times between periodic DIDs */
# endif
  uint16                           ClientSrcAddr;    /*!< Client source address. Required only when generic connection is used */
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  Dcm_CfgNetPTxObjHandleMemType    DelayCntr;        /*!< Number of remaining messages that can be dispatched before a delay is required */
  uint8                            NextDelayTimer;   /*!< Index of next delay timer to use */
  uint8                            FastestRate;      /*!< The fastest rate in which periodic DIDs are currently scheduled */
# endif
  Dcm_NetConnRefMemType            ConnHdlInUse;      /*!< Current owner (diagnostic client) of the periodic transmitter */
  Dcm_CfgNetPTxObjHandleMemType    NextTxObjectHdl;  /*!< Pointer to the next periodic message to be sent. Scope is only the current periodic transmitter owners list of periodic messages */
  Dcm_CfgNetPTxObjHandleMemType    TxObjectSentCntr; /*!< Keeps track of the already sent periodic messages. Scope is only the current periodic transmitter owners list of periodic messages */
};
typedef struct DCM_NETPERIODICTXCONTEXTTYPE_TAG Dcm_NetPeriodicTxContextType;

typedef P2VAR(Dcm_NetPeriodicTxObjectType, TYPEDEF, DCM_RAM_PBCFG) Dcm_NetPeriodicTxObjectPtrType;
#endif

typedef P2VAR(Dcm_NetComMContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_NetComMContextPtrType;
typedef P2VAR(Dcm_NetBufferContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_NetBufferContextPtrType;

/*! Control states of the network sub-component */
struct DCM_NETCONTEXTTYPE_TAG
{
  DCM_PB_RAM_DATA_DECL(Dcm_NetBufferContextType, BufferContext, DCM_NET_NUM_BUFFERS)                  /*!< Control states of the USDT message buffers (main and additional) */
  DCM_PB_RAM_DATA_DECL(Dcm_NetTransportObjectType, TransportObject, DCM_NET_MAX_NUM_TRANSP_OBJECTS)   /*!< Transport objects for simultaneous servicing of multiple clients */
  DCM_PB_RAM_DATA_DECL(Dcm_NetComMContextType, ComMContext, DCM_NET_MAX_NUM_COMM_CHANNELS)            /*!< Control states of ComM status notifications per DCM related com-channel (i.e. channel on which DCM communicates with a client */
#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
  Dcm_NetPeriodicTxContextType  PeriodicTxContext;                                                    /*!< Composition relation to the periodic message transmitter */
#endif
  DCM_PB_RAM_DATA_DECL(Dcm_CfgNetTObjHandleMemType, ConnHdl2TObjIdMap, DCM_NET_MAX_NUM_CONNECTIONS)   /*!< A map of type <key = connectionHdl, value = TransportObject>. Used for fast transport object allocation */
#if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
  DCM_PB_RAM_DATA_DECL(Dcm_CommunicationModeType, ComCtrlChannels, DCM_NET_MAX_NUM_ALL_COMM_CHANNELS) /*!< Communication state [Rx/Tx][On/Off] of each ComM channel known to DCM */
#endif
  Dcm_NetProtRefMemType         ActiveProtocol;                                                       /*!< The protocol handle last activated */
  Dcm_NetConnRefMemType         NumActiveConnections;                                                 /*!< Current number of simultaneously serviced clients/connections */
  Dcm_NetConnRefMemType         SessionConnection;                                                    /*!< Owner (client) of the non-default session last started */
  uint16                        SessionClientSrcAddr;                                                 /*!< Source address of client which started the non-default session */
  Dcm_NetActiveDiagnosticType   ActiveDiagnostic;                                                     /*!< Guard for prevention of DCMs automatic ComM diag-activate signal notification (this state is managed by the application) */
#if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
  boolean                       RxAllowed;                                                            /*!< Guard for global blocking of any request reception */
#endif
  boolean                       KeepAlive;                                                            /*!< Guard for prevention of diag-inactive notifications from DCM to ComM (e.g. in the default-session) */
};
typedef struct DCM_NETCONTEXTTYPE_TAG Dcm_NetContextType;
typedef P2CONST(Dcm_CfgDiagServiceInfoType, TYPEDEF, DCM_CONST)   Dcm_CfgDiagServiceInfoPtrType;
#if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
/*! DTC setting control states */
struct DCM_MODECTRLDTCSETTINGCONTEXTTYPE_TAG
{
# if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
  uint32                             DTCGroup;               /*!< The DTC group associated with the disabled DTC setting state */
# endif
  Rte_ModeType_DcmControlDtcSetting  Mode;                   /*!< Current DTC setting state (ENABLEDTCSETTING, DISABLEDTCSETTING) */
  uint8                              LastDisableDTCClientID; /*!< ClientID that was last used to disable DTC setting */
};
typedef struct DCM_MODECTRLDTCSETTINGCONTEXTTYPE_TAG Dcm_ModeCtrlDtcSettingContextType;
#endif

/*! Control data of the mode manager sub-component */
struct DCM_MODECONTEXTTYPE_TAG
{
#if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
  Dcm_ModeCtrlDtcSettingContextType CtrlDtcSetting; /*!< DTC setting mode management control data */
#else
  uint8 spare;                                      /*!< Reserved unused place for future extensions */
#endif
};
typedef struct DCM_MODECONTEXTTYPE_TAG Dcm_ModeContextType;
/*! Single timer runtime data */
struct DCM_TMRTIMERCONTEXTTYPE_TAG
{
  volatile Dcm_TmrTimerCntrMemType  Timer;         /*!< Remaining time of all running system timers */
           Dcm_TmrTimerIdMemType    TimerInfoRef;  /*!< Reference to Dcm_TmrTimerInfo[] */
};
typedef struct DCM_TMRTIMERCONTEXTTYPE_TAG Dcm_TmrTimerContextType;
typedef P2VAR(Dcm_TmrTimerContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_TmrTimerContextPtrType;
typedef P2CONST(Dcm_TmrTimerContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_TmrTimerContextConstPtrType;

/*! Control data of the timer sub-component */
struct DCM_TMRCONTEXTTYPE_TAG
{
  volatile Dcm_TmrMaskMemType       ControlMask;                               /*!< Control bit mask for all configured system timers */
           Dcm_TmrTimerContextType  TimerContext[DCM_TMR_NUM_TIMER_CONTEXTS];  /*!< Runtime data of each available timer */
};
typedef struct DCM_TMRCONTEXTTYPE_TAG Dcm_TmrContextType;

typedef uint8 Dcm_TmrTimerAttributeType;
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_CfgRidMgrInfoHandleOptType, AUTOMATIC, DCM_VAR_NOINIT) Dcm_CfgRidMgrInfoHandlePtrType;
typedef P2VAR(Dcm_CfgRidMgrOpHandleOptType, TYPEDEF, DCM_VAR_NOINIT) Dcm_CfgRidMgrOpHandlePtrType;
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
typedef uint8        Dcm_TskTaskPrioMemType;
typedef uint8_least  Dcm_TskTaskPrioOptType;

typedef uint8        Dcm_TskTaskAttributeType;
#if (DCM_TSK_TASK_FLAG_SUPPORT_ENABLED == STD_ON)
typedef uint8        Dcm_TskTaskFlagType;
#endif

#if (DCM_TSK_TRACING_ENABLED == STD_ON)
typedef Dcm_TskTaskIdMemType  Dcm_TskMgrTraceStackBaseType;
struct DCM_TSKMGRTRACESTACKTYPE_TAG
{
  Dcm_TskMgrTraceStackBaseType  Stack[DCM_TSK_NUM_PRIOS];  /*!< A stack of elements of a specific type */ \
  Dcm_UtiStackCntrType          StackTop;                  /*!< Pointer to the current top element of the stack */ \
};
/*! Stack with the running tasks (entry per task priority) */
typedef struct DCM_TSKMGRTRACESTACKTYPE_TAG Dcm_TskMgrTraceStackType;
#endif

/*! Single task runtime data */
struct DCM_TSKTASKCONTEXTTYPE_TAG
{
  Dcm_TskTaskEvMemType    TaskEvents;   /*!< Task related events */
#if (DCM_TSK_TASK_FLAG_SUPPORT_ENABLED == STD_ON)
  Dcm_TskTaskFlagType     TaskFlags;    /*!< Runtime status */
#endif
};
typedef struct DCM_TSKTASKCONTEXTTYPE_TAG Dcm_TskTaskContextType;
typedef volatile P2VAR(Dcm_TskTaskContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_TskTaskContextPtrType;

/*! Task scheduler (one per task priority) control data */
struct DCM_TSKSCHEDULERCONTEXTTYPE_TAG
{
  boolean SchdIsActive;  /*!< Activity state of scheduler (TRUE - scheduler has at least one active task, FALSE - scheduler is suspended) */
};
typedef struct DCM_TSKSCHEDULERCONTEXTTYPE_TAG Dcm_TskSchedulerContextType;
typedef volatile P2VAR(Dcm_TskSchedulerContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_TskSchedulerContextPtrType;

/*! Control states of the task manager sub-component */
struct DCM_TSKCONTEXTTYPE_TAG
{
  volatile Dcm_TskSchedulerContextType TaskScheduler[DCM_TSK_NUM_PRIOS];        /*!< Control data of each scheduler (one per priority) */
  volatile Dcm_TskTaskContextType      TaskContext[DCM_TSK_NUM_TASKS_CONTEXT];  /*!< Runtime data of each available task (priority independent) */
#if (DCM_TSK_TRACING_ENABLED == STD_ON)
  volatile Dcm_TskMgrTraceStackType    CurrentTaskPrioStack;                    /*!< Active task ID stack for tracing purposes (e.g. check whether a low prio task is interrupted by another one and which one or just see which task is active at a time) */
#endif
};
typedef struct DCM_TSKCONTEXTTYPE_TAG Dcm_TskContextType;
/*! Base type for the diagnostic service verification level */
typedef uint8 Dcm_DiagCheckLvlType;

/*! Function pointer prototype for a diagnostic service specific length getter */
typedef P2FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE, Dcm_DiagServiceLengthGetterFuncType) (
  Dcm_DiagSubServiceRefOptType pSubSvcRef  /* IN: Abstract (diagnostic service processor specific) sub-function handle */
  );
/*! Function pointer prototype for a diagnostic service with sub-function specific sequence checker */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DiagSubFuncSequenceCheckerFuncType) (
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_DiagSubServiceRefOptType pSubSvcRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#if (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
/*! Package with current communication and diagnostic variant selection (cached variant references) */
struct DCM_VARMANAGERCONTEXTTYPE_TAG
{
# if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
#  if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
  Dcm_CfgVarMgrBitSetBaseType    ActiveCfgVariants[Dcm_VarMgrBitSetCalcSize(DCM_VARMGR_NUM_CFG_VARIANTS)];  /*!< Contains all active CFG-criteria IDs */ /* PRQA S 1039 */ /* MD_Dcm_Rule1.2_1039 */
#  else
  Dcm_CfgVarMgrDiagVariantIdMemType  ActiveCfgVariantId; /*!< Contains the active CFG-criteria ID */
#  endif
# endif
# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
  Dcm_CfgVarMgrComVariantType    ActiveComVariant;      /*!< Points to the COM-criteria */
# endif
# if (DCM_VARMGR_MODE_POSTBUILD_ANY_ENABLED == STD_ON)
  Dcm_CfgVarMgrBridgeVariantType ActiveBridgeVariant;   /*!< Points to the COM-to-CFG-bridge information */
# endif
# if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
  Dcm_CfgVarMgrRamVariantType    ActiveRamVariant;      /*!< Points to the overall variant post-build-loadable RAM data */
  Dcm_CfgVarMgrRomVariantType    ActiveRomVariant;      /*!< Points to the overall variant post-build-loadable ROM data */
# endif
};
typedef struct DCM_VARMANAGERCONTEXTTYPE_TAG Dcm_VarManagerContextType;
#endif
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED == STD_ON)
/*! Service 0x19 paged-buffer updater dispatching item ID type */
typedef uint8 Dcm_Svc19SubUpdaterType;
# endif

typedef P2CONST(Dcm_CfgSvc19SubFuncInfoType, TYPEDEF, DCM_CONST)   Dcm_CfgSvc19SubFuncInfoPtrType;
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/*! Context for attempt counter handling */
struct DCM_SVC27CONTEXTTYPE_TAG
{
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
           uint32                   GetAttCntrEventMask;                            /*!< State of attempt counter read operations */
           uint32                   SetAttCntrEventMask;                            /*!< State of attempt counter write operations */
# endif
           uint32                   ReloadMask;                                     /*!< Infinite delay timer mask */
  volatile Dcm_TmrTimerCntrMemType  DelayTime[DCM_SVC_27_NUM_DELAY_TIMERS];         /*!< Array of delay timers for UUDT messages */
           uint8                    AttemptCount[DCM_SVC_27_NUM_ATTEMPT_COUNTERS];  /*!< Array of attempt counters */
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
           Dcm_OpStatusType         GetAttOpStatus;                                 /*!< Operation state of attempt counter read operation */
           Dcm_OpStatusType         SetAttOpStatus;                                 /*!< Operation state of attempt counter write operation */
# endif
           uint8                    SeedLevel;                                      /*!< Last requested security level for which a seed was sent (0 = invalid (no seed) -> 1..7F - active seed) */
};
typedef struct DCM_SVC27CONTEXTTYPE_TAG Dcm_Svc27ContextType;

typedef P2CONST(Dcm_CfgSvc27SecLevelInfoType, TYPEDEF, DCM_CONST)  Dcm_CfgSvc27SecLevelInfoPtrType;
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
typedef P2CONST(Dcm_CfgSvc29SubFuncInfoType, TYPEDEF, DCM_CONST) Dcm_CfgSvc29SubFuncInfoPtrType;
typedef uint8 Dcm_Svc29ProcessingState;

/*! Context for request sequence and async callback handling */
struct DCM_SVC29CONTEXTTYPE_TAG
{
  KeyM_CertificateIdType        PendingKeyMCertId;                                    /*!< Key Manager pending certificate ID */
  uint32                        PendingCsmJobId;                                      /*!< Crypto Service Manager pending Job ID */
  Crypto_VerifyResultType       SignatureVerifyResult;                                /*!< Store result for signature verify */
  uint32                        LengthAsyncCbk;                                       /*!< Length storage for async operations */
  uint16                        LengthChallengeSwapBuffer;                            /*!< Length of the generated challenge data */
  uint8                         ChallengeSwapBuffer[DCM_AUTHMGR_CHALLENGE_MAX_SIZE];  /*!< Pointer to generated challenge data */
  Dcm_Svc29ProcessingState      CbkProcessingState;                                   /*!< Asynchronous callback processing state */
  PduIdType                     RxPduId;                                              /*!< Pdu ID associated with the sequence flag */
  boolean                       OwnershipRequestExpected;                             /*!< Last subfunction that processed was 01 or 02 (0 = was failed or not processed) */
  KeyM_CertificateStatusType    KeyMCbkResult;                                        /*!< Key Manager callback result */
  Crypto_ResultType             CsmCbkResult;                                         /*!< Crypto Service Manager callback result */
};
typedef struct DCM_SVC29CONTEXTTYPE_TAG Dcm_Svc29ContextType;
#endif /* (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
typedef uint8       Dcm_Svc2ASchedRateMemType;
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
typedef uint8_least Dcm_Svc2ASchedRateOptType;
# endif
typedef uint8       Dcm_Svc2ASchdItemHandleMemType;
typedef uint8_least Dcm_Svc2ASchdItemHandleOptType;

/*! Service 0x2A scheduler entry data */
struct DCM_SVC2ASCHDENTRYTYPE_TAG
{
           Dcm_DidMgrDidInfoContextType DidContext; /*!< Information about the scheduled DID */
  volatile Dcm_TmrTimerCntrMemType      Timer;      /*!< Timer for the periodic transmission */
           Dcm_Svc2ASchedRateMemType    Rate;       /*!< Requested transmission rate */
};
typedef struct DCM_SVC2ASCHDENTRYTYPE_TAG Dcm_Svc2ASchdEntryType;

typedef P2VAR(Dcm_Svc2ASchdEntryType, TYPEDEF, DCM_VAR_NOINIT) Dcm_Svc2ASchdEntryPtrType;
typedef P2CONST(Dcm_Svc2ASchdEntryType, TYPEDEF, DCM_VAR_NOINIT) Dcm_Svc2ASchdEntryConstPtrType;

/*! Service 0x2A scheduler data */
struct DCM_SVC2ASCHEDULERTYPE_TAG
{
  Dcm_Svc2ASchdEntryType          Table[DCM_SVC_2A_SCHEDULER_SIZE];        /*!< Table of scheduled DIDs */
  Dcm_DidMgrDidOpTypeContextType  DidOpTypeContext;                        /*!< Information about operations on current DID */
  Dcm_CfgNetBufferSizeMemType     WriteIndex;                              /*!< Number of bytes that were already read */
  Dcm_Svc2ASchdItemHandleMemType  NumActiveEntries;                        /*!< Number of active entries in scheduler table */
  Dcm_Svc2ASchdItemHandleMemType  CurrentEntryIndex;                       /*!< Scheduler table entry that is currently processed */
  Dcm_CfgNetPTxObjHandleMemType   MsgTxHandle;                             /*!< Index of current tx object */
  Dcm_OpStatusType                OpStatus;                                /*!< Current operation status */
};
typedef struct DCM_SVC2ASCHEDULERTYPE_TAG Dcm_Svc2ASchedulerType;
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/*! Context for handling of periodic transmision */
struct DCM_SVC2ACONTEXTTYPE_TAG
{
  Dcm_Svc2ASchedulerType Scheduler;                        /*!< Scheduler for periodic transmission */
};
typedef struct DCM_SVC2ACONTEXTTYPE_TAG Dcm_Svc2AContextType;
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/*! Context for the processing of a specific DynDID */
struct DCM_SVC2CDYNDIDPROCESSCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidInfoContextType         SrcDidContext;    /*!< Info context of the currently requested source DID */
  Dcm_DidMgrDidOpTypeContextType       DidOpTypeContext; /*!< Operation type context */
  Dcm_CfgDidMgrDynDidSrcItemIdxMemType ItemInProgress;   /*!< Index of the currently processed source item */
  Dcm_CfgDidMgrDynDidSrcItemIdxMemType ItemToStop;       /*!< Index of the item after the last source item */
};
typedef struct DCM_SVC2CDYNDIDPROCESSCONTEXTTYPE_TAG Dcm_Svc2CDynDidProcessContextType;

typedef P2VAR(Dcm_Svc2CDynDidProcessContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_Svc2CDynDidProcessContextPtrType;

/*! Context for the handling of the read access to a DynDID */
struct DCM_SVC2CDYNDIDACCESSCONTEXT_TAG
{
  Dcm_Svc2CDynDidProcessContextType ProcessContext[DCM_SVC_2C_NUM_PROCESS_CONTEXTS]; /*!< Process contexts for DynDIDs */
  Dcm_CfgDidMgrDynDidHandleMemType  DynDidHandleInUse;                               /*!< Handle of currently processed DynDID */
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
  Dcm_MsgItemType                   Buffer[DCM_SVC_2C_READ_BUFFER_SIZE];             /*!< DynDID read buffer */
# endif
};
typedef struct DCM_SVC2CDYNDIDACCESSCONTEXT_TAG Dcm_Svc2CDynDidReadAccessContext;
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/*! Context for the handling of DynDIDs */
struct DCM_SVC2CCONTEXTTYPE_TAG
{
  Dcm_Svc2CDynDidReadAccessContext   DynDidAccessContext; /*!< Access context of the DynDID */
  Dcm_MsgLenType                     ReadIndex;           /*!< Number of bytes that are already read */
};
typedef struct DCM_SVC2CCONTEXTTYPE_TAG Dcm_Svc2CContextType;

typedef P2CONST(Dcm_CfgSvc2CSubFuncInfoType, TYPEDEF, DCM_CONST) Dcm_CfgSvc2CSubFuncInfoPtrType;
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/*! Context for the handling of IODIDs */
struct DCM_SVC2FCONTEXTTYPE_TAG
{
  Dcm_DiagDataContextType DataContext;                                                /*!< Data context */
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
  Dcm_UtiBitSetBaseType   ActiveIoDids[Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS)]; /*!< Bit masks of active IO operations */
  boolean                 HasAnyActiveIoDid;                                          /*!< Active IODID operation flag */
# endif
};
typedef struct DCM_SVC2FCONTEXTTYPE_TAG Dcm_Svc2FContextType;
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)
/*! Context for the handling of RIDs */
struct DCM_SVC31CONTEXTTYPE_TAG
{
  uint8 IntegrityBuffer[DCM_SVC_31_INTEGRITY_BUFFER_SIZE];  /*!< Buffer for copy of input or output data */
};
typedef struct DCM_SVC31CONTEXTTYPE_TAG Dcm_Svc31ContextType;
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */

#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_AUTHMGR_SET_DEAUTH_ROLE_ENABLED == STD_ON)
/*! Pending data for processing of Dcm_SetDeauthenticatedRole() */
struct DCM_AUTHMGRPENDINGROLETYPE_TAG
{
  uint32                    ConnectionMask;                        /*!< Bit mask for the connetionId for which Dcm_SetDeauthenticatedRole() was called */
  Dcm_CfgStateGroupMemType  Role[DCM_CFGAUTHMGRNETCONNINFO_SIZE];  /*!< Pending role from Dcm_SetDeauthenticatedRole() */
};
typedef struct DCM_AUTHMGRPENDINGROLETYPE_TAG Dcm_AuthMgrPendingRoleType;
# endif

/*! Authentication manager context */
struct DCM_AUTHMGRCONTEXTTYPE_TAG
{
# if (DCM_AUTHMGR_SET_DEAUTH_ROLE_ENABLED == STD_ON)
  Dcm_AuthMgrPendingRoleType    PendingData;                                 /*!< Pending data for processing of Dcm_SetDeauthenticatedRole() */
# endif
  Dcm_AuthMgrTimerExpiredMaskType  TimerExpiredMask;                         /*!< A flag to store expired timers for authentication sessions */
# if (DCM_AUTHMGR_DEFAULT_SESSION_TIMEOUT_ENABLED == STD_ON)
  Dcm_AuthMgrTimerType             DelayTime[DCM_AUTHMGR_NUM_DELAY_TIMERS];  /*!< Array of delay timers for authentication sessions */
# endif
# if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
  boolean                          GrantGlobalAccess;                        /*!< Global access flag */
# endif
};
typedef struct DCM_AUTHMGRCONTEXTTYPE_TAG Dcm_AuthMgrContextType;
#endif /* (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/*! Control data of the unsolicited response at ECU start-up task */
struct DCM_STARTUPRESPONSECONTEXTTYPE_TAG
{
  Dcm_ProgConditionsType          ProgConditions;                             /*!< Dedicated programming condition storage in case a parallel request needs the repeater proxy pool */
  Dcm_MsgItemType                 ResBuffer[DCM_DIAG_START_UP_FBL_RES_SIZE];  /*!< Dedicated response buffer for the final response */
  boolean                         IsResponseRequired;                         /*!< Response-required information extracted from the pre-boot time context */
  Dcm_NetTransmissionResultType   TxStatus;                                   /*!< Transports the response transmission result to the Dcm_DiagTaskFblRes() */
  sint8                           SessStateRef;                               /*!< Diagnostic session index (values <0 mean no session transition). Use sint8 since no more than 127 sessions are possible */
  Dcm_NetConnRefMemType           ConnHdl;                                    /*!< Connection handle on which the unsolicited response was sent for post-processing purposes */
};
typedef struct DCM_STARTUPRESPONSECONTEXTTYPE_TAG Dcm_DiagStartUpResContextType;
#endif

#if (DCM_DIAG_SVC_CONTEXT_ENABLED == STD_ON)
/*! Storage of all diagnostic services contexts that shall be kept in memory not only during a diagnostic request but during the whole ECU operation cycle */
struct DCM_DIAGSERVICESCONTEXTTYPE_TAG
{
# if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc27ContextType  Svc27;  /*!< Storage place for all "SecurityAccess" data */
# endif
# if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc29ContextType  Svc29;  /*!< Storage place for all "Authentication" data */
# endif
# if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2AContextType  Svc2A;  /*!< Storage place for all "ReadDataByPeriodicId" data */
# endif
# if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2CContextType  Svc2C;  /*!< Storage place for all "DynamicallyDefineIdentifier" data */
# endif
# if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2FContextType  Svc2F;  /*!< Storage place for all "IOControlByIdentifier" data */
# endif
# if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc31ContextType  Svc31;  /*!< Storage place for all "RoutineControl" data */
# endif
};
typedef struct DCM_DIAGSERVICESCONTEXTTYPE_TAG Dcm_DiagServicesContextType;
#endif

#if (DCM_DIAG_SPECIFIC_CAUSE_CODE_ENABLED == STD_ON)
/*! Control data of the specific cause code */
struct DCM_CAUSECODECONTEXTTYPE_TAG
{
  Dcm_SpecificCauseCodeType CauseCode;      /*!< The specific cause code */
  boolean                   SendCauseCode;  /*!< Flag to send the CauseCode */
};
typedef struct DCM_CAUSECODECONTEXTTYPE_TAG Dcm_DiagCauseCodeContextType;
#endif

#if (DCM_DIAG_CONTEXT_ENABLED == STD_ON)
/*! Control intanced data of the sub-component diagnostic kernel */
struct DCM_DIAGCONTEXTTYPE_TAG
{
# if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
  Dcm_DiagStartUpResContextType  StartUpFbl;        /*!< The global data of the unsolicited response task (Dcm_DiagTaskFblRes()) */
# endif
# if (DCM_DIAG_SVC_CONTEXT_ENABLED == STD_ON)
  Dcm_DiagServicesContextType    Services;          /*!< Diagnostic service processors "long term" memory */
# endif
# if (DCM_DIAG_SPECIFIC_CAUSE_CODE_ENABLED == STD_ON)
  Dcm_DiagCauseCodeContextType   CauseCodeContext;  /*!< Context of the specific cause code */
# endif
# if(DCM_STATE_SECURITY_BYPASS_ENABLED == STD_ON)
  boolean                        IsSecurityBypass;
# endif
};
typedef struct DCM_DIAGCONTEXTTYPE_TAG Dcm_DiagContextType;
#endif

/*! Function pointer prototype for a system timer related time-out notification */
typedef P2FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE, Dcm_TmrTimeoutFuncType) (
  Dcm_ThreadIdMemType threadId  /* IN: Active thread */
  );

/*! Single timer configuration data */
struct DCM_TMRTIMERINFOTYPE_TAG
{
  Dcm_TmrTimeoutFuncType     OnTimeoutFunc;    /*!< Pointer to the timeout notification handler of kind Dcm_OnTimeout<TimerName>() (e.g. Dcm_OnTimeoutP2()) */
  Dcm_TmrTimerAttributeType  Attributes;       /*!< Configuration attributes (Valid values: DCM_TSK_ATR_*) */
  Dcm_TmrTimerIdMemType      TimerContextRef;  /*!< Reference to Dcm_SingletonContext.TimerMgr.TimerContext[] */
};
typedef struct DCM_TMRTIMERINFOTYPE_TAG Dcm_TmrTimerInfoType;
typedef P2CONST(Dcm_TmrTimerInfoType, TYPEDEF, DCM_CONST) Dcm_TmrTimerInfoPtrType;
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
/* Read port operations */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadSyncType)(
  Dcm_MsgType data
  );

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadAsyncType)(
  Dcm_OpStatusType opStatus,
  Dcm_MsgType data
  );

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadSRType)(
  Dcm_DiagDataContextPtrType pDataContext
  );

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadPagedDidType)(
  Dcm_OpStatusType opStatus,
  Dcm_MsgType data,
  Dcm_DidMgrDidLengthPtrType length
  );
# endif

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadDidRangeType)(
  uint16 did,
  Dcm_MsgType data,
  Dcm_OpStatusType opStatus,
  Dcm_DidMgrDidLengthPtrType length,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadWrapperAsyncType)(
  uint16 did,
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext
  );

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadWrapperSyncType)(
  Dcm_DiagDataContextPtrType pDataContext
  );

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadVidType)(
  Dcm_OpStatusType opStatus,
  Dcm_MsgType data
# if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
  ,Dcm_Uint8VarDataPtrType Length
# endif
  );

/* Read Length port operations */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadDidRangeLengthType)(
  uint16 did,
  Dcm_OpStatusType opStatus,
  Dcm_DidMgrDidLengthPtrType Length
  );

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadLengthSyncType)(
  Dcm_DidMgrDidLengthPtrType Length
  );

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadLengthAsyncType)(
  Dcm_OpStatusType opStatus,
  Dcm_DidMgrDidLengthPtrType Length
  );

/* Read CheckCondition port operations */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadCheckCondSyncType)(
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadCheckCondAsyncType)(
  Dcm_OpStatusType opStatus,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/* ScalingInformation port operations */
# if (DCM_DIDMGR_OPTYPE_GETSCALINGINFO_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncGetScalingInfoSyncType)(
  Dcm_MsgType data,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncGetScalingInfoAsyncType)(
  Dcm_OpStatusType opStatus,
  Dcm_MsgType data,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_DIDMGR_OPTYPE_WRITE_ENABLED == STD_ON)
/* Write port operations */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteNLenSyncNResErrorType)(
  Dcm_MsgType data,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteNLenAsyncNResErrorType)(
  Dcm_MsgType data,
  Dcm_OpStatusType opStatus,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteLenAsyncNResErrorType)(
  Dcm_MsgType data,
  Dcm_DidMgrDidLengthType Length,
  Dcm_OpStatusType opStatus,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteLenSyncNResErrorType)(
  Dcm_MsgType data,
  Dcm_DidMgrDidLengthType Length,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteNLenSyncNResNErrorType)(
  Dcm_MsgType data
  );
# endif

# if (DCM_DIDMGR_OPTYPE_WRITE_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteDidRangeType)(
  uint16 did,
  Dcm_MsgType data,
  Dcm_OpStatusType opStatus,
  Dcm_DidMgrDidLengthType Length,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif
# if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
/* IsAvailable range DID port operations */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncRangeIsAvailDidType)(
  uint16 did,
  Dcm_OpStatusType opStatus,
  P2VAR(Dcm_DidSupportedType, AUTOMATIC, DCM_VAR_NOINIT) isAvailable
  );
# endif

# if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/* IO Control port operations */

/* No CEMR */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenSyncNCemrErrorType)(
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenASyncNCemrErrorType)(
  Dcm_OpStatusType opStatus,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenSyncNCemrErrorType)(
  Dcm_ReadOnlyMsgType data,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncNCemrErrorType)(
  Dcm_ReadOnlyMsgType data,
  Dcm_DidMgrDidLengthType Length,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenASyncNCemrErrorType)(
  Dcm_ReadOnlyMsgType data,
  Dcm_OpStatusType opStatus,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenASyncNCemrErrorType)(
  Dcm_ReadOnlyMsgType data,
  Dcm_DidMgrDidLengthType Length,
  Dcm_OpStatusType opStatus,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
/* CEMR 8Bit */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenSyncCemr8ErrorType)(
  uint8 cemr,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenASyncCemr8ErrorType)(
  Dcm_OpStatusType opStatus,
  uint8 cemr,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenSyncCemr8ErrorType)(
  Dcm_ReadOnlyMsgType data,
  uint8 cemr,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncCemr8ErrorType)(
  Dcm_ReadOnlyMsgType data,
  Dcm_DidMgrDidLengthType Length,
  uint8 cemr,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenASyncCemr8ErrorType)(
  Dcm_ReadOnlyMsgType data,
  Dcm_OpStatusType opStatus,
  uint8 cemr,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenASyncCemr8ErrorType)(
  Dcm_ReadOnlyMsgType data,
  Dcm_DidMgrDidLengthType Length,
  Dcm_OpStatusType opStatus,
  uint8 cemr,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
/* CEMR 16Bit */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenSyncCemr16ErrorType)(
  uint16 cemr,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenASyncCemr16ErrorType)(
  Dcm_OpStatusType opStatus,
  uint16 cemr,
  Dcm_NegativeResponseCodePtrType ErrorCode);
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenSyncCemr16ErrorType)(
  Dcm_ReadOnlyMsgType data,
  uint16 cemr,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncCemr16ErrorType)(
  Dcm_ReadOnlyMsgType data,
  Dcm_DidMgrDidLengthType Length,
  uint16 cemr,
  Dcm_NegativeResponseCodePtrType ErrorCode);
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenASyncCemr16ErrorType)(
  Dcm_ReadOnlyMsgType data,
  Dcm_OpStatusType opStatus,
  uint16 cemr,
  Dcm_NegativeResponseCodePtrType ErrorCode);
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenASyncCemr16ErrorType)(
  Dcm_ReadOnlyMsgType data,
  Dcm_DidMgrDidLengthType Length,
  Dcm_OpStatusType opStatus,
  uint16 cemr,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
/* CEMR 32Bit */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenSyncCemr32ErrorType)(
  uint32 cemr,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenASyncCemr32ErrorType)(
  Dcm_OpStatusType opStatus,
  uint32 cemr,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenSyncCemr32ErrorType)(
  Dcm_ReadOnlyMsgType data,
  uint32 cemr,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncCemr32ErrorType)(
  Dcm_ReadOnlyMsgType data,
  Dcm_DidMgrDidLengthType Length,
  uint32 cemr,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenASyncCemr32ErrorType)(
  Dcm_ReadOnlyMsgType data,
  Dcm_OpStatusType opStatus,
  uint32 cemr,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenASyncCemr32ErrorType)(
  Dcm_ReadOnlyMsgType data,
  Dcm_DidMgrDidLengthType Length,
  Dcm_OpStatusType opStatus,
  uint32 cemr,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
/* CEMR NBit */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenSyncCemrNErrorType)(
  Dcm_ReadOnlyMsgType data,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenASyncCemrNErrorType)(
  Dcm_OpStatusType opStatus,
  Dcm_ReadOnlyMsgType data,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenSyncCemrNErrorType)(
  Dcm_ReadOnlyMsgType reqData,
  Dcm_ReadOnlyMsgType data,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncCemrNErrorType)(
  Dcm_ReadOnlyMsgType reqData,
  Dcm_DidMgrDidLengthType Length,
  Dcm_ReadOnlyMsgType data,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenASyncCemrNErrorType)(
  Dcm_ReadOnlyMsgType reqData,
  Dcm_OpStatusType opStatus,
  Dcm_ReadOnlyMsgType data,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenASyncCemrNErrorType)(
  Dcm_ReadOnlyMsgType reqData,
  Dcm_DidMgrDidLengthType Length,
  Dcm_OpStatusType opStatus,
  Dcm_ReadOnlyMsgType data,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)
/*! Routine operation function prototype with no request and response data */
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncNoParamsType)(
  Dcm_OpStatusType opStatus,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/*! Routine operation function prototype with only request data both with static length */
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncReqType)(
  Dcm_ReadOnlyMsgType data,
  Dcm_OpStatusType opStatus,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/*! Routine operation function prototype with request and response data with static length */
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncReqResType)(
  Dcm_ReadOnlyMsgType reqData,
  Dcm_OpStatusType opStatus,
  Dcm_MsgType resData,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/*! Routine operation function prototype with only response data with static length */
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncResType)(
  Dcm_OpStatusType opStatus,
  Dcm_MsgType data,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/*! Routine operation function prototype with only request data with dynamic length */
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncReqDynLenType)(
  Dcm_ReadOnlyMsgType data,
  Dcm_OpStatusType opStatus,
  Dcm_RidMgrRidLengthType Length,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/*! Routine operation function prototype with request data with dynamic length and response data with static length */
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncReqDynLenResType)(
  Dcm_ReadOnlyMsgType reqData,
  Dcm_OpStatusType opStatus,
  Dcm_MsgType resData,
  Dcm_RidMgrRidLengthType Length,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/*! Routine operation function prototype with request data with dynamic/static length and response data with dynamic length */
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncReqAnyLenResDynLenType)(
  Dcm_ReadOnlyMsgType reqData,
  Dcm_OpStatusType opStatus,
  Dcm_MsgType resData,
  Dcm_RidMgrRidLengthPtrType Length,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/*! Routine operation function prototype with response data with dynamic length */
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncResDynLenType)(
  Dcm_OpStatusType opStatus,
  Dcm_MsgType data,
  Dcm_RidMgrRidLengthPtrType Length,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/*! Generic routine operation function prototype which implementation will be generated depending on the RID configuration */
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncWrapperType)(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_RidMgrRidLengthPtrType Length,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
/*! Data container for data shared among all DCM threads */
struct DCM_SINGLETONCONTEXTTYPE_TAG
{
#if (DCM_DIAG_CONTEXT_ENABLED == STD_ON)
  Dcm_DiagContextType        Diag;        /*!< Diagnostic kernel sub-component per-instance memory */
#endif
  Dcm_NetContextType         Network;     /*!< Network sub-component shared memory */
  Dcm_TskContextType         TaskMgr;     /*!< System task manager sub-component shared memory */
  Dcm_TmrContextType         TimerMgr;    /*!< System timer manager sub-component shared memory */
  Dcm_StateContextType       StateMgr;    /*!< Diagnostic state manager sub-component shared memory */
#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
  Dcm_AuthMgrContextType     AuthMgr;     /*!< Authentication manager sub-component shared memory */
#endif
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
  Dcm_ModeContextType        ModeMgr;     /*!< Mode manager sub-component shared memory */
#endif
#if (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
  Dcm_VarManagerContextType  VarMgr;      /*!< Variant manager sub-component shared memory */
#endif
#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
  Dcm_RecoveryContextType    Recovery;    /*!< Recovery context containing the operation state and the recovery information */
#endif
#if (DCM_FBLMGR_SUPPORT_ENABLED == STD_ON)
  Dcm_FblMgrContextType      FblMgr;      /*!< Fbl manager sub-component shared memory */
#endif
};
typedef struct DCM_SINGLETONCONTEXTTYPE_TAG Dcm_SingletonContextType;
/*! Single task configuration data */
struct DCM_TSKTASKINFOTYPE_TAG
{
  Dcm_TskTaskFuncType      TskFunc;         /*!< Pointer to the task handler Dcm_<SubComp>Task<Name>() (e.g. Dcm_NetTaskRx()) */
  Dcm_TskTaskAttributeType TskAtr;          /*!< Configuration attributes (e.g. can be terminated, number of executions per Dcm_MainFunction() call etc.) */
  Dcm_TskTaskPrioMemType   TskPrio;         /*!< The priority of the task (e.g. DEFAULT, HIGH, LOW etc.) */
  Dcm_TskTaskEvMemType     NonKillEvents;   /*!< If a task is determined as a killable one (DCM_TSK_ATR_KILL_ALWAYS) here are kept all events that shall not be reset during task termination */
  Dcm_TskTaskIdMemType     TaskContextRef;   /*!< Reference to Dcm_SingletonContext.TaskMgr.TaskContext[] */
};
typedef struct DCM_TSKTASKINFOTYPE_TAG Dcm_TskTaskInfoType;

typedef P2CONST(Dcm_TskTaskInfoType, TYPEDEF, DCM_CONST) Dcm_TskTaskInfoPtrType;
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEMAPI_SVC_19_SETDTCFILTER_ENABLED == STD_ON)
/*! DEM filter configuration selector type */
typedef uint8 Dcm_Svc19DemSetFilterClassType;
# endif
# if (DCM_DEMAPI_SVC_19_GETDTCSTATUSAVAILABILITYMASK_ENABLED == STD_ON)
/*! DEM DTC status availability Mask pointer type */
typedef uint8 Dcm_Svc19DemDtcStatusAvailMaskType;
typedef P2VAR(Dcm_Svc19DemDtcStatusAvailMaskType, TYPEDEF, AUTOMATIC) Dcm_Svc19DemDtcStatusAvailMaskPtrType;
# endif
# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/*! Report DTC by status mask engine mask usage type */
typedef uint8 Dcm_Svc19DemSetFilterMaskUsageType;
# endif
# if (DCM_SVC_19_ABSTRACT_RECORD_ITER_ENABLED == STD_ON)
/*! Abstract DTC record iterator result type */
typedef uint8 Dcm_Svc19UtiRecordIterResultType;
# endif
# if (DCM_SVC_19_SETDTCFILTER_INFO_CLASS_ENABLED == STD_ON)
/*! Descriptor of a DEM filter configuration */
struct DCM_SVC19DEMDTCFILTERINFOTYPE_TAG
{
#  if (DCM_DEM_API_421_ENABLED == STD_ON)
  Dem_DTCKindType                Kind;             /*!< DTC kind */
#  endif
  Dem_DTCOriginType              Origin;           /*!< DTC origin */
  Dcm_DemFilterWithSeverityType  ConsiderSeverity; /*!< DTC severity */
};
typedef struct DCM_SVC19DEMDTCFILTERINFOTYPE_TAG Dcm_Svc19DemDtcFilterInfoType;
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/*! Function pointer prototype for a Get-Seed handler with Security-Access-Data-Record */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_Svc27OpFuncSeedWAdr)(
  Dcm_MsgType seed,
  Dcm_OpStatusType opStatus,
  Dcm_MsgType adr,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/*! Function pointer prototype for a Get-Seed handler without Security-Access-Data-Record */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_Svc27OpFuncSeedWoAdr)(
  Dcm_OpStatusType opStatus,
  Dcm_MsgType seed,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
typedef P2CONST(Dcm_CfgSvc28SubFuncInfoType, TYPEDEF, DCM_CONST)   Dcm_CfgSvc28SubFuncInfoPtrType;
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
typedef P2CONST(Dcm_CfgSvc85SubFuncInfoType, TYPEDEF, DCM_CONST)   Dcm_CfgSvc85SubFuncInfoPtrType;
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */

/**********************************************************************************************************************
 *  LOCAL FUNCTION DECLARATIONS
 *********************************************************************************************************************/
#define DCM_START_SEC_CODE
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MemMgrCheckMemoryRange()
 *********************************************************************************************************************/
/*! \brief          Validates memory range within a particular memory map.
 *  \details        -
 *  \param[in]      pMemBlock          The memory block descriptor for validation
 *  \param[in]      memOp              The memory block operation type
 *  \param[in]      pMemMapDescriptor  The the corresponding memory map to be searched in
 *  \param[out]     ErrorCode          The NRC
 *  \return         DCM_E_OK     - memory range is valid
 *  \return         DCM_E_NOT_OK - memory range validation failed (ErrorCode contains NRC)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrCheckMemoryRange(
  Dcm_MemMgrMemBlockConstPtrType pMemBlock,
  Dcm_MemMgrMemoryOpType memOp,
  Dcm_CfgMemMgrMemIdInfoConstPtrType pMemMapDescriptor,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_FBLMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_FblMgrParseMemStream()
 *********************************************************************************************************************/
/*! \brief          Validates the request memory ALFID.
 *  \details        -
 *  \param[in]      alfid         Requested ALFID byte
 *  \param[in,out]  pMsgContext   Current message context with the memory address and size byte stream
 *  \param[out]     pMemBlock     Interpreted memory block information
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            It shall be assured that the ALFID value matches the length of the data stream to be parsed.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_FblMgrParseMemStream(
  uint8 alfid,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_FblMgrMemBlockPtrType pMemBlock
  );

/**********************************************************************************************************************
 *  Dcm_FblMgrReset()
 *********************************************************************************************************************/
/*! \brief          Reset download data elements
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_FblMgrReset(void);
#endif /* (DCM_FBLMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidData_SupportedId()
 *********************************************************************************************************************/
/*! \brief          Read operation for a Supported OBD MID Mask.
 *  \details        -
 *  \param[in]      ObdMID         Supported OBD Monitor Id
 *  \param[in,out]  pDataContext   The pointer to the data context
 *  \return         DCM_E_OK       Read operation was successful
 *  \return         DCM_E_NOT_OK   Read operation was not successful
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            Obd MID is a supported MID (0x00, 0x20, 0x40,..)
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidData_SupportedId(
  uint8 ObdMID,
  Dcm_DiagDataContextPtrType pDataContext
  );
# endif

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidData_DataId()
 *********************************************************************************************************************/
/*! \brief          Read operation for a OBD MID.
 *  \details        Reads test result for given OBD MID
 *  \param[in]      ObdMID         OBD Monitor Id
 *  \param[in,out]  pDataContext   The pointer to the data context
 *  \return         DCM_E_OK       Read operation was successful
 *  \return         DCM_E_NOT_OK   Read operation was not successful
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            Obd MID is not a supported MID (0x00, 0x20, 0x40,..)
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidData_DataId(
  uint8 ObdMID,
  Dcm_DiagDataContextPtrType pDataContext
  );
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_AUTHMGR_DEFAULT_SESSION_TIMEOUT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrTimerStart()
 *********************************************************************************************************************/
/*! \brief          Sets the value of a specific connection idle timer.
 *  \details        Starts the base authentication idle connection timer.
 *  \param[in]      authInfoRef      The authentication info reference
 *  \param[in]      value            Timer value for the specific idle connection timer
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrTimerStart(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_AuthMgrTimerType value
  );

/**********************************************************************************************************************
 *  Dcm_AuthMgrTimerSet()
 *********************************************************************************************************************/
/*! \brief          Sets the value of a specific idle connection session timer.
 *  \details        -
 *  \param[in]      authInfoRef  The authentication info reference
 *  \param[in]      value        Timer value
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrTimerSet(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_AuthMgrTimerType value
  );
# endif

/**********************************************************************************************************************
 *  Dcm_AuthMgrSetConnAuthState()
 *********************************************************************************************************************/
/*! \brief          Sets the authentication state of a connection of the given index.
 *  \details        -
 *  \param[in]      authInfoRef  Index to the ConnAuthStates array
 *  \param[in]      value        New authentication state of connection
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrSetConnAuthState(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_AuthenticationStateType value
  );

# if(DCM_AUTHMGR_WHITELISTS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrGetWLContext()
 *********************************************************************************************************************/
/*! \brief          Get white lists for a connection.
 *  \details        -
 *  \param[in]      authInfoRef     Index to white lists array
 *  \param[out]     pWLContext      White list entries for a connection
 *  \param[out]     ErrorCode       Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrGetWLContext(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  CONSTP2VAR(Dcm_AuthMgrWLContextPtrType, AUTOMATIC, AUTOMATIC) pWLContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

/**********************************************************************************************************************
 *  Dcm_AuthMgrUpdateActiveRole()
 *********************************************************************************************************************/
/*! \brief          Authentication Manager update active role.
 *  \details        Sets the active role to a particular connection to the new authentication role argument.
 *  \param[in]      authInfoRef                Index to the ConnActiveRole array
 *  \param[in]      authRole                   The new authentication role
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrUpdateActiveRole(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_CfgStateGroupMemType authRole
  );

# if (DCM_AUTHMGR_DEFAULT_SESSION_TIMEOUT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrDetectIdleConnection()
 *********************************************************************************************************************/
/*! \brief          Detects an idle connection and deauthenticates it if necessary
 *  \details        -
 *  \param[in]      oldSession    The old session
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrDetectIdleConnection(
  Dcm_CfgStateGroupOptType oldSession
  );
# endif

/**********************************************************************************************************************
 *  Dcm_AuthMgrDeauthenticateIdleConn()
 *********************************************************************************************************************/
/*! \brief          Deauthenticates all idle connections
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrDeauthenticateIdleConn(
  void
  );

/**********************************************************************************************************************
 *  Dcm_AuthMgrSetAuthentication()
 *********************************************************************************************************************/
/*! \brief          Performs an authentication state transition.
 *  \details        -
 *  \param[in]      authInfoRef    The authentication information reference
 *  \param[in]      authState      The new authentication state
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrSetAuthentication(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_AuthenticationStateType authState
  );

/**********************************************************************************************************************
 *  Dcm_AuthMgrInit()
 *********************************************************************************************************************/
/*! \brief          State initialization.
 *  \details        Initialization of the authentication manager sub-module.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrInit(
  void
  );

/**********************************************************************************************************************
 *  Dcm_AuthMgrCancelOperation()
 *********************************************************************************************************************/
/*! \brief          Cancels an ongoing authentication operation.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrCancelOperation(
  void
  );

# if (DCM_AUTHMGR_SET_DEAUTH_ROLE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrSetDeauthenticatedRole()
 *********************************************************************************************************************/
/*! \brief          Handles the event set by API Dcm_SetDeauthenticatedRole().
 *  \details        -
 *  \param[in]      pContext  Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrSetDeauthenticatedRole(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  );

/**********************************************************************************************************************
 *  Dcm_AuthMgrSetPendingRole()
 *********************************************************************************************************************/
/*! \brief          Sets the pending role coming from external API Dcm_SetDeauthenticatedRole().
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrSetPendingRole(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_CfgStateGroupMemType pendingRole
  );
# endif
#endif /* (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_NetIsKeepAliveTimeStartOnFunc3E80Enabled()
 *********************************************************************************************************************/
/*! \brief          Returns DCM_NET_KEEP_ALIVE_TIME_START_ON_FUNC_3E_80_ENABLED as boolean.
 *  \details        -
 *  \return         TRUE         DCM_NET_KEEP_ALIVE_TIME_START_ON_FUNC_3E_80_ENABLED is STD_ON
 *  \return         FALSE        DCM_NET_KEEP_ALIVE_TIME_START_ON_FUNC_3E_80_ENABLED is STD_OFF
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsKeepAliveTimeStartOnFunc3E80Enabled(
  void
  );

/**********************************************************************************************************************
 *  Dcm_NetIsRxPduIdValid()
 *********************************************************************************************************************/
/*! \brief          Checks the received rxPduId.
 *  \details        -
 *  \param[in]      rxPduId    The rxPduId of the request
 *  \return         TRUE       The rxPduId is valid
 *  \return         FALSE      The rxPduId is not valid
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsRxPduIdValid(
  PduIdType rxPduId
  );

/**********************************************************************************************************************
 *  Dcm_NetIsTxPduIdValid()
 *********************************************************************************************************************/
/*! \brief          Checks the received txPduId.
 *  \details        -
 *  \param[in]      txPduId    The txPduId of the request
 *  \return         TRUE       The txPduId is valid
 *  \return         FALSE      The txPduId is not valid
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsTxPduIdValid(
  PduIdType txPduId
  );

/**********************************************************************************************************************
 *  Dcm_NetGetComMContext()
 *********************************************************************************************************************/
/*! \brief          Returns a ComM context element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a ComM context
 *  \return         ComM context object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetComMContextPtrType, DCM_CODE) Dcm_NetGetComMContext(
  Dcm_CfgNetNetIdRefOptType index
  );

/**********************************************************************************************************************
 *  Dcm_NetGetBufferContext()
 *********************************************************************************************************************/
/*! \brief          Returns a buffer context element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a buffer context
 *  \return         Buffer context object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetBufferContextPtrType, DCM_CODE) Dcm_NetGetBufferContext(
  Dcm_CfgNetBufferRefOptType index
  );

#if (DCM_NET_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetSetComControlChannelState()
 *********************************************************************************************************************/
/*! \brief          Sets the state of a communication control channel of the given index.
 *  \details        -
 *  \param[in]      index    Index to the communication control channel
 *  \param[in]      value    New communication mode
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetSetComControlChannelState(
  uint8_least index,
  Dcm_CommunicationModeType value
  );
#endif

/**********************************************************************************************************************
 *  Dcm_NetPutToConn2TObjMap()
 *********************************************************************************************************************/
/*! \brief          Sets a transport object handle of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a transport object handle
 *  \param[in]      value    New handle
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPutToConn2TObjMap(
  Dcm_NetConnRefOptType index,
  Dcm_CfgNetTObjHandleMemType value
  );

/**********************************************************************************************************************
 *  Dcm_NetWriteAddBufferU8At()
 *********************************************************************************************************************/
/*! \brief          Writes into the additional buffer of a transport object.
 *  \details        -
 *  \param[in]      pTranspObj    The transport object
 *  \param[in]      index         Index to the additional buffer
 *  \param[in]      value         New value of the transport object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetWriteAddBufferU8At(
  Dcm_NetTransportObjectPtrType pTranspObj,
  uint8_least index,
  Dcm_MsgItemType value
  );

/**********************************************************************************************************************
 *  Dcm_NetGetBufferInfo()
 *********************************************************************************************************************/
/*! \brief          Returns a buffer information element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a buffer information element
 *  \return         Buffer info object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_PbCfgNetBufferInfoPtrType, DCM_CODE) Dcm_NetGetBufferInfo(
  Dcm_CfgNetBufferRefOptType index
  );

/**********************************************************************************************************************
 *  Dcm_NetCommonInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the common network related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetCommonInit(
  void
  );

/**********************************************************************************************************************
 *  Dcm_NetComMInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the ComM related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetComMInit(
  void
  );

/**********************************************************************************************************************
 *  Dcm_NetBufferInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the buffer related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetBufferInit(
  void
  );

/**********************************************************************************************************************
 *  Dcm_NetConnectionInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the connection related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetConnectionInit(
  void
  );

/**********************************************************************************************************************
 *  Dcm_NetTranspObjInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the transport object related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTranspObjInit(
  void
  );

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the periodic message related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgInit(
  void
  );
#endif

/**********************************************************************************************************************
 *  Dcm_NetInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the network sub-module.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetInit(
  void
  );

/**********************************************************************************************************************
 *  Dcm_NetRegisterActiveConnection()
 *********************************************************************************************************************/
/*! \brief          Registers an active connection.
 *  \details        Function will be called from Dcm_NetStartOfReception.
 *  \param[in]      pTranspObj    The transport object
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRegisterActiveConnection(
  Dcm_NetTransportObjectPtrType pTranspObj
  );

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetOnRequestDetection()
 *********************************************************************************************************************/
/*! \brief          Cancels any pending job if detected another ECU to be requested from the same client.
 *  \details        Function will be called from Dcm_NetStartOfReception.
 *  \param[in]      connHdl        The connection ID of the foreign ECU request
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetOnRequestDetection(
  Dcm_NetConnRefMemType connHdl
  );
#endif

/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisationFindWinner()
 *********************************************************************************************************************/
/*! \brief          Determination of request with highest priority.
 *  \details        -
 *  \param[in]      ev                      The active event(s) of the task Dcm_NetTaskRx
 *  \param[out]     pBusyEvents             Bitfield for busy requests
 *  \return         ID of the winner
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetTObjHandleOptType, DCM_CODE) Dcm_NetRxPrioritisationFindWinner(
  Dcm_TskTaskEvOptType ev,
  Dcm_TskTaskEvPtrType pBusyEvents
  );

/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisationProcessWinner()
 *********************************************************************************************************************/
/*! \brief          Processing of the request with the highest priority.
 *  \details        -
 *  \param[in]      pContext      Pointer to the context
 *  \param[in]      pTranspObj    The transport object
 *  \param[in,out]  pBusyEvents   Bitfield for busy requests
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRxPrioritisationProcessWinner(
  Dcm_ContextPtrType pContext,
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_TskTaskEvPtrType pBusyEvents
  );

/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisationProcessLoosers()
 *********************************************************************************************************************/
/*! \brief          Processing of requests that were preempted.
 *  \details        -
 *  \param[in]      BusyEvents             Bitfield for busy requests
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRxPrioritisationProcessLoosers(
  Dcm_TskTaskEvOptType BusyEvents
  );

/**********************************************************************************************************************
 *  Dcm_NetExecStartProtocolOp()
 *********************************************************************************************************************/
/*! \brief          Executes a protocol start up.
 *  \details        -
 *  \param[in]      newProtocol    The new protocol ID to be evaluated for starting
 *  \return         TRUE           Proceed with protocol starting
 *  \return         FALSE          Skip any further service processing after return
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetExecStartProtocolOp(
  Dcm_ProtocolType newProtocol
  );

/**********************************************************************************************************************
 *  Dcm_NetComposeAddNegResponse()
 *********************************************************************************************************************/
/*! \brief          Composes a negative response.
 *  \details        -
 *  \param[in]      pTranspObj    The transport object
 *  \param[in]      resType       The response type
 *  \param[in]      nrc           The negative response code
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetComposeAddNegResponse(
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_NetResponseType resType,
  Dcm_NegativeResponseCodeType nrc
  );

/**********************************************************************************************************************
 *  Dcm_NetProcessStartProtocol()
 *********************************************************************************************************************/
/*! \brief          Starts a new protocol.
 *  \details        Delegates a new request with a new protocol and terminates the old one.
 *  \param[in]      pTranspObj    The transport object
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetProcessStartProtocol(
  Dcm_NetTransportObjectPtrType pTranspObj
  );

/**********************************************************************************************************************
 *  Dcm_NetTransmitUsdtResponse()
 *********************************************************************************************************************/
/*! \brief          Start transmission on this connection.
 *  \details        Start an USDT transmission over a specific connection.
 *  \param[in]      pTranspObj            The transport object to be used during the transmission.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            All the items of the structure must be validly initialized:
 *                  hBuffer               Shall be the TxBuffer handle
 *                  pduInfo.SduDataPtr    Shall point to the TxBuffer
 *                  pduInfo.SduLength     Shall contain the length of the data to be sent
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTransmitUsdtResponse(
  Dcm_NetTransportObjectPtrType pTranspObj
  );

#if (DCM_NET_CONN_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetLockConnection()
 *********************************************************************************************************************/
/*! \brief          Allocates a transport object for a concrete client connection.
 *  \details        -
 *  \param[in]      connHdl            The connection to be locked
 *  \param[out]     pTranspObj         The allocated transport object
 *  \return         BUFREQ_OK          The operation was successful
 *  \return         BUFREQ_E_NOT_OK    The given index was invalid
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetLockConnection(
  Dcm_NetConnRefMemType connHdl,
  CONSTP2VAR(Dcm_NetTransportObjectPtrType, AUTOMATIC, AUTOMATIC) pTranspObj
  );
#endif

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndicationNotOk()
 *********************************************************************************************************************/
/*! \brief          Indication of finished reception with no success.
 *  \details        This function is called by Dcm_NetTpRxIndication.
 *  \param[in]      pTranspObj    The transport object
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndicationNotOk(
  Dcm_NetTransportObjectPtrType pTranspObj
  );

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndicationOk()
 *********************************************************************************************************************/
/*! \brief          Indication of finished reception with success.
 *  \details        This function is called by Dcm_NetTpRxIndication.
 *  \param[in]      pTranspObj    The transport object
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndicationOk(
  Dcm_NetTransportObjectPtrType pTranspObj
  );

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetDelayTimerGet()
 *********************************************************************************************************************/
/*! \brief          Get remaining delay time.
 *  \details        Returns the remaining delay time of the given timer
 *  \param[in]      timer       ID of the timer
 *  \return         Remaining delay time
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TmrTimerCntrOptType, DCM_CODE) Dcm_NetDelayTimerGet(
  uint8_least timer
  );
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetDelayTimerSet()
 *********************************************************************************************************************/
/*! \brief          Set delay timeout.
 *  \details        Sets the timout for the given delay timer
 *  \param[in]      timer       ID of the timer
 *  \param[in]      timeout     Timeout value
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetDelayTimerSet(
  uint8_least timer,
  Dcm_TmrTimerCntrOptType timeout
  );
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetDelayTimerExpired()
 *********************************************************************************************************************/
/*! \brief          Check if the delay timer timed out.
 *  \details        Returns whether the given delay timer timed out
 *  \param[in]      timer       ID of the timer
 *  \return         TRUE        Timer has expired
 *  \return         FALSE       Timer is running
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetDelayTimerExpired(
  uint8_least timer
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxObjTimerSet()
 *********************************************************************************************************************/
/*! \brief          Set the timeout for the given periodic transport object.
 *  \details        -
 *  \param[in]      pPeriodicTxObj    The periodic transport object
 *  \param[in]      timeout           Timout of the timer
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxObjTimerSet(
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj,
  Dcm_TmrTimerCntrMemType timeout
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxObjTimerStart()
 *********************************************************************************************************************/
/*! \brief          Start the timer for the given periodic transport object.
 *  \details        -
 *  \param[in]      pPeriodicTxObj    The periodic transport object
 *  \param[in]      timeout           Timout of the timer
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxObjTimerStart(
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj,
  Dcm_TmrTimerCntrMemType timeout
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxObjTimerStop()
 *********************************************************************************************************************/
/*! \brief          Stop the timer for the given periodic transport object.
 *  \details        -
 *  \param[in]      pPeriodicTxObj    The periodic transport object
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxObjTimerStop(
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj
  );
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgIncNextDelayTimer()
 *********************************************************************************************************************/
/*! \brief          Set delay timer index to next timer.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgIncNextDelayTimer(
  void
  );
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgSetFastestRate()
 *********************************************************************************************************************/
/*! \brief          Sets a new fastest rate.
 *  \details        -
 *  \param[in]      Rate    The periodic rate
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgSetFastestRate(
  Dcm_Svc2ASchedRateOptType Rate
  );
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxDelayTimerStart()
 *********************************************************************************************************************/
/*! \brief          Starts a delay timer for periodic message transmission.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxDelayTimerStart(
  void
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutTxObjectHandler()
 *********************************************************************************************************************/
/*! \brief          Executes jobs on timeout of a transport object timer.
 *  \details        -
 *  \return         Flag whether timer needs to be reloaded
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_OnTimeoutTxObjectHandler(
  void
  );
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutDelayTimerHandler()
 *********************************************************************************************************************/
/*! \brief          Executes jobs on timeout of a delay timer.
 *  \details        -
 *  \return         Flag whether timer needs to be reloaded
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_OnTimeoutDelayTimerHandler(
  void
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetGetPeriodicTxObject()
 *********************************************************************************************************************/
/*! \brief          Returns a periodic transport object element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a periodic transport object
 *  \return         Periodic transport object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetPeriodicTxObjectPtrType, DCM_CODE) Dcm_NetGetPeriodicTxObject(
  Dcm_CfgNetPTxObjHandleOptType index
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgGetTxBuffer()
 *********************************************************************************************************************/
/*! \brief          Return the tx buffer of the periodic message with the given index.
 *  \details        -
 *  \param[in]      perTxObjHandle    Handle of periodic transport object to be transmitted
 *  \return         Tx buffer of periodic transport object
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            The periodic message shall first be allocated via Dcm_NetPeriodicMsgAllocate()
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_MsgType, DCM_CODE) Dcm_NetPeriodicMsgGetTxBuffer(
  Dcm_CfgNetPTxObjHandleOptType perTxObjHandle
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgTransmitTxObj()
 *********************************************************************************************************************/
/*! \brief          Transmits a periodic message.
 *  \details        -
 *  \param[in]      perTxObjHandle    Handle of periodic transport object to be transmitted
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            The periodic message shall first be allocated via Dcm_NetPeriodicMsgAllocate()
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgTransmitTxObj(
  Dcm_CfgNetPTxObjHandleOptType perTxObjHandle
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgResetConnection()
 *********************************************************************************************************************/
/*! \brief          Resets the periodic message connection.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgResetConnection(
  void
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgStopDid()
 *********************************************************************************************************************/
/*! \brief          Stops transmission of DID and also removes queued transport objects.
 *  \details        -
 *  \param[in]      Did      DID that is to be stopped
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgStopDid(
  uint16 Did
  );
#endif

/**********************************************************************************************************************
 *  Dcm_NetIsPduInfoValid()
 *********************************************************************************************************************/
/*! \brief          Checks the received PduInfo.
 *  \details        -
 *  \param[in]      info       Message context (data and length of the portion)
 *  \return         TRUE       The info element is valid
 *  \return         FALSE      The info element is not valid
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsPduInfoValid(
  P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info
  );

/**********************************************************************************************************************
 *  Dcm_NetCopyRxData()
 *********************************************************************************************************************/
/*! \brief          Copies request data from the lower layer.
 *  \details        This function is called by Dcm_CopyRxData.
 *  \param[in]      pTranspObj         The transport object
 *  \param[in]      info               Message context (data and length of the portion)
 *  \param[out]     bufferSizePtr      Available buffer size
 *  \return         BUFREQ_OK          A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK    No free buffer is available - ignore request
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyRxData(
  Dcm_NetTransportObjectPtrType pTranspObj,
  P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info,
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr
  );

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndication()
 *********************************************************************************************************************/
/*! \brief          Indication of finished reception.
 *  \details        This function is called by Dcm_TpRxIndication.
 *  \param[in]      rxPduId    The RxPDUID of the request.
 *  \param[in]      result     Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndication(
  PduIdType rxPduId,
  Std_ReturnType result
  );

/**********************************************************************************************************************
 *  Dcm_NetCopyLinearTxData()
 *********************************************************************************************************************/
/*! \brief          Copies transmit data in linear form to the lower layer.
 *  \details        This function is called by Dcm_NetCopyTxData for the linear response data case.
 *  \param[in]      pTranspObj          The transport object
 *  \param[in]      info                Pointer to a PduInfoType, which indicates the number of bytes to be copied
 *                                      (SduLength) and the location where the data have to be copied to (SduDataPtr).
 *                                      An SduLength of 0 is possible in order to poll the available transmit data
 *                                      count. In this case no data are to be copied and SduDataPtr might be invalid.
 *  \param[in]      availableDataPtr    Remaining Tx data after completion of this call
 *  \return         BUFREQ_OK           A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK     Some error occurred (i.e. internal error detected)
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyLinearTxData(
  Dcm_NetTransportObjectPtrType pTranspObj,
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info ,                                                                                                /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr
  );

/**********************************************************************************************************************
 *  Dcm_NetCopyTxData()
 *********************************************************************************************************************/
/*! \brief          Copies transmit data to the lower layer.
 *  \details        This function is called by Dcm_CopyTxData.
 *  \param[in]      pTranspObj          The transport object
 *  \param[in]      info                Pointer to a PduInfoType, which indicates the number of bytes to be copied
 *                                      (SduLength) and the location where the data have to be copied to (SduDataPtr).
 *                                      An SduLength of 0 is possible in order to poll the available transmit data
 *                                      count. In this case no data are to be copied and SduDataPtr might be invalid.
 *  \param[in]      availableDataPtr    Remaining Tx data after completion of this call.
 *  \return         BUFREQ_OK           Response data is available - all requested data are copied
 *  \return         BUFREQ_E_BUSY       The required amount of data is not available - try later again
 *  \return         BUFREQ_E_NOT_OK     Some error occurred (e.g. no more data, internal error detected etc.)
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyTxData(
  Dcm_NetTransportObjectPtrType pTranspObj,
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info ,                                                                                                /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr
  );
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferInitByThread()
 *********************************************************************************************************************/
/*! \brief          Reset paged-buffer any time.
 *  \details        Resetting the paged-buffer.
 *  \param[in]      ThreadId    Active thread
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferInitByThread(
  Dcm_ThreadIdOptType threadId
  );
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferInit()
 *********************************************************************************************************************/
/*! \brief          Initialize paged-buffer any time.
 *  \details        Initialization of the paged-buffer.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferInit(
  void
  );
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferDefragmentPage()
 *********************************************************************************************************************/
/*! \brief          Defragments the current paged-buffer page.
 *  \details        -
 *  \param[in]      pContext  Pointer to the context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferDefragmentPage(
  Dcm_ContextPtrType pContext
  );
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferUpdatePage()
 *********************************************************************************************************************/
/*! \brief          Dispatches the UpdatePage call.
 *  \details        Dispatches the UpdatePage call regarding the paged-buffer.
 *  \param[in]      pContext  Pointer to the context
 *  \param[out]     ErrorCode             The NRC
 *  \return         DCM_E_OK              All data has been copied - evaluate the out parameters
 *  \return         DCM_E_PENDING         No result yet, retry later
 *  \return         DCM_E_NOT_OK          Something went wrong, stop updating(only in DET situation)
 *  \return         DCM_E_BUFFERTOOLOW    Some data copied but no place, retry later on TP buffer under-run
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferUpdatePage(
  Dcm_ContextPtrType pContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCopyData()
 *********************************************************************************************************************/
/*! \brief          Copy from paged-buffer to the TP layer.
 *  \details        -
 *  \param[in]      pTranspObj          The transport object
 *  \param[in]      info                Message context (data and length of the portion)
 *  \param[in]      availableDataPtr    Remaining Tx data after completion of this call
 *  \return         BUFREQ_OK           A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK     No free buffer is available - ignore request
 *  \return         BUFREQ_E_BUSY       No free buffer at this time - try later again
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_PagedBufferCopyData(
  Dcm_NetTransportObjectPtrType pTranspObj,
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info,
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr
  );
#endif
/**********************************************************************************************************************
 *  Dcm_RepeaterNextStep()
 *********************************************************************************************************************/
/*! \brief          Sets next step of repeater proxy.
 *  \details        -
 *  \param[in]      pContext    Pointer to the context
 *  \param[in]      nextStep    Next step to be processed
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_RepeaterNextStep(
  Dcm_ContextPtrType pContext,
  Dcm_RepeaterProgressType nextStep
  );

/**********************************************************************************************************************
 *  Dcm_CfgDiagServiceInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Get service info descriptor.
 *  \details        -
 *  \param[in]      SidIndex        Index to a service info descriptor
 *  \param[out]     pServiceInfo    The service info descriptor
 *  \param[out]     ErrorCode       Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgDiagServiceInfoGetEntry(
  uint8_least SidIndex,
  CONSTP2VAR(Dcm_CfgDiagServiceInfoPtrType, AUTOMATIC, AUTOMATIC) pServiceInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgModeMgrRulesGetEntry()
 *********************************************************************************************************************/
/*! \brief          Get module rule.
 *  \details        -
 *  \param[in]      modeRuleRef     A reference to a mode rule
 *  \param[out]     pModeRuleFunc   The mode rule function
 *  \param[out]     ErrorCode       Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgModeMgrRulesGetEntry(
  Dcm_CfgModeMgrRuleRefOptType modeRuleRef,
  CONSTP2VAR(Dcm_ModeRuleFuncType, AUTOMATIC, AUTOMATIC) pModeRuleFunc,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#endif

#if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeCheck()
 *********************************************************************************************************************/
/*! \brief          Performs a mode rule check.
 *  \details        -
 *  \param[in]      modeRuleRef    A reference to a mode rule
 *  \param[out]     ErrorCode      The NRC
 *  \return         DCM_E_OK       Mode rule check was successful
 *  \return         DCM_E_NOT_OK   Mode rule check was not successful
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeCheck(
  Dcm_CfgModeMgrRuleRefOptType modeRuleRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#endif

#if (DCM_MODE_CTRLDTCSETTING_MONITOR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeMonitorControlDtcSetting()
 *********************************************************************************************************************/
/*! \brief          Verifies that the DTCsetting auto-recovery condition is not yet met.
 *  \details        -
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeMonitorControlDtcSetting(
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

#if (DCM_MODE_COMMCTRL_MONITOR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeMonitorCommunicationControl()
 *********************************************************************************************************************/
/*! \brief          Verifies that the CommunicationControl auto-recovery condition is not yet met.
 *  \details        -
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeMonitorCommunicationControl(
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

#if (DCM_MODE_COMMCTRL_ENABLED == STD_ON) || \
    (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeInit()
 *********************************************************************************************************************/
/*! \brief          Initializes DCM mode manager sub-module.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts must be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeInit(
  void
  );
#endif

#if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)   || \
    (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckResultInterpreter()
 *********************************************************************************************************************/
/*! \brief          Converts a ModeSwitchAck API return value to a DCM standard result.
 *  \details        -
 *  \param[in]      modeSwitchAckResult    The ModeSwitchAck API result
 *  \return         The DCM standard result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckResultInterpreter(
  Std_ReturnType modeSwitchAckResult
  );
#endif

#if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckEcuReset()
 *********************************************************************************************************************/
/*! \brief          Mode switch acknowledgment for an ECU reset command.
 *  \details        -
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckEcuReset(
  void
  );
#endif

#if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchEcuReset()
 *********************************************************************************************************************/
/*! \brief          Mode switching for an ECU reset command.
 *  \details        -
 *  \param[in]      mode    The mode
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchEcuReset(
  Rte_ModeType_DcmEcuReset mode
  );
#endif

#if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckRapidShutDown()
 *********************************************************************************************************************/
/*! \brief          Mode switch acknowledgment for a rapid power shutdown command.
 *  \details        -
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckRapidShutDown(
  void
  );
#endif

#if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchRapidShutDown()
 *********************************************************************************************************************/
/*! \brief          Mode switching for an ECU reset rapid shut down command.
 *  \details        -
 *  \param[in]      mode    The mode
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchRapidShutDown(
  Rte_ModeType_DcmModeRapidPowerShutDown mode
  );
#endif
/**********************************************************************************************************************
 *  Dcm_StateInit()
 *********************************************************************************************************************/
/*! \brief          State initialization.
 *  \details        Initialization of the state manager sub-module.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateInit(
  void
  );

/**********************************************************************************************************************
 *  Dcm_StateExecOnStateChangeFunc()
 *********************************************************************************************************************/
/*! \brief          Executes all registered on state change functions if precondition no more fulfilled.
 *  \details        -
 *  \param[in]      notifList        The notification list
 *  \param[in]      formerStateId    The former state
 *  \param[in]      newStateId       The new state
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateExecOnStateChangeFunc(
  Dcm_CfgStateNotificationInfoPtrType notifList,
  uint8 formerStateId,
  uint8 newStateId
  );

#if (DCM_STATE_SECURITY_LOOKUP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateFindStateIndexFromSecLevel()
 *********************************************************************************************************************/
/*! \brief          Map an external state identifier to an internal state index.
 *  \details        -
 *  \param[in]      secLevel    The security level (incl. LOCKED)
 *  \return         -1          Not found
 *  \return         >= 0        Internal state index
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(sint8_least, DCM_CODE) Dcm_StateFindStateIndexFromSecLevel(
  Dcm_SecLevelType secLevel
  );
#endif

#if ((DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)  && (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON))
/**********************************************************************************************************************
 *  Dcm_StateVsgGetSecurityFixedByteStateIdx()
 *********************************************************************************************************************/
/*! \brief         Returns referencs to active security fixed byte.
 *  \details        Returns a reference to a security fixed byte that is assigned to a active VSG
 *  \param[in,out]  pStateIndex      Index to security fixed byte VSG configuration in
 *                                   Dcm_CfgStateVsgMaskSecurityFixedByte
 *  \return         DCM_E_OK         Operation succeeded
 *  \return         DCM_E_NOT_OK     No active security fixed byte available
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_StateVsgGetSecurityFixedByteStateIdx(
  P2VAR(sint32_least, AUTOMATIC, DCM_APPL_DATA) pStateIndex
  );
#endif

#if (DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateGetSecurityLevelFixedBytes()
 *********************************************************************************************************************/
/*! \brief          Provides fixed bytes set up for a specific security level.
 *  \details        This function provides the fixed bytes for the requested security level.
 *                  A security level without configured fixed bytes will return E_OK and no bytes (bufferSize = 0)
 *  \param[in]      secLevel              The requested security level
 *  \param[out]     fixedBytes            Buffer to receive the fixed byte values
 *  \param[in,out]  bufferSize
 *                  IN                    The provided buffer size
 *                  OUT                   The number of fixed bytes for the requested level
 *  \return         E_OK                  The security bytes were copied to the provided buffer
 *  \return         DCM_E_NOT_OK          The security level is not configured
 *  \return         DCM_E_BUFFERTOOLOW    The buffer was too small, bufferSize will contain the number of bytes needed
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_StateGetSecurityLevelFixedBytes(
  Dcm_SecLevelType secLevel,
  P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) fixedBytes,
  P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) bufferSize
  );
#endif

#if (DCM_STATE_NOTIFY_SVC_PRO_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateNotifyServiceProcessors()
 *********************************************************************************************************************/
/*! \brief          Notifies all related service processors for a state change (of any state group).
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateNotifyServiceProcessors(
  void
  );
#endif
/**********************************************************************************************************************
 *  Dcm_TmrGetTimerInfo()
 *********************************************************************************************************************/
/*! \brief          Returns a timer info element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a timer info
 *  \return         The timer info element corresponding to the index
 *  \return         NULL_PTR      On invalid array boundaries (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TmrTimerInfoPtrType, DCM_CODE) Dcm_TmrGetTimerInfo(
  Dcm_TmrTimerIdOptType index
  );

/**********************************************************************************************************************
 *  Dcm_TmrGetTimerContext()
 *********************************************************************************************************************/
/*! \brief          Returns a timer context element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a timer context
 *  \return         The timer context element corresponding to the index
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TmrTimerContextPtrType, DCM_CODE) Dcm_TmrGetTimerContext(
  Dcm_TmrTimerIdOptType index
  );

/**********************************************************************************************************************
 *  Dcm_TmrInit()
 *********************************************************************************************************************/
/*! \brief          Timer initialization.
 *  \details        Initialization of the timer manager sub-module.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TmrInit(
  void
  );
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrInit()
 *********************************************************************************************************************/
/*! \brief          Initializes the DID manager sub-component.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrInit(
  void
  );

/**********************************************************************************************************************
 *  Dcm_CfgDidMgrSignalOpClassInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Returns a signal operation class info element of the given index.
 *  \details        -
 *  \param[in]      opInfoRef            The index of the signal operation class info
 *  \param[out]     pSignalOpClassInfo   The signal operation class info element of the given index
 *  \param[out]     ErrorCode            Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgDidMgrSignalOpClassInfoGetEntry(
  Dcm_CfgDidMgrSignalOpClassRefOptType opInfoRef,
  CONSTP2VAR(Dcm_DidMgrSignalOpClassInfoPtrType, AUTOMATIC, AUTOMATIC) pSignalOpClassInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_CfgDidMgrDidOpClassInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Returns a DID operation class info element of the given index.
 *  \details        -
 *  \param[in]      opInfoRef  The index of the operation class info
 *  \return         Operation class info entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DidMgrDidOpClassInfoPtrType, DCM_CODE) Dcm_CfgDidMgrDidOpClassInfoGetEntry(
  Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef
  );

# if (DCM_DIDMGR_SR_IO_CONTROL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgDidMgrIoControlSenderReceiverHandlersGetEntry()
 *********************************************************************************************************************/
/*! \brief          Returns a pointer to a struct of SR IO-control handlers.
 *  \details        -
 *  \param[in]      ioControlSRHandlerRef  The index of the IO control handlers
 *  \return         Pointer to a struct of SR IO-control handlers
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DidMgrIoCtrlSRHandlersPtrType, DCM_CODE) Dcm_CfgDidMgrIoControlSenderReceiverHandlersGetEntry(
  Dcm_CfgDidMgrIoCtrlSRHandlersRefOptType ioControlSRHandlerRef
  );
# endif

# if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrFilterDidRangeGap()
 *********************************************************************************************************************/
/*! \brief          Verifies whether the DID is supported within a range.
 *  \details        -
 *  \param[in]      opStatus                    Current operation status
 *  \param[in]      pDidInfoContext             The DID configuration context
 *  \param[in]      pDidOpTypeContext           The context of the DID operation
 *  \return         DCM_E_OK                    Positive look up result
 *  \return         DCM_E_NOT_OK                Negative look up result
 *  \return         DCM_E_LOOKUP_MATCH_FOUND    DID range match, but found a gap
 *  \return         DCM_E_PENDING               Final result is pending, retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrFilterDidRangeGap(
  Dcm_OpStatusType opStatus,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
  );
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrDidRangeLookUp()
 *********************************************************************************************************************/
/*! \brief          Searches for the DID in a range to get its corresponding handle (up to 32768 items).
 *  \details        -
 *  \param[in]      opStatus                    Current operation status
 *  \param[in,out]  pDidInfoContext             The DID to be found and its context
 *  \param[in,out]  pDidOpTypeContext           The context of the DID operation
 *  \param[in]      didOp                       The DID operation
 *  \return         DCM_E_OK                    Positive look up result
 *  \return         DCM_E_NOT_OK                Negative look up result
 *  \return         DCM_E_LOOKUP_MATCH_FOUND    DID range match, but found a gap
 *  \return         DCM_E_PENDING               Final result is pending, retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrDidRangeLookUp(
  Dcm_OpStatusType opStatus,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_DidMgrOpOptType didOp
  );

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED== STD_ON) && \
     (DCM_DIDMGR_RTE_IMPLICIT_COM_ENABLED  == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetRequiredSignalBufSize()
 *********************************************************************************************************************/
/*! \brief          Returns the required buffer size for a read callout of a signal.
 *  \details        -
 *  \param[in]      pDidInfoContext    The context of the DID configuration
 *  \param[in]      pDidOpTypeContext  The context of the DID operation
 *  \return         The required buffer size
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            OpClass of the requested DID must be set.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetBufferSizeOptType, DCM_CODE) Dcm_DidMgrGetRequiredSignalBufSize(
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
  );
# endif

# if (DCM_DIDMGR_OPTYPE_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWriteAtomicSRResultInterpreter()
 *********************************************************************************************************************/
/*! \brief          Converts a ModeSwitchAck API return value to a DCM standard result.
 *  \details        -
 *  \param[in]      rteResult          The RTE result
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The DCM standard result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrWriteAtomicSRResultInterpreter(
  Std_ReturnType rteResult,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_DIDMGR_OPTYPE_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWriteSignal()
 *********************************************************************************************************************/
/*! \brief          Writes a single DID signal for service 0x2E.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrWriteSignal(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_DIDMGR_OPTYPE_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWrite()
 *********************************************************************************************************************/
/*! \brief          Executes DID writing.
 *  \details        Iterates over all signals of a DID.
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrWrite(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_DIDMGR_OPTYPE_GETSCALINGINFO_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetScalingInfoSignal()
 *********************************************************************************************************************/
/*! \brief          Returns a scaling information item of a given DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetScalingInfoSignal(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_DIDMGR_OPTYPE_GETSCALINGINFO_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetScalingInfo()
 *********************************************************************************************************************/
/*! \brief          Returns the scaling information of a given DID.
 *  \details        Iterates over all signals of a DID.
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetScalingInfo(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

# endif

# if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlSignal()
 *********************************************************************************************************************/
/*! \brief          DID IO control operator.
 *  \details        -
 *  \param[in]      opStatus            The operation status
 *  \param[in,out]  pMsgContext         The current request context
 *  \param[in,out]  pDidInfoContext     The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext   The context of the DID operation
 *  \param[out]     ErrorCode           Negative response code in case return value is DCM_E_NOT_OK
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControlSignal(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControl()
 *********************************************************************************************************************/
/*! \brief          DID IO control operator.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControl(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlWithMask()
 *********************************************************************************************************************/
/*! \brief          DID IO control with control enable mask record support operator.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControlWithMask(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlRtrnCtrl2EcuSignal()
 *********************************************************************************************************************/
/*! \brief          Optimized function for ReturnControlToEcu only!.
 *  \details        -
 *  \param[in]      opInfoRef    Operation information
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrIoControlRtrnCtrl2EcuSignal(
  Dcm_CfgDidMgrSignalOpClassRefOptType opInfoRef
  );
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlRtrnCtrl2Ecu()
 *********************************************************************************************************************/
/*! \brief          Optimized function for ReturnControlToEcu only!.
 *  \details        -
 *  \param[in]      opInfoRef    Operation information
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrIoControlRtrnCtrl2Ecu(
  Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef
  );
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalRange()
 *********************************************************************************************************************/
/*! \brief          Reads a specific DID range.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalRange(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalAsync()
 *********************************************************************************************************************/
/*! \brief          Reads an asynchronous signal of a DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalAsync(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalSync()
 *********************************************************************************************************************/
/*! \brief          Reads a synchronous signal of a DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalSync(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalPaged()
 *********************************************************************************************************************/
/*! \brief          Reads a paged signal of a DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalPaged(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalVid()
 *********************************************************************************************************************/
/*! \brief          Reads a paged signal of a VID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalVid(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalSR()
 *********************************************************************************************************************/
/*! \brief          Reads a signal of a DID with a SR interface.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalSR(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalWrapperAsync()
 *********************************************************************************************************************/
/*! \brief          Reads a signal of a DID using a generated wrapper.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalWrapperAsync(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalWrapperSync()
 *********************************************************************************************************************/
/*! \brief          Reads a signal of a DID using a generated wrapper.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalWrapperSync(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignal()
 *********************************************************************************************************************/
/*! \brief          Reads a signal of a DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignal(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrReadLengthSignal()
 *********************************************************************************************************************/
/*! \brief          Returns the length of a signal.
 *  \details        Reads the length of a specific signal of a DID.
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     pResLength         The returned length
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_PENDING      Job processing is not yet finished
 *  \return         DCM_E_OK           Job processing finished, send positive response
 *  \return         DCM_E_NOT_OK       Job processing finished, send NRC from the ErrorCode
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadLengthSignal(
  Dcm_OpStatusType opStatus,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_DidMgrDidLengthPtrType pResLength,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_DidMgrReadCheckCondSignal()
 *********************************************************************************************************************/
/*! \brief          Reads the check condition of a specific signal of a DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK           Check condition of signal failed
 *  \return         DCM_E_PENDING      Check condition not yet finished
 *  \return         DCM_E_NOT_OK       Check condition of signal succeeded
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadCheckCondSignal(
  Dcm_OpStatusType opStatus,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrGetSignalLength()
 *********************************************************************************************************************/
/*! \brief          Returns the length of the current signal.
 *  \details        -
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetBufferSizeOptType, DCM_CODE) Dcm_DidMgrGetSignalLength(
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
  );
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrFilterDidLookUp()
 *********************************************************************************************************************/
/*! \brief          Verifies whether a supported DID is currently enabled for a specific DID operation.
 *  \details        -
 *  \param[in]      pDidInfoContext    The DID configuration information
 *  \param[in]      didOp              The lookup DID operation context
 *  \return         DCM_E_OK           Positive look up result
 *  \return         DCM_E_NOT_OK       Negative look up result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrFilterDidLookUp(
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrOpOptType didOp
  );

/**********************************************************************************************************************
 *  Dcm_DidMgrConcreteDidLookUp()
 *********************************************************************************************************************/
/*! \brief          Look up for a concrete DID number (no range).
 *  \details        -
 *  \param[in]      pDidInfoContext    The DID configuration context
 *  \param[in]      didOp              The lookup DID operation context
 *  \return         DCM_E_OK           Positive look up result
 *  \return         DCM_E_NOT_OK       Negative look up result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrConcreteDidLookUp(
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrOpOptType didOp
  );

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrCheckSignalSize()
 *********************************************************************************************************************/
/*! \brief          Checks whether the DCM buffer is large enough to read the next signal.
 *  \details        -
 *  \param[in]      pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The DID configuration context
 *  \param[in,out]  pDidOpTypeContext  The DID operation context
 *  \return         TRUE               The buffer is large enough
 *  \return         FALSE              The buffer is too small
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_DidMgrCheckSignalSize(
  Dcm_DiagDataContextConstPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
  );
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrReadMultiSignal()
 *********************************************************************************************************************/
/*! \brief          Reads all signals for a specific DID using the paged-buffer.
 *  \details        -
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The DID configuration context
 *  \param[in,out]  pDidOpTypeContext  The DID operation context
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadMultiSignal(
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

# if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetSidFromOp()
 *********************************************************************************************************************/
/*! \brief          Get the SID of the did operation.
 *  \details        -
 *  \param[in]      didOp              The DID operation
 *  \return         SID                The service Id
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint8, DCM_CODE) Dcm_DidMgrGetSidFromOp(
  Dcm_DidOpType didOp
  );
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgRidMgrOpInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Get operation descriptor.
 *  \details        -
 *  \param[in]      ridOpInfoIdx    Index to a operation descriptor of a RID operation
 *  \param[out]     pRidOpInfo      The operation descriptor
 *  \param[out]     ErrorCode       Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgRidMgrOpInfoGetEntry(
  Dcm_CfgRidMgrOpHandleOptType ridOpInfoIdx,
  CONSTP2VAR(Dcm_RidMgrOpInfoPtrType, AUTOMATIC, AUTOMATIC) pRidOpInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_RidMgrExecuteRoutine()
 *********************************************************************************************************************/
/*! \brief          Executes a routine operation.
 *  \details        -
 *  \param[in]      opStatus       The operations status
 *  \param[in]      pMsgContext    Current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrExecuteRoutine(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc31RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_RidMgrGetOpInfo()
 *********************************************************************************************************************/
/*! \brief          Returns the operation descriptor of a RID operation.
 *  \details        -
 *  \param[in]      ridInfoIdx       Index to the RID info object
 *  \param[in]      ridOp            The requested RID operation
 *  \param[out]     pRidOpInfoIdx    Index to the RID operation information in the configuration table
 *  \return         DCM_E_OK         Returning descriptor is successful (pRidOpInfoIdx value shall be evaluated)
 *  \return         DCM_E_NOT_OK     Returning descriptor is not successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrGetOpInfo(
  Dcm_CfgRidMgrInfoHandleOptType ridInfoIdx,
  Dcm_RidMgrOpType ridOp,
  Dcm_CfgRidMgrOpHandlePtrType pRidOpInfoIdx
  );

/**********************************************************************************************************************
 *  Dcm_RidMgrRidLookUp()
 *********************************************************************************************************************/
/*! \brief          Looks for the RID to get its corresponding RID information reference.
 *  \details        -
 *  \param[in]      opStatus        The operations status
 *  \param[in]      rid             The RID to be found
 *  \param[in,out]  pRidInfoIdx     Index to the RID information in the configuration table
 *  \return         DCM_E_NOT_OK    No RID has been found
 *  \return         DCM_E_OK        Look up success
 *  \return         DCM_E_PENDING   Look up result is pending, try again
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrRidLookUp(
  Dcm_OpStatusType opStatus,
  uint16 rid,
  Dcm_CfgRidMgrInfoHandlePtrType pRidInfoIdx
  );

/**********************************************************************************************************************
 *  Dcm_RidMgrRidLookUpFilter()
 *********************************************************************************************************************/
/*! \brief          Filters the RID look up result.
 *  \details        If the look-up has found a match, this filter may override this result and specify the RID as
 *                  not-supported.
 *  \param[in]      rid             The RID to be found
 *  \param[in]      ridInfoIdx      Index to the RID information
 *  \return         DCM_E_NOT_OK    No RID has been found
 *  \return         DCM_E_OK        Look up success
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrRidLookUpFilter(
  uint16 rid,
  Dcm_CfgRidMgrInfoHandleOptType ridInfoIdx
  );
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrSetNextStep()
 *********************************************************************************************************************/
/*! \brief          Set next progress step.
 *  \details        -
 *  \param[in]      NextStep         Next step to be processed by local Repeater
 *  \param[in,out]  pRepContext      Current repeater proxy context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ObdDtcMgrSetNextStep(
  Dcm_RepeaterProgressType NextStep,
  Dcm_ObdDtcManagerContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrGetNextStep()
 *********************************************************************************************************************/
/*! \brief          Get next progress step.
 *  \details        -
 *  \return         Next step to be processed by local Repeater
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_RepeaterProgressType, DCM_CODE) Dcm_ObdDtcMgrGetNextStep(
  Dcm_ObdDtcManagerContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrDemGetNumFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Calls the GetNumberOfFilteredDTC function.
 *  \param[in]      opStatus                The operation status
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Stop Repeater Proxy
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrDemGetNumFltrdDtc(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_ObdDtcManagerContextPtrType pRepContext
  );

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrCopyLinearData()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Copies some linear data.
 *  \param[in]      opStatus                The operation status
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrCopyLinearData(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_ObdDtcManagerContextPtrType pRepContext
  );
# endif
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_InitContext()
 *********************************************************************************************************************/
/*! \brief          Initializes the processing context.
 *  \details        -
 *  \param[in]      pContext        Pointer to the context
 *  \param[in]      threadId        The active thread identifier
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_InitContext(
  Dcm_ContextPtrType pContext,
  Dcm_ThreadIdOptType threadId
  );

/**********************************************************************************************************************
 *  Dcm_GetThreadContext()
 *********************************************************************************************************************/
/*! \brief          Returns a thread context element of the given index.
 *  \details        -
 *  \param[in]      threadId    The active thread identifier
 *  \return         Valid thread context.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_ThreadContextPtrType, DCM_CODE) Dcm_GetThreadContext(
  Dcm_ThreadIdOptType threadId
  );
/**********************************************************************************************************************
 *  Dcm_TskGetTaskInfo()
 *********************************************************************************************************************/
/*! \brief          Returns a task info element of the given index.
 *  \details        -
 *  \param[in]      index           Unique handle to a task info
 *  \param[out]     pTaskInfo       The task info element
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_TskGetTaskInfo(
  Dcm_TskTaskIdOptType index,
  CONSTP2VAR(Dcm_TskTaskInfoPtrType, AUTOMATIC, AUTOMATIC) pTaskInfo
  );

/**********************************************************************************************************************
 *  Dcm_TskGetTaskContext()
 *********************************************************************************************************************/
/*! \brief          Returns a task context element of the given task ID.
 *  \details        -
 *  \param[in]      taskId          The task ID the context will be returned
 *  \param[out]     pTaskContext    The task context element of the given task ID
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given task ID was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_TskGetTaskContext(
  Dcm_TskTaskIdOptType taskId,
  CONSTP2VAR(Dcm_TskTaskContextPtrType, AUTOMATIC, AUTOMATIC) pTaskContext
  );

#if (DCM_TSK_TRACING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskRegisterActiveTask()
 *********************************************************************************************************************/
/*! \brief          Registers a task as an active one on top of the task stack.
 *  \details        -
 *  \param[in]      taskId    The task ID to be registered as active.
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE only in case split task is supported.
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskRegisterActiveTask(
  Dcm_TskTaskIdOptType taskId
  );
#else
# define Dcm_TskRegisterActiveTask(taskId)                           /* not used */
#endif

#if (DCM_TSK_TRACING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskUnRegisterActiveTask()
 *********************************************************************************************************************/
/*! \brief          Removes an activated task from the task stack.
 *  \details        -
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE only in case split task is supported.
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskUnRegisterActiveTask(
  void
  );
#else
# define Dcm_TskUnRegisterActiveTask()                               /* not used */
#endif

/**********************************************************************************************************************
 *  Dcm_TskExecuteActiveTask()
 *********************************************************************************************************************/
/*! \brief          Executes a specific task until all its jobs are finished.
 *  \details        -
 *  \param[in]      taskId    The ID of the task to be executed.
 *  \param[in]      taskEv    A current snapshot of the task's events.
 *  \param[in]      ThreadId  Active thread
 *  \context        TASK
 *  \reentrant      TRUE only in case split task is supported.
 *  \pre            Must be called only from the Dcm_TskScheduler().
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskExecuteActiveTask(
  Dcm_TskTaskIdOptType taskId,
  Dcm_TskTaskEvOptType taskEv,
  Dcm_ThreadIdOptType threadId
  );

/**********************************************************************************************************************
 *  Dcm_TskGetSchedulerContext()
 *********************************************************************************************************************/
/*! \brief          Returns a scheduler context element of the given priority.
 *  \details        -
 *  \param[in]      schedulerPrio        Scheduler priority matching to a specific scheduler context
 *  \param[out]     pSchedulerContext    The scheduler context
 *  \return         DCM_E_OK             The operation was successful
 *  \return         DCM_E_NOT_OK         The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_TskGetSchedulerContext(
  Dcm_TskTaskPrioOptType schedulerPrio,
  CONSTP2VAR(Dcm_TskSchedulerContextPtrType, AUTOMATIC, AUTOMATIC) pSchedulerContext
  );

/**********************************************************************************************************************
 *  Dcm_TskInit()
 *********************************************************************************************************************/
/*! \brief          Task initialization.
 *  \details        Initialization of the task manager sub-module.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskInit(
  void
  );

/**********************************************************************************************************************
 *  Dcm_TskKillTask()
 *********************************************************************************************************************/
/*! \brief          Kills a killable task.
 *  \details        Suspends all internal tasks according to their configuration in Dcm_TskTaskInfo[].
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskKillTask(
  Dcm_TskTaskIdOptType tskIter
  );

/**********************************************************************************************************************
 *  Dcm_TskKillAllTasks()
 *********************************************************************************************************************/
/*! \brief          Kills all killable tasks of basic thread.
 *  \details        Suspends all internal tasks according to their configuration in Dcm_TskTaskInfo[].
 *                  This has only to be done for basic thread because this is the only killable one.
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskKillAllTasks(
  void
  );

#if (DCM_TSK_TASK_COMPLEX_KILL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskReviveAllTasks()
 *********************************************************************************************************************/
/*! \brief          Revives all killed tasks of basic thread.
 *  \details        This has only to be done for basic thread because this is the only killable one.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            Must be called within a critical section.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskReviveAllTasks(
  void
  );
#else
# define Dcm_TskReviveAllTasks()                                     /* not used */
#endif
/**********************************************************************************************************************
 *  Dcm_DiagSetNewReqBaseToCurProgress()
 *********************************************************************************************************************/
/*! \brief          Sets the request context base to the current progress.
 *  \details        Updates all request related members to an initial value, starting with buffer that skips the already
 *                  consumed request bytes.
 *  \param[in,out]  pMsgContext   Current message context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetNewReqBaseToCurProgress(
  Dcm_MsgContextPtrType pMsgContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagSetQueuedTranspObj()
 *********************************************************************************************************************/
/*! \brief          Setter of the transport object carrying the diagnostic request to be processed at next.
 *                  Dcm_DiagTaskWorker() activation
 *  \details        -
 *  \param[in]      pThreadContext    Pointer to the context with all thread specific elements
 *  \param[in]      pTranspObj        Currently active DCM external/internal connection
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetQueuedTranspObj(
  Dcm_ThreadContextPtrType pThreadContext,
  Dcm_NetTransportObjectPtrType pTranspObj
  );

/**********************************************************************************************************************
 *  Dcm_DiagSetNewResBaseToCurProgress()
 *********************************************************************************************************************/
/*! \brief          Sets the response context base to the current progress.
 *  \details        Updates all response related members to an initial value, starting with buffer that skips the already
 *                  provided response bytes.
 *  \param[in,out]  pMsgContext   Current message context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetNewResBaseToCurProgress(
  Dcm_MsgContextPtrType pMsgContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagGetPostProcessorFunc()
 *********************************************************************************************************************/
/*! \brief          Returns a pointer to a post-processor function of the given index.
 *  \details        -
 *  \param[in]      index       Unique handle to a post-processor function
 *  \return         Post-handler
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcConfirmationFuncType, DCM_CODE) Dcm_DiagGetPostProcessorFunc(
  uint8_least index
  );

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetUpdateFunc()
 *********************************************************************************************************************/
/*! \brief          Returns a pointer to an update function of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to an update function
 *  \return         Paged-buffer update-handler
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcUpdateFuncType, DCM_CODE) Dcm_DiagGetUpdateFunc(
  uint8_least index
  );
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetCancelFunc()
 *********************************************************************************************************************/
/*! \brief          Returns a pointer to a cancellation function of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a cancellation function
 *  \return         Paged-buffer cancel-handler
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcCancelFuncType, DCM_CODE) Dcm_DiagGetCancelFunc(
  uint8_least index
  );
#endif

/**********************************************************************************************************************
 *  Dcm_DiagInit()
 *********************************************************************************************************************/
/*! \brief          Initializes DCM diagnostic sub-module.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts must be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInit(
  void
  );

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagPutStartUpFblResBuffer()
 *********************************************************************************************************************/
/*! \brief          Writes into the global start up FBL response buffer.
 *  \details        -
 *  \param[in]      index         Index to the start up FBL response buffer
 *  \param[in]      value         New value of the start up FBL response buffer
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagPutStartUpFblResBuffer(
  uint8_least index,
  Dcm_MsgItemType value
  );
#endif

/**********************************************************************************************************************
 *  Dcm_DiagAcceptNewRequest()
 *********************************************************************************************************************/
/*! \brief          Checks whether a new request will be accepted.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM USDT connection
 *  \return         TRUE          New request is accepted
 *  \return         FALSE         New request is not accepted
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_DiagAcceptNewRequest(
  Dcm_NetTransportObjectPtrType pTranspObj
  );

/**********************************************************************************************************************
 *  Dcm_DiagOnTxFinished()
 *********************************************************************************************************************/
/*! \brief          Notifies the diagnostic sub-module that an ongoing transmission just finished.
 *  \details        Called by the TP once an ongoing transmission is finished.
 *  \param[in]      pTranspObj    Currently active DCM USDT connection
 *  \param[in]      txStatus      Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagOnTxFinished(
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_NetTransmissionResultType txStatus
  );

/**********************************************************************************************************************
 *  Dcm_DiagExecConfirmationFunc()
 *********************************************************************************************************************/
/*! \brief          Executes a confirmation callback and evaluates its return values.
 *  \details        -
 *  \param[in]     pContext       Pointer to the context
 *  \param[in]      notifList     The diagnostic request confirmation list to be executed
 *  \param[in]      confStatus    The post-processing status
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            The last element of the passed notifList must be marked by NULL_PTR.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagExecConfirmationFunc(
  Dcm_ContextPtrType pContext,
  Dcm_CfgDiagNotificationInfoPtrType notifList,
  Dcm_ConfirmationStatusType confStatus
  );

/**********************************************************************************************************************
 *  Dcm_DiagGetPostProcessResult()
 *********************************************************************************************************************/
/*! \brief          Calculates the Dcm_ConfirmationType value for the post processors.
 *  \details        -
 *  \param[in]      pContext    Pointer to the context
 *  \return         The confirmation status
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_ConfirmationStatusType, DCM_CODE) Dcm_DiagGetPostProcessResult(
  Dcm_ContextPtrType pContext
  );

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetRecoverySignature()
 *********************************************************************************************************************/
/*! \brief          Composes the recovery information control check-sum signature.
 *  \details        -
 *  \return         The control checksum
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint32, DCM_CODE) Dcm_DiagGetRecoverySignature(
  void
  );
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagProvideRecoveryStates()
 *********************************************************************************************************************/
/*! \brief          Takes the restored DCM state over.
 *  \details        Takes the external stored and recovered DCM state over.
 *  \param[in,out]  RecoveryInfo    Reference to structure that stores recovery info
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagProvideRecoveryStates(
  P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo
  );
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagProcessRecoveryInfo()
 *********************************************************************************************************************/
/*! \brief          Takes the restored DCM state over.
 *  \details        Takes the external stored and recovered DCM state over.
 *  \param[in,out]  RecoveryInfo    Reference to structure that stores recovery info
 *  \param[in]      opStatus        Current operation status
 *  \context        TASK
 *  \return         DCM_E_OK        Processing succeeded
 *  \return         DCM_E_PENDING   Disable DTC API call is pending
 *  \return         DCM_E_NOT_OK    Disable DTC API call failed
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagProcessRecoveryInfo(
  P2CONST(Dcm_RecoveryInfoType, AUTOMATIC, DCM_VAR_NOINIT) RecoveryInfo,
  Dcm_OpStatusType opStatus
  );
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagSafeProcessRecoveryInfo()
 *********************************************************************************************************************/
/*! \brief          Checks and takes the restored DCM state over.
 *  \details        Checks and takes the external stored and recovered DCM state over.
 *  \param[in,out]  RecoveryInfo    Reference to structure that stores recovery info
 *  \param[in]      opStatus        Current operation status
 *  \context        TASK
 *  \return         DCM_E_OK        Processing succeeded
 *  \return         DCM_E_PENDING   Disable DTC API call is pending
 *  \return         DCM_E_NOT_OK    Processing failed
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSafeProcessRecoveryInfo(
  P2CONST(Dcm_RecoveryInfoType, AUTOMATIC, DCM_VAR_NOINIT) RecoveryInfo,
  Dcm_OpStatusType opStatus
  );
#endif

#if (DCM_DIAG_SPECIFIC_CAUSE_CODE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagSetSpecificCauseCode()
 *********************************************************************************************************************/
/*! \brief          Registers a specific cause code.
 *  \details        Registers a specific cause code to the request in progress if no other specific cause code already
 *                  set.
 *  \param[in]      specificCauseCode    The specific cause code to be registered
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetSpecificCauseCode(
  Dcm_SpecificCauseCodeType specificCauseCode
  );
#endif

#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagIsSessionChangeAllowed()
 *********************************************************************************************************************/
/*! \brief          Checks whether any other thread is currently busy with a parallel request.
 *  \details        -
 *  \param[in]      pContext    Pointer to the context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagIsSessionChangeAllowed(
  Dcm_ContextPtrType pContext
  );
#endif

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcCancelOpenJobs()
 *********************************************************************************************************************/
/*! \brief          Cancel open diagnostic jobs.
 *  \details        -
 *  \param[in]      pContext    Pointer to the context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoCancelProcCancelOpenJobs(
  Dcm_ContextPtrType pContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcReviveKilledTasks()
 *********************************************************************************************************************/
/*! \brief          Revive tasks that were killed during cancellation.
 *  \details        -
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoCancelProcReviveKilledTasks(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcessing()
 *********************************************************************************************************************/
/*! \brief          Performs diagnostic job cancellation.
 *  \details        If a diagnostic job is ongoing the appropriate action will be taken to close it deterministically.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoCancelProcessing(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoPostProcessing()
 *********************************************************************************************************************/
/*! \brief          Performs post processing of currently finished request.
 *  \details        -
 *  \param[in]      pContext        Pointer to the context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoPostProcessing(
  Dcm_ContextPtrType pContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagWorkerSetDefSessionExtern()
 *********************************************************************************************************************/
/*! \brief          Performs session transition to the default session on external request.
 *  \details        Synchronizes an external session change request with the internal DCM state. If a diagnostic job is
 *                  still in processing, the session change request will be postponed till the job is finished. This is
 *                  required in order to guarantee clean sequence flow on session change and active diagnostic jobs.
 *  \param[in]      pContext  Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerSetDefSessionExtern(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagSwitchProcessingContext()
 *********************************************************************************************************************/
/*! \brief          Performs a context switch of the current working serivice processing set.
 *  \details        -
 *  \param[in]      pContext    Pointer to the context
 *  \context        TASK
 *  \return         DCM_E_OK                Initialization succeeded, proceed with next step
 *  \return         DCM_E_NOT_OK            Initialization failed, repeat again next time
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSwitchProcessingContext(
  Dcm_ContextPtrType pContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagInitMsgContextBufferInfo()
 *********************************************************************************************************************/
/*! \brief          Initializes the given message context.
 *  \details        Initializes the given message context so that it points always to a valid buffer.
 *  \param[in,out]  pMsgContext   Current message context
 *  \param[in]      index         Unique handle to a buffer information element
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInitMsgContextBufferInfo(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_CfgNetBufferRefOptType index
  );

/**********************************************************************************************************************
 *  Dcm_DiagInitiateServiceProcessing()
 *********************************************************************************************************************/
/*! \brief          Initiates diagnostic kernel for new request processing.
 *  \details        -
 *  \param[in]      pContext        Pointer to the context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *  \note           The parameter pMsgContext is passed to this function for initialization.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInitiateServiceProcessing(
  Dcm_ContextPtrType pContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagHandleSuppressBit()
 *********************************************************************************************************************/
/*! \brief          Handles the SPRMIB if set and supported by the requested service.
 *  \details        -
 *  \param[in]      pContext       Pointer to the context
 *  \param[in]      pTranspObj     The transport object
 *  \param[in,out]  pMsgContext    Current request context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagHandleSuppressBit(
  Dcm_ContextPtrType pContext,
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_MsgContextPtrType pMsgContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagHandleDispatching()
 *********************************************************************************************************************/
/*! \brief          Handles the service dispatching.
 *  \details        -
 *  \param[in]      sid            The SID of the request
 *  \param[in,out]  pMsgContext    Current request context
 *  \param[in]      pContext       Pointer to the context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagHandleDispatching(
  uint8 sid,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_ContextPtrType pContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagValidateAndDispatchService()
 *********************************************************************************************************************/
/*! \brief          Validates received SID and dispatches further processing.
 *  \details        -
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The error code to be returned
 *  \return         DCM_E_OK                Validation succeeded. Initiate recognized service processing
 *  \return         DCM_E_NOT_OK            Validation failed. Finish service processing with the ErrorCode result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Dcm_DiagInitiateServiceProcessing() shall be called first.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagValidateAndDispatchService(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_ContextPtrType pContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_DiagWorkerProcessNewRequest()
 *********************************************************************************************************************/
/*! \brief          Initiates diagnostic service processing once a new request is received.
 *  \details        -
 *  \param[in]      pContext  Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerProcessNewRequest(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagWorkerProcessRcrRpTxEnd()
 *********************************************************************************************************************/
/*! \brief          Prepares for application notification after enforced RCR-RP transmission.
 *  \details        -
 *  \param[in]      pContext  Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerProcessRcrRpTxEnd(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON) && \
    (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerCancelOperation()
 *********************************************************************************************************************/
/*! \brief          Cancels any ongoing diagnostic operation.
 *  \details        -
 *  \param[in]      pContext  Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerCancelOperation(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

#if (DCM_STATE_SECURITY_BYPASS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerSetSecurityBypass()
 *********************************************************************************************************************/
/*! \brief          Performs security level bypass.
 *  \details        Enables or disables a security bypass mode. If a diagnostic job is still in processing,
 *                  the security bypass mode will be postponed until the job is finished. This is required
 *                  in order to prevent security state inconsistencies.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerSetSecurityBypass(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoRepeat()
 *********************************************************************************************************************/
/*! \brief          Triggers a scheduled diagnostic job activity.
 *  \details        Each registered diagnostic job activity will be called out from this point.
 *  \param[in]      pContext  Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoRepeat(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );

#if (DCM_TSK_NUM_DIAG_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoGetProgCond()
 *********************************************************************************************************************/
/*! \brief          Gets the programming conditions from FBL/Application.
 *  \details        Checks and takes the external stored and recovered DCM state over.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagFblResDoGetProgCond(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoWaitTxComm()
 *********************************************************************************************************************/
/*! \brief          Waits until the ComM has processed the DCM communication request.
 *  \details        Waits for either P2Star timeout of ComM acknowledge of channel wake up.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagFblResDoWaitTxComm(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoResetFlags()
 *********************************************************************************************************************/
/*! \brief          Resets all FBL flags.
 *  \details        Resets all FBL related flags so at next power-on/reset no final response to be sent.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagFblResDoResetFlags(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoProcessTxConfirmation()
 *********************************************************************************************************************/
/*! \brief          Performs a session transition after a final positive response.
 *  \details        If the final response was for SID 0x10, the corresponding session transition is performed here.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagFblResDoProcessTxConfirmation(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagTxPostponeFinalPagedResponse()
 *********************************************************************************************************************/
/*! \brief          Postpones the diagnostic service final response transmission if paged-buffer used.
 *  \details        The postponing is required only if the SPRMIB was set. Since the SPMRIB=TRUE means
 *                  "execute job, but do not send a response", in the case of paged-buffer the response is sent during
 *                  the "job execution". So if the P2 time is exceeded while performing the job, the final response may
 *                  not be able to provide all of the response data (the previous data pages are already lost)
 *  \param[in]      pContext  Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagTxPostponeFinalPagedResponse(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

/**********************************************************************************************************************
 *  Dcm_DiagTxStartFinalResponse()
 *********************************************************************************************************************/
/*! \brief          Initiates diagnostic service final response transmission.
 *  \details        -
 *  \param[in]      pContext  Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagTxStartFinalResponse(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagTxStartRcrRpResponse()
 *********************************************************************************************************************/
/*! \brief          Initiates diagnostic service RCR-RP response transmission.
 *  \details        -
 *  \param[in]      pContext  Pointer to the context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagTxStartRcrRpResponse(
  Dcm_ContextPtrType pContext
  );

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetRecoveryInfoComMChannelState()
*********************************************************************************************************************/
/*! \brief          Returns a pointer to a ComM channel state of the recovery info.
 *  \details        -
 *  \param[in]      RecoveryInfo    Reference to structure that stores recovery info
 *  \param[in]      index           Index to a ComM channel state
 *  \return         A valid pointer to a ComM channel state
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_RecoveryInfoComMChannelStatePtrType, DCM_CODE) Dcm_DiagGetRecoveryInfoComMChannelState(
  P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo,
  Dcm_CfgNetNetIdRefOptType index
  );
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON && DCM_MODE_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetRecoveryInfoCommControlState()
*********************************************************************************************************************/
/*! \brief          Returns a pointer to the communication state of a ComM channel of the recovery info.
 *  \details        -
 *  \param[in]      RecoveryInfo    Reference to structure that stores recovery info
 *  \param[in]      index           Index to the communication state of a ComM channel
 *  \return         A valid pointer to the communication state of a ComM channel
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_RecoveryInfoCommControlStatePtrType, DCM_CODE) Dcm_DiagGetRecoveryInfoCommControlState(
  P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo,
  Dcm_CfgNetNetIdRefOptType index
  );
#endif

/**********************************************************************************************************************
 *  Dcm_DiagIsCancellationNeeded()
 *********************************************************************************************************************/
/*! \brief          Check whether cancellation of diagnostic service processing is necessary.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_DiagIsCancellationNeeded(
  Dcm_NetTransportObjectPtrType pTranspObj
  );
#if (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrInit()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Initialization of variant manager sub-module.
 *  \param[in]      configPtr    Pointer to a concrete configuration root
 *  \return         TRUE         Configuration root pointer is valid
 *  \return         FALSE        Configuration root pointer is invalid
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_VarMgrInit(
  Dcm_ConfigPtrType configPtr
  );
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrInitActiveCfgVariants()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Initialization of variant manager ActiveCfgVariants global variable.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrInitActiveCfgVariants(
  void
  );
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrVsgSetSingle()
 *********************************************************************************************************************/
/*! \brief          Sets the status of a single VSG.
 *  \details        -
 *  \param[in]      VsgId         Unique handle of the VSG.
 *  \param[in]      State         DCM_VSG_ENABLED:  Set VSG to active
 *                                DCM_VSG_DISABLED: Set VSG to inactive
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrVsgSetSingle(
  Dcm_VsgIdentifierType VsgId,
  Dcm_VsgStateType State
  );
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrVsgIsActive()
 *********************************************************************************************************************/
/*! \brief          Returns status of a single VSG.
 *  \details        -
 *  \param[in]      VsgId         Unique handle of the VSG.
 *  \param[out]     State         DCM_VSG_ENABLED:  VSG is active
 *                                DCM_VSG_DISABLED: VSG is inactive
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrVsgIsActive(
  Dcm_VsgIdentifierType VsgId,
  P2VAR(Dcm_VsgStateType, AUTOMATIC, DCM_APPL_DATA) State
  );
#endif
#if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc01ServiceInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Get service info descriptor.
 *  \details        -
 *  \param[in]      index           Index to a service info descriptor
 *  \param[out]     pServiceInfo    The service info descriptor
 *  \param[out]     ErrorCode       Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc01ServiceInfoGetEntry(
  uint8_least index,
  CONSTP2VAR(Dcm_CfgSvc01ServiceInfoPtrType, AUTOMATIC, AUTOMATIC) pServiceInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc01Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x01 Handler.
 *  \details        -
 *  \param[in]      pContext        Pointer to the context
 *  \param[in]      opStatus        The operations status
 *  \param[in,out]  pMsgContext     Current message context
 *  \param[out]     ErrorCode       The NRC
 *  \param[in,out]  pRepContext     Current repeater proxy context
 *  \return         DCM_E_NOT_OK    Send negative response
 *  \return         DCM_E_LOOP      Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc01Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc01RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc01_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x01 worker.
 *  \details        -
 *  \param[in]      opStatus         The operations status
 *  \param[in]      pMsgContext      Current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[in,out]  pRepContext      Current repeater proxy context
 *  \return         DCM_E_OK         Send response
 *  \return         DCM_E_NOT_OK     Send negative response
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc01_XX_RepeaterProxy(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc01RepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc02Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x02 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc02Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc02RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc02_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x02 worker.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send positive response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc02_XX_RepeaterProxy(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc02RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc02ReadPidData()
 *********************************************************************************************************************/
/*! \brief          Reads a single valid PID data.
 *  \details        -
 *  \param[in]      pid          The PID which data shall be read
 *  \param[in,out]  pMsgContext  The message context
 *  \param[in,out]  pRepContext  Current repeater proxy context
 *  \return         DCM_E_OK        Send positive response
 *  \return         DCM_E_NOT_OK    Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc02ReadPidData(
  uint8 pid,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_Svc02RepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_02_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc03Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x03 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc03Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_ObdDtcManagerContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc03UtiDemSetDTCFilter()
 *********************************************************************************************************************/
/*! \brief          Wrapper function for Dem_SetDTCFilter API.
 *  \details        Sets the DTC filter using the respective DEM API.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc03UtiDemSetDTCFilter(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_ObdDtcManagerContextPtrType pRepContext
  );
#endif /* (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc04Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x04 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc04Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc04RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc04_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x04 worker.
 *  \details        Calls the ClearDTC function.
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc04_XX_RepeaterProxy(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc04RepeaterProxyContextPtrType pRepContext
  );

# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc04_XX_RepeaterProxy_SelectDTC()
 *********************************************************************************************************************/
/*! \brief          Service 0x04 worker.
 *  \details        Calls the SelectDTC function.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc04_XX_RepeaterProxy_SelectDTC(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc04RepeaterProxyContextPtrType pRepContext
  );
# endif
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc06Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x06 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc06Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc06RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc06_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x06 worker.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send positive response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc06_XX_RepeaterProxy(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc06RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Service06ProcessSupportedMidRequest()
 *********************************************************************************************************************/
/*! \brief          Check and process if every MID in request is an availability MID (0x00, 0x20, 0x40...).
 *  \details        -
 *  \param[in,out]  pMsgContext             The current request context
 *  \param[out]     ErrorCode               Negative response code
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service06ProcessSupportedMidRequest(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Service06Process_SupportedMids()
 *********************************************************************************************************************/
/*! \brief          Reading supported MIDs.
 *  \details        -
 *  \param[in,out]  pMsgContext             The current request context
 *  \param[out]     ErrorCode               Negative response code
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service06Process_SupportedMids(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc06MidTidInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Get Mid Tid info descriptor.
 *  \details        -
 *  \param[in]      index           Index to a service info descriptor
 *  \param[out]     pMidTidInfo     The Mid Tid info descriptor.
 *  \param[out]     ErrorCode       Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc06MidTidInfoGetEntry(
  uint8_least index,
  CONSTP2VAR(Dcm_CfgSvc06MidTidInfoPtrType, AUTOMATIC, AUTOMATIC) pMidTidInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc06Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x06 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc06Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc06RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc06_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x06 worker.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc06_XX_RepeaterProxy(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc06RepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_07_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc07Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x07 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc07Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_ObdDtcManagerContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc07UtiDemSetDTCFilter()
 *********************************************************************************************************************/
/*! \brief          Wrapper function for Dem_SetDTCFilter API.
 *  \details        Sets the DTC filter using the respective DEM API.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc07UtiDemSetDTCFilter(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_ObdDtcManagerContextPtrType pRepContext
  );
#endif /* (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc08ServiceInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Get service info descriptor.
 *  \details        -
 *  \param[in]      index           Index to a service info descriptor
 *  \param[out]     pServiceInfo    The service info descriptor
 *  \param[out]     ErrorCode       Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc08ServiceInfoGetEntry(
  uint8_least index,
  CONSTP2VAR(Dcm_CfgSvc08ServiceInfoPtrType, AUTOMATIC, AUTOMATIC) pServiceInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc08Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x08 Handler.
 *  \details        -
 *  \param[in]      pContext        Pointer to the context
 *  \param[in]      opStatus        The operations status
 *  \param[in,out]  pMsgContext     Current message context
 *  \param[out]     ErrorCode       The NRC
 *  \param[in,out]  pRepContext     Current repeater proxy context
 *  \return         DCM_E_NOT_OK    Send negative response
 *  \return         DCM_E_LOOP      Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc08Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc08RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc08_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x08 worker.
 *  \details        -
 *  \param[in]      opStatus         The operations status
 *  \param[in]      pMsgContext      Current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[in,out]  pRepContext      Current repeater proxy context
 *  \return         DCM_E_OK         Send response
 *  \return         DCM_E_NOT_OK     Send negative response
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc08_XX_RepeaterProxy(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc08RepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc09ServiceInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Get service info descriptor.
 *  \details        -
 *  \param[in]      index           Index to a service info descriptor
 *  \param[out]     pServiceInfo    The service info descriptor
 *  \param[out]     ErrorCode       Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc09ServiceInfoGetEntry(
  uint8_least index,
  CONSTP2VAR(Dcm_CfgSvc09ServiceInfoPtrType, AUTOMATIC, AUTOMATIC) pServiceInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc09Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x09 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc09Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc09RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc09CheckAccess()
 *********************************************************************************************************************/
/*! \brief          Checks the service 0x09 access.
 *  \details        Tries to lock a given Did and react accordingly.
 *  \param[in]      pContext         Pointer to the context
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \param[in]      pRepContext      Current repeater proxy context
 *  \param[out]     ErrorCode        The NRC
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc09CheckAccess(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc09RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc09_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x09 worker.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc09_XX_RepeaterProxy(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc09RepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc0AHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x0A Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc0AHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_ObdDtcManagerContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc0AUtiDemSetDTCFilter()
 *********************************************************************************************************************/
/*! \brief          Wrapper function for Dem_SetDTCFilter API.
 *  \details        Sets the DTC filter using the respective DEM API.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc0AUtiDemSetDTCFilter(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_ObdDtcManagerContextPtrType pRepContext
  );
#endif /* (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_TriggerReset()
 *********************************************************************************************************************/
/*! \brief          Triggers an Ecu Reset.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_FORCE_RCRRP       Enforce a RCR-RP transmission
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_NOT_OK            Operation failed, send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_TriggerReset(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext
  );
#endif


#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_WaitForResetAck()
 *********************************************************************************************************************/
/*! \brief          Wait for Ecu Reset acknowledgment.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_FORCE_RCRRP       Enforce a RCR-RP transmission
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_NOT_OK            Operation failed, send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_WaitForResetAck(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext
  );
#endif

#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_WaitForRcrRpAck()
 *********************************************************************************************************************/
/*! \brief          Wait for RCR-RP acknowledgment.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \return         DCM_E_NOT_OK            Operation failed, send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_WaitForRcrRpAck(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext
  );
#endif

#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_SetProgConditions()
 *********************************************************************************************************************/
/*! \brief          Sets programming conditions.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Trigger to stop repeater (programming conditions set)
 *  \return         DCM_E_NOT_OK            Operation failed, send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_SetProgConditions(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext
  );
#endif

/**********************************************************************************************************************
 *  Dcm_Svc10Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x10 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send final positive response
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \return         DCM_E_NOT_OK            Operation failed
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc10CheckAccess()
 *********************************************************************************************************************/
/*! \brief          Checks whether transistion to requested session can be performed.
 *  \details        If e.g. any OBD request is currently in progress the session change request has to be delayed.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send final positive response
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \return         DCM_E_NOT_OK            Operation failed
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10CheckAccess(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext
  );
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc11SubFuncInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor.
 *  \details        -
 *  \param[in]      SubSvcRef       Index to a subfunction descriptor
 *  \param[out]     pSubFuncInfo    The subfunction descriptor
 *  \param[out]     ErrorCode       Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc11SubFuncInfoGetEntry(
  Dcm_DiagSubServiceRefOptType SubSvcRef,
  CONSTP2VAR(Dcm_CfgSvc11SubFuncInfoPtrType, AUTOMATIC, AUTOMATIC) pSubFuncInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc11Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc11RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc11SubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 SubFunction Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11SubFuncHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc11RepeaterProxyContextPtrType pRepContext
  );

# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_EcuRst_WaitForAck()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 repeater.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_EcuRst_WaitForAck(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc11RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_11_RAPID_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_RapPwrDwn_WaitForAck()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 repeater.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_RapPwrDwn_WaitForAck(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc11RepeaterProxyContextPtrType pRepContext
  );
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc14Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x14 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc14RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc14_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x14 worker.
 *  \details        Calls the ClearDTC function.
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send positive response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14_XX_RepeaterProxy(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc14RepeaterProxyContextPtrType pRepContext
  );

# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc14_XX_RepeaterProxySelectDTC()
 *********************************************************************************************************************/
/*! \brief          Service 0x14 worker.
 *  \details        Calls the SelectDTC function.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14_XX_RepeaterProxySelectDTC(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc14RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  );
# endif

# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc14_XX_RepeaterProxyCheckSelectionResult()
 *********************************************************************************************************************/
/*! \brief          Service 0x14 worker.
 *  \details        Calls the GetDTCSelectionResult function.
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14_XX_RepeaterProxyCheckSelectionResult(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc14RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  );
# endif
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc19SubFuncInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor.
 *  \details        -
 *  \param[in]      SubSvcRef       Index to a subfunction descriptor
 *  \param[out]     pSubFuncInfo    The subfunction descriptor
 *  \param[out]     ErrorCode       Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc19SubFuncInfoGetEntry(
  Dcm_DiagSubServiceRefOptType SubSvcRef,
  CONSTP2VAR(Dcm_CfgSvc19SubFuncInfoPtrType, AUTOMATIC, AUTOMATIC) pSubFuncInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc19Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x19 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc19SubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x19 SubFunction Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19SubFuncHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSelectDTC()
 *********************************************************************************************************************/
/*! \brief          Wrapper function for Dem_SelectDTC API.
 *  \details        Performs the DTC selection using the respective DEM API.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Selection API never fails
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSelectDTC(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_DEMAPI_SVC_19_SETDTCFILTER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSetDTCFilter()
 *********************************************************************************************************************/
/*! \brief          Wrapper function for Dem_SetDTCFilter API.
 *  \details        Sets the DTC filter using the respective DEM API.
 *  \param[out]     ErrorCode               The NRC
 *  \param[in]      DsfClass                DEM SetFilter class type
 *  \param[in]      DtcStatusMask           DTC status mask
 *  \param[in]      DtcSeverityMask         DTC severity mask
 *  \param[in]      FilterForFDC            Filter for fault detection counter
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Filter successully set
 *  \return         DCM_E_OK                Setting filter failed
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSetDTCFilter(
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19DemSetFilterClassType DsfClass,
  uint8 DtcStatusMask,
  Dem_DTCSeverityType DtcSeverityMask,
  Dcm_DemFilterForFDCType FilterForFDC,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_DEMAPI_SVC_19_GETDTCSTATUSAVAILABILITYMASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask()
 *********************************************************************************************************************/
/*! \brief          Wrapper function for Dem_GetDTCStatusAvailabilityMask API.
 *  \details        Returns the supported DTC status availability mask using the respective DEM API.
 *  \param[out]     pDtcStatusAvailMask     Pointer to the DTCStatusMask
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK        Filter successully set
 *  \return         DCM_E_NOT_OK    Setting filter failed
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask(
  Dcm_Svc19DemDtcStatusAvailMaskPtrType pDtcStatusAvailMask,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Sv19UtiStartReporting()
 *********************************************************************************************************************/
/*! \brief          Dispatches the current update job to the corresponding sub-updater function.
 *  \details        This is shared utility function of the Repeater and PagedBuffer.
 *  \param[in]      pContext        Pointer to the context
 *  \param[in]      pMsgContext     Pointer to current message context
 *  \param[in]      subUpdater      The reporting engine to be invoked
 *  \param[in]      reportSize      Calculated report size (used only for paged buffer)
 *  \param[in,out]  pRepContext     Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Let the page-buffer do the job
 *  \return         DCM_E_OK                Send response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Sv19UtiStartReporting(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,
  uint8 subUpdater,
  Dcm_MsgLenType reportSize,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_19_ABSTRACT_RECORD_ITER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Sv19UtiRecordIterNext()
 *********************************************************************************************************************/
/*! \brief          Returns the next DTC record or end of iteration result.
 *  \details        -
 *  \param[in,out]  pRepContext     Current repeater proxy context
 *  \return         DCM_SVC19_UTI_REC_ITER_RSLT_OK                Next record has been found
 *  \return         DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS   End of iteration (record ID shall not be evaluated from now on)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            A non-empty list of records has to be passed to this utility
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc19UtiRecordIterResultType, DCM_CODE) Dcm_Svc19UtiRecordIterNext(
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19UtiCopyData()
 *********************************************************************************************************************/
/*! \brief          Dispatches the current update job to the corresponding sub-updater function.
 *  \details        This is shared utility function of the Repeater and PagedBuffer.
 *  \param[in]      pContext                    Pointer to the context
 *  \param[in,out]  pDataContext                Pointer to the data context
 *  \param[out]     ErrorCode                   The NRC
 *  \param[in,out]  pRepContext                 Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_PENDING_LIMITER       Runtime limit reached, retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available space any more
 *  \return         DCM_E_NOT_OK                Error occured
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service19UtiCopyData(
  Dcm_ContextPtrType pContext,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_19_COPY_LINEAR_DATA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCopyLinearData()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Utility to copy linear data.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_PENDING_LIMITER   Runtime limit reached, retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCopyLinearData(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemDisableRecordUpdate()
 *********************************************************************************************************************/
/*! \brief          Disables the update of records of a particular DTC.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemDisableRecordUpdate(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_DEMAPI_SVC_19_GETSTATUSOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetStatusOfDtc()
 *********************************************************************************************************************/
/*! \brief          Reads the DTC status bits.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetStatusOfDtc(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFFFRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSizeOfFFRecord()
 *********************************************************************************************************************/
/*! \brief          Calculates the size of one or multiple freeze-frame data record(s).
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Let the page-buffer do the job
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSizeOfFFRecord(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_DEM_API_SELECT_EDR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSelectExtRecord()
 *********************************************************************************************************************/
/*! \brief          Selects the extended data record(s).
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Let the page-buffer do the job
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSelectExtRecord(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFEXTRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSizeOfExtRecord()
 *********************************************************************************************************************/
/*! \brief          Calculates the size of one or multiple extended data record(s).
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Let the page-buffer do the job
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSizeOfExtRecord(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_DEMAPI_SVC_19_GETNUMFILTEREDDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNumFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          Retrieves the number of filtered DTCs.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNumFltrdDtc(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*! \brief          Initiates reading filtered DTCs severity.
 *  \details        Depending of enabled/disabled paged buffer, starts corresponding reporting process.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER       Stop polling
 *  \return         DCM_E_LOOP                Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdSeverity(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSeverityOfDtc()
 *********************************************************************************************************************/
/*! \brief          Reads the next filtered DTCs severity.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSeverityOfDtc(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetFuncUnitOfDtc()
 *********************************************************************************************************************/
/*! \brief          Reads the functional unit of the requested DTC.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetFuncUnitOfDtc(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );

# endif

# if (DCM_DEMAPI_SVC_19_GETNEXTFILTEREDDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          Read the next filtered DTC and its status mask.
 *  \details        -
 *  \param[in]      pContext                    Pointer to the context
 *  \param[in,out]  pDataContext                Pointer to the data context
 *  \param[out]     ErrorCode                   The NRC
 *  \param[in,out]  pRepContext                 Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_PENDING_LIMITER       Runtime limit reached, retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available space any more
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \return         DCM_E_NOT_OK                Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdDtc(
  Dcm_ContextPtrType pContext,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_DEM_API_SELECT_FFR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSelectFFData()
 *********************************************************************************************************************/
/*! \brief          Selects a freeze-frame data record.
 *  \details        -
 *  \param[in]      pContext              Pointer to the context
 *  \param[in,out]  pRepContext           Current repeater proxy context
 *  \param[out]     ErrorCode             The NRC
 *  \return         DCM_E_LOOP            Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSelectFFData(
  Dcm_ContextPtrType pContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetFFRecord()
 *********************************************************************************************************************/
/*! \brief          Read the next DTCs freeze-frame data record.
 *  \details        -
 *  \param[in,out]  pDataContext          Pointer to the data context
 *  \param[out]     ErrorCode             The NRC
 *  \param[in,out]  pRepContext           Current repeater proxy context
 *  \return         DCM_E_OK              All data copied
 *  \return         DCM_E_PENDING         Retry later
 *  \return         DCM_E_BUFFERTOOLOW    Retry later, because of no available space any more
 *  \return         DCM_E_NOT_OK          Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetFFRecord(
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdFDC()
 *********************************************************************************************************************/
/*! \brief          Initiates reading filtered DTCs FDC.
 *  \details        Depending of enabled/disabled paged buffer, starts corresponding reporting process.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER       Stop polling
 *  \return         DCM_E_LOOP                Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdFDC(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_19_56_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
*  Dcm_Svc19UtiDemSetReadinessGroupIdentifierFilter()
*********************************************************************************************************************/
/*! \brief         Initiates reading of DTCs filtered by ReadinessGroupIdentifier.
*  \details        -
*  \param[in]      readinessGroupNumber    readiness group identifier
*  \param[out]     ErrorCode               The NRC
*  \param[in,out]  pRepContext             Current repeater proxy context
*  \return         DCM_E_OK       Setting the filter was successfully
*  \return         DCM_E_NOT_OK   Error occured
*  \context        TASK
*  \reentrant      FALSE
*  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSetReadinessGroupIdentifierFilter(
  Dem_EventOBDReadinessGroupType readinessGroupNumber,
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  );
# endif

# if (DCM_SVC_19_16_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSetExtDataRecordFilter()
 *********************************************************************************************************************/
/*! \brief          Initiates reading of filtered extended data records.
 *  \details        -
 *  \param[out]     ErrorCode      The NRC
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         DCM_E_OK       Setting the filter was successfully
 *  \return         DCM_E_NOT_OK   Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSetExtDataRecordFilter(
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  );
# endif

# if (DCM_SVC_19_16_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdExtRecord()
 *********************************************************************************************************************/
/*! \brief          Read the next filtered extended data record.
 *  \details        -
 *  \param[in,out]  pDataContext          Pointer to the data context
 *  \param[out]     ErrorCode             The NRC
 *  \param[in,out]  pRepContext           Current repeater proxy context
 *  \return         DCM_E_OK              All data copied
 *  \return         DCM_E_PENDING         Retry later
 *  \return         DCM_E_BUFFERTOOLOW    Retry later, because of no available space any more
 *  \return         DCM_E_NOT_OK          Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdExtRecord(
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiWwhObdDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*! \brief          Initiates reading filtered DTCs status mask.
 *  \details        Depending of enabled/disabled paged buffer, starts corresponding reporting process.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Stop polling
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiWwhObdDemGetNxtFltrdSeverity(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_DEMAPI_SVC_19_GETNEXTFILTEREDDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          Initiates reading filtered DTCs status mask.
 *  \details        Depending of enabled/disabled paged buffer, starts corresponding reporting process.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER       All data copied
 *  \return         DCM_E_LOOP                Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdDtc(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiPutNumFilteredDtc()
 *********************************************************************************************************************/
/*! \brief          Write caclucalted by DEM number of filtered DTCs into the response buffer.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                This value is always returned
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiPutNumFilteredDtc(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Calls the GetNextFilteredDTCAndSeverity function.
 *  \param[in]      pContext                    Pointer to the context
 *  \param[in,out]  pDataContext                Pointer to the data context
 *  \param[out]     ErrorCode                   The NRC
 *  \param[in,out]  pRepContext                 Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_PENDING_LIMITER       Runtime limit reached, retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available space any more
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity(
  Dcm_ContextPtrType pContext,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Calls the GetNextFilteredDTCAndSeverity function.
 *  \param[in]      pContext                    Pointer to the context
 *  \param[in,out]  pDataContext                Pointer to the data context
 *  \param[out]     ErrorCode                   The NRC
 *  \param[in,out]  pRepContext                 Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_PENDING_LIMITER       Runtime limit reached, retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available space any more
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \return         DCM_E_NOT_OK                Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity(
  Dcm_ContextPtrType pContext,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_19_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdRecord()
 *********************************************************************************************************************/
/*! \brief          Read the next filtered DTC and its record number.
 *  \details        -
 *  \param[in,out]  pDataContext                Pointer to the data context
 *  \param[out]     ErrorCode                   The NRC
 *  \param[in,out]  pRepContext                 Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_PENDING_LIMITER       Runtime limit reached, retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available space any more
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \return         DCM_E_NOT_OK                Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdRecord(
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetExtRecord()
 *********************************************************************************************************************/
/*! \brief          Read the next DTCs extended data record.
 *  \details        -
 *  \param[in,out]  pDataContext          Pointer to the data context
 *  \param[out]     ErrorCode             The NRC
 *  \param[in,out]  pRepContext           Current repeater proxy context
 *  \return         DCM_E_OK              All data copied
 *  \return         DCM_E_PENDING         Retry later
 *  \return         DCM_E_BUFFERTOOLOW    Retry later, because of no available space any more
 *  \return         DCM_E_NOT_OK          Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetExtRecord(
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_19_1A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSetDTCFilterByExtendedDataRecordNumber()
*********************************************************************************************************************/
/*! \brief          Initiates reading of DTCs filtered by ExtendedDataRecordNumber.
 *  \details        -
 *  \param[in]      ExtendedDataRecordNumber    The number of the extended data record.
 *  \param[out]     ErrorCode                   The NRC
 *  \param[in,out]  pRepContext                 Current repeater proxy context
 *  \return         DCM_E_OK       Setting the filter was successfully
 *  \return         DCM_E_NOT_OK   Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSetDTCFilterByExtendedDataRecordNumber(
  uint8 ExtendedDataRecordNumber,
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  );
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22GetDidInfoContext()
 *********************************************************************************************************************/
/*! \brief          Returns a pointer to a DidInfoContext of the index given by the repeater proxy context.
 *  \details        -
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         A valid pointer to a DidInfoContext
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DidMgrDidInfoContextPtrType, DCM_CODE) Dcm_Svc22GetDidInfoContext(
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc22Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x22 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc22ReadDid()
 *********************************************************************************************************************/
/*! \brief          Reads a single paged DID for service 0x22.
 *  \details        -
 *  \param[in]      opStatus                The operation status
 *  \param[in,out]  pDataContext            The pointer to the data context
 *  \param[in,out]  pDidInfoContext         The DID configuration context
 *  \param[in,out]  pDidOpTypeContext       The DID configuration operation context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK                All data has been copied
 *  \return         DCM_E_PENDING           No result yet, retry later
 *  \return         DCM_E_BUFFERTOOLOW      Some data copied but no place, retry later on TP buffer under-run
 *  \return         DCM_E_FORCE_RCRRP       Enforce a RCR-RP transmission
 *  \return         DCM_E_NOT_OK            The DID reading has failed for some reason. NRC is already set.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22ReadDid(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc22UtiReadData()
 *********************************************************************************************************************/
/*! \brief          Reads the requested DIDs for service 0x22.
 *  \details        This is shared utility function of the Repeater and PagedBuffer.
 *  \param[in]      opStatus                Current operation status
 *  \param[in,out]  pDataContext            Pointer to the data context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Service 0x22 repeater context
 *  \return         DCM_E_OK                All data has been copied
 *  \return         DCM_E_PENDING           No result yet, retry later
 *  \return         DCM_E_BUFFERTOOLOW      Some data copied but no place, retry later on TP buffer under-run
 *  \return         DCM_E_FORCE_RCRRP       Enforce a RCR-RP transmission
 *  \return         DCM_E_NOT_OK            The DID reading has failed for some reason. NRC is already set.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22UtiReadData(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc22DidLookUp()
 *********************************************************************************************************************/
/*! \brief          A generic DID look-up for SID 0x22.
 *  \details        Performs a lookup for a specific DID on any request.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Go to next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22DidLookUp(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc22CheckCondition()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x22.
 *  \details        Checks the conditions of a requested DID.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CheckCondition(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc22GetLength()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x22.
 *  \details        Reads the length of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22GetLength(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc22ReadData()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x22.
 *  \details        Reads the data of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_FORCE_RCRRP       Force RCR-RP
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22ReadData(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc23Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x23 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc23RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc23CheckAccess()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x23.
 *  \details        Checks the service 0x23 access.
 *  \param[in]      pContext         Pointer to the context
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[in,out]  pRepContext      Current repeater proxy context
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23CheckAccess(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc23RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc23ReadMemory()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x23.
 *  \details        Reads the data from the memory.
 *  \param[in]      opStatus                Current operation status
 *  \param[in,out]  pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in]      pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_FORCE_RCRRP       Force RCR-RP
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23ReadMemory(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc23RepeaterProxyContextConstPtrType pRepContext
  );
#endif /* (DCM_SVC_23_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc24Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc24RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc24ExecuteOp()
 *********************************************************************************************************************/
/*! \brief          Service 0x24 operation execution unit.
 *  \details        Executes a specific service 0x24 operation.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24ExecuteOp(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc24RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc24DidLookUp()
 *********************************************************************************************************************/
/*! \brief          Service 0x24 DID look up client.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Stop polling
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24DidLookUp(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc24RepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc27SecLevelInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Get security level descriptor.
 *  \details        -
 *  \param[in]      secLev           Zero based security level index
 *  \param[out]     pSecLevelInfo    The security level descriptor
 *  \param[out]     ErrorCode        Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK         The operation was successful
 *  \return         DCM_E_NOT_OK     The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc27SecLevelInfoGetEntry(
  uint8_least secLev,
  CONSTP2VAR(Dcm_CfgSvc27SecLevelInfoPtrType, AUTOMATIC, AUTOMATIC) pSecLevelInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc27CounterSet()
 *********************************************************************************************************************/
/*! \brief          Sets the value of a specific security level attempt counter.
 *  \details        -
 *  \param[in]      secLev      Zero based security level index
 *  \param[in]      value       Attempt counter value
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27CounterSet(
  uint8_least secLev,
  uint8 value
  );

/**********************************************************************************************************************
 *  Dcm_Svc27CounterInc()
 *********************************************************************************************************************/
/*! \brief          Increments the value of a specific security level attempt counter.
 *  \details        -
 *  \param[in]      secLev      Zero based security level index
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27CounterInc(
  uint8_least secLev
  );

/**********************************************************************************************************************
 *  Dcm_Svc27TimerSet()
 *********************************************************************************************************************/
/*! \brief          Sets the value of a specific security level timer.
 *  \details        -
 *  \param[in]      secLev      Zero based security level index
 *  \param[in]      value       Timer value
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27TimerSet(
  uint8_least secLev,
  Dcm_TmrTimerCntrMemType value
  );

/**********************************************************************************************************************
 *  Dcm_Svc27TimerStart()
 *********************************************************************************************************************/
/*! \brief          Sets the value of a specific security level timer.
 *  \details        Starts the base security level timer.
 *  \param[in]      secLev      Zero based security level index
 *  \param[in]      value       Timer value for the specific security level
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27TimerStart(
  uint8_least secLev,
  Dcm_TmrTimerCntrMemType value
  );

/**********************************************************************************************************************
 *  Dcm_Service27Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Service27SeedProcessor()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 get application generated seed.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \return         DCM_E_OK                Request was successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SeedProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Service27KeyProcessor()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 get application key comparator.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27KeyProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext
  );

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27UtiGetAttemptCntr()
 *********************************************************************************************************************/
/*! \brief          Restores the attempt counter values from the application.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in,out]  levelMask               Pointer to a security level mask.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27UtiGetAttemptCntr(
  Dcm_OpStatusType opStatus,
  P2VAR(uint32, AUTOMATIC, DCM_VAR_NOINIT) levelMask
  );
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27ReadAttemptCounter()
 *********************************************************************************************************************/
/*! \brief          Manages reading of an attempt counter value.
 *  \details        If a diagnostic job is ongoing the appropriate action will be taken to close it deterministically.
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27ReadAttemptCounter(
  Dcm_TskEventContextPtrType pEventContext
  );
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27WriteAttemptCounter()
 *********************************************************************************************************************/
/*! \brief          Manages writing of an attempt counter value.
 *  \details        If a diagnostic job is ongoing the appropriate action will be taken to close it deterministically.
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27WriteAttemptCounter(
  Dcm_TskEventContextPtrType pEventContext
  );
# endif

/**********************************************************************************************************************
 *  Dcm_Service27SeedRepeater()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 get seed service port accessor.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in,out]  pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SeedRepeater(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Service27KeyRepeater()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 send key service port accessor.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send neagative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27KeyRepeater(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_ReadOnlyMsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Service27CheckAttemptsExceededRepeater()
 *********************************************************************************************************************/
/*! \brief          Checks whether the number of allowed attempts were reached.
 *  \details        Determines the final negative response code (0x35 or 0x36).
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27CheckAttemptsExceededRepeater(
  Dcm_OpStatusType opStatus,
  Dcm_ReadOnlyMsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext
  );

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27SetAttemptCntrRepeater()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 set attempt counter service port accessor.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SetAttemptCntrRepeater(
  Dcm_OpStatusType opStatus,
  Dcm_ReadOnlyMsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext
  );
# endif
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc28SubFuncInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor.
 *  \details        -
 *  \param[in]      SubSvcRef       Index to a subfunction descriptor
 *  \param[out]     pSubFuncInfo    The subfunction descriptor
 *  \param[out]     ErrorCode       Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc28SubFuncInfoGetEntry(
  Dcm_DiagSubServiceRefOptType SubSvcRef,
  CONSTP2VAR(Dcm_CfgSvc28SubFuncInfoPtrType, AUTOMATIC, AUTOMATIC) pSubFuncInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc28Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x28 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc28Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc28RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc28SubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x28 SubFunction Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc28SubFuncHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc28RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc28ApplyCommControl()
 *********************************************************************************************************************/
/*! \brief          Apply concrete operation on network channel(s).
 *  \details        -
 *  \param[in]      networkRef The network handle
 *  \param[in]      mode       The communication mode
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc28ApplyCommControl(
  Dcm_CfgNetNetIdRefMemType networkRef,
  Dcm_CommunicationModeType mode
  );
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc29SubFuncInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor.
 *  \details        -
 *  \param[in]      subSvcRef       Index to a subfunction descriptor
 *  \param[out]     pSubFuncInfo    The subfunction descriptor
 *  \param[out]     ErrorCode       Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc29SubFuncInfoGetEntry(
  Dcm_DiagSubServiceRefOptType subSvcRef,
  CONSTP2VAR(Dcm_CfgSvc29SubFuncInfoPtrType, AUTOMATIC, AUTOMATIC) pSubFuncInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc29Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc29CbkResultDispatcher()
 *********************************************************************************************************************/
/*! \brief          Dispatch the asynchronous callback result.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29CbkResultDispatcher(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc29SubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 SubFunction Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send positive response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29SubFuncHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_ModeSwitchAuthentication()
*********************************************************************************************************************/
/*! \brief          Mode switching for authentication state change.
 *  \details        -
 *  \param[in]      authInfoRef     The authentication info table reference
 *  \param[in]      mode            The next authentication mode
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeSwitchAuthentication(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  uint8 mode
  );

/**********************************************************************************************************************
 *  Dcm_Svc29KeyMSetCertificate()
*********************************************************************************************************************/
/*! \brief          Set certificate wrapper function.
 *  \details        Stores certificate in KeyM and handles possible return values.
 *  \param[in]      certId                The certificate identifier
 *  \param[in]      pCertificateData      Pointer to struct containing certificate data and length
 *  \param[out]     ErrorCode             The NRC
 *  \return         DCM_E_NOT_OK          Send negative response
 *  \return         DCM_E_OK              Successful
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29KeyMSetCertificate(
  KeyM_CertificateIdType certId,
  P2CONST(KeyM_CertDataType, AUTOMATIC, DCM_APPL_DATA) pCertificateData,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc29KeyMVerifyCertificate()
*********************************************************************************************************************/
/*! \brief          Verify stored certificate wrapper function.
 *  \details        Verifies stored certificate in KeyM and handles possible return values.
 *  \param[in]      pContext              Pointer to the context
 *  \param[in]      certId                The certificate identifier
 *  \param[out]     ErrorCode             The NRC
 *  \return         DCM_E_NOT_OK          Send negative response
 *  \return         DCM_E_PENDING         Retry later
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29KeyMVerifyCertificate(
  Dcm_ContextPtrType pContext,
  KeyM_CertificateIdType certId,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

# if (DCM_MODE_AUTH_GENERAL_NRC_ENABLED == STD_ON)
 /**********************************************************************************************************************
 *  Dcm_Svc29GeneralNrcCheck()
 *********************************************************************************************************************/
/*! \brief          Changes Certificate Verification Failed NRC to General NRC.
 *  \details        If NRC pertains to Certificate Verification Failed, it is changed to General NRC.
 *  \param[in,out]  ErrorCode             The NRC
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc29GeneralNrcCheck(
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

/**********************************************************************************************************************
 *  Dcm_Svc29FinalizeSequenceStartReq()
 *********************************************************************************************************************/
/*! \brief          Finalize request processing of subfunction 0x01 and 0x02.
 *  \details        -
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \return         DCM_E_OK                Send positive response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29FinalizeSequenceStartReq(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

# if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29GetServerCertificate()
 *********************************************************************************************************************/
/*! \brief          Gets the server certificate of KeyM.
 *  \details        -
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Server certificate retreived
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29GetServerCertificate(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );
# endif

/**********************************************************************************************************************
 *  Dcm_Svc29ValidateCsmCbkResult()
 *********************************************************************************************************************/
/*! \brief          Validates the callback result of Csm.
 *  \details        -
 *  \param[out]     ErrorCode               The NRC
 *  \return         DCM_E_OK                Successful callback result
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29ValidateCsmCbkResult(
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc29ValidateKeyMCbkResult()
 *********************************************************************************************************************/
/*! \brief          Validates the callback result of KeyM.
 *  \details        -
 *  \param[out]     ErrorCode               The NRC
 *  \return         DCM_E_OK                Successful callback result
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29ValidateKeyMCbkResult(
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#endif /* (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/* --- public members ---------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_Service2ASchedulerInit()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Initializes the periodic DID scheduler.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Service2ASchedulerInit(
  void
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdAddItemByDid()
 *********************************************************************************************************************/
/*! \brief          Inserts a new item to the scheduler without activating it.
 *  \details        -
 *  \param[in,out]  pDidInfoContext    The context of the DID
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdAddItemByDid(
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCommit()
 *********************************************************************************************************************/
/*! \brief          Commits already inserted items to be scheduled with a given rate.
 *  \details        -
 *  \param[in]      rate    The scheduling rate
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdCommit(
  Dcm_Svc2ASchedRateMemType rate
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdDiscard()
 *********************************************************************************************************************/
/*! \brief          Discards all inserted items.
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdDiscard(
  void
  );

# if (DCM_DIDMGR_PERIODICDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2AOnStateChanged()
 *********************************************************************************************************************/
/*! \brief          Stops all scheduled DIDs no more allowed by the new states.
 *  \details        Stops all scheduled DIDs that are nor more allowed after the state has been changed.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2AOnStateChanged(
  void
  );
# endif

/* --- private members --------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdFindFreeOrInUseItemByDid()
 *********************************************************************************************************************/
/*! \brief          Tries to find already used DID entry slot. If not, returns the last free found.
 *  \details        -
 *  \param[in]      did           The did
 *  \param[in]      schdHandle    Handle of the found slot
 *  \return         TRUE          A slot was found
 *  \return         FALSE         No slot was found - schdHandle output parameter is invalid
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdFindFreeOrInUseItemByDid(
  uint16 did,
  P2VAR(Dcm_Svc2ASchdItemHandleOptType, AUTOMATIC, AUTOMATIC) schdHandle
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdUpdateTimers()
 *********************************************************************************************************************/
/*! \brief          Updates all active scheduled item timers.
 *  \details        -
 *  \return         TRUE     Activate processor task
 *  \return         FALSE    Don't activate processor task
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdUpdateTimers(
  void
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdNextEntryIdxInc()
 *********************************************************************************************************************/
/*! \brief          Scheduler item iterator increment.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdNextEntryIdxInc(
  void
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdGetEntry()
 *********************************************************************************************************************/
/*! \brief          Obtain a service 0x2A scheduler entry.
 *  \details        -
 *  \param[in]      schdHandle    The scheduler entry handle
 *  \return         Pointer to requested 2A scheduler entry - if handle is invalid, pointer to first entry
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc2ASchdEntryPtrType, DCM_CODE) Dcm_Svc2ASchdGetEntry(
  Dcm_Svc2ASchdItemHandleOptType schdHandle
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdInitDidMgrResources()
 *********************************************************************************************************************/
/*! \brief          Allocate DID manager resources for PDID
 *  \details        -
 *  \param[in,out]  pDataContext    Pointer to the data context
 *  \param[in]      did             The DID that is about to be read
 *  \return         DCM_E_OK        Continue processing
 *  \return         DCM_E_PENDING   DID is currently in use by another service
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ASchdInitDidMgrResources(
  Dcm_DiagDataContextPtrType pDataContext,
  uint16 did
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdProcessEntry()
 *********************************************************************************************************************/
/*! \brief          A single PDID processing step.
 *  \details        Performs PDID reading and sending on expired PDID slots.
 *  \param[in]      pSchedTableEntry    The scheduler entry to be processed
 *  \return         DCM_E_OK        Continue processing
 *  \return         DCM_E_PENDING   Processing was postponed
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ASchdProcessEntry(
  Dcm_Svc2ASchdEntryPtrType pSchedTableEntry
  );
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2AScheduledDidLookUp()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2A.
 *  \details        Performs a lookup for a specific DID on scheduling requests.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Go to next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AScheduledDidLookUp(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2AStoppedDidLookUp()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2A.
 *  \details        Performs a lookup for a specific DID on stop DID requests.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Go to next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AStoppedDidLookUp(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ADidCheckCondition()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2A.
 *  \details        Checks the conditions of a requested DID.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidCheckCondition(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ADidGetLength()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2A.
 *  \details        Returns the length of a requested DID.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Go on with next DID
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidGetLength(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2AIsUdsRateSupported()
 *********************************************************************************************************************/
/*! \brief          Checks whether the UDS rate is supported.
 *  \details        -
 *  \param[in]      udsRate                 Rate to be checked
 *  \return         TRUE                    Rate is supported
 *  \return         FALSE                   Rate is not supported
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc2AIsUdsRateSupported(
  Dcm_Svc2ATransmissionModeType udsRate
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ADoScheduleDids()
 *********************************************************************************************************************/
/*! \brief          Updates the scheduler content.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADoScheduleDids(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc2AStopScheduledDids()
 *********************************************************************************************************************/
/*! \brief          Stops requested DIDs.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AStopScheduledDids(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2AHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2A Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Operation failed
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrInit()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Service 0x2C DID definition manager initializer.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2CDefMgrInit(
  void
  );

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadSrcItems()
 *********************************************************************************************************************/
/*! \brief          Performs reading on a single DynDID source item (DID or memory area).
 *  \details        -
 *  \param[in]      opStatus         Current DynDID read operation status.
 *  \param[in,out]  pDataContext     Pointer to the data context
 *  \param[in,out]  pProcessContext  The process context
 *  \return         DCM_E_OK         Read of all source items finished with success.
 *  \return         DCM_E_PENDING    One of the source items needs more time to return final result, call again.
 *  \return         DCM_E_NOT_OK     One of the source items returned an error.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadSrcItems(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_Svc2CDynDidProcessContextPtrType pProcessContext
  );

# if (DCM_DIDMGR_DYNDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2COnStateChanged()
 *********************************************************************************************************************/
/*! \brief          Clears all no more allowed DynDIDs in the new states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2COnStateChanged(
  void
  );
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CGetSrcItem()
 *********************************************************************************************************************/
/*! \brief          Return the requested source item
 *  \details        -
 *  \param[in]      srcItemIndex    Index of the source item
 *  \return         The requested source item or any valid source item if the provided index is invalid
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc2CDynDidSrcItemPtrType, DCM_CODE) Dcm_Svc2CGetSrcItem(
  Dcm_CfgDidMgrDynDidSrcItemIdxOptType srcItemIndex
  );

/**********************************************************************************************************************
 *  Dcm_Svc2CGetItem()
 *********************************************************************************************************************/
/*! \brief          Return the requested item
 *  \details        -
 *  \param[in]      itemIndex    Index of the item
 *  \return         The requested item or any valid item if the provided index is invalid
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc2CDynDidItemPtrType, DCM_CODE) Dcm_Svc2CGetItem(
  Dcm_CfgDidMgrDynDidHandleOptType itemIndex
  );

/**********************************************************************************************************************
 *  Dcm_Svc2CGetDDDidProcessContext()
 *********************************************************************************************************************/
/*! \brief          Return the requested process context
 *  \details        -
 *  \param[in]      processContextIndex    Index of the process context
 *  \return         The process context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc2CDynDidProcessContextPtrType, DCM_CODE) Dcm_Svc2CGetDDDidProcessContext(
  uint8 processContextIndex
  );

# if (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_STATE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CStateCheckSrcItems()
 *********************************************************************************************************************/
/*! \brief          Check state and mode group preconditions of each source item.
 *  \details        -
 *  \param[in]      connHdl         The connection identifier
 *  \param[in]      dynDidHandle    DynDID reference to be checked
 *  \param[out]     ErrorCode       The NRC
 *  \return         DCM_E_OK        Check was successful
 *  \return         DCM_E_OK        Check was not successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CStateCheckSrcItems(
  Dcm_NetConnRefMemType connHdl,
  Dcm_CfgDidMgrDynDidHandleOptType dynDidHandle,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01DefMgrRead()
 *********************************************************************************************************************/
/*! \brief          Reads a single DID source item.
 *  \details        -
 *  \param[in]      opStatus        Current DID sourceItem operation status.
 *  \param[in,out]  pDataContext    Pointer to the data context
 *  \param[in,out]  pProcessContext The process context
 *  \return         DCM_E_OK        Reading finished with success.
 *  \return         DCM_E_PENDING   Reading needs some additional time. Call again.
 *  \return         DCM_E_NOT_OK    Reading finished with failed.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01DefMgrRead(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_Svc2CDynDidProcessContextPtrType pProcessContext
  );
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C02DefMgrRead()
 *********************************************************************************************************************/
/*! \brief          Reads a single Memory source item.
 *  \details        -
 *  \param[in]      opStatus        Current Memory sourceItem operation status.
 *  \param[in,out]  pDataContext    Pointer to the data context
 *  \return         DCM_E_OK            Reading finished with success.
 *  \return         DCM_E_FORCE_RCRRP   Send RCR-RP response. Once sent, call again.
 *  \return         DCM_E_PENDING       Reading needs some additional time. Call again.
 *  \return         DCM_E_NOT_OK        Reading finished with failed.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C02DefMgrRead(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext
  );
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadCheckAccessAndInit()
 *********************************************************************************************************************/
/*! \brief          Check read acces for requested DynDID.
 *  \details        -
 *  \param[in]      dynDidHandle    Current dynDid handle to be read.
 *  \param[in,out]  pOpStatus       Current and modified operation status.
 *  \return         DCM_E_OK            Check succeeded, proceed with read.
 *  \return         DCM_E_PENDING       The DynDID is still in usage, try later
 *  \return         DCM_E_NOT_OK        Check failed, leave the DynDID reading.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadCheckAccessAndInit(
  Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle,
  P2VAR(Dcm_OpStatusType, AUTOMATIC, AUTOMATIC) pOpStatus
  );
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc2CSubFuncInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor.
 *  \details        -
 *  \param[in]      SubSvcRef       Index to a subfunction descriptor
 *  \param[out]     pSubFuncInfo    The subfunction descriptor
 *  \param[out]     ErrorCode       Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc2CSubFuncInfoGetEntry(
  Dcm_DiagSubServiceRefOptType SubSvcRef,
  CONSTP2VAR(Dcm_CfgSvc2CSubFuncInfoPtrType, AUTOMATIC, AUTOMATIC) pSubFuncInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc2CHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2CSubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C SubFunction Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CSubFuncHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  );

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01SrcDidLookUp()
 *********************************************************************************************************************/
/*! \brief          Processes the source items of service 0x2C 0x01.
 *  \details        Performs a lookup for a specific source DID.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01SrcDidLookUp(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01SrcDidCheckCondition()
 *********************************************************************************************************************/
/*! \brief          Processes the source items of service 0x2C 0x01.
 *  \details        Checks the condition of a specific source DID.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01SrcDidCheckCondition(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01SrcDidGetLength()
 *********************************************************************************************************************/
/*! \brief          Processes the source items of service 0x2C 0x01.
 *  \details        Calculates and stores the length of a specific source DID.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01SrcDidGetLength(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C02SrcItemsGetLength()
 *********************************************************************************************************************/
/*! \brief          Processes the source items of service 0x2C 0x02.
 *  \details        Calculates the total length of all source items
 *  \param[in]      alfid                   The ALFID of the request
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Calculation succeeded
 *  \return         DCM_E_NOT_OK            Error during calculation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C02SrcItemsGetLength(
  uint8 alfid,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_Svc2C03DidLookUp()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C 0x03 dedicated DID look up client.
 *  \details        -
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[out]     pRepContext    Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C03DidLookUp(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  );
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CSetMaxAllowedDynDIDLength()
 *********************************************************************************************************************/
/*! \brief          Set the maximum allowed length for the currently processed DynDID.
 *  \details        -
 *  \param[in]      pContext       Pointer to the context
 *  \param[in]      pRepContext    Current repeater proxy context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2CSetMaxAllowedDynDIDLength(
  Dcm_ContextPtrType pContext,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  );

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CInitDidInfoFromDidInfoIdx()
 *********************************************************************************************************************/
/*! \brief          Returns information of a specific DID.
 *  \details        Retrieve the DID information using DidInfoIdx.
 *  \param[in]      didInfoIdx        The current operation status
 *  \param[in,out]  pSrcDidContext    The source DID context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2CInitDidInfoFromDidInfoIdx(
  Dcm_CfgDidMgrDidInfoRefType didInfoIdx,
  Dcm_DidMgrDidInfoContextPtrType pSrcDidContext
  );
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2EHandler()
 *********************************************************************************************************************/
/*! \brief          Handles Service 0x2E.
 *  \details        Checks if Did information is correct and either ready to write data or pending.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2EHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ERepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ECheckAccess()
 *********************************************************************************************************************/
/*! \brief          Checks the service 0x2E access.
 *  \details        Tries to lock a given Did and react accordingly.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \param[in]      pRepContext      Current repeater proxy context
 *  \param[out]     ErrorCode        The NRC
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ECheckAccess(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ERepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2EWriteData()
 *********************************************************************************************************************/
/*! \brief          Executes service 0x2E operation.
 *  \details        Writes the intended data and releases the lock if the operation result is not pending.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2EWriteData(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ERepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2F Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING           Final result is pending, retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  );

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FGetActiveIoDids()
 *********************************************************************************************************************/
/*! \brief          Return the requested active IODIDs bit mask
 *  \details        -
 *  \param[in]      ioDidIndex              Index of the IODID
 *  \return         The active IODIDs bit mask
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_UtiBitSetBasePtrType, DCM_CODE) Dcm_Svc2FGetActiveIoDids(
  Dcm_CfgDidMgrIoDidHandleOptType ioDidIndex
  );
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FReturnControlToEcu()
 *********************************************************************************************************************/
/*! \brief          Reset all active IO controls.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FReturnControlToEcu(
  void
  );
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FOnStateChanged()
 *********************************************************************************************************************/
/*! \brief          Reset all active IO controls no more supported in the active DCM state.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FOnStateChanged(
  void
  );
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2FExtractCEMR()
 *********************************************************************************************************************/
/*! \brief          Extracts the CEMR from the request.
 *  \details        Extracts the CEMR from a byte stream into a 32bit variable. If CEMRsize > 4 -> value is 0.
 *  \param[in]      cemrStream   Points to the beginning of the CEMR in the request
 *  \param[in]      cemrSize     Specifies the CEMR total length
 *  \return         0            If the CEMR size > 4 or no bit has been set. This value is invalid and will only
 *                               be used as initialization of the CEMR, but not passed to the application for NBit CEMR.
 *  \return         >0           Extracted CEMR. Note: For 3Byte CEMR the result is MSB bound!

 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint32, DCM_CODE) Dcm_Svc2FExtractCEMR(
  Dcm_ReadOnlyMsgType cemrStream,
  Dcm_CfgDidMgrIoDidCemrLengthMemType cemrSize
  );

/**********************************************************************************************************************
 *  Dcm_Svc2FProcessCEMR()
 *********************************************************************************************************************/
/*! \brief          Processes CEMR of IO DID request if the IO DID supports CEMR.
 *  \details        On IO DIDs with CEMR the CEMR will be extracted and verified for non-zero value.
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pRepContext        Current repeater proxy context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FProcessCEMR(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2FCalculateExpectedReqLength()
 *********************************************************************************************************************/
/*! \brief          Calculates the expected request length including DID data and CEMR.
 *  \details        -
 *  \param[out]     expLengthMin        Returns the expected request minimum length.
 *  \param[out]     expLengthMax        Returns the expected request maximum length.
 *  \param[in,out]  pRepContext         Current repeater proxy context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FCalculateExpectedReqLength(
  Dcm_DidMgrDidLengthPtrType expLengthMin,
  Dcm_DidMgrDidLengthPtrType expLengthMax,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2FCheckReqLength()
 *********************************************************************************************************************/
/*! \brief          Verifies the request length.
 *  \details        Verifies that the request length is valid for the concrete DID and IO operation incl. CEMR.
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pRepContext        Current repeater proxy context
 *  \return         DCM_E_POSITIVERESPONSE            Request length is valid.
 *  \return         !=DCM_E_POSITIVERESPONSE          A validation error has occurred.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_Svc2FCheckReqLength(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2FIoDidOperationProcessor()
 *********************************************************************************************************************/
/*! \brief          Process a concrete IODID and its requested operation.
 *  \details        -
 *  \param[in]      pContext         Pointer to the context
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[out]     pRepContext      Current repeater proxy context
 *  \return         DCM_E_NOT_OK     Send negative response
 *  \return         DCM_E_LOOP       Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FIoDidOperationProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2FCheckAccess()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2F.
 *  \details        Checks the service 0x2F access.
 *  \param[in]      pContext         Pointer to the context
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[in]      pRepContext      Current repeater proxy context
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FCheckAccess(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2FExecuteOp()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2F.
 *  \details        Executes a specific service 0x2F operation.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[in,out]  pRepContext      Current repeater proxy context
 *  \return         Next action to perform
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FExecuteOp(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2FGetLength()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2F.
 *  \details        Reads the length of a requested DID.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FGetLength(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2FReadData()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2F.
 *  \details        -
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[out]     pRepContext    Current repeater proxy context
 *  \return         DCM_E_OK       Send response
 *  \return         DCM_E_NOT_OK   Send negative response
 *  \return         DCM_E_PENDING  Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FReadData(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc31Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x31 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc31Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc31RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc31RedirectMsgContext()
 *********************************************************************************************************************/
/*! \brief          Redirects the buffer to local provided one.
 *  \details        -
 *  \param[in]      pMsgContext          Current message context
 *  \param[in]      pMsgContextCopied    Message context to be filled
 *  \param[in,out]  pRepContext          Current repeater proxy context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc31RedirectMsgContext(
  Dcm_ReadOnlyMsgContextPtrType pMsgContext,
  Dcm_MsgContextPtrType pMsgContextCopied,
  Dcm_Svc31RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc31ExecuteRoutine()
 *********************************************************************************************************************/
/*! \brief          Executes a routine operation.
 *  \details        Ensures that the request data stays availalbe during service processing.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Operation succeeded
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_NOT_OK            Operation failed, ErrorCode contains the NRC
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc31ExecuteRoutine(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc31RepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_34_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc34Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x34 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc34Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc34RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc34ProcessRequestDownload()
 *********************************************************************************************************************/
/*! \brief         Service 0x34 Request Download.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc34ProcessRequestDownload(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc34RepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_34_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_36_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc36Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x36 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[in,out]  pDownloadData           Download data context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pDownloadData           Download data context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc36Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc36RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc36ProcessTransferDataWrite()
 *********************************************************************************************************************/
/*! \brief         Service 0x36 Tranfer Data.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pDownloadData           Download data context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_OK                Send positive response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_FORCE_RCRRP       Enforce a RCR-RP transmission
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc36ProcessTransferDataWrite(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc36RepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_36_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_37_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc37Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x37 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc37Handler(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc37RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc37ProcessRequestTransferExit()
 *********************************************************************************************************************/
/*! \brief         Service 0x37 Tranfer Exit.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_OK                Send positive response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc37ProcessRequestTransferExit(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc37RepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_37_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc3DHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x3D Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc3DRepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc3DCheckAccess()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x3D.
 *  \details        Checks the service 0x3D access.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[in]      pRepContext      Current repeater proxy context
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DCheckAccess(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_ReadOnlyMsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc3DRepeaterProxyContextConstPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc3DWriteMemory()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x3D.
 *  \details        Writes the data to the memory.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in]      pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_FORCE_RCRRP       Force RCR-RP
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DWriteMemory(
  Dcm_OpStatusType opStatus,
  Dcm_ReadOnlyMsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc3DRepeaterProxyContextConstPtrType pRepContext
  );
#endif /* (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc85SubFuncInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor.
 *  \details        -
 *  \param[in]      SubSvcRef       Index to a subfunction descriptor
 *  \param[out]     pSubFuncInfo    The subfunction descriptor
 *  \param[out]     ErrorCode       Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc85SubFuncInfoGetEntry(
  Dcm_DiagSubServiceRefOptType SubSvcRef,
  CONSTP2VAR(Dcm_CfgSvc85SubFuncInfoPtrType, AUTOMATIC, AUTOMATIC) pSubFuncInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc85Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x85 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc85RepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc86SubFuncInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor.
 *  \details        -
 *  \param[in]      SubSvcRef       Index to a subfunction descriptor
 *  \param[out]     pSubFuncInfo    The subfunction descriptor
 *  \param[out]     ErrorCode       Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc86SubFuncInfoGetEntry(
  Dcm_DiagSubServiceRefOptType SubSvcRef,
  CONSTP2VAR(Dcm_CfgSvc86SubFuncInfoPtrType, AUTOMATIC, AUTOMATIC) pSubFuncInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc86Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x86 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc86Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc86RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc86SubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x86 SubFunction Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc86SubFuncHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc86RepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */

#define DCM_START_SEC_CODE
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MemMgrValidateAndGetAlfid()
 *********************************************************************************************************************/
/*! \brief          Validates the request memory ALFID and extracts it from request.
 *  \details        -
 *  \param[in,out]  pMsgContext        Requested memory data starting with the ALFID byte.
 *  \param[out]     pAlfid             ALFID byte
 *  \param[out]     pBlockLength       Returns the left part of the stream (i.e. without protocol header)
 *  \param[out]     ErrorCode          The NRC
 *  \return         DCM_E_OK      - no error found
 *  \return         DCM_E_NOT_OK  - invalid ALFID (NRC is set to ErrorCode)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            The request data within the pMsgContext must contain an ALFID byte.
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrValidateAndGetAlfid(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_Uint8VarDataPtrType pAlfid,
  Dcm_Uint8VarDataPtrType pBlockLength,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_MemMgrParseMemStream()
 *********************************************************************************************************************/
/*! \brief          Validates the request memory ALFID.
 *  \details        -
 *  \param[in]      alfid         Requested ALFID byte
 *  \param[in,out]  pMsgContext   Current message context with the memory address and size byte stream
 *  \param[out]     pMemBlock     Interpreted memory block information
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            It shall be assured that the ALFID value matches the length of the data stream to be parsed.
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_MemMgrParseMemStream(
  uint8 alfid,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_MemMgrMemBlockPtrType pMemBlock
  );

/**********************************************************************************************************************
 *  Dcm_MemMgrCheckMemBlock()
 *********************************************************************************************************************/
/*! \brief          Checks a specific memory block.
 *  \details        -
 *  \param[in]      pMemBlock    The memory block descriptor for validation
 *  \param[in]      memOp        The memory block operation type
 *  \param[out]     ErrorCode    The NRC
 *  \return         Result of analysis
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrCheckMemBlock(
  Dcm_MemMgrMemBlockConstPtrType pMemBlock,
  Dcm_MemMgrMemoryOpType memOp,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

# if (DCM_MEMMGR_MEMOP_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MemMgrReadMemory()
 *********************************************************************************************************************/
/*! \brief          Executes a read memory operation.
 *  \details        -
 *  \param[in]      opStatus      Current operation status
 *  \param[in]      pMemBlock     The memory block descriptor for validation
 *  \param[in]      pDataContext  Pointer to the data context
 *  \param[out]     ErrorCode     The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrReadMemory(
  Dcm_OpStatusType opStatus,
  Dcm_MemMgrMemBlockConstPtrType pMemBlock,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_MEMMGR_MEMOP_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MemMgrWriteMemory()
 *********************************************************************************************************************/
/*! \brief          Executes a write memory operation.
 *  \details        -
 *  \param[in]      opStatus      Current operation status
 *  \param[in]      pMemBlock     The memory block descriptor for validation
 *  \param[in]      data          data buffer
 *  \param[out]     ErrorCode     The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrWriteMemory(
  Dcm_OpStatusType opStatus,
  Dcm_MemMgrMemBlockConstPtrType pMemBlock,
  Dcm_MsgType data,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_22_OBD_CALIBRATION_ENABLED == STD_ON) || \
     (DCM_SVC_31_OBD_CALIBRATION_ENABLED == STD_ON) || \
     (DCM_OBDUDSIDMGR_CALIBRATION_ENABLED   == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrIsIdEnabled()
 *********************************************************************************************************************/
/*! \brief          Returns the calibrated state of an OBD ID.
 *  \details        -
 *  \param[in]      obdId              The OBD ID to be verified.
 *  \param[in]      pMaskData    A pointer to the OBD ID availability range mask list
 *  \return         TRUE               OBD ID is still enabled
 *  \return         FALSE              OBD ID was calibrated to be disabled
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_ObdIdMgrIsIdEnabled(
  uint8 obdId,
  P2CONST(Dcm_ObdIdMgrMaskValueTableType, AUTOMATIC, DCM_CONST) pMaskData
  );
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrIdLookUp()
 *********************************************************************************************************************/
/*! \brief          Look up for a given OBD ID.
 *  \details        Considers any variant handling/calibration.
 *  \param[in]      id     The OBD ID to look for
 *  \param[in,out]  pParserDesc
 *                  IN     LookUpTable
 *                  IN     LookUpFilterTable
 *                  IN     MaskData
 *                  OUT    Handle
 *  \return         DCM_E_OK        Look up was successful
 *  \return         DCM_E_NOT_OK    Look up was not successful
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgrIdLookUp(
  uint8 id,
  Dcm_ObdIdMgrDescPtrType pParserDesc
  );

/**********************************************************************************************************************
 *  Dcm_ObdIdMgrGetAvailabilityMask()
 *********************************************************************************************************************/
/*! \brief          A utility to provide a lookup result of an OBD ID and returning the corresponding AID mask value.
 *  \details        -
 *  \param[in]      id     The OBD ID to look for
 *  \param[in,out]  pParserDesc
 *                  IN     LookUpTable
 *                  IN     LookUpFilterTable
 *                  IN     MaskData
 *                  OUT    Handle
 *  \return         The generated 32bit mask value (variant independent/calibratable)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            The requested id has to be supported and to be an availability one.
 *********************************************************************************************************************/
DCM_LOCAL FUNC(uint32, DCM_CODE) Dcm_ObdIdMgrGetAvailabilityMask(
  uint8 id,
  Dcm_ObdIdMgrDescPtrType pParserDesc
  );

# if (DCM_OBDIDMGR_REQ_PARSER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrProcessSupportedIdRequest()
 *********************************************************************************************************************/
/*! \brief          Validates and processes any OBD ID availability ID request.
 *  \details        Processes a list of IDs and in case of availability ID request writes the response data.
 *  \param[in,out]  pMsgContext               Current request context
 *  \param[in]      pParserDesc
 *                  IN     LookUpTable
 *                  IN     LookUpFilterTable
 *                  IN     MaskData
 *                  OUT    Handle
 *  \param[out]     ErrorCode                 The NRC
 *  \return         DCM_E_OK        Request processing was successful
 *  \return         DCM_E_NOT_OK    Request was not valid
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgrProcessSupportedIdRequest(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_ObdIdMgrDescPtrType pParserDesc,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif
#endif /* (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrGetCertRole()
 *********************************************************************************************************************/
/*! \brief          Reads the role element of a certificate.
 *  \details        -
 *  \param[in]      opStatus                   The operation status
 *  \param[out]     ErrorCode                  The NRC
 *  \param[in,out]  pRepContext                The repeater context
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrGetCertRole(
  Dcm_OpStatusType opStatus,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );

# if (DCM_AUTHMGR_WHITELISTS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrGetCertWLElement()
 *********************************************************************************************************************/
/*! \brief          Reads a white list element of a certificate.
 *  \details        -
 *  \param[in]      certificateId              Certificate Id
 *  \param[in]      certElementId              Certificate element Id
 *  \param[out]     pElementData               Pointer to store the element data
 *  \param[in,out]  pElementDataLength         Element data length
 *  \param[in]      opStatus                   The operation status
 *  \param[in,out]  pRepContext                The repeater context
 *  \param[out]     ErrorCode                  The NRC
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   No element left (end of list)
 *  \return         DCM_E_LOOP                 Element successfully read
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrGetCertWLElement(
  uint16 certificateId,
  uint16 certElementId,
  Dcm_MsgType pElementData,
  Dcm_Uint32VarDataPtrType pElementDataLength,
  Dcm_OpStatusType opStatus,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrServiceWLReadList()
 *********************************************************************************************************************/
/*! \brief          Reads the services white list element of a certificate.
 *  \details        -
 *  \param[in,out]  pRepContext                The repeater context
 *  \param[out]     ErrorCode                  The NRC
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrServiceWLReadList(
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_AUTHMGR_WHITELIST_DID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrDidWLReadList()
 *********************************************************************************************************************/
/*! \brief          Reads the DID white list element of a certificate.
 *  \details        -
 *  \param[in,out]  pRepContext                The repeater context
 *  \param[out]     ErrorCode                  The NRC
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrDidWLReadList(
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_AUTHMGR_WHITELIST_RID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrRidWLReadList()
 *********************************************************************************************************************/
/*! \brief          Reads the RID white list element of a certificate.
 *  \details        -
 *  \param[in,out]  pRepContext                The repeater context
 *  \param[out]     ErrorCode                  The NRC
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrRidWLReadList(
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_AUTHMGR_WHITELIST_MEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrMemWLReadList()
 *********************************************************************************************************************/
/*! \brief          Reads the memory selection white list element of a certificate.
 *  \details        -
 *  \param[in,out]  pRepContext                The repeater context
 *  \param[out]     ErrorCode                  The NRC
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrMemWLReadList(
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckRole()
 *********************************************************************************************************************/
/*! \brief          Authentication role check for execution preconditons reference
 *  \details        -
 *  \param[in]      stateRef                   The operation execution precondition reference
 *  \param[in]      authInfoRef                The authentication information reference
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckRole(
  Dcm_CfgStateRefOptType stateRef,
  Dcm_CfgNetAuthInfoRefMemType authInfoRef
  );

/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckDispatcherLevel()
 *********************************************************************************************************************/
/*! \brief          Authentication access rights check on dispatcher level
 *  \details        -t
 *  \param[in]      sid                        The service identifier
 *  \param[in]      stateRef                   The operation execution precondition reference
 *  \param[in,out]  pMsgContext                The message context
 *  \param[in]      authInfoRef                The authentication information reference
 *  \param[out]     ErrorCode                  The NRC
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckDispatcherLevel(
  uint8 sid,
  Dcm_CfgStateRefOptType stateRef,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

# if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckServiceWLDispatcher()
 *********************************************************************************************************************/
/*! \brief          Authentication service white list check for DSD
 *  \details        Checks that the request matches first bytes of an element in service white list
 *  \param[in]      sid                        The service identifier
 *  \param[in,out]  pMsgContext                The message context
 *  \param[in]      authInfoRef                The authentication information reference
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckServiceWLDispatcher(
  uint8 sid,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_CfgNetAuthInfoRefMemType authInfoRef
  );
# endif

# if (DCM_AUTHMGR_WHITELIST_DID_ENABLED == STD_ON) || \
     (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckDidWL()
 *********************************************************************************************************************/
/*! \brief          Authentication DID white list check
 *  \details        Checks if DID and op matches element in DID white list
 *  \param[in]      did                        The DID identifier
 *  \param[in]      didOpMask                  The operation (bit-wise)
 *  \param[in]      authInfoRef                The authentication information reference
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckDidWL(
  uint16 did,
  Dcm_DidOpType didOpMask,
  Dcm_CfgNetAuthInfoRefMemType authInfoRef
  );
# endif

# if (DCM_AUTHMGR_DID_CHECK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckDid()
 *********************************************************************************************************************/
/*! \brief          DID operation authentication checks
 *  \details        Checks if DID operation is allowed by role or DID white list
 *  \param[in]      connHdl                    The connection identifier
 *  \param[in]      did                        The DID identifier
 *  \param[in]      didOpMask                  The operation (bit-wise)
 *  \param[in]      stateRef                   The operation execution precondition reference
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckDid(
  Dcm_NetConnRefMemType connHdl,
  uint16 did,
  Dcm_DidOpType didOpMask,
  Dcm_CfgStateRefOptType stateRef
  );
# endif

# if (DCM_AUTHMGR_WHITELIST_RID_ENABLED == STD_ON) || \
     (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckRidWL()
 *********************************************************************************************************************/
/*! \brief          Authentication RID white list check
 *  \details        Checks if RID and op matches element in RID white list
 *  \param[in]      rid                        The RID identifier
 *  \param[in]      ridSubfunc                 The routine control subfunction
 *  \param[in]      authInfoRef                The authentication information reference
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckRidWL(
  uint16 rid,
  uint8 ridSubfunc,
  Dcm_CfgNetAuthInfoRefMemType authInfoRef
  );
# endif

# if (DCM_AUTHMGR_RID_CHECK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckRid()
 *********************************************************************************************************************/
/*! \brief          RID operation authentication checks
 *  \details        Checks if RID operation is allowed by role or RID white list
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in]      rid                        The RID identifier
 *  \param[in]      ridSubfunc                 The routine control subfunction
 *  \param[in]      stateRef                   The operation execution precondition reference
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckRid(
  Dcm_ContextPtrType pContext,
  uint16 rid,
  uint8 ridSubfunc,
  Dcm_CfgStateRefOptType stateRef
  );
# endif

# if (DCM_AUTHMGR_WHITELIST_MEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckMemWL()
 *********************************************************************************************************************/
/*! \brief          Authentication MEM white list check
 *  \details        Checks if MemorySelection matches element in MEM white list
 *  \param[in]      memId                      The MemorySelection
 *  \param[in]      authInfoRef                The authentication information reference
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckMemWL(
  uint8 memId,
  Dcm_CfgNetAuthInfoRefMemType authInfoRef
  );
# endif

# if (DCM_AUTHMGR_MEM_CHECK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckMem()
 *********************************************************************************************************************/
/*! \brief          MemorySelection authentication checks
 *  \details        Checks if MemorySelection is allowed by MEM white list
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in]      memId                      The memory selection id
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckMem(
  Dcm_ContextPtrType pContext,
  uint8 memId
  );
# endif
#endif /* (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_NetUnRegisterAllComMActivity()
 *********************************************************************************************************************/
/*! \brief          Tries to unregister all ComM channels activities.
 *  \details        -
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterAllComMActivity(
  void
  );

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterComMActivity()
 *********************************************************************************************************************/
/*! \brief          Tries to unregister a ComM channel activity.
 *  \details        -
 *  \param[in]      connHdl    The connection which has finished its job
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            Must be called only for external diagnostic requests
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterComMActivity(
  Dcm_NetConnRefMemType connHdl
  );

/**********************************************************************************************************************
 *  Dcm_NetRegisterComMActivity()
 *********************************************************************************************************************/
/*! \brief          Tries to register a ComM channel activity.
 *  \details        -
 *  \param[in]      pTranspObj    The transport object which starts diagnostic job
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetRegisterComMActivity(
  Dcm_NetTransportObjectPtrType pTranspObj
  );

/**********************************************************************************************************************
 *  Dcm_NetUsdtTxConfirmation()
 *********************************************************************************************************************/
/*! \brief          Transport object transmission finalization.
 *  \details        Finalization of a transmitted USDT message.
 *  \param[in]      pTranspObj    The transport object used during transmission
 *  \param[in]      result        The transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUsdtTxConfirmation(
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_NetTransmissionResultType result
  );

/**********************************************************************************************************************
 *  Dcm_NetAllocateOrGetTranspObject()
 *********************************************************************************************************************/
/*! \brief          Transport object allocation.
 *  \details        Allocates a transport object for a concrete client connection.
 *  \param[in]      connHdl            The connection identifier
 *  \param[out]     pTranspObj         The allocated transport object
 *  \return         BUFREQ_OK          The operation was successful
 *  \return         BUFREQ_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Must be called within a critical section to guarantee unique result
 *********************************************************************************************************************/
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetAllocateOrGetTranspObject(
  Dcm_NetConnRefOptType connHdl,
  CONSTP2VAR(Dcm_NetTransportObjectPtrType, AUTOMATIC, AUTOMATIC) pTranspObj
  );

/**********************************************************************************************************************
 *  Dcm_NetGetTranspObjOfConnection()
 *********************************************************************************************************************/
/*! \brief          Returns the transport object of the given connection.
 *  \details        -
 *  \param[in]      connHdl            The connection identifier
 *  \param[out]     pTranspObj         The transport object assigned to the given connection
 *  \return         BUFREQ_OK          The operation was successful
 *  \return         BUFREQ_E_NOT_OK    The given index was invalid
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            Since only getter, can be called outside of a critical section, but for consistent results do call within critical section
 *********************************************************************************************************************/
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetGetTranspObjOfConnection(
  Dcm_NetConnRefOptType connHdl,
  CONSTP2VAR(Dcm_NetTransportObjectPtrType, AUTOMATIC, AUTOMATIC) pTranspObj
  );

/**********************************************************************************************************************
 *  Dcm_NetTranspObjRelease()
 *********************************************************************************************************************/
/*! \brief          Release transport object resource.
 *  \details        Releases a given transport object.
 *  \param[in]      pTranspObj    The transport object to be released
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTranspObjRelease(
  Dcm_NetTransportObjectPtrType pTranspObj
  );

/**********************************************************************************************************************
 *  Dcm_NetGetConnHdlByTesterAddress()
 *********************************************************************************************************************/
/*! \brief          Tries to find the corresponding connection of a diagnostic client.
 *  \details        -
 *  \param[in]      testerAddress    The diagnostic client address to look for
 *  \return         < DCM_NET_INVALID_CONNHDL    Valid connection id found.
 *  \return         DCM_NET_INVALID_CONNHDL      No connection found for the source address.
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetConnRefMemType, DCM_CODE) Dcm_NetGetConnHdlByTesterAddress(
  uint16 testerAddress
  );

#if ((DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON) && (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)) || \
    (DCM_AUTHMGR_SET_DEAUTH_ROLE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetGetConnHdlByConnectionId()
 *********************************************************************************************************************/
/*! \brief          Tries to find the corresponding connection of a connection handle.
 *  \details        -
 *  \param[in]      connectionId                Connection identifier
 *  \return         < DCM_NET_INVALID_CONNHDL    Valid connection id found.
 *  \return         DCM_NET_INVALID_CONNHDL      No connection found for the source address.
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetConnRefMemType, DCM_CODE) Dcm_NetGetConnHdlByConnectionId(
  uint16 connectionId
  );
#endif

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterActiveConnection()
 *********************************************************************************************************************/
/*! \brief          Unregister a connection.
 *  \details        Unregister an active connection referenced by the given transport object.
 *  \param[in]      pTranspObj    The transport object to be released
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterActiveConnection(
  Dcm_NetTransportObjectPtrType pTranspObj
  );

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgAllocate()
 *********************************************************************************************************************/
/*! \brief          Periodic message allocation.
 *  \details        Allocates a resource for a periodic message.
 *  \param[in]      Did     DID of the message that is allocated
 *  \return         DCM_NET_INVALID_PTXOBJ_HANDLE      No free resource found
 *  \return         < DCM_NET_INVALID_PTXOBJ_HANDLE    A concrete valid handle is returned
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_CfgNetPTxObjHandleMemType, DCM_CODE) Dcm_NetPeriodicMsgAllocate(
  uint16 Did
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgRelease()
 *********************************************************************************************************************/
/*! \brief          Releases a concrete periodic message resource.
 *  \details        -
 *  \param[in]      pPeriodicTxObj    The periodic transport object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgRelease(
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgTransmit()
 *********************************************************************************************************************/
/*! \brief          Transmits a periodic message.
 *  \details        -
 *  \param[in]      pPeriodicTxObj    The periodic transport object
 *  \param[in]      length            The periodic response message length
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgTransmit(
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj,
  PduLengthType length
  );
#endif

/**********************************************************************************************************************
 *  Dcm_NetStartOfReception()
 *********************************************************************************************************************/
/*! \brief          Start of new request reception.
 *  \details        This function is called by Dcm_StartOfReception.
 *  \param[in]      rxPduId            The RxPDUID of the request
 *  \param[in]      info               Message context (data and length of the portion)
 *  \param[in]      tpSduLength        The total length of the TP message
 *  \param[out]     bufferSizePtr      Available buffer size
 *  \param[in]      addTObjFlags       Additional transport object flags from caller
 *  \return         BUFREQ_OK          A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK    No free buffer is available - ignore request
 *  \return         BUFREQ_E_OVFL      The request message is too long for the configured buffer
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetStartOfReception(
  PduIdType rxPduId,
  P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info,
  PduLengthType tpSduLength,
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr,
  Dcm_NetTransportObjectFlagType addTObjFlags
  );

/**********************************************************************************************************************
 *  Dcm_NetSetComModeEntered()
 *********************************************************************************************************************/
/*! \brief          Internal utility for updating the new communication state.
 *  \details        -
 *  \param[in]      networkId      The communication channel on which this state is now active
 *  \param[in]      newComState    The new state of the communication channel (e.g. DCM_NET_COMM_STATE_RX_DIS_TX_DIS)
 *  \context        ISR1|ISR2
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetSetComModeEntered(
  NetworkHandleType networkId,
  Dcm_NetComMStateType newComState
  );
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferExecute()
 *********************************************************************************************************************/
/*! \brief          Starts polling a paged buffer update function.
 *  \details        -
 *  \param[in]      pContext  Pointer to the context
 *  \param[in,out]  pDataContext          The pointer to the data context
 *  \param[out]     ErrorCode             The NRC
 *  \return         DCM_E_OK              All data has been copied - evaluate the out parameters
 *  \return         DCM_E_PENDING         No result yet, retry later
 *  \return         DCM_E_PENDING_LIMITER Runtime limit reached, retry later
 *  \return         DCM_E_NOT_OK          Something went wrong, stop updating (only in DET situation)
 *  \return         DCM_E_BUFFERTOOLOW    Some data copied but no place, retry later on TP buffer under-run
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferExecute(
  Dcm_ContextPtrType pContext,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCancel()
 *********************************************************************************************************************/
/*! \brief          Dispatches the CancelPage call.
 *  \details        Dispatches the CancelPage call regarding the paged-buffer.
 *  \param[in]      pContext        Pointer to the context
 *  \param[out]     ErrorCode       The NRC
 *  \return         DCM_E_OK        Operation finished with success
 *  \return         DCM_E_NOT_OK    Operation failed, ErrorCode contains the NRC
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferCancel(
  Dcm_ContextPtrType pContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferStart()
 *********************************************************************************************************************/
/*! \brief          Activate paged-buffer write process.
 *  \details        -
 *  \param[in,out]  pMsgContext   Current request context
 *  \param[in]      resDataLen    Specifies how many bytes will be copied using the update page function.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_PagedBufferStart(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_MsgLenType resDataLen
  );
#endif
/**********************************************************************************************************************
 *  Dcm_RepeaterExecute()
 *********************************************************************************************************************/
/*! \brief          Starts polling a repeater proxy.
 *  \details        -
 *  \param[in]      pContext    Pointer to the context
 *  \param[out]     ErrorCode   The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_RepeaterExecute(
  Dcm_ContextPtrType pContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_RepeaterSetCallee()
 *********************************************************************************************************************/
/*! \brief          Starts polling a repeater proxy.
 *  \details        -
 *  \param[in]      pContext               Pointer to the context
 *  \param[in]      serviceProcessorIdx    The proxy callee
 *  \context        TASK
 *  \reentrant      FALSE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_RepeaterSetCallee(
  Dcm_ContextPtrType pContext,
  uint8 serviceProcessorIdx
  );
#if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchDtcSetting()
 *********************************************************************************************************************/
/*! \brief          Mode management on control DTC setting.
 *  \details        -
 *  \param[in]      newMode       The mode
 *  \param[in]      DTCGroup      The affected DTC group of changed setting
 *  \param[in]      DemClientId   The DEM client id
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeSwitchDtcSetting(
  Rte_ModeType_DcmControlDtcSetting newMode,
  uint32 DTCGroup,
  uint8 DemClientId
  );
#endif

#if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchCommControl()
 *********************************************************************************************************************/
/*! \brief          Mode management on communication control.
 *  \details        -
 *  \param[in]      networkRef The network handle
 *  \param[in]      newMode    The mode
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeSwitchCommControl(
  Dcm_CfgNetNetIdRefOptType networkRef,
  Dcm_CommunicationModeType newMode
  );
#endif
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateCheckRID()
 *********************************************************************************************************************/
/*! \brief          Performs a RID state rule check.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      rid                     The RID identifier
 *  \param[in]      ridSubfunc              The routine control subfunction
 *  \param[in]      stateRef                Reference to the state precondition table
 *  \param[out]     ErrorCode               The NRC
 *  \return         DCM_E_OK                State rule check was sucessful
 *  \return         DCM_E_NOT_OK            State rule check was not sucessful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_StateCheckRID(
  Dcm_ContextPtrType pContext,
  uint16 rid,
  uint8 ridSubfunc,
  Dcm_CfgStateRefOptType stateRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#endif

/**********************************************************************************************************************
 *  Dcm_StateCheck()
 *********************************************************************************************************************/
/*! \brief          Performs a state rule check.
 *  \details        -
 *  \param[in]      stateRef                  Reference to the state precondition table
 *  \param[in]      chkLevel                  State level check
 *  \param[out]     ErrorCode                 The NRC
 *  \return         DCM_E_OK                  State rule check was sucessful
 *  \return         DCM_E_NOT_OK              State rule check was not sucessful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_StateCheck(
  Dcm_CfgStateRefOptType stateRef,
  Dcm_DiagCheckLvlType chkLevel,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_StateSetSession()
 *********************************************************************************************************************/
/*! \brief          Performs a session state transition.
 *  \details        -
 *  \param[in]      stateRef    The state order number.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_StateSetSession(
  Dcm_StateIndexOptType stateRef
  );

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateSetSecurity()
 *********************************************************************************************************************/
/*! \brief          Performs a security state transition.
 *  \details        -
 *  \param[in]      stateRef    The state order number.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_StateSetSecurity(
  Dcm_StateIndexOptType stateRef
  );
#endif
/**********************************************************************************************************************
 *  Dcm_OnTimeoutP2()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a P2 timeout occurs.
 *  \param[in]      ThreadId  Active thread
 *  \return         Returns always 0 -> no reload
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutP2(
  Dcm_ThreadIdMemType threadId
  );

/**********************************************************************************************************************
 *  Dcm_OnTimeoutS3()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a S3 timeout occurs.
 *  \param[in]      ThreadId  Active thread
 *  \return         Returns always 0 -> no reload
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutS3(
  Dcm_ThreadIdMemType threadId
  );

#if (DCM_TMR_NUM_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutFblRes()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when the P2* time expires after FBL-to-APPL transition.
 *  \param[in]      ThreadId  Active thread
 *  \return         Returns always 0 -> no reload
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutFblRes(
  Dcm_ThreadIdMemType threadId
  );
#endif

#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSecurityAccess()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a security access timeout occurs.
 *  \param[in]      ThreadId  Active thread
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSecurityAccess(
  Dcm_ThreadIdMemType threadId
  );
#endif

#if (DCM_TMR_NUM_PERIODIC_TX > 0u)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutPeriodicTx()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        The periodic transmission timeout is reached
 *  \param[in]      ThreadId  Active thread
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutPeriodicTx(
  Dcm_ThreadIdMemType threadId
  );
#endif

#if (DCM_TMR_NUM_SVC2A_SCHEDULER > 0u)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSvc2AScheduler()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a service 0x2A scheduler timeout occurs.
 *  \param[in]      ThreadId  Active thread
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSvc2AScheduler(
  Dcm_ThreadIdMemType threadId
  );
#endif

#if (DCM_TMR_NUM_KEEP_ALIVE > 0u)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutKeepAlive()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a keep alive timeout occurs.
 *  \param[in]      ThreadId  Active thread
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutKeepAlive(
  Dcm_ThreadIdMemType threadId
  );
#endif

#if (DCM_TMR_NUM_AUTHENTICATION > 0u)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutAuthentication()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a authentication timeout occurs.
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutAuthentication(
  Dcm_ThreadIdMemType threadId
  );
#endif
#if (DCM_DEM_API_421_ENABLED == STD_ON) || (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON)
# if (DCM_DEMAPI_RETVAL_TO_NRC_MAP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DemApiGetNrcForDemRetValue()
 *********************************************************************************************************************/
/*! \brief          Converts a DEM API return value to a concrete NRC.
 *  \details        -
 *  \param[in]      demResult           DEM API returned value
 *  \param[in]      demResult2NrcMap    Pointer to a DEM API specific map (serialized array of pair values)
 *  \return         The associated NRC for the given DEM result value
 *  \return         The panic NRC
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_DemApiGetNrcForDemRetValue(
  uint8 demResult,
  Dcm_Uint8ConstDataPtrType demResult2NrcMap
  );
# endif

# if (DCM_DEMAPI_GETNEXTFILTEREDITEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DemApiConvDemRsltGetNextFilteredItem()
 *********************************************************************************************************************/
/*! \brief          Converts a DEM API return value to a concrete DCM return value.
 *  \details        -
 *  \param[in]      demResult                 DEM API returned value
 *  \param[out]     ErrorCode                 The NRC
 *  \return         DCM_E_DATA_READY_PADDING  Force padding of remaining bytes
 *  \return         DCM_E_PENDING             Retry later
 *  \return         DCM_E_BUFFERTOOLOW        Retry later, because of no available space any more
 *  \return         DCM_E_NOT_OK              Error occured
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DemApiConvDemRsltGetNextFilteredItem(
  Dcm_DemReturnGetNextFilteredItemType demResult,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DemApiGetDTCOfOBDFreezeFrame()
 *********************************************************************************************************************/
/*! \brief          Wraps the DEM API call Dem_DcmGetDTCOfOBDFreezeFrame() for the correct API version.
 *  \details        -
 *  \param[in]      frameNumber               Unique identifier for a freeze frame record
 *  \param[in]      dtcFormat                 Output format of the DTC value
 *  \param[out]     dtc                       Diagnostic trouble code in OBD format
 *  \return         E_OK                      operation was successful
 *  \return         E_NOT_OK                  no DTC available
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DemApiGetDTCOfOBDFreezeFrame(
  uint8 frameNumber,
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) dtc,
  Dem_DTCFormatType dtcFormat
  );
# endif

# if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DemApiReadDataOfOBDFreezeFrame()
 *********************************************************************************************************************/
/*! \brief          Wraps the DEM API call Dem_DcmReadDataOfOBDFreezeFrame() for the correct API version.
 *  \details        -
 *  \param[in]      pid                       Identifier for PID
 *  \param[in]      dataElementIndexOfPid     Data element index of this PID
 *  \param[in,out]  destBuffer                Buffer where PID shall be written
 *  \param[in,out]  bufSize                   Max number of writable bytes
 *  \return         E_OK                      Freeze frame data successfully reported
 *  \return         E_NOT_OK                  Freeze frame data report failed
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DemApiReadDataOfOBDFreezeFrame(
  uint8 pid,
  uint8 dataElementIndexOfPid,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) destBuffer,
  P2VAR(Dcm_MsgLenType, AUTOMATIC, AUTOMATIC) bufSize
  );
# endif
#endif /* (DCM_DEM_API_421_ENABLED == STD_ON) || (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON) */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrCancelOperation()
 *********************************************************************************************************************/
/*! \brief          Cancels an ongoing DID operation.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrCancelOperation(
  void
  );

/**********************************************************************************************************************
 *  Dcm_DidMgrInitOpInfo()
 *********************************************************************************************************************/
/*! \brief          Initializes the index to Dcm_CfgDidMgrDidOpInfo[].
 *  \details        -
 *  \param[in]      pDidInfoContext    The DID configuration context
 *  \param[in]      didOp              The required DID operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrInitOpInfo(
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrOpOptType didOp
  );

/**********************************************************************************************************************
 *  Dcm_DidMgrInitOpTypeHandler()
 *********************************************************************************************************************/
/*! \brief          Initialization function of the  DID handler.
 *  \details        Prepare DID for multi signal processing for a specific operation type (i.e. Read, ReadCheckCond,
 *                  Write, etc.)
 *  \param[in]      pDidInfoContext    The DID configuration context
 *  \param[in]      pDidOpTypeContext  The DID operation context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrInitOpTypeHandler(
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
  );

# if (DCM_DIDMGR_DYNDID_DEEP_CHECK_ON_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrDynDidStateCheck()
 *********************************************************************************************************************/
/*! \brief          Checks the state of a specific DID.
 *  \details        Checks a DID operation info considering DynDID content.
 *  \param[in]      connHdl            The connection identifier
 *  \param[in]      pDidInfoContext    The DID configuration context
 *  \param[out]     ErrorCode          Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK           State check was successful
 *  \return         DCM_E_NOT_OK       State check was not successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrDynDidStateCheck(
  Dcm_NetConnRefMemType connHdl,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# else
/* a function like macro is used for optimal code size */
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrDemSetDTCFilter()
 *********************************************************************************************************************/
/*! \brief          Sets the DTC Filter in Dem.
 *  \details        -
 *  \param[in]      StatusMask              DTC Statusmask
 *  \param[in]      Origin                  DTC Origin
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrDemSetDTCFilter(
  uint8 StatusMask,
  Dem_DTCOriginType Origin,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_ObdDtcManagerContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrReadDtcByStatusMask()
 *********************************************************************************************************************/
/*! \brief          Processes a DTC read by status mask service for OBD.
 *  \details        -
 *  \param[in]      opStatus                The operation status
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_STOP_REPEATER     Stop Repeater Proxy
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            DTC Filter set in Dem (Dcm_ObdDtcMgrDemSetDTCFilter)
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrReadDtcByStatusMask(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_ObdDtcManagerContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          Data processor of service (0x03/0x07/0x0A).
 *  \details        Calls the GetNextFilteredDTC function.
 *  \param[in,out]  pDataContext                Pointer to the data context
 *  \param[out]     ErrorCode                   The NRC
 *  \param[in,out]  pRepContext                 Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_NOT_OK                Error occured
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available space any more
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc(
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_ObdDtcManagerContextPtrType pRepContext
  );
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_TskScheduler()
 *********************************************************************************************************************/
/*! \brief          Task scheduling.
 *  \details        Monitors for any tasks to be activated.
 *  \param[in]      tskPrio    The tasks priority to be monitored and activated
 *  \context        TASK
 *  \reentrant      TRUE only in case split task is supported.
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_TskScheduler(
  Dcm_TskTaskPrioMemType tskPrio
  );
/**********************************************************************************************************************
 *  Dcm_TmrTaskTimer()
 *********************************************************************************************************************/
/*! \brief          Timer task scheduling.
 *  \details        Scheduling of the timer manager sub-module.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_TmrTaskTimer(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferTask()
 *********************************************************************************************************************/
/*! \brief          Lo priority Tx task of the paged-buffer sub-module.
 *  \details        -
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_PagedBufferTask(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

/**********************************************************************************************************************
 *  Dcm_DiagTaskRx()
 *********************************************************************************************************************/
/*! \brief          High priority Rx task of the network sub-module.
 *  \details        -
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskRx(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagTaskWorker()
 *********************************************************************************************************************/
/*! \brief          Low priority task of the diagnostic sub-module.
 *  \details        -
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskWorker(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );

#if (DCM_TSK_NUM_DIAG_GARB_COL > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagTaskGarbageCollector()
 *********************************************************************************************************************/
/*! \brief          High priority task of the diagnostic sub-module.
 *  \details        Releases all obsolete transport objects after prioritization.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskGarbageCollector(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagTaskFblRes()
 *********************************************************************************************************************/
/*! \brief          Low priority task of the diagnostic sub-module.
 *  \details        -
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskFblRes(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

/**********************************************************************************************************************
 *  Dcm_DiagTaskTx()
 *********************************************************************************************************************/
/*! \brief          High priority Tx task of the diagnostic sub-module.
 *  \details        -
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskTx(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );

/**********************************************************************************************************************
 *  Dcm_NetTaskTx()
 *********************************************************************************************************************/
/*! \brief          High priority task of the network sub-module for transmissions.
 *  \details        -
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskTx(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );

/**********************************************************************************************************************
 *  Dcm_NetTaskRx()
 *********************************************************************************************************************/
/*! \brief          High priority task of the network sub-module for request prioritization.
 *  \details        -
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskRx(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetTaskTaMonitor()
 *********************************************************************************************************************/
/*! \brief          High priority task of the network sub-module for request processing suppression.
 *  \details        This function is used to prevent a request processing or to cancel an ongoing request processing.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskTaMonitor(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

#if (DCM_TSK_NUM_MODE_MONITOR > 0u)
/**********************************************************************************************************************
 *  Dcm_ModeTaskMonitor()
 *********************************************************************************************************************/
/*! \brief          Lo priority monitoring task of the Mode manager sub-module.
 *  \details        -
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeTaskMonitor(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

#if (DCM_TSK_NUM_SVC2A_SCHEDULER > 0u)
/**********************************************************************************************************************
 *  Dcm_Svc2ATaskSchdProcess()
 *********************************************************************************************************************/
/*! \brief          Low priority task.
 *  \details        Task for service 0x2A scheduling.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ATaskSchdProcess(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

#if (DCM_TSK_NUM_SVC27 > 0u)
/**********************************************************************************************************************
 *  Dcm_Svc27Task()
 *********************************************************************************************************************/
/*! \brief          Low priority task.
 *  \details        Task for service 0x27.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc27Task(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

#if (DCM_TSK_NUM_DIAG_RECOVERY > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagTaskRecovery()
 *********************************************************************************************************************/
/*! \brief          Low priority task of the diagnostic sub-module to recover an external stored DCM state.
 *  \details        -
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskRecovery(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif
/**********************************************************************************************************************
 *  Dcm_DiagRcrRpTxFinished()
 *********************************************************************************************************************/
/*! \brief          Performs post processing of currently finished RCR-RP transmission.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \param[in]      txStatus      Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagRcrRpTxFinished(
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_NetTransmissionResultType txStatus
  );

/**********************************************************************************************************************
 *  Dcm_DiagSetP2Timings()
 *********************************************************************************************************************/
/*! \brief          Sets the adjusted P2 timings.
 *  \details        -
 *  \param[in]      sesStateIdx    The index of the current session.
 *  \param[in]      protocolIdx    The index of the current protocol.
 *  \param[in]      threadId       Active thread
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagSetP2Timings(
  Dcm_StateIndexMemType sesStateIdx,
  Dcm_NetProtRefMemType protocolIdx,
  Dcm_ThreadIdMemType threadId
  );

/**********************************************************************************************************************
 *  Dcm_DiagRxIndication()
 *********************************************************************************************************************/
/*! \brief          Called once an incoming reception is finished.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM external/internal connection
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagRxIndication(
  Dcm_NetTransportObjectPtrType pTranspObj
  );

/**********************************************************************************************************************
 *  Dcm_SetNegResponse()
 *********************************************************************************************************************/
/*! \brief          Registers a NRC to the request in progress if no other NRC already set.
 *  \details        -
 *  \param[in]      nrc         The error code to be registered
 *  \param[in]      threadId    Active thread
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_SetNegResponse(
  Dcm_NegativeResponseCodeType nrc,
  Dcm_ThreadIdOptType threadId
  );

/**********************************************************************************************************************
 *  Dcm_ProcessingDone()
 *********************************************************************************************************************/
/*! \brief          Finalizes the service job processing.
 *  \details        -
 *  \param[in]      threadId    Active thread
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ProcessingDone(
  Dcm_ThreadIdOptType threadId
  );

/**********************************************************************************************************************
 *  Dcm_DiagLookUpFilter()
 *********************************************************************************************************************/
/*! \brief          Performs a lookup result filtering.
 *  \details        -
 *  \param[in,out]  pMsgContext          The current request context
 *  \param[in]      lookUpResult         The original result of the lookup
 *  \param[in]      lookUpFilterTable    List of filters
 *  \param[in]      chkLevel             Hierarchy level on which the lookup is performed
 *  \param[out]     errorCode            The error code to be returned
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_DiagLookUpFilter(
  Dcm_MsgContextPtrType pMsgContext,
  sint16_least lookUpResult,
  Dcm_VarRefMemPtrType lookUpFilterTable,
  Dcm_DiagCheckLvlType chkLevel,
  Dcm_NegativeResponseCodePtrType errorCode
  );
#if (DCM_DIAG_SF_ONLY_SERVICE_ENABLED == STD_ON)                                                                                                     /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DiagSvcWithOnlySubFuncReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Default sub-function length getter.
 *  \details        Always returns length of 1 byte (sub-function byte only expected)
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length (1 byte only)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_DiagSvcWithOnlySubFuncReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  );
#endif

/**********************************************************************************************************************
 *  Dcm_DiagNoSequenceChecker()
 *********************************************************************************************************************/
/*! \brief          Default sub-function sequence checker.
 *  \details        Always returns DCM_E_OK.
 *  \param[in,out]  pMsgContext          The current request context
 *  \param[in]      subSvcRef            The sub-function zero-based index.
 *  \param[out]     ErrorCode            The NRC
 *  \return         DCM_E_OK             Validation passed
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagNoSequenceChecker(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_DiagSubServiceRefOptType subSvcRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_DiagSvcWithSubFuncStateCheck()
 *********************************************************************************************************************/
/*! \brief          Performs a state rule check for a service with sub-function.
 *  \details        -
 *  \param[in,out]  pMsgContext               Current request context
 *  \param[in]      stateRef                  Reference to the state precondition table
 *  \param[in]      subFuncSequenceChecker    Function for accessing a service specific sequence check
 *  \param[in]      subSvcRef                 The sub-function zero-based index
 *  \param[out]     ErrorCode                 The NRC
 *  \return         DCM_E_OK                  State rule check was sucessful
 *  \return         DCM_E_NOT_OK              State rule check was not sucessful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSvcWithSubFuncStateCheck(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_CfgStateRefOptType stateRef,
  Dcm_DiagSubFuncSequenceCheckerFuncType subFuncSequenceChecker,
  Dcm_DiagSubServiceRefOptType subSvcRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_DiagVerifyServiceWithSubFunction()
 *********************************************************************************************************************/
/*! \brief          Verifies a service with sub-function.
 *  \details        Implements the ISO14229-1:2013 algorithm for sub-function validation
 *  \param[in,out]  pMsgContext            Current request context
 *  \param[in]      lookUpTable            The sub-service lookup table
 *  \param[in]      lookUpFilterTable      List of sub-service related filters
 *  \param[in]      svcLengthGetter        Functor for accessing a sub-service specific length
 *  \param[in]      subFuncSequenceChecker Function for accessing a service specific sequence check
 *  \param[out]     pSubSvcRef             A zero-based sub-service index for further processing
 *  \param[out]     ErrorCode              The NRC
 *  \return         DCM_E_OK               Validation passed
 *  \return         DCM_E_NOT_OK           Validation failed with the returned ErrorCode
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagVerifyServiceWithSubFunction(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_Uint8ConstDataPtrType lookUpTable,
  Dcm_VarRefMemPtrType lookUpFilterTable,
  Dcm_DiagServiceLengthGetterFuncType svcLengthGetter,
  Dcm_DiagSubFuncSequenceCheckerFuncType subFuncSequenceChecker,
  Dcm_DiagSubServiceRefOptPtrType pSubSvcRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_DiagExecIndicationFunc()
 *********************************************************************************************************************/
/*! \brief          Executes an indication callback and evaluates its return values.
 *  \details        -
 *  \param[in]      pContext            Pointer to the context
 *  \param[in]      sid                 The requested SID
 *  \param[in]      notificationType    The notification kind (OEM, SYS)
 *  \param[in]      notifList           The request indication list to be executed
 *  \param[out]     ErrorCode           The NRC
 *  \return         DCM_E_OK            Proceed with service validation after return
 *  \return         DCM_E_NOT_OK        At least one Xxx_Indication() has rejected further processing
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            The last element of the passed notifList must be marked by NULL_PTR.
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagExecIndicationFunc(
  Dcm_ContextPtrType pContext,
  Dcm_MsgItemType sid,
  Dcm_DiagApplNotificationType notificationType,
  Dcm_CfgDiagNotificationInfoPtrType notifList,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_DiagTxFinalization()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \param[in]      txStatus      Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTxFinalization(
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_NetTransmissionResultType txStatus
  );

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagOnFblResTxFinished()
 *********************************************************************************************************************/
/*! \brief          Called by the TP once an ongoing transmission is finished.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \param[in]      txStatus      Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagOnFblResTxFinished(
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_NetTransmissionResultType txStatus
  );
#endif

/**********************************************************************************************************************
 *  Dcm_DiagCancelProcessing()
 *********************************************************************************************************************/
/*! \brief          Cancel any ongoing job.
 *  \details        This function cancels any ongoing service processing.
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagCancelProcessing(
  Dcm_NetTransportObjectPtrType pTranspObj
  );
/**********************************************************************************************************************
 *  Dcm_VarMgrLookUpFilter()
 *********************************************************************************************************************/
/*! \brief          Performs a lookup result filtering.
 *  \details        Checks whether a diagnostic object is supported in the active variant.
 *  \param[in]      lookUpResult         The original result of the lookup (can also be "NOT_FOUND")
 *  \param[in]      lookUpFilterTable    List of filters
 *  \return         -1     Diagnostic entity not active in current variant
 *  \return         >=0    Success, index of the matched position
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_VarMgrLookUpFilter(
  sint16_least lookUpResult,
  Dcm_VarRefMemPtrType lookUpFilterTable
  );

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrIsEnabledInActiveVariants()
 *********************************************************************************************************************/
/*! \brief          Checks if a diagnostic object is active in at least one variant.
 *  \details        -
 *  \param[in]      cfgVariantRef    Reference to the variant configuration
 *  \return         TRUE             Diagnostic object is active in at least one variant
 *  \return         FALSE            Diagnostic object is not active
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_VarMgrIsEnabledInActiveVariants(
  Dcm_CfgStateRefOptType cfgVariantRef
  );
#else
# define Dcm_VarMgrIsEnabledInActiveVariants(cfgVariantRef)          ((boolean)Dcm_VarMgrBitSetTestBit(Dcm_PbCfgVarMgrDiagVariantFilter[(cfgVariantRef)], Dcm_SingletonContext.VarMgr.ActiveCfgVariantId)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_ProcessEcuReset()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 EcuReset mode switching management.
 *  \details        Manages the mode switches for service 0x11. If something goes wrong, an appropriate NRC will be sent.
 *  \param[in]      pContext            Pointer to the context
 *  \param[in]      mode                The ECU reset mode to be switched into
 *  \param[out]     ErrorCode           The NRC
 *  \return         DCM_E_NOT_OK        Send response (negative)
 *  \return         DCM_E_LOOP          Process immediately with next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_ProcessEcuReset(
  Dcm_ContextPtrType pContext,
  Rte_ModeType_DcmEcuReset mode,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_SVC_11_RAPID_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_ProcessRapPwrDwn()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 RapidPowerShutDown mode switching management.
 *  \details        Manages the mode switches for service 0x11. If something goes wrong, an appropriate NRC will be sent.
 *  \param[in]      pContext            Pointer to the context
 *  \param[in]      mode                The ECU reset mode to be switched into
 *  \param[out]     ErrorCode           The NRC
 *  \return         DCM_E_NOT_OK        Send response (negative)
 *  \return         DCM_E_LOOP          Process immediately with next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_ProcessRapPwrDwn(
  Dcm_ContextPtrType pContext,
  Rte_ModeType_DcmModeRapidPowerShutDown mode,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x19 sub-function length getter.
 *  \details        Always returns the sub-function specific length.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc19ReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  );
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportNumDtcByStatusMaskData()
 *********************************************************************************************************************/
/*! \brief          Compose response for any service 0x19 sub-function reporting number of DTC by status mask.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      dsfClass                DEM SetFilter class type
 *  \param[in]      dtcStatusMask           DTC status mask
 *  \param[in]      dtcSeverity             If severity specific search - define the severity level
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportNumDtcByStatusMaskData(
  Dcm_ContextPtrType pContext,
  Dcm_Svc19DemSetFilterClassType dsfClass,
  uint8 dtcStatusMask,
  Dem_DTCSeverityType dtcSeverity,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportDtcByStatusMaskData()
 *********************************************************************************************************************/
/*! \brief          Compose response for any service 0x19 sub-function reporting DTC and status mask.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      dsfClass                DEM SetFilter class type
 *  \param[in]      maskUsage               Specifies how to treat the requested status mask (if any)
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportDtcByStatusMaskData(
  Dcm_ContextPtrType pContext,
  Dcm_Svc19DemSetFilterClassType dsfClass,
  Dcm_Svc19DemSetFilterMaskUsageType maskUsage,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportExtDataRecordByDtcNum()
 *********************************************************************************************************************/
/*! \brief          Compose response for any service 0x19 sub-function reporting DTC and its extended data record(s).
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      dtcOrigin               The DTC origin to process
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportExtDataRecordByDtcNum(
  Dcm_ContextPtrType pContext,
  Dem_DTCOriginType dtcOrigin,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdFDC()
 *********************************************************************************************************************/
/*! \brief          Read the next filtered DTC and its FDC.
 *  \details        -
 *  \param[in,out]  pDataContext                Pointer to the data context
 *  \param[out]     ErrorCode                   The NRC
 *  \param[in,out]  pRepContext                 Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_PENDING_LIMITER       Runtime limit reached, retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available space any more
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \return         DCM_E_NOT_OK                Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdFDC(
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_19_CHAINING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiChainStart()
 *********************************************************************************************************************/
/*! \brief          Initiates a service processing chain of activities.
 *  \details        -
 *  \param[in]      pContext      Pointer to the context
 *  \param[in]      funcChain     The function chain
 *  \param[in,out]  pRepContext   Current repeater proxy context
 *  \return         DCM_E_LOOP    Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiChainStart(
  Dcm_ContextPtrType pContext,
  P2CONST(Dcm_RepeaterProgressType, AUTOMATIC, DCM_CONST) funcChain,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_19_CHAINING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiChainNext()
 *********************************************************************************************************************/
/*! \brief          Switches to the next processing activity in the chain specified by Dcm_Svc19UtiChainStart.
 *  \details        -
 *  \param[in]      pContext      Pointer to the context
 *  \param[in,out]  pRepContext   Current repeater proxy context
 *  \return         DCM_E_LOOP    Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiChainNext(
  Dcm_ContextPtrType pContext,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_OCCUR_TIME_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportNumDtcByOccurenceTime()
 *********************************************************************************************************************/
/*! \brief          Compose response for any service 0x19 sub-function reporting number DTC by occurence time.
 *  \details        -
 *  \param[in]     pContext             Pointer to the context
 *  \param[in]      dtcReqType              The DTC request type
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportNumDtcByOccurenceTime(
  Dcm_ContextPtrType pContext,
  Dem_DTCRequestType dtcReqType,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportDtcFFRByDtc()
 *********************************************************************************************************************/
/*! \brief          Compose response for any service 0x19 sub-function reporting DTC and its freze-frame data record(s).
 *  \details        -
 *  \param[in]      pContext       Pointer to the context
 *  \param[in]      dtcOrigin      The DTC origin to process
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         DCM_E_LOOP     Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportDtcFFRByDtc(
  Dcm_ContextPtrType pContext,
  Dem_DTCOriginType dtcOrigin,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  );
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27UtiSetAttemptCntr()
 *********************************************************************************************************************/
/*! \brief          Notifies the application about changed attempt counter values.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in,out]  levelMask               Pointer to a security level mask.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc27UtiSetAttemptCntr(
  Dcm_OpStatusType opStatus,
  P2VAR(uint32, AUTOMATIC, DCM_VAR_NOINIT) levelMask
  );
# endif

/**********************************************************************************************************************
 *  Dcm_Svc27ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 sub-function length getter.
 *  \details        Always returns the sub-function specific length.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc27ReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  );

/**********************************************************************************************************************
 *  Dcm_Svc27SubFuncSequenceChecker()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 sub-function sequence checker.
 *  \details        Checks whether the sub-function sequence is correct.
 *  \param[in]      pMsgContext          Pointer to current message context
 *  \param[in]      subSvcRef            The sub-function zero-based index.
 *  \param[out]     ErrorCode            The NRC
 *  \return         DCM_E_OK             Validation passed
 *  \return         DCM_E_NOT_OK         Send negative response
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc27SubFuncSequenceChecker(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_DiagSubServiceRefOptType subSvcRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc28EnableCommunication()
 *********************************************************************************************************************/
/*! \brief          Enable communication on all affected channels.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc28EnableCommunication(
  void
  );

/**********************************************************************************************************************
 *  Dcm_Svc28OnChangeSession()
 *********************************************************************************************************************/
/*! \brief         Service 0x28 utility function about a session change.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc28OnChangeSession(
  void
  );

/**********************************************************************************************************************
 *  Dcm_Svc28ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x28 sub-function length getter.
 *  \details        Always returns the sub-function specific length.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc28ReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  );
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29CancelOperation()
 *********************************************************************************************************************/
/*! \brief          Cancels an ongoing service 0x29 request.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
 DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc29CancelOperation(
  void
  );

/**********************************************************************************************************************
 *  Dcm_Svc29CertificateStoreVerify()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function 0x01 and 0x02 storage and verfication step.
 *  \details        Stores and verifies client certificate from request.
 *  \param[in]      cocoField               COCO value of the requets
 *  \param[in]      clientCertLength        Client certificate length
 *  \param[in]      pContext                Pointer to the context
 *  \param[in,out]  pMsgContext             The message context
 *  \param[out]     ErrorCode               The NRC
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29CertificateStoreVerify(
  uint8 cocoField,
  uint16 clientCertLength,
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc29CertificateVerificationDoneHandler()
*********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function 0x01 and 0x02 stored certificate verification step.
 *  \details        Stored certificate verification.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             The message context
 *  \param[in,out]  pRepContext             The repeater context
 *  \param[out]     ErrorCode               The NRC
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29CertificateVerificationDoneHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc29GenerateServerChallenge()
 *********************************************************************************************************************/
/*! \brief          Challenge generation wrapper function.
 *  \details        Triggers the Csm to generate the server challenge.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in,out]  pMsgContext             The message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             The repeater context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29GenerateServerChallenge(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc29ChallengeGenerationDoneHandler()
*********************************************************************************************************************/
/*! \brief          Service 0x29 certificate signing step.
 *  \details        Certificate signing after successful challenge generation.
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in]      opStatus                   The operations status
 *  \param[in,out]  pMsgContext                The message context
 *  \param[out]     ErrorCode                  The NRC
 *  \param[in,out]  pRepContext                The repeater context
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29ChallengeGenerationDoneHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );

# if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29GenerateSignature()
 *********************************************************************************************************************/
/*! \brief          Signature generation wrapper function.
 *  \details        Evaluates previous operation result and generates challenge.
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in,out]  pMsgContext                The message context
 *  \param[out]     ErrorCode                  The NRC
 *  \param[in,out]  pRepContext                The repeater context
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29GenerateSignature(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29_02ChallengeSigningDoneHandler()
*********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function 0x02 final step.
 *  \details        Sends positive response if challege signing and certificate retrieval was successful.
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in]      opStatus                   The operations status
 *  \param[in,out]  pMsgContext                The message context
 *  \param[out]     ErrorCode                  The NRC
 *  \param[in,out]  pRepContext                The repeater context
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Send positive response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_02ChallengeSigningDoneHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );

# endif

/**********************************************************************************************************************
 *  Dcm_Svc29_03RoleRead()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function 0x03 role retrieval step.
 *  \details        Retrieve role from key manager.
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in]      opStatus                   The operation status
 *  \param[in,out]  pMsgContext                The message context
 *  \param[out]     ErrorCode                  The NRC
 *  \param[in,out]  pRepContext                The repeater context
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_LOOP                 Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03RoleRead(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc29_03ServiceWL()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function 0x03 SERVICE white list retrieval step.
 *  \details        Retrieve service white list from key manager.
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in]      opStatus                   The operation status
 *  \param[in,out]  pMsgContext                The message context
 *  \param[out]     ErrorCode                  The NRC
 *  \param[in,out]  pRepContext                The repeater context
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_LOOP                 Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03ServiceWL(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc29_03DidWL()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function 0x03 DID white list retrieval step.
 *  \details        Retrieve DID white list from key manager.
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in]      opStatus                   The operation status
 *  \param[in,out]  pMsgContext                The message context
 *  \param[out]     ErrorCode                  The NRC
 *  \param[in,out]  pRepContext                The repeater context
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_LOOP                 Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03DidWL(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc29_03RidWL()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function 0x03 RID white list retrieval step.
 *  \details        Retrieve RID white list from key manager.
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in]      opStatus                   The operation status
 *  \param[in,out]  pMsgContext                The message context
 *  \param[out]     ErrorCode                  The NRC
 *  \param[in,out]  pRepContext                The repeater context
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_LOOP                 Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03RidWL(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc29_03MemWL()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function 0x03 MEM white list retrieval step.
 *  \details        Retrieve MEM white list from key manager.
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in]      opStatus                   The operation status
 *  \param[in,out]  pMsgContext                The message context
 *  \param[out]     ErrorCode                  The NRC
 *  \param[in,out]  pRepContext                The repeater context
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Send positive response
 *  \return         DCM_E_LOOP                 Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03MemWL(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc29_03PersistAuthentication()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function 0x03 Persistence.
 *  \details        Call NvMWriteBlock in order to persist authentication data.
 *  \param[in]      opStatus                   The operation status
 *  \param[in,out]  pMsgContext                The message context
 *  \param[out]     ErrorCode                  The NRC
 *  \param[in,out]  pRepContext                The repeater context
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Send positive response
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03PersistAuthentication(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc29ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function length getter.
 *  \details        Always returns the sub-function specific length.
 *  \param[in]      sfRef                The sub-function zero-based index
 *  \return         Expected sub-function specific length
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc29ReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  );

/**********************************************************************************************************************
 *  Dcm_Svc29VerifySignature()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function 0x03 Signature verify.
 *  \details        Triggers the verify signature job of Csm.
 *  \param[in]      proofOfOwnershipLength     Proof of Ownership length
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in,out]  pMsgContext                The message context
 *  \param[out]     ErrorCode                  The NRC
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29VerifySignature(
  uint16 proofOfOwnershipLength,
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc29SubFuncSequenceChecker()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function sequence checker.
 *  \details        Checks whether the sub-function sequence is correct.
 *  \param[in,out]  pMsgContext                 The message context
 *  \param[in]      subSvcRef                   The sub-function zero-based index
 *  \param[out]     ErrorCode                   The NRC
 *  \return         DCM_E_NOT_OK                Wrong sequence
 *  \return         DCM_E_OK                    Successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29SubFuncSequenceChecker(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_DiagSubServiceRefOptType subSvcRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#endif /* (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/* --- public members ---------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopAll()
 *********************************************************************************************************************/
/*! \brief          Stops all scheduled DIDs.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopAll(
  void
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCancelReadByHandle()
 *********************************************************************************************************************/
/*! \brief          Stops a single scheduled item.
 *  \details        -
 *  \param[in]      schdHandle    The handle
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdCancelReadByHandle(
  Dcm_Svc2ASchdItemHandleOptType schdHandle
  );

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCancelReadByDid()
 *********************************************************************************************************************/
/*! \brief          Cancels the reading of a single scheduled item.
 *  \details        -
 *  \param[in]      did    The did
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdCancelReadByDid(
  uint16 did
  );
# endif

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2AGetConnectionOfDID()
 *********************************************************************************************************************/
/*! \brief          Returns the connection ID of scheduled DID.
 *  \details        -
 *  \param[in]      did    The DID
 *  \return         Valid connection ID (if DID is scheduled)
 *  \return         DCM_NET_INVALID_CONNHDL (if DID is not scheduled)
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetConnRefMemType, DCM_CODE) Dcm_Svc2AGetConnectionOfDID(
  uint16 did
  );
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopItemByHandle()
 *********************************************************************************************************************/
/*! \brief          Stops a single scheduled item.
 *  \details        -
 *  \param[in]      schdHandle    The handle
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopItemByHandle(
  Dcm_Svc2ASchdItemHandleOptType schdHandle
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopItemByDid()
 *********************************************************************************************************************/
/*! \brief          Cancels the reading of a single scheduled item.
 *  \details        -
 *  \param[in]      did    The did
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopItemByDid(
  uint16 did
  );

/* --- private members --------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdGetItemByDid()
 *********************************************************************************************************************/
/*! \brief          Look up for a scheduled DID.
 *  \details        -
 *  \param[in]      did           The did
 *  \param[in]      schdHandle    Handle of the found entry
 *  \return         TRUE          Entry was found
 *  \return         FALSE         Entry was not found - schdHandle output parameter is invalid
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdGetItemByDid(
  uint16 did,
  P2VAR(Dcm_Svc2ASchdItemHandleOptType, AUTOMATIC, AUTOMATIC) schdHandle
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdFinishEntryProcessing()
 *********************************************************************************************************************/
/*! \brief          Finalizes scheduler entry processing (with or without response).
 *  \details        Resets all global states after a scheduler entry was processed. Initiates response transmission
 *                  or releases UUDT message.
 *  \param[in]      doSendResponse    Specifies whether a response shall be sent or not
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdFinishEntryProcessing(
  boolean doSendResponse
  );
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ADidLookUp()
 *********************************************************************************************************************/
/*! \brief          A generic DID look-up for SID 0x2A.
 *  \details        Performs a lookup for a specific DID on any request.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Go to next step
 *  \return         DCM_E_OK                Found a DID, make next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidLookUp(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrClear()
 *********************************************************************************************************************/
/*! \brief          Clear all DDID definitions.
 *  \details        Clears all previously defined DDIDs.
 *  \param[in]      dynDidHandle    DynDID reference to be cleared
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2CDefMgrClear(
  Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle
  );
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C sub-function length getter.
 *  \details        Always returns length of 0 byte to show that the requests have dynamic length and the concrete
 *                  length will be checked later.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc2CReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  );

/**********************************************************************************************************************
 *  Dcm_Svc2CParseAndCheckDynDid()
 *********************************************************************************************************************/
/*! \brief          Parses and validates the DynDID to be defined.
 *  \details        -
 *  \param[in]      pContext       Pointer to the context
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[out]     pRepContext    Current repeater proxy context
 *  \return         DCM_E_OK       Send response
 *  \return         DCM_E_NOT_OK   Send neagative response
 *  \return         DCM_E_PENDING  Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CParseAndCheckDynDid(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2CCheckAndSetNumOfItems()
 *********************************************************************************************************************/
/*! \brief          Check DynDID has enough space to keep all requested definitions.
 *  \details        If the check succeeds also stores the number of requested items for further processing.
 *  \param[in]      numRequestedItems  Number of requested Items
 *  \param[out]     ErrorCode          The NRC
 *  \param[in,out]  pRepContext        Current repeater proxy context
 *  \return         DCM_E_OK        Check succeeded
 *  \return         DCM_E_NOT_OK    Check failed (NRC is stored in ErrorCode)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CCheckAndSetNumOfItems(
  uint8 numRequestedItems,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc85EnableDtcSetting()
 *********************************************************************************************************************/
/*! \brief          Service 0x85 enabler.
 *  \details        Calls the EnableDtcSetting function.
 *  \param[in]      DemClientId                The DEM ClientId
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85EnableDtcSetting(
  uint8 DemClientId
  );

# if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc85DisableDtcSetting()
 *********************************************************************************************************************/
/*! \brief          Service 0x85 disabler.
 *  \details        Calls the DisableDtcSetting function.
 *  \param[in]      DTCGroup                   The DTC Group to be disabled
 *  \param[in]      DemClientId                The DEM ClientId
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85DisableDtcSetting(
  Dem_DTCGroupType DTCGroup,
  uint8 DemClientId
  );
# endif

/**********************************************************************************************************************
 *  Dcm_Svc85OnChangeSession()
 *********************************************************************************************************************/
/*! \brief         Service 0x85 utility function about a session change.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc85OnChangeSession(
  void
  );

/**********************************************************************************************************************
 *  Dcm_Svc85ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x85 sub-function length getter.
 *  \details        Always returns length of 1 or 4 byte depending on whether the optional DTC group is supported.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc85ReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  );

/**********************************************************************************************************************
 *  Dcm_Svc85_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x85 worker.
 *  \details        Calls the Enable/DisableDTCSetting function.
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85_XX_RepeaterProxy(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc85RepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc86ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x86 sub-function length getter.
 *  \details        Always returns the sub-function specific length.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc86ReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  );
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */

/**********************************************************************************************************************
 *  LOCAL DATA DECLARATIONS
 *********************************************************************************************************************/
#define DCM_START_SEC_VAR_NO_INIT_8
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/*!< CEMR session mask (only used in case of ReturnControlToEcu) */
DCM_LOCAL Dcm_MsgItemType Dcm_DidMgrIoControlCemrSessionMask[DCM_DIDMGR_IODID_MAX_EXT_CEMR_SIZE];
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_VAR_NO_INIT_8
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */

#define DCM_START_SEC_VAR_NO_INIT_UNSPECIFIED
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */
#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
/*! Authentication manager data that can be read from and written to NvM (if NvM is configured) */
VAR(Dcm_AuthMgrNvMDataType, DCM_VAR_NOINIT) Dcm_AuthMgrNvMData[DCM_CFGAUTHMGRNETCONNINFO_SIZE];
#endif /* (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON) */
/*! Sub-components per-thread memory */
DCM_LOCAL VAR(Dcm_ThreadContextType, DCM_VAR_NOINIT)    Dcm_ThreadContext[DCM_NUM_THREADS];                                                          /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
/*! Sub-components shared memory */
DCM_LOCAL VAR(Dcm_SingletonContextType, DCM_VAR_NOINIT) Dcm_SingletonContext;
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/*! Service 0x2C Data that can be read from and written to NvM (if NvM is configured) */
VAR(Dcm_Svc2CDynDidNvMDataType, DCM_VAR_NOINIT) Dcm_Svc2CNvMData;
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_VAR_NO_INIT_UNSPECIFIED
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */

#define DCM_START_SEC_CONST_8
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */
#if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
/*! Converts DCMs implementation type definition values into the RTE Mode symbolic name values */
DCM_LOCAL CONST(Dcm_CommunicationModeType, DCM_CONST) Dcm_ModeComCtrlModeMap[12]=                                                                    /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
   RTE_MODE_DcmCommunicationControl_DCM_ENABLE_RX_TX_NORM
  ,RTE_MODE_DcmCommunicationControl_DCM_ENABLE_RX_DISABLE_TX_NORM
  ,RTE_MODE_DcmCommunicationControl_DCM_DISABLE_RX_ENABLE_TX_NORM
  ,RTE_MODE_DcmCommunicationControl_DCM_DISABLE_RX_TX_NORMAL
  ,RTE_MODE_DcmCommunicationControl_DCM_ENABLE_RX_TX_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_ENABLE_RX_DISABLE_TX_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_DISABLE_RX_ENABLE_TX_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_DISABLE_RX_TX_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_ENABLE_RX_TX_NORM_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_ENABLE_RX_DISABLE_TX_NORM_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_DISABLE_RX_ENABLE_TX_NORM_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_DISABLE_RX_TX_NORM_NM
};
#endif /* (DCM_MODE_COMMCTRL_ENABLED == STD_ON) */
/*! A map to get the negative response code corresponding to a specific diagnostic entity (i.e. service, sub-service or parameter identifier */
DCM_LOCAL CONST(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_StateSessionNrcs[DCM_DIAG_NUM_CHK_LVLS]=                                                 /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_E_SERVICENOTSUPPORTEDINACTIVESESSION /* on SID level */
 ,DCM_E_REQUESTOUTOFRANGE /* on Parameter (DID, RID, etc.) level */
 ,DCM_E_SUBFUNCTIONNOTSUPPORTEDINACTIVESESSION /* on SubFunction level */
};
#if (DCM_DEM_API_421_ENABLED == STD_ON) || (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON)
# if (DCM_DEMAPI_SVC_19_SETDTCFILTER_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_SETFFRECORDFILTER_ENABLED == STD_ON) || \
     (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)

/*! Dem SetDTCFilter API return value to NRC mapping */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_DemApiNrcMapSetDTCFilter[3]=                                                                                   /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_WRONG_FILTER, DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON) && \
     (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/*! Dem SelectDTC API return value to NRC mapping */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_DemApiNrcMapSelectDTC[]=                                                                                       /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if defined(DCM_DEM_RET_SELECT_BUSY)                                                                                                               /* COV_DCM_SUPPORT_ALWAYS TX */
  DCM_DEM_RET_SELECT_BUSY, DCM_E_CONDITIONSNOTCORRECT,
#  endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETNUMFILTEREDDTC_ENABLED == STD_ON) || \
     (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)
/*! Dem GetNumberOfFilteredDTC API return value to NRC mapping */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_DemApiNrcMapGetNumberOfFilteredDTC[3]=                                                                         /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_DEM_API_421_ENABLED == STD_ON)
  DEM_NUMBER_FAILED, DCM_E_CONDITIONSNOTCORRECT,
#  endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif
#endif /* (DCM_DEM_API_421_ENABLED == STD_ON) || (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)
/*! RID sub-function ID to operation type value conversion map */
DCM_LOCAL CONST(Dcm_RidMgrOpType, DCM_CONST) Dcm_RidMgrSubFunc2OpMap[4] =                                                                            /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_RIDMGR_OP_NONE,
  DCM_RIDMGR_OP_START,
  DCM_RIDMGR_OP_STOP,
  DCM_RIDMGR_OP_REQRSLTS
};
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
/*! Diagnostic service verification level to NRC map */
DCM_LOCAL CONST(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_DiagObjNotFoundNrcs[DCM_DIAG_NUM_CHK_LVLS]=                                              /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_E_SERVICENOTSUPPORTED     /*!< on SID level */
 ,DCM_E_REQUESTOUTOFRANGE       /*!< on Parameter (DID, RID, etc.) level */
 ,DCM_E_SUBFUNCTIONNOTSUPPORTED /*!< on SubFunction level */
};
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)
/*! Mapping of DEM Clear operation results to DCM NRCs */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc04NrcMapClearDTC[]=                                                                                         /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_CLEAR_W_DTC,        DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_CLEAR_FAILED,       DCM_E_CONDITIONSNOTCORRECT,
  DCM_DEM_RET_CLEAR_CLEAR_BUSY,   DCM_E_CONDITIONSNOTCORRECT,
# if defined(DCM_DEM_RET_CLEAR_BUSY)
  DCM_DEM_RET_CLEAR_BUSY,         DCM_E_CONDITIONSNOTCORRECT,
# endif
  DCM_DEM_RET_CLEAR_MEMORY_ERROR, DCM_E_CONDITIONSNOTCORRECT,
# if (DCM_DEM_API_421_ENABLED == STD_ON)
  /* DCM_DEM_RET_CLEAR_W_ORIGIN,  DCM_E_PANIC_NRC  - shall not occur since DCM sets the origin -> enforce DET */
# else
  DCM_DEM_RET_CLEAR_W_ORIGIN,     DCM_E_REQUESTOUTOFRANGE,
# endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
/*! Mapping of DEM Clear operation results to DCM NRCs */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc14NrcMapClearDTC[]=                                                                                         /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_CLEAR_W_DTC,        DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_CLEAR_FAILED,       DCM_E_CONDITIONSNOTCORRECT,
  DCM_DEM_RET_CLEAR_CLEAR_BUSY,   DCM_E_CONDITIONSNOTCORRECT,
# if defined(DCM_DEM_RET_CLEAR_BUSY)
  DCM_DEM_RET_CLEAR_BUSY,         DCM_E_CONDITIONSNOTCORRECT,
# endif
  DCM_DEM_RET_CLEAR_MEMORY_ERROR, DCM_E_GENERALPROGRAMMINGFAILURE,
# if (DCM_DEM_API_421_ENABLED == STD_ON)
  /* DCM_DEM_RET_CLEAR_W_ORIGIN,  DCM_E_PANIC_NRC  - shall not occur since DCM sets the origin -> enforce DET */
# else
  DCM_DEM_RET_CLEAR_W_ORIGIN,     DCM_E_REQUESTOUTOFRANGE,
# endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
/*! List of all (UDS and OBD) extended data records DEM supports */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19ExtDataRecords[DCM_SVC_19_EXTDATA_RECID_SIZE]=                                                            /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_SVC_19_NUM_EXTDATA_RECID > 0u)
 DCM_SVC_19_LST_EXTDATA_RECID,
#  endif
 DCM_SVC_19_RECLIST_END /* end marker */
};
# endif

# if (DCM_SVC_19_OBD_EXT_RECORD_ENABLED == STD_ON)
/*! List of all OBD extended data records DEM supports */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19ExtDataRecordsObd[DCM_SVC_19_OBD_EXTDATA_RECID_SIZE]=                                                     /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
 DCM_SVC_19_LST_OBD_EXTDATA_RECID,
 DCM_SVC_19_RECLIST_END /* end marker */
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON)
/*! List of all freeze frame data records DEM supports */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19FFDataRecords[DCM_SVC_19_FRZFRAME_RECID_SIZE]=                                                            /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_SVC_19_NUM_FRZFRAME_RECID > 0u)
 DCM_SVC_19_LST_FRZFRAME_RECID,
#  endif
 DCM_SVC_19_RECLIST_END /* end marker */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETDTCSAM_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_GETDTCSEVAM_ENABLED == STD_ON)
/*! DEM API with Std_ReturnType result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapStdReturnType[3]=                                                                                   /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  E_NOT_OK, DCM_E_CONDITIONSNOTCORRECT,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETDTCOCCURTIME_ENABLED == STD_ON)
/*! DEM API "GetDTCByOccurrenceTime" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetDTCByOccurrenceTime[] =                                                                          /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if defined (DCM_DEM_RET_OCCURR_N_OK)
  DCM_DEM_RET_OCCURR_N_OK, DCM_E_GENERALREJECT,
#  endif
#  if defined (DCM_DEM_RET_OCCURR_NO_SUCH_ELEMENT)
  DCM_DEM_RET_OCCURR_NO_SUCH_ELEMENT, DCM_E_POSITIVERESPONSE,
#  endif
#  if defined (DCM_DEM_RET_OCCURR_NOT_AVAILABLE)
  DCM_DEM_RET_OCCURR_NOT_AVAILABLE, DCM_E_POSITIVERESPONSE,
#  endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_SVC_19_05_SUPPORT_ENABLED == STD_ON)
/*! DEM API "GetOBDFreezeFrameData" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetOBDFreezeFrameData[1]=                                                                           /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
/*! DEM API "DisableDTCRecordUpdate", "EnableDTCRecordUpdate" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapAnyAbleRecordUpdate[]=                                                                              /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_DISABLE_DTC_REC_UP_WRONG_DTCORIGIN, DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_DISABLE_DTC_REC_UP_WRONG_DTC,       DCM_E_REQUESTOUTOFRANGE,
#  if defined (DCM_DEM_RET_DISABLE_DTC_REC_UP_WRONG_CONDITION)
  /* Let it be handled in default case (PANIC NRC + DET error) since this means wrong DCM implementation */
  /* DCM_DEM_RET_DISABLE_DTC_REC_UP_WRONG_CONDITION, DCM_E_PANIC, */
#  endif
#  if defined (DCM_DEM_RET_DISABLE_DTC_REC_UP_BUSY)
  DCM_DEM_RET_DISABLE_DTC_REC_UP_BUSY,            DCM_E_CONDITIONSNOTCORRECT,
#  endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETSTATUSOFDTC_ENABLED == STD_ON)
/*! DEM API "GetStatusOfDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetStatusOfDTC[] =                                                                                  /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_STATUS_WRONG_DTC,       DCM_E_REQUESTOUTOFRANGE,
#  if defined (DCM_DEM_RET_STATUS_FAILED)
  DCM_DEM_RET_STATUS_FAILED,          DCM_E_CONDITIONSNOTCORRECT,
#  endif
  DCM_DEM_RET_STATUS_WRONG_DTCORIGIN, DCM_E_CONDITIONSNOTCORRECT,
#  if defined (DCM_DEM_RET_STATUS_BUSY)
  DCM_DEM_RET_STATUS_BUSY,            DCM_E_CONDITIONSNOTCORRECT,
#  endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
/*! DEM API "GetSeverityOfDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetSeverityOfDTC[] =                                                                                /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_GET_SEVERITY_OF_DTC_WRONG_DTC, DCM_E_REQUESTOUTOFRANGE,
#  if defined (DCM_DEM_RET_GET_SEVERITY_OF_DTC_WRONG_DTCORIGIN)
  DCM_DEM_RET_GET_SEVERITY_OF_DTC_WRONG_DTCORIGIN, DCM_E_REQUESTOUTOFRANGE,
#  endif
#  if defined (DCM_DEM_RET_GET_SEVERITY_OF_DTC_BUSY)
  DCM_DEM_RET_GET_SEVERITY_OF_DTC_BUSY, DCM_E_CONDITIONSNOTCORRECT,
#  endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
/*! DEM API "GetFunctionalUnitOfDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetFunctionalUnitOfDTC[] =                                                                          /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if defined (DCM_DEM_RET_GET_FUNCTIONALUNITOFDTC_WRONG_DTCORIGIN)
  DCM_DEM_RET_GET_FUNCTIONALUNITOFDTC_WRONG_DTCORIGIN,  DCM_E_REQUESTOUTOFRANGE,
#  endif
  DCM_DEM_RET_GET_FUNCTIONALUNITOFDTC_WRONG_DTC,        DCM_E_REQUESTOUTOFRANGE,
#  if defined (DCM_DEM_RET_GET_FUNCTIONALUNITOFDTC_BUSY)
  DCM_DEM_RET_GET_FUNCTIONALUNITOFDTC_BUSY,             DCM_E_CONDITIONSNOTCORRECT,
#  endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFEXTRECORD_ENABLED == STD_ON)
/*! DEM API "GetSizeOfExtendedDataRecordByDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetSizeOfExtendedDataRecordByDTC[] =                                                                /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if defined (DCM_DEM_RET_SIZEOFEDR_N_OK)
  /* Let it be handled in default case (PANIC NRC + DET error) since this means wrong DCM implementation */
  /* DCM_DEM_RET_SIZEOFEDR_N_OK,     DCM_E_PANIC, */
#  endif
  DCM_DEM_RET_SIZEOFEDR_W_DTC,    DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_SIZEOFEDR_W_RNUM,   DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_SIZEOFEDR_W_ORIGIN, DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFFFRECORD_ENABLED == STD_ON)
/*! DEM API "GetSizeOfFreezeFrameByDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetSizeOfFreezeFrameByDTC[] =                                                                       /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if defined (DCM_DEM_RET_SIZEOFFFR_N_OK)
  /* Let it be handled in default case (PANIC NRC + DET error) since this means wrong DCM implementation */
  /* DCM_DEM_RET_SIZEOFFFR_N_OK,     DCM_E_PANIC, */
#  endif
  DCM_DEM_RET_SIZEOFFFR_W_DTC,    DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_SIZEOFFFR_W_RNUM,   DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_SIZEOFFFR_W_ORIGIN, DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED == STD_ON)
/*! DEM API "GetFreezeFrameDataByDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetFreezeFrameDataByDTC[7]=                                                                         /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_FFDATABYDTC_W_DTC,    DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_FFDATABYDTC_W_ORIGIN, DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_FFDATABYDTC_W_RNUM,   DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON)
/*! DEM API "GetExtendedDataRecordByDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetExtendedDataRecordByDTC[7]=                                                                      /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_DTC,       DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_DTCORIGIN, DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_NUMBER,    DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
DCM_LOCAL CONST(Dcm_DidMgrOpMemType, DCM_CONST) Dcm_Svc2FCtrlOp2DidOpTypeMap[4]=                                                                     /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU
 ,DCM_DIDMGR_OPTYPE_IO_RST2DEF
 ,DCM_DIDMGR_OPTYPE_IO_FRZCURSTATE
 ,DCM_DIDMGR_OPTYPE_IO_SHRTTRMADJ
};
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CONST_8
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */

#define DCM_START_SEC_CONST_UNSPECIFIED
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */
DCM_LOCAL CONST(Dcm_TmrTimerInfoType, DCM_CONST) Dcm_TmrTimerInfo[DCM_TMR_NUM_TIMERS] =                                                              /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  {Dcm_OnTimeoutP2,                       DCM_TMR_ATR_THREAD_MULTI,  DCM_TMR_CONTEXT_ID_P2 }
 ,{Dcm_OnTimeoutS3,                       DCM_TMR_ATR_THREAD_SINGLE, DCM_TMR_CONTEXT_ID_S3 }
#if (DCM_TMR_NUM_FBLRES > 0u)
 ,{Dcm_OnTimeoutFblRes,                   DCM_TMR_ATR_THREAD_SINGLE, DCM_TMR_CONTEXT_ID_FBLRES }
#endif
#if (DCM_TMR_NUM_SECURITY > 0u)
 ,{Dcm_OnTimeoutSecurityAccess,           DCM_TMR_ATR_THREAD_SINGLE, DCM_TMR_CONTEXT_ID_SECURITY }
#endif
#if (DCM_TMR_NUM_PERIODIC_TX > 0u)
 ,{Dcm_OnTimeoutPeriodicTx,               DCM_TMR_ATR_THREAD_SINGLE, DCM_TMR_CONTEXT_ID_PERIODIC_TX }
#endif
#if (DCM_TMR_NUM_SVC2A_SCHEDULER > 0u)
 ,{Dcm_OnTimeoutSvc2AScheduler,           DCM_TMR_ATR_THREAD_SINGLE, DCM_TMR_CONTEXT_ID_SVC2A_SCHEDULER }
#endif
#if (DCM_TMR_NUM_SVC86_SCHEDULER > 0u)
 ,{Dcm_ExtOnTimeoutSvc86Scheduler, DCM_TMR_ATR_THREAD_SINGLE, DCM_TMR_CONTEXT_ID_SVC86_SCHEDULER }
#endif
#if (DCM_TMR_NUM_KEEP_ALIVE > 0u)
 ,{Dcm_OnTimeoutKeepAlive,                DCM_TMR_ATR_THREAD_SINGLE, DCM_TMR_CONTEXT_ID_KEEP_ALIVE }
#endif
#if (DCM_TMR_NUM_AUTHENTICATION > 0u)
 ,{Dcm_OnTimeoutAuthentication,           DCM_TMR_ATR_THREAD_SINGLE, DCM_TMR_CONTEXT_ID_AUTHENTICATION }
#endif
};
/*! Configuration of all DCM internal tasks */
DCM_LOCAL CONST(Dcm_TskTaskInfoType, DCM_CONST) Dcm_TskTaskInfo[DCM_TSK_NUM_TASKS]=                                                                  /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  /* first to be processed */
#if (DCM_TSK_NUM_DIAG_RECOVERY > 0u)
  {Dcm_DiagTaskRecovery,     (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_NEVER | DCM_TSK_ATR_THREAD_SINGLE), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE, DCM_TSK_CONTEXT_ID_DIAG_RECOVERY}, /* Task to recover an external stored DCM state */
#endif
#if (DCM_TSK_NUM_NET_TA_MONITOR > 0u)
  {Dcm_NetTaskTaMonitor,     (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_NEVER | DCM_TSK_ATR_THREAD_SINGLE), DCM_TSK_PRIO_HIGH, DCM_TSK_EV_NONE, DCM_TSK_CONTEXT_ID_NET_TA_MONITOR}, /* Requests with a foreign N_TA will be handled here */
#endif
  {Dcm_NetTaskRx,            (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_NEVER | DCM_TSK_ATR_THREAD_MULTI), DCM_TSK_PRIO_HIGH, DCM_TSK_EV_NONE, DCM_TSK_CONTEXT_ID_NET_RX}, /* The P2 timer will be started here - put this task prior timer task. NetRx task must always work */
  {Dcm_TmrTaskTimer,         (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_NEVER | DCM_TSK_ATR_THREAD_SINGLE), DCM_TSK_PRIO_HIGH, DCM_TSK_EV_NONE, DCM_TSK_CONTEXT_ID_TIMER}, /* process timers first, the tasks will do their job according to the event priorities. Never kill timer task! */
  {Dcm_DiagTaskRx,           (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_ALWAYS | DCM_TSK_ATR_THREAD_MULTI), DCM_TSK_PRIO_HIGH, (DCM_TSK_EV_DIAG_RX_TMR_P2_TO | DCM_TSK_EV_DIAG_RX_NEW_REQ), DCM_TSK_CONTEXT_ID_DIAG_RX},
#if (DCM_TSK_NUM_MODE_MONITOR > 0u)
  {Dcm_ModeTaskMonitor,      (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_NEVER | DCM_TSK_ATR_THREAD_SINGLE), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE, DCM_TSK_CONTEXT_ID_MODE_MONITOR}, /* let monitors work in the background */
#endif
#if (DCM_TSK_NUM_DIAG_FBLRES > 0u)
  {Dcm_DiagTaskFblRes,       (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_NEVER | DCM_TSK_ATR_THREAD_SINGLE), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE, DCM_TSK_CONTEXT_ID_DIAG_FBLRES},/* let FBL work in the background till end */
#endif
#if (DCM_TSK_NUM_SVC27 > 0u)
  {Dcm_Svc27Task,            (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_NEVER | DCM_TSK_ATR_THREAD_SINGLE), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE, DCM_TSK_CONTEXT_ID_SVC27}, /* Collects the attempt counter values */
#endif
  {Dcm_DiagTaskWorker,       (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_ALWAYS | DCM_TSK_ATR_THREAD_MULTI), DCM_TSK_PRIO_LOW,  (DCM_TSK_EV_DIAG_WORK_KILL_JOBS|DCM_TSK_EV_DIAG_WORK_INT_SET2DEF|DCM_TSK_EV_DIAG_WORK_NEW_REQ|DCM_TSK_EV_DIAG_WORK_TX_END_FINAL|DCM_TSK_EV_DIAG_WORK_IDLE_CONN|DCM_TSK_EV_DIAG_WORK_EXT_SETROLE), DCM_TSK_CONTEXT_ID_DIAG_WORK},
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  {Dcm_PagedBufferTask,      (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_ALWAYS | DCM_TSK_ATR_THREAD_MULTI), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE, DCM_TSK_CONTEXT_ID_PGDBUF},
#endif
#if (DCM_TSK_NUM_ROE > 0u)
  {Dcm_ExtSvc86Task,         (DCM_TSK_ATR_ROE_EXEC   | DCM_TSK_ATR_KILL_NEVER | DCM_TSK_ATR_THREAD_SINGLE), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE, DCM_TSK_CONTEXT_ID_ROE}, /* let RoE work in the background - if RoE triggered the client prioritization will take place */
#endif
#if (DCM_TSK_NUM_DIAG_GARB_COL > 0u)
  {Dcm_DiagTaskGarbageCollector, (DCM_TSK_ATR_EXEC_ONCE | DCM_TSK_ATR_KILL_NEVER | DCM_TSK_ATR_THREAD_MULTI),  DCM_TSK_PRIO_HIGH, 0, DCM_TSK_CONTEXT_ID_DIAG_GARB_COL},
#endif
  {Dcm_DiagTaskTx,           (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_ALWAYS | DCM_TSK_ATR_THREAD_MULTI), DCM_TSK_PRIO_HIGH, DCM_TSK_EV_DIAG_TX_SEND_RCRRP, DCM_TSK_CONTEXT_ID_DIAG_TX},
#if (DCM_TSK_NUM_SVC2A_SCHEDULER > 0u)
  {Dcm_Svc2ATaskSchdProcess, (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_NEVER | DCM_TSK_ATR_THREAD_SINGLE), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE, DCM_TSK_CONTEXT_ID_SVC2A_SCHEDULER},/* let 0x2A work in the background if needed to be stopped -> the stop all API shall be used */
#endif
  {Dcm_NetTaskTx,            (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_NEVER | DCM_TSK_ATR_THREAD_SINGLE), DCM_TSK_PRIO_HIGH, DCM_TSK_EV_NONE, DCM_TSK_CONTEXT_ID_NET_TX}
  /* last to be processed */
};
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_19_SETDTCFILTER_INFO_CLASS_ENABLED == STD_ON)
/*! A set of all required DEM filter configurations */
#  if (DCM_DEM_API_421_ENABLED == STD_ON)
DCM_LOCAL CONST(Dcm_Svc19DemDtcFilterInfoType, DCM_CONST) Dcm_Svc19DemDtcFilterInfo[DCM_SVC_19_DEM_SETFILTER_NUM_CLASSES]=                           /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  {DEM_DTC_KIND_ALL_DTCS,           DEM_DTC_ORIGIN_PRIMARY_MEMORY,   DCM_DEM_FILTER_WITH_SEVERITY_NO}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_01: SF 0x01, 0x02, 0x14, 0x0A */
 ,{DEM_DTC_KIND_ALL_DTCS,           DEM_DTC_ORIGIN_PRIMARY_MEMORY,   DCM_DEM_FILTER_WITH_SEVERITY_YES} /* DCM_SVC_19_DEM_SETFILTER_CLASS_02: SF 0x07, 0x08 */
 ,{DEM_DTC_KIND_ALL_DTCS,           DEM_DTC_ORIGIN_MIRROR_MEMORY,    DCM_DEM_FILTER_WITH_SEVERITY_NO}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_03: SF 0x11, 0x0F */
 ,{DEM_DTC_KIND_EMISSION_REL_DTCS,  DEM_DTC_ORIGIN_PRIMARY_MEMORY,   DCM_DEM_FILTER_WITH_SEVERITY_NO}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_04: SF 0x12, 0x13 */
 ,{DEM_DTC_KIND_ALL_DTCS,           DEM_DTC_ORIGIN_PERMANENT_MEMORY, DCM_DEM_FILTER_WITH_SEVERITY_NO}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_05: SF 0x15, 0x55 */
 ,{DEM_DTC_KIND_ALL_DTCS,           DEM_DTC_ORIGIN_SECONDARY_MEMORY, DCM_DEM_FILTER_WITH_SEVERITY_NO}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_06: SF 0x17 */
 ,{DEM_DTC_KIND_EMISSION_REL_DTCS,  DEM_DTC_ORIGIN_PRIMARY_MEMORY,   DCM_DEM_FILTER_WITH_SEVERITY_YES} /* DCM_SVC_19_DEM_SETFILTER_CLASS_07: SF 0x42 */
};
#  else
DCM_LOCAL CONST(Dcm_Svc19DemDtcFilterInfoType, DCM_CONST) Dcm_Svc19DemDtcFilterInfo[DCM_SVC_19_DEM_SETFILTER_NUM_CLASSES]=                           /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  {DEM_DTC_ORIGIN_PRIMARY_MEMORY,      FALSE} /* DCM_SVC_19_DEM_SETFILTER_CLASS_01: SF 0x01, 0x02, 0x14, 0x0A */
 ,{DEM_DTC_ORIGIN_PRIMARY_MEMORY,      TRUE}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_02: SF 0x07, 0x08 */
 ,{DEM_DTC_ORIGIN_MIRROR_MEMORY,       FALSE} /* DCM_SVC_19_DEM_SETFILTER_CLASS_03: SF 0x11, 0x0F */
 ,{DEM_DTC_ORIGIN_OBD_RELEVANT_MEMORY, FALSE} /* DCM_SVC_19_DEM_SETFILTER_CLASS_04: SF 0x12, 0x13 */
 ,{DEM_DTC_ORIGIN_PERMANENT_MEMORY,    FALSE} /* DCM_SVC_19_DEM_SETFILTER_CLASS_05: SF 0x15, 0x55 */
#   if (DCM_DEM_API_431_ENABLED == STD_ON)
 ,{DCM_DEM_DTC_ORIGIN_USER_MEMORY,     FALSE} /* DCM_SVC_19_DEM_SETFILTER_CLASS_06: SF 0x17 */ /* 0x17: mem selection from request */
#   else
 ,{DEM_DTC_ORIGIN_SECONDARY_MEMORY,    FALSE} /* DCM_SVC_19_DEM_SETFILTER_CLASS_06: SF 0x17 */
#   endif
 ,{DEM_DTC_ORIGIN_OBD_RELEVANT_MEMORY, TRUE}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_07: SF 0x42 */
};
#  endif
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_OCCUR_TIME_ENABLED == STD_ON) || \
     (DCM_SVC_19_05_SUPPORT_ENABLED             == STD_ON)
/*! List of actions for acquiring DTC status and reporting it together with the DTC itself. This is also a termination activity chain triggering the final positive response */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19DemChainGetDtcStatusEnd[] =                                                            /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  DCM_SVC19_PROGRESS_DEMCHAIN_SELECT_DTC,
#  endif
  DCM_SVC19_PROGRESS_DEMCHAIN_GETSTATUSOFDTC
 ,DCM_SVC19_PROGRESS_CHAIN_END
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON)
/*! List of actions for freeze-frame data reporting prolog */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19DemChainReadFFRByDtc[] =                                                               /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  DCM_SVC19_PROGRESS_DEMCHAIN_SELECT_DTC,
#  endif
  DCM_SVC19_PROGRESS_DEMCHAIN_DISABLERECORDUPDATE
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETSTATUSOFDTC
#  if (DCM_DEM_API_SELECT_FFR_ENABLED == STD_ON)
 ,DCM_SVC19_PROGRESS_DEMCHAIN_SELECTFFREC
#  endif
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETSIZEOFFFREC
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
/*! List of actions for extended data reporting prolog */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19DemChainReadExtRecords[] =                                                             /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  DCM_SVC19_PROGRESS_DEMCHAIN_SELECT_DTC,
#  endif
  DCM_SVC19_PROGRESS_DEMCHAIN_DISABLERECORDUPDATE
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETSTATUSOFDTC
#  if (DCM_DEM_API_SELECT_EDR_ENABLED == STD_ON)
 ,DCM_SVC19_PROGRESS_DEMCHAIN_SELECTEXTDATAREC
#  endif
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETSIZEOFEXTDATAREC
};
# endif

# if (DCM_SVC_19_09_SUPPORT_ENABLED == STD_ON)
/*! List of actions for complete processing of SF 0x09 */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19_09DemChain[] =                                                                        /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  DCM_SVC19_PROGRESS_DEMCHAIN_SELECT_DTC,
#  endif
  DCM_SVC19_PROGRESS_DEMCHAIN_GETSEVERITYOFDTC
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETFUNCUNITOFDTC
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETSTATUSOFDTC
 ,DCM_SVC19_PROGRESS_CHAIN_END
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
/*! List of actions for complete processing of a SF reporting the number of filtered DTCs */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19DemChainDtcCount[2] =                                                                  /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC
 ,DCM_SVC19_PROGRESS_DEMCHAIN_PUTNUMFLTRDDTC
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON) || \
     (DCM_SVC_19_1A_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_19_55_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_19_56_SUPPORT_ENABLED == STD_ON)
/*! List of actions for complete processing of a SF reporting DTCs filtered by status mask */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19DemChainReadDtcByStatus[2] =                                                           /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
 DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC /* let this API to be called also in linear-buffer case in order to check for the last time if any DEM state error has occurred */
,DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDDTC
};
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/*! List of actions for complete processing of SF 0x08 */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19_08DemChain[2] =                                                                       /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDSEVERITY
};
# endif

# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/*! List of actions for complete processing of SF 0x14 */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19_14DemChain[2] =                                                                       /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDFDC
};
# endif
# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/*! List of actions for complete processing of SF 0x42 */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19_42DemChain[2] =                                                                       /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC /* let this API to be called also in linear-buffer case in order to check for the last time if any DEM state error has occurred */
 ,DCM_SVC19_PROGRESS_DEMCHAIN_WWHOBD_GETNEXTFLTRDSEVERITY
};
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CONST_UNSPECIFIED
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */

/**********************************************************************************************************************
 *  LOCAL FUNCTIONS
 *********************************************************************************************************************/
#define DCM_START_SEC_CODE
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferInitByThread()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferInitByThread(
  Dcm_ThreadIdOptType threadId
  )
{
  Dcm_ThreadContextPtrType pThreadContext = Dcm_GetThreadContext(threadId);

  pThreadContext->PagedBuffer.State = DCM_PAGEDBUFFER_STATE_INACTIVE;                                                                                /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferInit(
  void
  )
{
  Dcm_ThreadIdOptType lThreadIter;
  for(lThreadIter = 0; lThreadIter < DCM_NUM_THREADS; ++lThreadIter)
  {
    Dcm_PagedBufferInitByThread(lThreadIter);
  }
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferDefragmentPage()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferDefragmentPage(
  Dcm_ContextPtrType pContext                                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;
  Dcm_CfgNetBufferSizeOptType   lPageSize;

  lBufferInfo = Dcm_NetGetBufferInfo(pContext->Thread->PagedBuffer.BufferHdl);
  lPageSize = (Dcm_CfgNetBufferSizeOptType)(pContext->Thread->PagedBuffer.WriteIndex)
            - (Dcm_CfgNetBufferSizeOptType)(pContext->Thread->PagedBuffer.ReadIndex);

  Dcm_UtiMemCopySafe(&(lBufferInfo->BufferPtr[pContext->Thread->PagedBuffer.ReadIndex])
                    ,lBufferInfo->BufferPtr
                    ,0u
                    ,lBufferInfo->Size
                    ,(Dcm_MsgLenType)lPageSize);                                                                                                     /* SBSW_DCM_POINTER_WRITE_BUFFERINFO */

  /* Enter critical section (Reason: Protect against hi-priority task /ISR CopyTxData) */
  Dcm_UtiEnterCriticalSection();
  /* Update Read- and Write-Index */
  pContext->Thread->PagedBuffer.ReadIndex  = 0u;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
  pContext->Thread->PagedBuffer.WriteIndex = (Dcm_CfgNetBufferSizeMemType)lPageSize;                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
  /* Leave critical section */
  Dcm_UtiLeaveCriticalSection();
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferUpdatePage()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferUpdatePage(
  Dcm_ContextPtrType pContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                lStdResult;
  Dcm_DiagDataContextType       lDataContext;
  Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;
  uint8                         lUpdaterDataProvisionState;

  lBufferInfo = Dcm_NetGetBufferInfo(pContext->Thread->PagedBuffer.BufferHdl);

  Dcm_DebugAssert((pContext->Thread->PagedBuffer.State != DCM_PAGEDBUFFER_STATE_INACTIVE), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                   /* COV_DCM_RTM_DEV_DEBUG XF */

  /* If defragmentation needed: */
  if ((pContext->Thread->PagedBuffer.UpdaterDataProvisionState == DCM_PAGEDBUFFER_WAIT_FOR_DATA)
    &&(pContext->Thread->PagedBuffer.ReadIndex != 0u) )
  {
    Dcm_PagedBufferDefragmentPage(pContext);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* Derive new data context for the remaining data to be read */
  Dcm_UtiInitDataContext(&lDataContext, lBufferInfo->BufferPtr, lBufferInfo->Size);                                                                  /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */
  Dcm_UtiCommitData(&lDataContext, pContext->Thread->PagedBuffer.WriteIndex);                                                                        /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */

  /* Stronger limitation of the available buffer size - cut to the response length */
  if(lDataContext.AvailLen > pContext->Thread->PagedBuffer.RemainingLen)
  {
    Dcm_UtiDataContextSetAvailLen(&lDataContext, pContext->Thread->PagedBuffer.RemainingLen);                                                        /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */
  }

  /* Delegate to the page writer */
  lStdResult = Dcm_PagedBufferExecute(pContext, &lDataContext, ErrorCode);                                                                           /* SBSW_DCM_COMB_PTR_FORWARD */

  switch(lStdResult)
  {
    case DCM_E_OK:
    case DCM_E_NOT_OK:
      pContext->Thread->PagedBuffer.UpdateFinished = TRUE;                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_ALL_DATA_PROVIDED;
      break;
    case DCM_E_DATA_READY_PADDING:
      pContext->Thread->PagedBuffer.OpStatus = DCM_INITIAL;                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      /* Delegate to the padding writer */
      pContext->Thread->PagedBuffer.UpdateFuncRef = DCM_PAGEDBUFFER_PADDING_FUNC_REF;                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
      /* Application is done, now call the padding-bytes provider */
      pContext->Thread->PagedBuffer.UpdateFinished = TRUE;                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED;
      break;
    case DCM_E_PENDING:
      pContext->Thread->PagedBuffer.OpStatus = DCM_PENDING;                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      /* Data could also be written although DCM_E_PENDING was returned */
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED;
      break;
    case DCM_E_PENDING_LIMITER:
      /* Keep the last opStatus on "pending" forced by Dcm_PagedBufferExecute code */
      /* Data could also be written although DCM_E_PENDING was returned */
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED;
      lStdResult = DCM_E_PENDING;
      break;
    case DCM_E_BUFFERTOOLOW:
      pContext->Thread->PagedBuffer.OpStatus = DCM_PENDING;                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED;
      break;
    default:/* Unexpected return value */                                                                                                            /* COV_DCM_RTM_UNREACHABLE X */
      lStdResult = DCM_E_NOT_OK; /* Assure only valid values from here on */
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      pContext->Thread->PagedBuffer.UpdateFinished = TRUE;                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_ALL_DATA_PROVIDED;
      break;
  }

  if(lStdResult == DCM_E_NOT_OK)
  {
    if(pContext->Thread->PagedBuffer.State == DCM_PAGEDBUFFER_STATE_ACTIVATED)
    {
      /* Reset paged-buffer usage and delegate to the linear buffer processor */
      pContext->Thread->PagedBuffer.State = DCM_PAGEDBUFFER_STATE_CANCELED;                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      /* Wait for under-run transmission interruption (simulate successful update with zero data size) */
      lStdResult = DCM_E_OK;
    }
    pContext->Thread->PagedBuffer.UpdaterDataProvisionState = lUpdaterDataProvisionState;                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    /* Enter critical section (Reason: Protect against hi-priority task /ISR CopyTxData) */
    Dcm_UtiEnterCriticalSection();
    /* Update statistic */
    pContext->Thread->PagedBuffer.RemainingLen -= (Dcm_MsgLenType)(lDataContext.Usage - pContext->Thread->PagedBuffer.WriteIndex);                   /* SBSW_DCM_PARAM_PTR_WRITE */
    pContext->Thread->PagedBuffer.WriteIndex = (Dcm_CfgNetBufferSizeMemType)lDataContext.Usage;                                                      /* SBSW_DCM_PARAM_PTR_WRITE */

    /* Unlock CopyTx Data if more data is expected to be provided by a paged-buffer updater */
    pContext->Thread->PagedBuffer.UpdaterDataProvisionState = lUpdaterDataProvisionState;                                                            /* SBSW_DCM_PARAM_PTR_WRITE */

    /* Leave critical section */
    Dcm_UtiLeaveCriticalSection();

    /* If transmission not yet started and some data is already available for transmission: */
    if ((pContext->Thread->PagedBuffer.State == DCM_PAGEDBUFFER_STATE_ACTIVATED)
      && (lStdResult != DCM_E_PENDING))
    {
      /* Activate transmission */
      pContext->Thread->PagedBuffer.State = DCM_PAGEDBUFFER_STATE_ONTX;                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
      pContext->Thread->Diag.State |= DCM_DIAG_STATE_ON_TX; /* update diagnostic state (PROCESS && ON_TX) */                                         /* SBSW_DCM_PARAM_PTR_WRITE */
      Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_TX, DCM_TSK_EV_DIAG_TX_SEND_PAGED, pContext->Thread->ThreadId);
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL */
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCopyData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_PagedBufferCopyData(
  Dcm_NetTransportObjectPtrType pTranspObj,                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info,                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr                                                                                    /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  BufReq_ReturnType        lResult = BUFREQ_OK;
  Dcm_ThreadContextPtrType pThreadContext;

  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  pThreadContext = Dcm_GetThreadContext(Dcm_NetGetThreadIdOfTranspObj(pTranspObj));                                                                  /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */

  Dcm_DebugAssert((pThreadContext->PagedBuffer.State != DCM_PAGEDBUFFER_STATE_INACTIVE), DCM_SID_COPYTXDATA
                  ,DCM_E_ILLEGAL_STATE);                                                                                                             /* COV_DCM_RTM_DEV_DEBUG XF */

  *availableDataPtr = (PduLengthType)(pThreadContext->PagedBuffer.WriteIndex)
                                      - (PduLengthType)(pThreadContext->PagedBuffer.ReadIndex); /* Calculate and return page size */                 /* SBSW_DCM_PARAM_PTR_WRITE */

  if( (*availableDataPtr == 0u) /* no data at all */
    ||(*availableDataPtr < info->SduLength) ) /* real under-run */
  {
    if(info->SduLength != 0u)
    {
      lResult = BUFREQ_E_BUSY;
    }/* else - just buffer size check */

    if ((pThreadContext->PagedBuffer.UpdaterDataProvisionState == DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED)
      &&(pThreadContext->PagedBuffer.RemainingLen != 0u) )
    {
      pThreadContext->PagedBuffer.UpdaterDataProvisionState = DCM_PAGEDBUFFER_WAIT_FOR_DATA;                                                         /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
      Dcm_TskSetEventByThread(DCM_TSK_ID_PGDBUF, DCM_TSK_EV_PGDBUF_UPDATE_PAGE, Dcm_NetGetThreadIdOfTranspObj(pTranspObj));/* re-activate page updater */ /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */
    }/* else - still waiting for the data or all data provided */
  }
  else /* (lPageSize != 0u) && (lPageSize >= info->SduLength) => <check buffer availability> */
  {
    if ((pThreadContext->PagedBuffer.UpdaterDataProvisionState == DCM_PAGEDBUFFER_WAIT_FOR_DATA) /* still waiting for data OR data is currently being written */
      &&(pThreadContext->PagedBuffer.ReadIndex != 0u) /* with needed defragmentation */
      &&(info->SduLength != 0u) )/* no buffer availability check request */
    {
      lResult = BUFREQ_E_BUSY;/* avoid coping data during defragmentation of the paged-buffer (i.e. in case of adaptive CopyTxData call with reducing SduLength each time, or when SduLength == 0, and immediately called again with SduLength != 0 */
    }
    else
    {
      Dcm_PbCfgNetBufferInfoPtrType lBufferInfo = Dcm_NetGetBufferInfo(pThreadContext->PagedBuffer.BufferHdl);

      *availableDataPtr -= info->SduLength; /* Update remained data part */                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      /* Take the linear case always */
      Dcm_UtiMemCopySafe(&(lBufferInfo->BufferPtr[pThreadContext->PagedBuffer.ReadIndex])
                        ,info->SduDataPtr
                        ,0u
                        ,info->SduLength
                        ,info->SduLength);                                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      pThreadContext->PagedBuffer.ReadIndex += (Dcm_CfgNetBufferSizeMemType)(info->SduLength);                                                       /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
    }
  }

  return lResult;
}
#endif
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrInit(
  void
  )
{
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
  /* Set default ReturnControlToEcu values to 0xFF...FF */
  Dcm_UtiMemSetUintX(Dcm_DidMgrIoControlCemrSessionMask                                                                                              /* SBSW_DCM_POINTER_WRITE_IO_CTRL_CEMR_SESSION_MASK */
                    ,Dcm_MsgItemType
                    ,0xFFu
                    ,DCM_DIDMGR_IODID_MAX_EXT_CEMR_SIZE); /* DCM_DIDMGR_IODID_MAX_EXT_CEMR_SIZE will become 1 if IoControlCemrSessionMask not used */
# endif
}

/**********************************************************************************************************************
 *  Dcm_CfgDidMgrSignalOpClassInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgDidMgrSignalOpClassInfoGetEntry(
  Dcm_CfgDidMgrSignalOpClassRefOptType opInfoRef,
  CONSTP2VAR(Dcm_DidMgrSignalOpClassInfoPtrType, AUTOMATIC, AUTOMATIC) pSignalOpClassInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if(Dcm_DebugDetectRuntimeError(opInfoRef >= DCM_CFGDIDMGRSIGNALOPCLASSINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pSignalOpClassInfo = &Dcm_CfgDidMgrSignalOpClassInfo[opInfoRef];                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_CfgDidMgrDidOpClassInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_DidMgrDidOpClassInfoPtrType, DCM_CODE) Dcm_CfgDidMgrDidOpClassInfoGetEntry(
  Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef
  )
{
  Dcm_DidMgrDidOpClassInfoPtrType pOpClassInfo;

  if(Dcm_DebugDetectRuntimeError(opInfoRef >= DCM_CFGDIDMGRDIDOPCLASSINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    pOpClassInfo = &Dcm_CfgDidMgrDidOpClassInfo[0];
  }
  else
  {
    pOpClassInfo = &Dcm_CfgDidMgrDidOpClassInfo[opInfoRef];
  }

  return pOpClassInfo;
}

# if (DCM_DIDMGR_SR_IO_CONTROL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgDidMgrIoControlSenderReceiverHandlersGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_DidMgrIoCtrlSRHandlersPtrType, DCM_CODE) Dcm_CfgDidMgrIoControlSenderReceiverHandlersGetEntry(
  Dcm_CfgDidMgrIoCtrlSRHandlersRefOptType ioControlSRHandlerRef
  )
{
  Dcm_DidMgrIoCtrlSRHandlersPtrType pIoControlSrHandlers;

  if(Dcm_DebugDetectRuntimeError(ioControlSRHandlerRef >= DCM_CFGDIDMGR_IOCONTROLSENDERRECEIVERHANDLERS_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    pIoControlSrHandlers = &(Dcm_CfgDidMgr_IOControlSenderReceiverHandlers[0]);
  }
  else
  {
    pIoControlSrHandlers = &(Dcm_CfgDidMgr_IOControlSenderReceiverHandlers[ioControlSRHandlerRef]);
  }

  return pIoControlSrHandlers;
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrGetSignalLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetBufferSizeOptType, DCM_CODE) Dcm_DidMgrGetSignalLength(
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                                                                                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_CfgNetBufferSizeOptType        lSignalLength;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;
  Std_ReturnType                     lStdResult;
  Dcm_NegativeResponseCodeType       lNrc;

  lStdResult = Dcm_CfgDidMgrSignalOpClassInfoGetEntry(pDidOpTypeContext->Base.SignalOpClassInfoRef
                                                     ,&pSignalOpClassInfo
                                                     ,&lNrc);                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    /* If the signal has a variable length: */
    if(pSignalOpClassInfo->MinLength == 0u)
    {
      /* Calculate the length of the signal. A signal with variable length is always the last signal of the DID */
      lSignalLength = (Dcm_CfgNetBufferSizeOptType)(pDidInfoContext->DidLength)
                    - (Dcm_CfgNetBufferSizeOptType)(pDidOpTypeContext->OpType.Read.Progress);
    }
    else
    {
      /* Otherwise return the signal length */
      lSignalLength = (Dcm_CfgNetBufferSizeOptType)pSignalOpClassInfo->MinLength;
    }
  }
  else
  {
    lSignalLength = 0u;
  }

  return lSignalLength;
}
# endif

# if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrFilterDidRangeGap()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrFilterDidRangeGap(
  Dcm_OpStatusType opStatus,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  /* If the DID range supports gaps: */
  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext), DCM_DIDMGR_OPTYPE_RANGEISDIDAVAILABLE))
  {
    Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;
    Dcm_DidSupportedType               lIsAvailable = DCM_DID_NOT_SUPPORTED;
    Dcm_NegativeResponseCodeType       lNrc;

    /* Execute operation for evaluation gap match */
    Dcm_DidMgrInitOpClassInfo(pDidInfoContext, DCM_DIDMGR_OPTYPE_RANGEISDIDAVAILABLE);                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DidMgrInitOpTypeHandler(pDidInfoContext, pDidOpTypeContext);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdResult = Dcm_CfgDidMgrSignalOpClassInfoGetEntry(pDidOpTypeContext->Base.SignalOpClassInfoRef
                                                       ,&pSignalOpClassInfo
                                                       ,&lNrc);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)                                                                                                                       /* COV_DCM_RTM_RUNTIME_CHECK TX */
    {
      Dcm_DebugAssert(pSignalOpClassInfo->FuncClass == DCM_DIDMGR_OPCLS_ISDIDAVAILABLE
                     ,DCM_SID_INTERNAL
                     ,DCM_E_ILLEGAL_STATE);

      lStdResult = ((Dcm_DidMgrOpFuncRangeIsAvailDidType)pSignalOpClassInfo->OpFunc)(pDidInfoContext->Did                                            /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,opStatus
                                                                                    ,&lIsAvailable);                                                 /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_PARAM_PTR_FORWARD */

      /* If operation needs more time (DCM_E_PENDING) or acknowledges that the DID is still valid: */
      if( ( (lStdResult == DCM_E_OK)
          &&(lIsAvailable == DCM_DID_SUPPORTED) )
        ||(lStdResult == DCM_E_PENDING) )
      {
        /* Return the current/final result: DCM_E_PENDING, DCM_E_OK */
      }
      else
      {
        /* Otherwise: notify caller for range DID match but still DID invalid since in a gap */
        lStdResult = DCM_E_LOOKUP_MATCH_FOUND;
      }
    }
  }
  /* Otherwise: all DIDs within that range are valid: return DCM_E_OK */
  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrDidRangeLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrDidRangeLookUp(
  Dcm_OpStatusType opStatus,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,                                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrOpOptType didOp
  )
{
  Std_ReturnType lStdReturn;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                         /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
  lStdReturn = DCM_E_OK;

  if(opStatus == DCM_INITIAL)
# endif
  {
    sint16_least lResult;

    lStdReturn = DCM_E_NOT_OK;

    /* Try finding a range that encloses this DID */
    lResult = Dcm_UtiLookUpRangeUint16(Dcm_CfgDidMgrDidRanges, pDidInfoContext->Did);                                                                /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
    /* If a match found:  */
    if(lResult >= 0)
    {
      Dcm_DidMgrDidInfoPtrType pDidInfo = &(Dcm_CfgDidMgrDidInfo[Dcm_CfgDidMgrRangeDidInfoRefs[lResult]]);

      /* If the matched range supports the requested DID operation: */
      if(Dcm_DidMgrIsOpSupported(pDidInfo, didOp))
      {
        /* Prepare for positive final result; initialize DID context */
        pDidInfoContext->Descriptor.DidInfoIdx = Dcm_CfgDidMgrRangeDidInfoRefs[lResult];                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
        /* Set DID length. Later the concrete length will be stored here. Take the maximum length! */
        pDidInfoContext->DidLength = (Dcm_DidMgrDidLengthType)pDidInfo->MaxLength;                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
        pDidInfoContext->ReservedLength = (Dcm_DidMgrDidLengthType)pDidInfo->ReservedLength;                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
        /* Store DID operation information */
        Dcm_DidMgrInitOpInfo(pDidInfoContext, didOp);                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

        lStdReturn = DCM_E_OK;
      }
      /* Otherwise: Operation not supported -> DID not supported in context of the requested operation */
    }
  }
  /* Otherwise: keep current result: DCM_E_OK */

# if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
  /* If DID match found: */
  if(lStdReturn == DCM_E_OK)
  {
    /* Process potentially available DID range gaps, resp. re-call any pending operation */
    lStdReturn = Dcm_DidMgrFilterDidRangeGap(opStatus, pDidInfoContext, pDidOpTypeContext);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  /* Otherwise: return final result: DCM_E_NOT_OK, DCM_E_PENDING */
# endif

  return lStdReturn;
}

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON) && \
     (DCM_DIDMGR_RTE_IMPLICIT_COM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetRequiredSignalBufSize()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetBufferSizeOptType, DCM_CODE) Dcm_DidMgrGetRequiredSignalBufSize(
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                                                                                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_CfgNetBufferSizeOptType        lSignalLength;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;
  Std_ReturnType                     lStdResult;
  Dcm_NegativeResponseCodeType       lNrc;

  DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                           /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_CfgDidMgrSignalOpClassInfoGetEntry(pDidOpTypeContext->Base.SignalOpClassInfoRef
                                                     ,&pSignalOpClassInfo
                                                     ,&lNrc);                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    /* If the signal is part of a paged DID (Note: OpClass needs to be set -> precondition) */
    if (pSignalOpClassInfo->FuncClass == DCM_DIDMGR_OPCLS_READ_PAGED)
    {
      /* Return size of dedicated read buffer as it determines the page size */
      lSignalLength = (Dcm_CfgNetBufferSizeOptType)DCM_DIDMGR_READ_PAGE_SIZE;
    }
    else /* Signal cannot be part of a DynDID because DynDIDs are not allowed when paged buffer is enabled */
    {
      /* Return the maximal signal length */
      lSignalLength = (Dcm_CfgNetBufferSizeOptType)pSignalOpClassInfo->MaxLength;
    }
  }
  else
  {
    lSignalLength = (Dcm_CfgNetBufferSizeOptType)Dcm_UtiMaxValueOfUintType(Dcm_CfgNetBufferSizeMemType);
  }

  return lSignalLength;
}
# endif

# if (DCM_DIDMGR_OPTYPE_GETSCALINGINFO_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetScalingInfoSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetScalingInfoSignal(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,                                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  lStdResult = Dcm_CfgDidMgrSignalOpClassInfoGetEntry(pDidOpTypeContext->Base.SignalOpClassInfoRef
                                                     ,&pSignalOpClassInfo
                                                     ,ErrorCode);                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = Dcm_UtiMsgContextVerifySize(pMsgContext, pSignalOpClassInfo->MaxLength, ErrorCode);                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)                                                                                                                       /* COV_DCM_RTM_RUNTIME_CHECK TX */
    {
      switch(pSignalOpClassInfo->FuncClass)
      {
      case DCM_DIDMGR_OPCLS_GETSCALING_SYNC:
        DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                            /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
        lStdResult = ((Dcm_DidMgrOpFuncGetScalingInfoSyncType)pSignalOpClassInfo->OpFunc)(Dcm_UtiGetResData(pMsgContext)                             /* PRQA S 0313 */ /* MD_Dcm_0313 */ /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                                         ,ErrorCode);                                                /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_COMB_PTR_FORWARD */
        break;
      case DCM_DIDMGR_OPCLS_GETSCALING_ASYNC:
        lStdResult = ((Dcm_DidMgrOpFuncGetScalingInfoAsyncType)pSignalOpClassInfo->OpFunc)(opStatus                                                  /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                          ,Dcm_UtiGetResData(pMsgContext)                            /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                                          ,ErrorCode);                                               /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_COMB_PTR_FORWARD */
        break;
      default:
        DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                            /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
        DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                         /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
        DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                     /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG);                                                                                /* COV_DCM_RTM_DEV_DEBUG XF */
        break;
      }

      if(opStatus == DCM_CANCEL)
      {
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }

      if (lStdResult == DCM_E_OK)
      {
        Dcm_UtiProvideResData(pMsgContext, pSignalOpClassInfo->MaxLength);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      } /* Catch any RTE or unexpected specific errors */
      else if( (lStdResult != DCM_E_NOT_OK)
             &&(lStdResult != DCM_E_PENDING)
        )
      {
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
      else
      {
        /* Do nothing */
      }
    }
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_GETSCALINGINFO_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetScalingInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetScalingInfo(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,                                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  Dcm_OpStatusType lOpStatus = opStatus;

  if (lOpStatus == DCM_INITIAL)
  {
    /* Initialize DID handler */
    Dcm_DidMgrInitOpTypeHandler(pDidInfoContext, pDidOpTypeContext);                                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
  }

  do
  {
    lStdResult = Dcm_DidMgrGetScalingInfoSignal(lOpStatus
                                               ,pMsgContext
                                               ,pDidInfoContext
                                               ,pDidOpTypeContext
                                               ,ErrorCode);                                                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    if(lStdResult == DCM_E_OK)
    {
      pDidOpTypeContext->Base.NumSignals--;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */

      if(pDidOpTypeContext->Base.NumSignals == 0u)
      {
        break;
      }

      /* Go on with next signal */
      pDidOpTypeContext->Base.SignalOpClassInfoRef++;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
      lOpStatus = DCM_INITIAL; /* reset op status */
    }
  }
  while(lStdResult == DCM_E_OK);

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWriteAtomicSRResultInterpreter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrWriteAtomicSRResultInterpreter(
  Std_ReturnType rteResult,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  switch(rteResult)
  {
  case RTE_E_OK:
    /* switch accomplished */
    lStdResult = DCM_E_OK;
    break;
  case RTE_E_INVALID:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_GENERALPROGRAMMINGFAILURE;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  case RTE_E_HARD_TRANSFORMER_ERROR:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default: /* any error situation */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWriteSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrWriteSignal(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,                                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  lStdResult = Dcm_CfgDidMgrSignalOpClassInfoGetEntry(pDidOpTypeContext->Base.SignalOpClassInfoRef
                                                     ,&pSignalOpClassInfo
                                                     ,ErrorCode);                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    switch(pSignalOpClassInfo->FuncClass)
    {
    case DCM_DIDMGR_OPCLS_WRITE_RANGE:
      lStdResult = ((Dcm_DidMgrOpFuncWriteDidRangeType)pSignalOpClassInfo->OpFunc)(pDidInfoContext->Did                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                       ,Dcm_UtiGetReqData(pMsgContext)
                                                                       ,opStatus
                                                                       ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                       ,ErrorCode);                                                                  /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_COMB_PTR_FORWARD */
      break;

    case DCM_DIDMGR_OPCLS_WRITE_LEN_SYNC_NRES_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncWriteLenSyncNResErrorType)pSignalOpClassInfo->OpFunc)(                                                          /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                        Dcm_UtiGetReqData(pMsgContext)
                                                                       ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                       ,ErrorCode);                                                                  /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_COMB_PTR_FORWARD */
      break;

    case DCM_DIDMGR_OPCLS_WRITE_LEN_ASYNC_NRES_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncWriteLenAsyncNResErrorType)pSignalOpClassInfo->OpFunc)(                                                         /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                        Dcm_UtiGetReqData(pMsgContext)
                                                                       ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                       ,opStatus
                                                                       ,ErrorCode);                                                                  /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_COMB_PTR_FORWARD */
      break;

    case DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncWriteNLenSyncNResErrorType)pSignalOpClassInfo->OpFunc)(                                                         /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                         Dcm_UtiGetReqData(pMsgContext)
                                                                                        ,ErrorCode);                                                 /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_COMB_PTR_FORWARD */
      break;

    case DCM_DIDMGR_OPCLS_WRITE_NLEN_ASYNC_NRES_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncWriteNLenAsyncNResErrorType)pSignalOpClassInfo->OpFunc)(                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                         Dcm_UtiGetReqData(pMsgContext)
                                                                                        ,opStatus
                                                                                        ,ErrorCode);                                                 /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_COMB_PTR_FORWARD */
      break;
    case DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_NERROR:
      lStdResult = ((Dcm_DidMgrOpFuncWriteNLenSyncNResNErrorType)pSignalOpClassInfo->OpFunc)(                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_COMB_PTR_FORWARD */
                                                                                       Dcm_UtiGetReqData(pMsgContext));

      lStdResult = Dcm_DidMgrWriteAtomicSRResultInterpreter(lStdResult, ErrorCode);                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
    case DCM_DIDMGR_OPCLS_WRITE_GAP:
      /* Just a gap, do nothing */
      lStdResult = DCM_E_OK;
      break;

    default:
      DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                              /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
      DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                           /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
      DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                       /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
      DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                     /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG);                                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */
      break;
    }

    if(opStatus == DCM_CANCEL)
    {
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }

    if(lStdResult == DCM_E_OK)
    {
      /* Consuming request data is not necessary for the last signal. */
      if(pSignalOpClassInfo->MinLength != 0u)
      {
        Dcm_UtiConsumeReqData(pMsgContext, pSignalOpClassInfo->MaxLength);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
    }

    /* Catch any RTE or unexpected specific errors */
    if( (lStdResult != DCM_E_OK)
      &&(lStdResult != DCM_E_PENDING)
      &&(lStdResult != DCM_E_NOT_OK)
      )
    {
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030 */ /* MD_MSR_STPTH, MD_MSR_STCYC */
# endif

# if (DCM_DIDMGR_OPTYPE_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWrite()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrWrite(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;
  Dcm_OpStatusType lOpStatus = opStatus;

  if (lOpStatus == DCM_INITIAL)
  {
    /* Initialize DID handler */
    Dcm_DidMgrInitOpTypeHandler(pDidInfoContext, pDidOpTypeContext);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  do
  {
    lStdResult = Dcm_DidMgrWriteSignal(lOpStatus
                                      ,pMsgContext
                                      ,pDidInfoContext
                                      ,pDidOpTypeContext
                                      ,ErrorCode);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    if(lStdResult == DCM_E_OK)
    {
      pDidOpTypeContext->Base.NumSignals--;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */

      if(pDidOpTypeContext->Base.NumSignals == 0u)
      {
        break;
      }

      /* Go on with next signal */
      pDidOpTypeContext->Base.SignalOpClassInfoRef++;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
      lOpStatus = DCM_INITIAL; /* reset op status */
    }
  }
  while(lStdResult == DCM_E_OK);

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlRtrnCtrl2EcuSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrIoControlRtrnCtrl2EcuSignal(
  Dcm_CfgDidMgrSignalOpClassRefOptType opInfoRef
  )
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;
  Dcm_NegativeResponseCodeType       lNrc;

  lStdResult = Dcm_CfgDidMgrSignalOpClassInfoGetEntry(opInfoRef
                                                     ,&pSignalOpClassInfo
                                                     ,&lNrc);                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    switch(pSignalOpClassInfo->FuncClass)
    {
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_NCEMR_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncNCemrErrorType)pSignalOpClassInfo->OpFunc)(                                                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                      &lNrc);                                                        /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_NCEMR_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncNCemrErrorType)pSignalOpClassInfo->OpFunc)(DCM_INITIAL                                           /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                      ,&lNrc);                                                       /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;

    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR8_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr8ErrorType)pSignalOpClassInfo->OpFunc)(0xFFu                                                  /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                     ,&lNrc);                                                        /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR8_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr8ErrorType)pSignalOpClassInfo->OpFunc)(DCM_INITIAL                                           /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                      ,0xFFu
                                                                                      ,&lNrc);                                                       /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR16_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr16ErrorType)pSignalOpClassInfo->OpFunc)(0xFFFFu                                               /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                      ,&lNrc);                                                       /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR16_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr16ErrorType)pSignalOpClassInfo->OpFunc)(DCM_INITIAL                                          /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                       ,0xFFFFu
                                                                                       ,&lNrc);                                                      /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR32_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr32ErrorType)pSignalOpClassInfo->OpFunc)(0xFFFFFFFFUL                                          /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                      ,&lNrc);                                                       /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR32_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr32ErrorType)pSignalOpClassInfo->OpFunc)(DCM_INITIAL                                          /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                       ,0xFFFFFFFFUL
                                                                                       ,&lNrc);                                                      /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;

    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMRN_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemrNErrorType)pSignalOpClassInfo->OpFunc)(                                                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                     Dcm_DidMgrIoControlCemrSessionMask
                                                                    ,&lNrc);                                                                         /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMRN_ERROR:
      lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemrNErrorType)pSignalOpClassInfo->OpFunc)(DCM_INITIAL                                           /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                    ,Dcm_DidMgrIoControlCemrSessionMask
                                                                    ,&lNrc);                                                                         /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;

    case DCM_DIDMGR_OPCLS_IO_GAP:
      /* Just a gap, do nothing */
      lStdResult = DCM_E_OK;
      break;
    default:
      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG);                                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */
      break;
    }
    Dcm_DebugAssert(lStdResult != DCM_E_PENDING, DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);

    /*
    No need to handle application NRC since not used!
    Dcm_UtiHandleApplNrc(lStdResult, &lNrc, DCM_E_CONDITIONSNOTCORRECT);
    */
  }
  DCM_IGNORE_UNREF_PARAM(lStdResult);                                                                                                                /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
}                                                                                                                                                    /* PRQA S 6030 */ /* MD_MSR_STCYC */
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlRtrnCtrl2Ecu()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrIoControlRtrnCtrl2Ecu(
  Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef
  )
{
  Dcm_CfgDidMgrSignalOpClassRefOptType lSignalIter;

  for(lSignalIter = Dcm_CfgDidMgrDidOpClassInfoGetEntry(opInfoRef + 0u)->OpClassRef;                                                                 /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */
      lSignalIter < Dcm_CfgDidMgrDidOpClassInfoGetEntry(opInfoRef + 1u)->OpClassRef;
      ++lSignalIter)
  {
    Dcm_DidMgrIoControlRtrnCtrl2EcuSignal(lSignalIter);
  }
}
# endif

# if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControlSignal(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,                                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  lStdResult = Dcm_CfgDidMgrSignalOpClassInfoGetEntry(pDidOpTypeContext->Base.SignalOpClassInfoRef
                                                     ,&pSignalOpClassInfo
                                                     ,ErrorCode);                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = Dcm_UtiMsgContextVerifySize(pMsgContext, pSignalOpClassInfo->MaxLength, ErrorCode);                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)                                                                                                                       /* COV_DCM_RTM_RUNTIME_CHECK TX */
    {
      switch(pSignalOpClassInfo->FuncClass)
      {
    /* No CEMR */
      case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_NCEMR_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncNCemrErrorType)pSignalOpClassInfo->OpFunc)(ErrorCode);                                          /* PRQA S 0313 */ /* MD_Dcm_0313 */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_NCEMR_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncNCemrErrorType)pSignalOpClassInfo->OpFunc)(opStatus                                            /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                                ,ErrorCode);                                         /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_NCEMR_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenSyncNCemrErrorType)pSignalOpClassInfo->OpFunc)(                                                      /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                           Dcm_UtiGetReqData(pMsgContext)
                                                                                          ,ErrorCode);                                               /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_NCEMR_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncNCemrErrorType)pSignalOpClassInfo->OpFunc)(                                                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                          Dcm_UtiGetReqData(pMsgContext)
                                                                         ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                         ,ErrorCode);                                                                /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_NCEMR_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenASyncNCemrErrorType)pSignalOpClassInfo->OpFunc)(                                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                           Dcm_UtiGetReqData(pMsgContext)
                                                                                          ,opStatus
                                                                                          ,ErrorCode);                                               /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_NCEMR_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoReqLenASyncNCemrErrorType)pSignalOpClassInfo->OpFunc)(                                                      /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                          Dcm_UtiGetReqData(pMsgContext)
                                                                         ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                         ,opStatus
                                                                         ,ErrorCode);                                                                /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;

    /* CEMR 8Bit */
      case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR8_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr8ErrorType)pSignalOpClassInfo->OpFunc)(                                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                               (uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                              ,ErrorCode);                                                                           /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR8_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr8ErrorType)pSignalOpClassInfo->OpFunc)(opStatus                                            /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                              ,(uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                              ,ErrorCode);                                                                           /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR8_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenSyncCemr8ErrorType)pSignalOpClassInfo->OpFunc)(Dcm_UtiGetReqData(pMsgContext)                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                              ,(uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                              ,ErrorCode);                                                                           /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR8_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncCemr8ErrorType)pSignalOpClassInfo->OpFunc)(Dcm_UtiGetReqData(pMsgContext)                         /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                              ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                              ,(uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                              ,ErrorCode);                                                                           /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR8_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenASyncCemr8ErrorType)pSignalOpClassInfo->OpFunc)(Dcm_UtiGetReqData(pMsgContext)                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                              ,opStatus
                                                              ,(uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                              ,ErrorCode);                                                                           /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR8_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoReqLenASyncCemr8ErrorType)pSignalOpClassInfo->OpFunc)(Dcm_UtiGetReqData(pMsgContext)                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                              ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                              ,opStatus
                                                              ,(uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                              ,ErrorCode);                                                                           /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;

    /* CEMR 16Bit */
      case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR16_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr16ErrorType)pSignalOpClassInfo->OpFunc)(                                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                              (uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                             ,ErrorCode);                                                                            /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR16_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr16ErrorType)pSignalOpClassInfo->OpFunc)(opStatus                                           /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                             ,(uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                             ,ErrorCode);                                                                            /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR16_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenSyncCemr16ErrorType)pSignalOpClassInfo->OpFunc)(Dcm_UtiGetReqData(pMsgContext)                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                             ,(uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                             ,ErrorCode);                                                                            /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR16_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncCemr16ErrorType)pSignalOpClassInfo->OpFunc)(                                                      /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                              Dcm_UtiGetReqData(pMsgContext)
                                                             ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                             ,(uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                             ,ErrorCode);                                                                            /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR16_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenASyncCemr16ErrorType)pSignalOpClassInfo->OpFunc)(                                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                              Dcm_UtiGetReqData(pMsgContext)
                                                             ,opStatus
                                                             ,(uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                             ,ErrorCode);                                                                            /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR16_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoReqLenASyncCemr16ErrorType)pSignalOpClassInfo->OpFunc)(                                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                              Dcm_UtiGetReqData(pMsgContext)
                                                             ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                             ,opStatus
                                                             ,(uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                             ,ErrorCode);                                                                            /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;

    /* CEMR 32Bit */
      case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR32_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr32ErrorType)pSignalOpClassInfo->OpFunc)(                                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                      pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                     ,ErrorCode);                                                                    /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR32_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr32ErrorType)pSignalOpClassInfo->OpFunc)(opStatus                                           /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                     ,pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                     ,ErrorCode);                                                                    /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR32_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenSyncCemr32ErrorType)pSignalOpClassInfo->OpFunc)(                                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                      Dcm_UtiGetReqData(pMsgContext)
                                                                     ,pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                     ,ErrorCode);                                                                    /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR32_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncCemr32ErrorType)pSignalOpClassInfo->OpFunc)(                                                      /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                      Dcm_UtiGetReqData(pMsgContext)
                                                                     ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                     ,pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                     ,ErrorCode);                                                                    /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR32_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenASyncCemr32ErrorType)pSignalOpClassInfo->OpFunc)(                                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                      Dcm_UtiGetReqData(pMsgContext)
                                                                     ,opStatus
                                                                     ,pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                     ,ErrorCode);                                                                    /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR32_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoReqLenASyncCemr32ErrorType)pSignalOpClassInfo->OpFunc)(                                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                      Dcm_UtiGetReqData(pMsgContext)
                                                                     ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                     ,opStatus
                                                                     ,pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                     ,ErrorCode);                                                                    /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;

    /* CEMR NBit */
      case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMRN_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemrNErrorType)pSignalOpClassInfo->OpFunc)(                                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                               ,ErrorCode);                                                          /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMRN_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemrNErrorType)pSignalOpClassInfo->OpFunc)(opStatus                                            /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                               ,pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                               ,ErrorCode);                                                          /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMRN_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenSyncCemrNErrorType)pSignalOpClassInfo->OpFunc)(                                                      /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                Dcm_UtiGetReqData(pMsgContext)
                                                                               ,pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                               ,ErrorCode);                                                          /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMRN_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncCemrNErrorType)pSignalOpClassInfo->OpFunc)(                                                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                          Dcm_UtiGetReqData(pMsgContext)
                                                                         ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                         ,pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                         ,ErrorCode);                                                                /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMRN_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenASyncCemrNErrorType)pSignalOpClassInfo->OpFunc)(                                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                Dcm_UtiGetReqData(pMsgContext)
                                                                               ,opStatus
                                                                               ,pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                               ,ErrorCode);                                                          /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMRN_ERROR:
        lStdResult = ((Dcm_DidMgrOpFuncIoReqLenASyncCemrNErrorType)pSignalOpClassInfo->OpFunc)(                                                      /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                          Dcm_UtiGetReqData(pMsgContext)
                                                                         ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                         ,opStatus
                                                                         ,pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                         ,ErrorCode);                                                                /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
        break;
      case DCM_DIDMGR_OPCLS_IO_GAP:
        /* Just a gap, do nothing */
        lStdResult = DCM_E_OK;
        break;
      default:
        DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                            /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
        DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                         /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
        DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                     /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
        DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                   /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG);                                                                                /* COV_DCM_RTM_DEV_DEBUG XF */
        break;
      }

      if(opStatus == DCM_CANCEL)
      {
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }

      if(lStdResult == DCM_E_OK)
      {
        /* Consuming request data is not necessary for the dynamic signal because it is the last signal */
        if(pSignalOpClassInfo->MinLength != 0u)
        {
          Dcm_UtiConsumeReqData(pMsgContext, pSignalOpClassInfo->MaxLength);                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
      }

      /* Catch any RTE or unexpected specific errors */
      if( (lStdResult != DCM_E_OK)
        &&(lStdResult != DCM_E_PENDING)
        &&(lStdResult != DCM_E_NOT_OK)
        )
      {
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }

      Dcm_UtiHandleApplNrc(lStdResult, ErrorCode, DCM_E_CONDITIONSNOTCORRECT);                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030 */ /* MD_MSR_STPTH, MD_MSR_STCYC */
# endif

# if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControl(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,                                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  Dcm_OpStatusType lOpStatus = opStatus;

  if (lOpStatus == DCM_INITIAL)
  {
    /* Initialize DID handler */
    Dcm_DidMgrInitOpTypeHandler(pDidInfoContext, pDidOpTypeContext);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(Dcm_DidMgrGetCtrlEnblMaskHandling(Dcm_CfgDidMgrGetDidInfo(pDidInfoContext)) == DCM_DIDMGR_IO_CEMR_HANDLING_INTERNAL)
  {
    lStdResult = Dcm_DidMgrIoControlWithMask(lOpStatus, pMsgContext, pDidInfoContext, pDidOpTypeContext, ErrorCode);                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    while(pDidOpTypeContext->Base.NumSignals != 0u)
    {
      lStdResult = Dcm_DidMgrIoControlSignal(lOpStatus
                                            ,pMsgContext
                                            ,pDidInfoContext
                                            ,pDidOpTypeContext
                                            ,ErrorCode);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
      if(lStdResult != DCM_E_OK)
      {
        /* on pending or not OK -> just leave */
        break;
      }

      pDidOpTypeContext->Base.NumSignals--;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      if(pDidOpTypeContext->Base.NumSignals != 0u)
      {
        /* Go on with next signal */
        pDidOpTypeContext->Base.SignalOpClassInfoRef++;                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      lOpStatus = DCM_INITIAL; /* reset op status */
    }
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlWithMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControlWithMask(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;
  Dcm_OpStatusType lOpStatus = opStatus;

  if (lOpStatus == DCM_INITIAL)
  {
    /* DID handler is already initialized in Dcm_DidMgrIoControl() */
    pDidOpTypeContext->OpType.Io.OperExecuted= FALSE;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    pDidOpTypeContext->OpType.Io.SignalIter  = 0u;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    pDidOpTypeContext->OpType.Io.BitScanner  = 0x80u;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  DCM_UTI_LOOP_FOR_EVER                                                                                                                              /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  {
    if(Dcm_UtiBitOpTest(Dcm_MsgItemType
                       ,pDidOpTypeContext->OpType.Io.EnableMaskPtr[0]
                       ,pDidOpTypeContext->OpType.Io.BitScanner))
    {
      pDidOpTypeContext->OpType.Io.OperExecuted = TRUE;                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */

      lStdResult = Dcm_DidMgrIoControlSignal(lOpStatus
                                            ,pMsgContext
                                            ,pDidInfoContext
                                            ,pDidOpTypeContext
                                            ,ErrorCode);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

      if(lStdResult != DCM_E_OK)
      {
        break;
      }
    }
    else
    {
      /* signal not allowed -> skip */
      Dcm_UtiConsumeReqData(pMsgContext
                           ,Dcm_CfgDidMgrSignalOpClassInfo[pDidOpTypeContext->Base.SignalOpClassInfoRef].MaxLength);                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    }

    pDidOpTypeContext->OpType.Io.SignalIter++;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    if(pDidOpTypeContext->OpType.Io.SignalIter >= pDidOpTypeContext->Base.NumSignals)
    {
      break;
    }

    /* next signal */
    /* Gaps are not considered as signals by control enable mask, so skip them here */
    if(Dcm_CfgDidMgrSignalOpClassInfo[pDidOpTypeContext->Base.SignalOpClassInfoRef].FuncClass != DCM_DIDMGR_OPCLS_IO_GAP)
    {
      pDidOpTypeContext->OpType.Io.BitScanner >>= 1;                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
      if(pDidOpTypeContext->OpType.Io.BitScanner == 0u)
      {
        pDidOpTypeContext->OpType.Io.BitScanner = 0x80u;                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
        Dcm_UtiNextItemByPtr(pDidOpTypeContext->OpType.Io.EnableMaskPtr,1);                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      }
    }

    /* Go on with next signal */
    pDidOpTypeContext->Base.SignalOpClassInfoRef++;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    lOpStatus = DCM_INITIAL;/* reset op status */
  }

  if(pDidOpTypeContext->OpType.Io.OperExecuted == FALSE)
  {
    /* the enable mask record did not enable any signal */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010 */ /* MD_MSR_STPTH */
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalRange()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalRange(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,                                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;
  Dcm_DidMgrDidLengthType            lResLength = 0u; /* Set just in case not set by application */

  lStdResult = Dcm_CfgDidMgrSignalOpClassInfoGetEntry(pDidOpTypeContext->Base.SignalOpClassInfoRef
                                                     ,&pSignalOpClassInfo
                                                     ,ErrorCode);                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = Dcm_UtiDataContextVerifySize(pDataContext, pSignalOpClassInfo->MaxLength, ErrorCode);                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)                                                                                                                       /* COV_DCM_RTM_RUNTIME_CHECK TX */
    {
      /* Call the appropriate application callback for that DID range signal */
      lStdResult = ((Dcm_DidMgrOpFuncReadDidRangeType)pSignalOpClassInfo->OpFunc)(pDidInfoContext->Did                                               /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                               ,Dcm_UtiGetDataContextBuffer(pDataContext)
                                                                               ,opStatus
                                                                               ,&lResLength
                                                                               ,ErrorCode);                                                          /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_COMB_PTR_FORWARD */

      if(lStdResult == DCM_E_OK)
      {
        /* Update final response length only in positive/final case */
        if(Dcm_DebugDetectError(lResLength > pDidInfoContext->DidLength))
        {
          lStdResult = DCM_E_NOT_OK;
          *ErrorCode = DCM_E_PANIC_NRC;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
          Dcm_DebugReportError(DCM_SID_SVCPORT_DATASVCS_OP_READDIDRANGE, DCM_E_INTERFACE_BUFFER_OVERFLOW);
        }
        else
        {
          pDidInfoContext->DidLength = lResLength;/* update current DID length */                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */

          Dcm_UtiCommitData(pDataContext, lResLength);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
      }
    }
  }

  return lStdResult;
}

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalAsync()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalAsync(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  lStdResult = Dcm_CfgDidMgrSignalOpClassInfoGetEntry(pDidOpTypeContext->Base.SignalOpClassInfoRef
                                                     ,&pSignalOpClassInfo
                                                     ,ErrorCode);                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = Dcm_UtiDataContextVerifySize(pDataContext, pSignalOpClassInfo->MaxLength, ErrorCode);                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)                                                                                                                       /* COV_DCM_RTM_RUNTIME_CHECK TX */
    {
      /* Call the appropriate application callback for that asynchronous signal */
      lStdResult = ((Dcm_DidMgrOpFuncReadAsyncType)pSignalOpClassInfo->OpFunc)(opStatus                                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                             ,Dcm_UtiGetDataContextBuffer(pDataContext));                            /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */

      if(lStdResult == DCM_E_OK)
      {
        Dcm_CfgNetBufferSizeOptType lSignalLen;

        /* Update the remaining available length */
        lSignalLen = Dcm_DidMgrGetSignalLength(pDidInfoContext, pDidOpTypeContext);                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_UtiCommitData(pDataContext, (Dcm_MsgLenType)lSignalLen);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      else if(lStdResult == DCM_E_NOT_OK)
      {
        /* Handle NRC here since no NRC can be passed by the application on this interface */
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      else
      {
        /* Nothing to do */
      }
    }
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalSync()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalSync(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_CfgDidMgrSignalOpClassInfoGetEntry(pDidOpTypeContext->Base.SignalOpClassInfoRef
                                                     ,&pSignalOpClassInfo
                                                     ,ErrorCode);                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = Dcm_UtiDataContextVerifySize(pDataContext, pSignalOpClassInfo->MaxLength, ErrorCode);                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)                                                                                                                       /* COV_DCM_RTM_RUNTIME_CHECK TX */
    {
      /* Call the appropriate application callback for that synchronous signal */
      lStdResult = ((Dcm_DidMgrOpFuncReadSyncType)pSignalOpClassInfo->OpFunc)(Dcm_UtiGetDataContextBuffer(pDataContext));                            /* PRQA S 0313 */ /* MD_Dcm_0313 */ /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */

      if(lStdResult == DCM_E_OK)
      {
        Dcm_CfgNetBufferSizeOptType lSignalLen;

        /* Update the remaining available length */
        lSignalLen = Dcm_DidMgrGetSignalLength(pDidInfoContext, pDidOpTypeContext);                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_UtiCommitData(pDataContext, (Dcm_MsgLenType)lSignalLen);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      else
      {
        /* Handle NRC here since no NRC can be passed by the application through this interface */
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalPaged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalPaged(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,                                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrDidLengthType            lTmpAvailLen;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;
#  if (DCM_DIDMGR_RTE_IMPLICIT_COM_ENABLED == STD_ON)                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  boolean                            lLoopPossible;
#  endif

  DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                           /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_CfgDidMgrSignalOpClassInfoGetEntry(pDidOpTypeContext->Base.SignalOpClassInfoRef
                                                     ,&pSignalOpClassInfo
                                                     ,ErrorCode);                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
#  if (DCM_DIDMGR_RTE_IMPLICIT_COM_ENABLED == STD_ON)                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    lStdResult = Dcm_UtiDataContextVerifySize(pDataContext, DCM_DIDMGR_READ_PAGE_SIZE, ErrorCode);                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)                                                                                                                       /* COV_DCM_RTM_RUNTIME_CHECK TX */
#  endif
    {
      lTmpAvailLen = (Dcm_DidMgrDidLengthType)pDataContext->AvailLen;

#  if (DCM_DIDMGR_RTE_IMPLICIT_COM_ENABLED == STD_ON)                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
      if (lTmpAvailLen > DCM_DIDMGR_READ_PAGE_SIZE)
      {
        lTmpAvailLen = DCM_DIDMGR_READ_PAGE_SIZE;
        lLoopPossible = TRUE;
      }
      else
      {
        lLoopPossible = FALSE;
      }
#  endif

      /* Call the appropriate application callback for that paged signal */
      lStdResult = ((Dcm_DidMgrOpFuncReadPagedDidType)pSignalOpClassInfo->OpFunc)(opStatus                                                           /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                               ,Dcm_UtiGetDataContextBuffer(pDataContext)
                                                                               ,&lTmpAvailLen);                                                      /* SBSW_DCM_COMB_PTR_FORWARD */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */

      switch (lStdResult)
      {
        case DCM_E_BUFFERTOOLOW:
#  if (DCM_DIDMGR_RTE_IMPLICIT_COM_ENABLED == STD_ON)                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
          if (lLoopPossible == TRUE)
          {
            lStdResult = DCM_E_LOOP;
          }
#  endif
          /* fall through */
        case DCM_E_OK:                                                                                                                               /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
          Dcm_UtiCommitData(pDataContext, lTmpAvailLen);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
          break;

        case DCM_E_NOT_OK:
          /* Handle NRC here since no NRC can be passed by the application on this interface */
          *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
          break;

        default:
          /* Nothing to do */
          break;
      }
    }
  }

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalVid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalVid(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,                                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  lStdResult = Dcm_CfgDidMgrSignalOpClassInfoGetEntry(pDidOpTypeContext->Base.SignalOpClassInfoRef
                                                     ,&pSignalOpClassInfo
                                                     ,ErrorCode);                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = Dcm_UtiDataContextVerifySize(pDataContext, pSignalOpClassInfo->MaxLength, ErrorCode);                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)                                                                                                                       /* COV_DCM_RTM_RUNTIME_CHECK TX */
    {
      uint8 lResLength = (uint8)pSignalOpClassInfo->MaxLength;

      /* Call the appropriate application callback for that VID signal */
      lStdResult = ((Dcm_DidMgrOpFuncReadVidType)pSignalOpClassInfo->OpFunc)(opStatus                                                                /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                            ,Dcm_UtiGetDataContextBuffer(pDataContext)
# if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
                                                                            ,&lResLength
# endif
                                                                            );                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_COMB_PTR_FORWARD */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */

      /* Handle NRC here since no NRC can be passed by the application on this interface */
      if(lStdResult == DCM_E_OK)
      {
        /* If VID signal with dynamic length supported (Autosar Version >= 4.2.2) */
# if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
        /* Update final response length only in positive/final case */
        if(Dcm_DebugDetectError( (lResLength == 0u) /* At least the NODI byte has to be written */
                               ||(lResLength > pSignalOpClassInfo->MaxLength) ))
        {
          lStdResult = DCM_E_NOT_OK;
          *ErrorCode = DCM_E_PANIC_NRC;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
          Dcm_DebugReportError(DCM_SID_SVCPORT_DATASVCS_OP_READVID, DCM_E_INTERFACE_BUFFER_OVERFLOW);
        }
        else
# endif
        {
          /* Decrement length of signal if NODI byte reporting disabled */
# if (DCM_DIDMGR_REPORT_NODIBYTE_ENABLED == STD_OFF)
          lResLength--;

          /* Remove NODI byte from VID signal if NODI byte reporting disabled */
          Dcm_UtiProvideDataAsUN(pDataContext, &Dcm_UtiGetDataContextBuffer(pDataContext)[1], lResLength);                                           /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_COMB_PTR_FORWARD */
# else
          Dcm_UtiCommitData(pDataContext, lResLength);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
# endif

          pDidInfoContext->DidLength = lResLength; /* Update current DID length */                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
        }
      }
      else if(lStdResult == DCM_E_PENDING)
      {
        /* Retry later */
      }
      else
      {
        Dcm_DebugAssert((lStdResult == DCM_E_NOT_OK), DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);

        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalSR()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalSR(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_CfgDidMgrSignalOpClassInfoGetEntry(pDidOpTypeContext->Base.SignalOpClassInfoRef
                                                     ,&pSignalOpClassInfo
                                                     ,ErrorCode);                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = Dcm_UtiDataContextVerifySize(pDataContext, pSignalOpClassInfo->MaxLength, ErrorCode);                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)                                                                                                                       /* COV_DCM_RTM_RUNTIME_CHECK TX */
    {
      /* Call the appropriate application callback for that SR signal */
      lStdResult = ((Dcm_DidMgrOpFuncReadSRType)pSignalOpClassInfo->OpFunc)(pDataContext);                                                           /* PRQA S 0313 */ /* MD_Dcm_0313 */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */ /* SBSW_DCM_PARAM_PTR_FORWARD */

      if(lStdResult == DCM_E_OK)
      {
        Dcm_CfgNetBufferSizeOptType lSignalLen;

        /* Update the remaining available length */
        lSignalLen = Dcm_DidMgrGetSignalLength(pDidInfoContext, pDidOpTypeContext);                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_UtiCommitData(pDataContext, (Dcm_MsgLenType)lSignalLen);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      else
      {
        /* Handle NRC here since no NRC can be passed by the application through this interface */
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
  }

  return lStdResult;
}

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalWrapperAsync()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalWrapperAsync(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,                                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  lStdResult = Dcm_CfgDidMgrSignalOpClassInfoGetEntry(pDidOpTypeContext->Base.SignalOpClassInfoRef
                                                     ,&pSignalOpClassInfo
                                                     ,ErrorCode);                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = Dcm_UtiDataContextVerifySize(pDataContext, pSignalOpClassInfo->MaxLength, ErrorCode);                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)                                                                                                                       /* COV_DCM_RTM_RUNTIME_CHECK TX */
    {
      /* Call the appropriate application callback for that asynchronous signal */
      lStdResult = ((Dcm_DidMgrOpFuncReadWrapperAsyncType)pSignalOpClassInfo->OpFunc)(pDidInfoContext->Did                                           /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                     ,opStatus
                                                                                     ,pDataContext);                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */

      if(lStdResult == DCM_E_NOT_OK)
      {
        /* Handle NRC here since no NRC can be passed by the application on this interface */
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
      }
    }
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalWrapperSync()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalWrapperSync(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,                                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                           /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_CfgDidMgrSignalOpClassInfoGetEntry(pDidOpTypeContext->Base.SignalOpClassInfoRef
                                                     ,&pSignalOpClassInfo
                                                     ,ErrorCode);                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = Dcm_UtiDataContextVerifySize(pDataContext, pSignalOpClassInfo->MaxLength, ErrorCode);                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)                                                                                                                       /* COV_DCM_RTM_RUNTIME_CHECK TX */
    {
      /* Call the appropriate application callback for that asynchronous signal */
      lStdResult = ((Dcm_DidMgrOpFuncReadWrapperSyncType)pSignalOpClassInfo->OpFunc)(pDataContext);                                                  /* PRQA S 0313 */ /* MD_Dcm_0313 */ /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */

      if(lStdResult == DCM_E_NOT_OK)
      {
        /* Handle NRC here since no NRC can be passed by the application on this interface */
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
      }
    }
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignal(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,                                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  lStdResult = Dcm_CfgDidMgrSignalOpClassInfoGetEntry(pDidOpTypeContext->Base.SignalOpClassInfoRef
                                                     ,&pSignalOpClassInfo
                                                     ,ErrorCode);                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    switch(pSignalOpClassInfo->FuncClass)
    {
    case DCM_DIDMGR_OPCLS_READ_RANGE:
      lStdResult = Dcm_DidMgrReadSignalRange(opStatus, pDataContext, pDidInfoContext, pDidOpTypeContext, ErrorCode);                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;

    case DCM_DIDMGR_OPCLS_READ_ASYNC:
      lStdResult = Dcm_DidMgrReadSignalAsync(opStatus, pDataContext, pDidInfoContext, pDidOpTypeContext, ErrorCode);                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;

    case DCM_DIDMGR_OPCLS_READ_SYNC:
      lStdResult = Dcm_DidMgrReadSignalSync(opStatus, pDataContext, pDidInfoContext, pDidOpTypeContext, ErrorCode);                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;

#  if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
    case DCM_DIDMGR_OPCLS_READ_PAGED:
      lStdResult = Dcm_DidMgrReadSignalPaged(opStatus, pDataContext, pDidInfoContext, pDidOpTypeContext, ErrorCode);                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif

    case DCM_DIDMGR_OPCLS_READ_VID:
      lStdResult = Dcm_DidMgrReadSignalVid(opStatus, pDataContext, pDidInfoContext, pDidOpTypeContext, ErrorCode);                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;

    case DCM_DIDMGR_OPCLS_READ_SR:
      lStdResult = Dcm_DidMgrReadSignalSR(opStatus, pDataContext, pDidInfoContext, pDidOpTypeContext, ErrorCode);                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;

    case DCM_DIDMGR_OPCLS_READ_WRAPPER_ASYNC:
      lStdResult = Dcm_DidMgrReadSignalWrapperAsync(opStatus, pDataContext, pDidInfoContext, pDidOpTypeContext, ErrorCode);                          /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;

    case DCM_DIDMGR_OPCLS_READ_WRAPPER_SYNC:
      lStdResult = Dcm_DidMgrReadSignalWrapperSync(opStatus, pDataContext, pDidInfoContext, pDidOpTypeContext, ErrorCode);                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;

    default:
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG);                                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */
      break;
    }

    if(opStatus == DCM_CANCEL)
    {
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }

    /* Catch any RTE or unexpected specific errors */
    if( (lStdResult != DCM_E_OK)
      &&(lStdResult != DCM_E_NOT_OK)
      &&(lStdResult != DCM_E_PENDING)
#  if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
      &&(lStdResult != DCM_E_BUFFERTOOLOW)
      &&(lStdResult != DCM_E_LOOP)
#  endif
#  if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
      &&(lStdResult != DCM_E_FORCE_RCRRP)
#  endif
      )
    {
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }

    Dcm_UtiHandleApplNrc(lStdResult, ErrorCode, DCM_E_CONDITIONSNOTCORRECT);                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6050, 6060 */ /* MD_MSR_STPTH,  MD_MSR_STCYC,  MD_MSR_STCAL, MD_MSR_STPAR */
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrReadLengthSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadLengthSignal(
  Dcm_OpStatusType opStatus,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,                                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrDidLengthPtrType pResLength,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                           /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_CfgDidMgrSignalOpClassInfoGetEntry(pDidOpTypeContext->Base.SignalOpClassInfoRef
                                                     ,&pSignalOpClassInfo
                                                     ,ErrorCode);                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    switch(pSignalOpClassInfo->FuncClass)
    {
    case DCM_DIDMGR_OPCLS_READLENGTH_SYNC:
      lStdResult = ((Dcm_DidMgrOpFuncReadLengthSyncType)pSignalOpClassInfo->OpFunc)(pResLength);                                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;

    case DCM_DIDMGR_OPCLS_READLENGTH_ASYNC:
      lStdResult = ((Dcm_DidMgrOpFuncReadLengthAsyncType)pSignalOpClassInfo->OpFunc)(opStatus                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,pResLength);                                                    /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;

    case DCM_DIDMGR_OPCLS_READLENGTH_RANGE:
      lStdResult = ((Dcm_DidMgrOpFuncReadDidRangeLengthType)pSignalOpClassInfo->OpFunc)(pDidInfoContext->Did                                         /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                       ,opStatus
                                                                                       ,pResLength);                                                 /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;

    default:
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG);                                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */
      break;
    }

    if(opStatus == DCM_CANCEL)
    {
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }

    if(lStdResult == DCM_E_NOT_OK)
    {
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT; /* return NRC CNC since no error code supported by the application API */                             /* SBSW_DCM_PARAM_PTR_WRITE */
    }

    /* Catch any RTE or unexpected specific errors */
    if( (lStdResult != DCM_E_OK)
      &&(lStdResult != DCM_E_PENDING)
      &&(lStdResult != DCM_E_NOT_OK)
      )
    {
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_DidMgrReadCheckCondSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadCheckCondSignal(
  Dcm_OpStatusType opStatus,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,                                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType pSignalOpClassInfo;

  DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                           /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_CfgDidMgrSignalOpClassInfoGetEntry(pDidOpTypeContext->Base.SignalOpClassInfoRef
                                                     ,&pSignalOpClassInfo
                                                     ,ErrorCode);                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    switch(pSignalOpClassInfo->FuncClass)
    {
    case DCM_DIDMGR_OPCLS_READCHK_COND_SYNC:
      lStdResult = ((Dcm_DidMgrOpFuncReadCheckCondSyncType)pSignalOpClassInfo->OpFunc)(ErrorCode);                                                   /* PRQA S 0313 */ /* MD_Dcm_0313 */ /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    case DCM_DIDMGR_OPCLS_READCHK_COND_ASYNC:
      lStdResult = ((Dcm_DidMgrOpFuncReadCheckCondAsyncType)pSignalOpClassInfo->OpFunc)(opStatus                                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                       ,ErrorCode);                                                  /* SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC */
      break;
    default:
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG);                                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */
      break;
    }

    if(opStatus == DCM_CANCEL)
    {
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }

    /* Catch any RTE or unexpected specific errors */
    if( (lStdResult != DCM_E_OK)
      &&(lStdResult != DCM_E_PENDING)
      &&(lStdResult != DCM_E_NOT_OK)
      )
    {
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }

    Dcm_UtiHandleApplNrc(lStdResult, ErrorCode, DCM_E_CONDITIONSNOTCORRECT);                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_DidMgrFilterDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrFilterDidLookUp(
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrOpOptType didOp
  )
{
  Std_ReturnType             lStdReturn = DCM_E_OK;
  Dcm_DidMgrDidOpInfoPtrType pDidOpInfoPtr;

  DCM_IGNORE_UNREF_PARAM(didOp);                                                                                                                     /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  pDidOpInfoPtr = Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext);

# if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
  if(Dcm_VarMgrIsEnabledInActiveVariants(pDidOpInfoPtr->ExecCondRef) == FALSE)                                                                       /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
  {
    /* Not supported in current variant */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
  /* Check session state */
  if(!Dcm_StateIsSupportedInSession(Dcm_StateGetPreconditionStates(pDidOpInfoPtr->ExecCondRef)))
  {
    /* Not supported in current session */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  {
# if (DCM_SVC_22_OBD_CALIBRATION_ENABLED == STD_ON) && \
     (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
    /* Perform this check only on supported DIDs ! */
    if( (pDidInfoContext->Did >= (uint16)0xF400u)
      &&(pDidInfoContext->Did <= (uint16)0xF8FFu)
#  if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
      /* Already filtered in the IsDidAvailable operation of the 0xF6xx DID range.
       * Note: Dcm_CfgSvc22SupportedIdMask does not contain any information for this DID range -> exclude from indexing.
       */
      &&((pDidInfoContext->Did & 0xF600u) != 0xF600u)
#  endif
      )
    {
      if(Dcm_ObdIdMgrIsIdEnabled(Dcm_UtiGetLoByte(pDidInfoContext->Did),
                    &Dcm_CfgSvc22SupportedIdMask[Dcm_CfgSvc22SupportedIdMaskOffset[Dcm_UtiGetHiByte(pDidInfoContext->Did)-(uint8)0xF4u]]) == FALSE)  /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
      {
        /* OBD DID not enabled */
        lStdReturn = DCM_E_NOT_OK;
      }/* else - still enabled */
    }
    else/* not an (WWH-)OBD DID */
# endif
    {
# if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
      if(didOp != DCM_DIDMGR_OP_DEFINE) /* isolate SID 0x2C - Define or Clear on not defined DDDID is always allowed! */
      {
        if(!Dcm_Svc2CIsDidDefined(Dcm_CfgDidMgrGetDidInfo(pDidInfoContext)))                                                                         /* PRQA S 3415 */ /* MD_Dcm_Rule13.5 */
        {
          /* not yet defined for other operations than DEFINE */
          lStdReturn = DCM_E_NOT_OK;
        }/* else - defined for other operations */
      }
# endif
    }
  }

  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_DidMgrConcreteDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrConcreteDidLookUp(
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrOpOptType didOp
  )
{
  Std_ReturnType lStdReturn = DCM_E_NOT_OK;
  /* Search for the DID in the database */
  sint16_least  lResult = Dcm_UtiLookUpUint16(Dcm_CfgDidMgrDidLookUpTable, pDidInfoContext->Did);                                                    /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  /* Check DID lookup result: */
  if(lResult >= 0)
  {
    /* If found, check if the DID supports the required operation: */
    if(Dcm_DidMgrIsOpSupported(&Dcm_CfgDidMgrDidInfo[lResult], didOp))
    {
      /* If operation supported, initialize DID information (set DID as supported) */
      pDidInfoContext->Descriptor.DidInfoIdx = (Dcm_CfgDidMgrDidInfoRefType)lResult;                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
      /* Set DID length. Later the concrete length will be stored here. Take the maximum/concrete length! */
      pDidInfoContext->DidLength      = (Dcm_DidMgrDidLengthType)Dcm_CfgDidMgrDidInfo[lResult].MaxLength;                                            /* SBSW_DCM_PARAM_PTR_WRITE */
      pDidInfoContext->ReservedLength = (Dcm_DidMgrDidLengthType)Dcm_CfgDidMgrDidInfo[lResult].ReservedLength;                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      /* Initialize DID operation information  */
      Dcm_DidMgrInitOpInfo(pDidInfoContext, didOp);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdReturn = DCM_E_OK;
    }/* else - not a supported DID in the operation context! */
  }/* else - not a supported DID at all! */

  return lStdReturn;
}

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrCheckSignalSize()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_DidMgrCheckSignalSize(
  Dcm_DiagDataContextConstPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                                                                                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_CfgNetBufferSizeOptType lRequiredBufSize;

#  if (DCM_DIDMGR_RTE_IMPLICIT_COM_ENABLED == STD_ON)                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lRequiredBufSize = Dcm_DidMgrGetRequiredSignalBufSize(pDidInfoContext, pDidOpTypeContext);                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
#  else
  /* Calculate the remaining available length */
  lRequiredBufSize = Dcm_DidMgrGetSignalLength(pDidInfoContext, pDidOpTypeContext);                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
#  endif

  /*
   * Note: An additional check against AvailLen is not necessary here, since AvailLen is always equal to Size.
   *       The only exception is the last page during paged buffering, because AvailLen is than reduced to the
   *       remaining data length. As such it is already guaranteed that the signal fits into AvailLen.
   */
  return Dcm_UtiDataContextCheckSize(pDataContext, (Dcm_MsgLenType)lRequiredBufSize);                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrReadMultiSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadMultiSignal(                                                                           /* PRQA S 2889 */ /* MD_Dcm_Optimize_2889 */
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  /* For each signal of the DID: */
  do
  {
# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
    if (Dcm_DidMgrCheckSignalSize(pDataContext, pDidInfoContext, pDidOpTypeContext) == FALSE)                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    {
      /* Try it the next task cycle */
      lResult = DCM_E_BUFFERTOOLOW;
    }
    else
# endif
    {
      Dcm_CfgNetBufferSizeOptType lAvailLen;

      lAvailLen = (Dcm_CfgNetBufferSizeOptType)(pDataContext->AvailLen);

      /* Read the signal data considering gaps */
      lResult = Dcm_DidMgrReadSignal(pDidOpTypeContext->OpType.Read.OpStatus
                                    ,pDataContext
                                    ,pDidInfoContext
                                    ,pDidOpTypeContext
                                    ,ErrorCode);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

      switch(lResult)
      {
        case DCM_E_OK:
          pDidOpTypeContext->Base.NumSignals--;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
          if(pDidOpTypeContext->Base.NumSignals == 0u)
          {
            return DCM_E_OK;                                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
          }

          pDidOpTypeContext->OpType.Read.Progress += (Dcm_CfgDidMgrOptimizedDidLengthType)(lAvailLen - pDataContext->AvailLen);                      /* SBSW_DCM_PARAM_PTR_WRITE */

          /* Go on with next signal */
          pDidOpTypeContext->Base.SignalOpClassInfoRef++;                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
          pDidOpTypeContext->OpType.Read.OpStatus = DCM_INITIAL; /* reset op status */                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
          break;
        case DCM_E_BUFFERTOOLOW:
        case DCM_E_LOOP:
          pDidOpTypeContext->OpType.Read.Progress += (Dcm_CfgDidMgrOptimizedDidLengthType)(lAvailLen - pDataContext->AvailLen);                      /* SBSW_DCM_PARAM_PTR_WRITE */
          /* fall through */
        case DCM_E_PENDING:                                                                                                                          /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
          pDidOpTypeContext->OpType.Read.OpStatus = DCM_PENDING;                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
          break;
        default: /* DCM_E_FORCE_RCRRP, DCM_E_NOT_OK */
          break;
      }
    }
  } while( (lResult == DCM_E_OK) || (lResult == DCM_E_LOOP) );

  return lResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

# if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetSidFromOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(uint8, DCM_CODE) Dcm_DidMgrGetSidFromOp(
  Dcm_DidOpType didOp
  )
{
  uint8 lSid;

  switch(didOp)
  {
    case DCM_DID_OP_READ:
      lSid = DCM_DIDMGR_SVC_READ;
      break;
    case DCM_DID_OP_WRITE:
      lSid = DCM_DIDMGR_SVC_WRITE;
      break;
    case DCM_DID_OP_IO:
      lSid = DCM_DIDMGR_SVC_IOCTRL;
      break;
    case DCM_DID_OP_SCALINGINFO:
      lSid = DCM_DIDMGR_SVC_SCALING;
      break;
    case DCM_DID_OP_DEFINE:
      lSid = DCM_DIDMGR_SVC_DEFINE;
      break;
    default:
      lSid = DCM_DIDMGR_SVC_NONE;
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
      break;
  }

  return lSid;
}
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */

#define DCM_START_SEC_CODE
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */
/**********************************************************************************************************************
 *  Dcm_DiagAcceptNewRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_DiagAcceptNewRequest(
  Dcm_NetTransportObjectPtrType pTranspObj                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  boolean lResult = TRUE;
  /* If SID in range: [0x40, 0x7F]U[0xC0, 0xFF] */
#if (DCM_DIAG_IGNORE_RESPONSE_SID_ENABLED == STD_ON)
  if((pTranspObj->RxData[0] & 0x40u) != 0u)
  {
    pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_IGNORE;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = FALSE;
  }
  else
#endif
  /* If valid functional "0x3E 0x80" */
  if( (pTranspObj->RxData[0] == 0x3Eu)
    &&(pTranspObj->RxData[1] == 0x80u)
    &&(pTranspObj->RxLength  == 2u)
    &&(Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE) )                                                                               /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
  {
#if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
    /* In case of generic connections, a connection can be used by a pool of testers. Tester address has to be checked as well. */
    if( ((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) == 0u) /* A non-default session is/will be active */
      &&( (Dcm_NetGetSessionConnection() != pTranspObj->ConnHdl)
        ||(Dcm_NetGetSessionClientSrcAddr() != pTranspObj->ClientSrcAddr)) ) /* Request from different tester */
    {
      pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_IGNORE;                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
    }
#endif
    lResult = FALSE;
  }
  else
  {
    /* nothing to do */
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_DiagOnTxFinished()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagOnTxFinished(
  Dcm_NetTransportObjectPtrType pTranspObj,                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NetTransmissionResultType txStatus
  )
{
  switch(pTranspObj->ResType)
  {
  case DCM_NET_TOBJ_RESTYPE_LINEAR:
  case DCM_NET_TOBJ_RESTYPE_PAGED:
    /* Do finalize main response */
    Dcm_DiagTxFinalization(pTranspObj, txStatus);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_NET_TOBJ_RESTYPE_RCRRP:
    Dcm_DiagRcrRpTxFinished(pTranspObj, txStatus);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
  case DCM_NET_TOBJ_RESTYPE_UNSOLICITED:
    Dcm_DiagOnFblResTxFinished(pTranspObj, txStatus);                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
#endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    /* Unknown response type */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }
}
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
# if (DCM_DIDMGR_PERIODICDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2AOnStateChanged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2AOnStateChanged(
  void
  )
{
  if(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
    Dcm_NegativeResponseCodeType   lNrc;
    Dcm_Svc2ASchdItemHandleOptType lSchdIter;
    Std_ReturnType lStdReturn;

    for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
    {
      Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);                                                                       /* PRQA S 3679 */ /* MD_Dcm_Design_3679 */
      if(pSchdEntry->Rate < DCM_SVC2A_RATE_TYPE_STOPPED)/* is still an active entry? */
      {
        lStdReturn = Dcm_DidMgrDynDidStateCheck(DCM_NET_INVALID_CONNHDL, &(pSchdEntry->DidContext), &lNrc);                                          /* SBSW_DCM_COMB_PTR_FORWARD */
        if (lStdReturn == DCM_E_NOT_OK)
        {
          Dcm_Svc2ASchdStopItemByHandle(lSchdIter);
        }
      }
    }
  }
}
# endif
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CGetSrcItem()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_Svc2CDynDidSrcItemPtrType, DCM_CODE) Dcm_Svc2CGetSrcItem(
  Dcm_CfgDidMgrDynDidSrcItemIdxOptType srcItemIndex
  )
{
  Dcm_Svc2CDynDidSrcItemPtrType pSourceItem;

  if (Dcm_DebugDetectRuntimeError(srcItemIndex >= DCM_NUM_DYNDID_ITEMS))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    pSourceItem = &Dcm_Svc2CNvMData.SrcItems[0];
  }
  else
  {
    pSourceItem = &Dcm_Svc2CNvMData.SrcItems[srcItemIndex];
  }

  return pSourceItem;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CGetItem()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_Svc2CDynDidItemPtrType, DCM_CODE) Dcm_Svc2CGetItem(
  Dcm_CfgDidMgrDynDidHandleOptType itemIndex
  )
{
  Dcm_Svc2CDynDidItemPtrType pItem;

  if (Dcm_DebugDetectRuntimeError(itemIndex >= DCM_NUM_DYNDIDS))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    pItem = &Dcm_Svc2CNvMData.Items[0];
  }
  else
  {
    pItem = &Dcm_Svc2CNvMData.Items[itemIndex];
  }

  return pItem;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CGetDDDidProcessContext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_Svc2CDynDidProcessContextPtrType, DCM_CODE) Dcm_Svc2CGetDDDidProcessContext(
  uint8 processContextIndex
  )
{
  Dcm_Svc2CDynDidProcessContextPtrType pProcessContext;

  if (Dcm_DebugDetectRuntimeError(processContextIndex >= DCM_SVC_2C_NUM_PROCESS_CONTEXTS))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    pProcessContext = &Dcm_SingletonContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[0];
  }
  else
  {
    pProcessContext = &Dcm_SingletonContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[processContextIndex];
  }

  return pProcessContext;
}

# if (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_STATE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CStateCheckSrcItems()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CStateCheckSrcItems(
  Dcm_NetConnRefMemType connHdl,
  Dcm_CfgDidMgrDynDidHandleOptType dynDidHandle,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;
  Dcm_CfgDidMgrDynDidSrcItemIdxOptType currItem;
  Dcm_CfgDidMgrDynDidSrcItemIdxOptType endItem;

  DCM_IGNORE_UNREF_PARAM(connHdl);                                                                                                                   /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  currItem = Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle);
  endItem = (Dcm_CfgDidMgrDynDidSrcItemIdxOptType)(currItem + Dcm_Svc2CGetItem(dynDidHandle)->Count);

  Dcm_DebugAssert((currItem < endItem), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                      /* COV_DCM_RTM_DEV_DEBUG XF */

  for(; currItem < endItem; currItem++)
  {
    if(Dcm_Svc2CIsDidSrcItem(currItem))
    {
#  if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
      Dcm_DidMgrDidInfoContextType lDidInfoContext;

      Dcm_Svc2CInitDidInfoFromDidInfoIdx(Dcm_Svc2CGetSrcItem(currItem)->DidDescriptor.DidInfoIdx, &lDidInfoContext);                                 /* SBSW_DCM_POINTER_FORWARD_STACK */

      lStdResult = Dcm_StateCheckDID(connHdl
                                    ,lDidInfoContext.Did
                                    ,DCM_DIDMGR_OP_READ
                                    ,Dcm_CfgDidMgrGetDidOpInfo(&lDidInfoContext)->ExecCondRef                                                        /* PRQA S 2962 */ /* MD_Dcm_2962 */
                                    ,ErrorCode);                                                                                                     /* SBSW_DCM_COMB_PTR_FORWARD */
#  endif
    }
    else
    {
#  if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
      lStdResult = Dcm_MemMgrCheckMemBlock(&(Dcm_Svc2CGetSrcItem(currItem)->MemDescriptor.MemBlock)
                                          ,DCM_MEMMGR_OP_READ
                                          ,ErrorCode);                                                                                               /* SBSW_DCM_COMB_PTR_FORWARD */
#  endif
    }
    if (lStdResult != DCM_E_OK)
    {
      break;
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
# endif

# if (DCM_DIDMGR_DYNDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2COnStateChanged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2COnStateChanged(
  void
  )
{
  /* clear all DynDID definitions not supported any more */
  Dcm_NegativeResponseCodeType     lNrc;
  Std_ReturnType                   lStdResult;
  Dcm_CfgDidMgrDynDidHandleOptType lDynDidIter;
#  if (DCM_SVC_2C_NVRAM_SUPPORT_ENABLED == STD_ON)
  boolean                          lAnyCleared = FALSE;
#  endif

  for(lDynDidIter = 0; lDynDidIter < DCM_NUM_DYNDIDS; ++lDynDidIter)
  {
    if(Dcm_Svc2CIsDynDidDefined(lDynDidIter))
    {
      lStdResult = Dcm_DidMgrStaticDidNoAuthStateCheck(Dcm_DidMgrGetDynDidReadExecPrecond(lDynDidIter), &lNrc);                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

#  if (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_STATE_ENABLED == STD_ON)
      if(lStdResult == DCM_E_OK) /* all DDDID conditions OK - check inside */
      {
        lStdResult = Dcm_Svc2CStateCheckSrcItems(DCM_NET_INVALID_CONNHDL, lDynDidIter, &lNrc);                                                       /* SBSW_DCM_POINTER_FORWARD_STACK */
      }
#  endif

      if(lStdResult == DCM_E_NOT_OK) /* any condition not fulfilled? */
      {
        Dcm_Svc2CDefMgrClear((Dcm_CfgDidMgrDynDidHandleMemType)lDynDidIter);
#  if (DCM_SVC_2C_NVRAM_SUPPORT_ENABLED == STD_ON)
        if(lAnyCleared == FALSE)
        {
          lAnyCleared = TRUE;
          Dcm_UtiNvMSetRamBlockStatus((uint16)DCM_SVC_2C_NVRAM_BLOCKID);
        }
#  endif
      }
    } /* else - DDDID not defined yet */
  }
}
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* Min Length already checked in DiagDispatcher and expected to be 3 !!! */
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &(pRepContext->DidInfoContext.Did));                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  lStdResult = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&(pRepContext->DidInfoContext)
                                   ,&(pRepContext->DidOpTypeContext)
                                   ,DCM_DIDMGR_OP_IO);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

  switch(lStdResult)
  {
  case DCM_E_OK:
    {
      uint8 lControlOp;
      Dcm_UtiConsumeReqDataAsU8(pMsgContext, &lControlOp);                                                                                           /* SBSW_DCM_COMB_PTR_FORWARD */

      /* convert from UDS to internal operation representation */
      if(lControlOp < 4u)
      {
        pRepContext->OpType = Dcm_Svc2FCtrlOp2DidOpTypeMap[lControlOp]; /* use interpreted value */                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      else
      {
        pRepContext->OpType = (Dcm_DidMgrOpMemType)0x00u; /* no supported operation */                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
      }

      /* Check for supported sub-operation */
      if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&pRepContext->DidInfoContext), pRepContext->OpType))                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      {
        /* Commit response header */
        Dcm_UtiProvideResData(pMsgContext, 3);                                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */

        lStdResult = Dcm_Svc2FIoDidOperationProcessor(pContext, pMsgContext, ErrorCode, pRepContext);                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      else
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
    break;
  case DCM_E_NOT_OK:
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default: /* DCM_E_PENDING -> try again */
    break;
  }

  return lStdResult;
}

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FGetActiveIoDids()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_UtiBitSetBasePtrType, DCM_CODE) Dcm_Svc2FGetActiveIoDids(
  Dcm_CfgDidMgrIoDidHandleOptType ioDidIndex
  )
{
  Dcm_UtiBitSetBasePtrType pActiveIoDids;

  if (Dcm_DebugDetectRuntimeError(ioDidIndex >= Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS)))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    pActiveIoDids = &Dcm_SingletonContext.Diag.Services.Svc2F.ActiveIoDids[0];
  }
  else
  {
    pActiveIoDids = &Dcm_SingletonContext.Diag.Services.Svc2F.ActiveIoDids[ioDidIndex];
  }

  return pActiveIoDids;
}
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FOnStateChanged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FOnStateChanged(
  void
  )
{
  if(Dcm_SingletonContext.Diag.Services.Svc2F.HasAnyActiveIoDid == TRUE)
  {
    Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRefPage = 0;
    Dcm_CfgDidMgrIoDidHandleOptType ioDidIter;

    Dcm_SingletonContext.Diag.Services.Svc2F.HasAnyActiveIoDid = FALSE; /* Assume all IODIDs will be deactivated */

    for(ioDidIter = 0; ioDidIter < Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS); ioDidIter++)
    {
      Dcm_UtiBitSetBasePtrType pActiveIoDids = Dcm_Svc2FGetActiveIoDids(ioDidIter);
      Dcm_UtiBitSetBaseType lActiveIoDids = *pActiveIoDids;
      Dcm_UtiBitSetBaseType lActiveIoDidScanner = 0x01u;
      Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef = opInfoRefPage;

      DCM_UTI_LOOP_BIT_SCAN(lActiveIoDids)
      {
        if(Dcm_UtiBitOpTest(Dcm_UtiBitSetBaseType, *pActiveIoDids, lActiveIoDidScanner))
        {
          Dcm_NegativeResponseCodeType lNrc;
          Std_ReturnType lStdReturn;

          /*
           * No Authentication check needed as service 2F is only allowed in the extended session,
           * and therefore no other tester has access to the DCM during that time.
           */
          lStdReturn = Dcm_DidMgrStaticDidNoAuthStateCheck(Dcm_DidMgrGetCtrlOpExecCondRef(opInfoRef), &lNrc);                                        /* SBSW_DCM_POINTER_FORWARD_STACK */
          if (lStdReturn == DCM_E_NOT_OK)
          {
            Dcm_UtiBitOpClr(Dcm_UtiBitSetBaseType, *pActiveIoDids, lActiveIoDidScanner);                                                             /* SBSW_DCM_POINTER_WRITE_2FACTIVEIODIDS */
            Dcm_DidMgrIoControlRtrnCtrl2Ecu(Dcm_DidMgrGetCtrlOpInfoRef(opInfoRef));
          }
        }

        lActiveIoDidScanner<<=1;
        ++opInfoRef;
      }

      /* If still any IODID active in this row: */
      if(*pActiveIoDids != 0u)
      {
        /* Update IODID activity statistics */
        Dcm_SingletonContext.Diag.Services.Svc2F.HasAnyActiveIoDid = TRUE;
      }

      opInfoRefPage += (Dcm_CfgDidMgrDidOpClassHandleOptType)Dcm_UtiGetNumBitsOfXintType(Dcm_UtiBitSetBaseType);/* next bunch of IoDids */           /* PRQA S 2983 */ /* MD_Dcm_Redundant_2983 */
    }
  }
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */

#define DCM_START_SEC_CODE
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MemMgrCheckMemoryRange()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrCheckMemoryRange(
  Dcm_MemMgrMemBlockConstPtrType pMemBlock,
  Dcm_MemMgrMemoryOpType memOp,
  Dcm_CfgMemMgrMemIdInfoConstPtrType pMemMapDescriptor,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  Dcm_CfgMemMgrReqAddrType reqEndAddress;
  Dcm_CfgMemMgrMemMapInfoPtrType pUsedMemMap;

  pUsedMemMap = pMemMapDescriptor->MemMapTable;
  reqEndAddress = pMemBlock->Address + (Dcm_CfgMemMgrReqAddrType)(pMemBlock->Length) - 1u; /* possible overflows does not take any effect for now */

  /* Check for address overflow or no data required (length == 0) */
  if( (pMemBlock->Length != 0u)
    &&(reqEndAddress >= pMemBlock->Address) )
  {
    Dcm_CfgMemMgrMemMapIdxOptType  memMapIter = 0;
    Dcm_CfgMemMgrMemAddrType       lastEndAddr = pUsedMemMap->EndAddr;
    boolean                        isBlockBeginFound = FALSE;
    boolean                        isMemMapAreaFound = FALSE;

    lStdResult = DCM_E_OK;

    for(;memMapIter < pMemMapDescriptor->Size; ++memMapIter)                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
    {
      if(pUsedMemMap[memMapIter].EndAddr >= pMemBlock->Address) /* first block that may contain the requested range */
      {
        if(isBlockBeginFound == FALSE)
        {
          isBlockBeginFound = TRUE;
          if(pUsedMemMap[memMapIter].StartAddr > pMemBlock->Address) /* the start address must be within the configured block  */
          {
            /* the requested start address is not within the memory block */
            break;
          }
          /* else - OK, let's analyze the other properties of the configuration block */
        }
        else /* scanning subsequent blocks */
        {
          ++lastEndAddr; /* prepare for the potential next concatenated range startAddr */
          if(pUsedMemMap[memMapIter].StartAddr != lastEndAddr) /* no concatenated ranges */
          {
            /* Stop scanning due to an error */
            break;
          }/* else - the end address block was not found yet, check this range borders and conditions */
        }

        if (pUsedMemMap[memMapIter].ExecCondRefs[memOp] == 0u) /* memory operation supported for this block in currently active variant(s) ? */
        {
          /* Stop scanning due to an error */
          break;
        }
        else/* else - range supports operation - go on with state checks */
        {
# if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
          if (Dcm_VarMgrIsEnabledInActiveVariants((Dcm_CfgStateRefOptType)(pUsedMemMap[memMapIter].ExecCondRefs[memOp]) - (Dcm_CfgStateRefOptType)1u) == FALSE) /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
          {
            /* Stop scanning due to an error */
            break;
          }
# endif
        }

        if(lStdResult == DCM_E_OK) /* still no error found */
        {
          lStdResult = Dcm_StateCheck(((Dcm_CfgStateRefOptType)(pUsedMemMap[memMapIter].ExecCondRefs[memOp]) - (Dcm_CfgStateRefOptType)1u),
                                      DCM_DIAG_CHK_LVL_PARAMETER,
                                      ErrorCode);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
        }/* else - ErrorCode already set, let see if the range is at least OK */

        if(((Dcm_CfgMemMgrReqAddrType)pUsedMemMap[memMapIter].EndAddr) >= reqEndAddress)
        {
          isMemMapAreaFound = TRUE;
          /* stop scanning: send either POS_RES or first condition error: depends on the last lStdResult value
           * (ErrorCode already set in case of E_NOT_OK)
           */
          break;
        }/* else - try next range (if any still available) */
        lastEndAddr = pUsedMemMap[memMapIter].EndAddr;/* update for next iteration */
      }/* else - not reached a range from the bottom */
    }/* no valid range found */

    /* If requested start address is too high or end address was not met:
      * (e.g. due to wrong operation in any sub-area or end address too high, resp. outside of started area)
      */
    if(isMemMapAreaFound == FALSE)
    {
      /* Send negative response NRC 0x31 */
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }/* Otherwise - matching area found: either POS_RES for valid states or NEG_RES due to invalid states */
  }
  else/* else - length == 0 or req_addr > blockEnd */
  {
    /* Send negative response NRC 0x31 */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_FBLMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_FblMgrParseMemStream()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_FblMgrParseMemStream(
  uint8 alfid,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_FblMgrMemBlockPtrType pMemBlock
  )
{
  uint8_least lAddressLength;

  lAddressLength = Dcm_UtiGetMemBlockAddrSize(alfid);

# if (DCM_FBLMGR_MID_SUPPORT_ENABLED == STD_ON)
  --lAddressLength; /* skip mid */
  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &(pMemBlock->Mid));                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
# else
  pMemBlock->Mid = 0;                                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
# endif

  /* extract address */
  pMemBlock->Address = (Dcm_FblMgrMemoryAddressType)Dcm_UtiDwordExtract(pMsgContext, lAddressLength);                                                /* SBSW_DCM_PARAM_PTR_WRITE */ /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* extract size  */
  pMemBlock->Length = (Dcm_FblMgrMemorySizeType)Dcm_UtiDwordExtract(pMsgContext, Dcm_UtiGetMemBlockLenSize(alfid));                                  /* SBSW_DCM_PARAM_PTR_WRITE */ /* SBSW_DCM_PARAM_PTR_FORWARD */
}

/**********************************************************************************************************************
 *  Dcm_FblMgrReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_FblMgrReset(void)
{
  Dcm_SingletonContext.FblMgr.DownloadState = DCM_FBL_DOWNLOAD_STATE_IDLE;
  Dcm_SingletonContext.FblMgr.BlockSequenceCounterOld = 0u;
  Dcm_SingletonContext.FblMgr.Start = TRUE;
}
#endif /* (DCM_FBLMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidData_SupportedId()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidData_SupportedId(
  uint8 ObdMID,
  Dcm_DiagDataContextPtrType pDataContext
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint32 lObdMidAvailMask;

  /* If request of MID Mask value from Dem is successful */
  if (Dem_DcmGetAvailableOBDMIDs(ObdMID, &lObdMidAvailMask) == E_OK)                                                                                 /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    /* Copy MID Mask value to data context */
    Dcm_UtiProvideDataAsU32(pDataContext, lObdMidAvailMask);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidData_DataId()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidData_DataId(
  uint8 ObdMID,
  Dcm_DiagDataContextPtrType pDataContext
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint8 lNumOfTIDs;

  /* Request number of TIDs for DID from Dem */
  if (Dem_DcmGetNumTIDsOfOBDMID(ObdMID, &lNumOfTIDs) == E_OK)                                                                                        /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    /* If request is successful */
    uint8 lTidIter;
    uint16 lTestValue;
    uint16 lTestValuMin;
    uint16 lTestValueMax;
    uint8 lTidValue;
    uint8 lUaSid;

    /* Request Test Result of each TID from Dem */
    for (lTidIter = 0; lTidIter < lNumOfTIDs; lTidIter++)
    {
      if (Dem_DcmGetDTRData(ObdMID, lTidIter, &lTidValue, &lUaSid, &lTestValue, &lTestValuMin, &lTestValueMax) == E_OK)                              /* SBSW_DCM_POINTER_FORWARD_STACK */
      {
        /* If request is successful for a TID */
        /* Copy response data to data context */
        Dcm_UtiProvideDataAsU8(pDataContext,lTidValue);                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */

        Dcm_UtiProvideDataAsU8(pDataContext,lUaSid);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

        Dcm_UtiProvideDataAsU16(pDataContext,lTestValue);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */

        Dcm_UtiProvideDataAsU16(pDataContext,lTestValuMin);                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

        Dcm_UtiProvideDataAsU16(pDataContext,lTestValueMax);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      else
      {
        lStdResult = DCM_E_NOT_OK;
        break;
      }
    }
  }
  else
  {
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_AUTHMGR_DEFAULT_SESSION_TIMEOUT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrTimerStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrTimerStart(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_AuthMgrTimerType value
  )
{
  /* Start the appropriate authentication timer */
  Dcm_AuthMgrTimerSet(authInfoRef, value);

  if(!Dcm_TmrIsTimerRunning(DCM_TMR_ID_AUTHENTICATION))
  {
    /* Start the base authentication timer */
    Dcm_TmrStartTimer(DCM_TMR_ID_AUTHENTICATION, 1u);
  }
}
# endif

# if (DCM_AUTHMGR_DEFAULT_SESSION_TIMEOUT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrTimerSet()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrTimerSet(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_AuthMgrTimerType value
  )
{
  uint8_least lTimerIdx = Dcm_AuthMgrGetTimerIdx(authInfoRef);

  if(Dcm_DebugDetectRuntimeError(lTimerIdx >= DCM_AUTHMGR_NUM_DELAY_TIMERS))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    Dcm_SingletonContext.AuthMgr.DelayTime[lTimerIdx] = value;                                                                                       /* SBSW_DCM_POINTER_WRITE_DELAYTIME_AUTH */
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_AuthMgrSetConnAuthState()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrSetConnAuthState(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_AuthenticationStateType value
  )
{
  if(Dcm_DebugDetectRuntimeError(authInfoRef >= DCM_CFGAUTHMGRNETCONNINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    Dcm_AuthMgrNvMData[authInfoRef].ConnContext.AuthState = value;                                                                                   /* SBSW_DCM_POINTER_WRITE_AUTHNVMDATA */
  }
}

# if(DCM_AUTHMGR_WHITELISTS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrGetWLContext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrGetWLContext(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  CONSTP2VAR(Dcm_AuthMgrWLContextPtrType, AUTOMATIC, AUTOMATIC) pWLContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if (Dcm_DebugDetectRuntimeError(authInfoRef >= DCM_CFGAUTHMGRNETCONNINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pWLContext = &Dcm_AuthMgrNvMData[authInfoRef].ConnContext.WLContext;                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_AuthMgrUpdateActiveRole()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrUpdateActiveRole(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_CfgStateGroupMemType authRole
  )
{

  if (Dcm_DebugDetectRuntimeError(authInfoRef >= DCM_CFGAUTHMGRNETCONNINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    Dcm_AuthMgrNvMData[authInfoRef].ConnContext.ActiveRole = authRole;                                                                               /* SBSW_DCM_POINTER_WRITE_AUTHNVMDATA */
  }
}

# if (DCM_AUTHMGR_DEFAULT_SESSION_TIMEOUT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrDetectIdleConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrDetectIdleConnection(
  Dcm_CfgStateGroupOptType oldSession
  )
{
  /* If this is not a transition from default to default session: */
  if (oldSession != DCM_STATE_VALUE_SESSION_INIT)
  {
    Dcm_CfgNetAuthInfoRefMemType lAuthInfoRef = Dcm_NetGetAuthInfoRef(Dcm_NetGetSessionConnection());

    if (lAuthInfoRef != DCM_AUTHMGR_INVALID_AUTH_INFO_REF)
    {
      boolean lIsTimerActive;

      /* Enter critical section (Reason: A timer can be modified from an ISR or high priority task) */
      Dcm_UtiEnterCriticalSection();
      /*=================================*
      BEGIN CRITICAL SECTION
      *=================================*/
      lIsTimerActive = Dcm_AuthMgrTimerActive(lAuthInfoRef);                                                                                         /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
      /*=================================*
      END CRITICAL SECTION
      *=================================*/
      /* Leave critical section */
      Dcm_UtiLeaveCriticalSection();

      if (lIsTimerActive == FALSE)
      {
        if (Dcm_AuthMgrAuthenticationState(lAuthInfoRef) == DCM_AUTHENTICATED)
        {
          /* Deauthenticate the connection */
          Dcm_AuthMgrUpdateActiveRole(lAuthInfoRef, DCM_AUTHMGR_DEAUTHENTICATED_ROLE);
          Dcm_AuthMgrSetAuthentication(lAuthInfoRef, DCM_DEAUTHENTICATED);
        }
      }
    }
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_AuthMgrDeauthenticateIdleConn()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrDeauthenticateIdleConn(
  void
  )
{
  Dcm_CfgNetAuthInfoRefOptType    lTmrIter = 0u;
  Dcm_AuthMgrTimerExpiredMaskType lExpiredTimers;

  /* Enter critical section (Reason: A timer can be modified from an ISR) */
  Dcm_UtiEnterCriticalSection();
  /*=================================*
  BEGIN CRITICAL SECTION
  *=================================*/
  /* Retrieve all expired authentication timers atomically */
  lExpiredTimers = Dcm_AuthMgrTimerExpireMaskGet();

  /* Reset global expired timers flag */
  Dcm_AuthMgrTimerExpireMaskReset();
  /*=================================*
  END CRITICAL SECTION
  *=================================*/
  /* Leave critical section */
  Dcm_UtiLeaveCriticalSection();

  DCM_UTI_LOOP_BIT_SCAN(lExpiredTimers)
  {
    if (Dcm_UtiBitOpTest(Dcm_AuthMgrTimerExpiredMaskType, lExpiredTimers, 0x01u))
    {
      /* If the connection is authenticated */
      if (Dcm_AuthMgrAuthenticationState(lTmrIter) == DCM_AUTHENTICATED)
      {
        if ( (Dcm_StateIsDefaultSessionActive())
           ||(lTmrIter != Dcm_NetGetAuthInfoRef(Dcm_NetGetSessionConnection())) )
        {
          Dcm_AuthMgrUpdateActiveRole((Dcm_CfgNetAuthInfoRefMemType)lTmrIter, DCM_AUTHMGR_DEAUTHENTICATED_ROLE);
          Dcm_AuthMgrSetAuthentication((Dcm_CfgNetAuthInfoRefMemType)lTmrIter, DCM_DEAUTHENTICATED);
        }
      }
    }

    ++lTmrIter;
  }
}

/**********************************************************************************************************************
 *  Dcm_AuthMgrSetAuthentication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrSetAuthentication(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_AuthenticationStateType authState
  )
{
  /* Set Authentication flag for connection to new state */
  Dcm_AuthMgrSetConnAuthState(authInfoRef, authState);
  /* Rte mode switch to new state */
  Dcm_ModeSwitchAuthentication(authInfoRef, authState);
}

/**********************************************************************************************************************
 *  Dcm_AuthMgrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrInit(
  void
  )
{
# if (DCM_AUTHMGR_PERSIST_STATE_ENABLED == STD_ON)
  Dcm_NegativeResponseCodeType lErrorCode;
# endif

# if (DCM_AUTHMGR_PERSIST_STATE_ENABLED == STD_ON)
  if (Dcm_ModeCheck(DCM_MODE_AUTH_PERSIST_STATE_MODERULE_REF, &lErrorCode) != DCM_E_OK)                                                              /* SBSW_DCM_POINTER_FORWARD_STACK */
# endif
  {
    Dcm_CfgNetAuthInfoRefOptType lAuthInfoRef;

    for (lAuthInfoRef = 0u; lAuthInfoRef < DCM_CFGAUTHMGRNETCONNINFO_SIZE; lAuthInfoRef++)
    {
      Dcm_AuthMgrSetConnAuthState((Dcm_CfgNetAuthInfoRefMemType)lAuthInfoRef, DCM_DEAUTHENTICATED);
      Dcm_AuthMgrUpdateActiveRole((Dcm_CfgNetAuthInfoRefMemType)lAuthInfoRef, DCM_AUTHMGR_DEAUTHENTICATED_ROLE);
    }
  }

# if (DCM_AUTHMGR_SET_DEAUTH_ROLE_ENABLED == STD_ON)
  Dcm_SingletonContext.AuthMgr.PendingData.ConnectionMask = 0u;
# endif
  Dcm_AuthMgrTimerExpireMaskReset();
}

/**********************************************************************************************************************
 *  Dcm_AuthMgrCancelOperation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrCancelOperation(
  void
  )
{
  Dcm_Svc29CancelOperation();
  /* Post processor will reset the authentication state */
}

# if (DCM_AUTHMGR_SET_DEAUTH_ROLE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrSetDeauthenticatedRole()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrSetDeauthenticatedRole(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
  /* If diagnostic kernel is still busy with a diagnostic job, retry next task activation */
  if (pContext->Thread->Diag.State != DCM_DIAG_STATE_IDLE)
  {
    Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_DIAG_WORK_EXT_SETROLE);                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    Dcm_NetConnRefOptType lConnHdl = 0u;
    uint32 lMask;

    /* Enter critical section (Reason: Protect against interrupts from Dcm_SetDeauthenticatedRole() API) */
    Dcm_UtiEnterCriticalSection();
    /*=================================*
     BEGIN CRITICAL SECTION
     *=================================*/
    lMask = Dcm_SingletonContext.AuthMgr.PendingData.ConnectionMask;

    DCM_UTI_LOOP_BIT_SCAN(lMask)
    {
      if (Dcm_UtiBitOpTest(uint32, lMask, 0x01u))
      {
        Dcm_CfgNetAuthInfoRefMemType lAuthInfoRef = Dcm_NetGetAuthInfoRef(lConnHdl);

        if (Dcm_AuthMgrAuthenticationState(lAuthInfoRef) == DCM_DEAUTHENTICATED)
        {
          Dcm_AuthMgrUpdateActiveRole(lAuthInfoRef, Dcm_SingletonContext.AuthMgr.PendingData.Role[lAuthInfoRef]);
        }
      }

      ++lConnHdl;
    }

    Dcm_SingletonContext.AuthMgr.PendingData.ConnectionMask = 0u;
    /*=================================*
     END CRITICAL SECTION
     *=================================*/
    /* Leave critical section */
    Dcm_UtiLeaveCriticalSection();
  }
}

/**********************************************************************************************************************
 *  Dcm_AuthMgrSetPendingRole()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrSetPendingRole(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_CfgStateGroupMemType pendingRole
  )
{
  if (Dcm_DebugDetectRuntimeError(authInfoRef >= DCM_CFGAUTHMGRNETCONNINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    Dcm_SingletonContext.AuthMgr.PendingData.Role[authInfoRef] = pendingRole;                                                                        /* SBSW_DCM_ARRAY_WRITE_PENDINGROLEDATA */
  }
}
# endif
#endif /* (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_NetIsKeepAliveTimeStartOnFunc3E80Enabled()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsKeepAliveTimeStartOnFunc3E80Enabled(
  void
  )
{
  return (DCM_NET_KEEP_ALIVE_TIME_START_ON_FUNC_3E_80_ENABLED == STD_ON);                                                                            /* PRQA S 2995, 2996 */ /* MD_Dcm_ConstExpr */
}
/**********************************************************************************************************************
 *  Dcm_NetIsRxPduIdValid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsRxPduIdValid(
  PduIdType rxPduId
  )
{
  boolean lResult = TRUE;

  if( (rxPduId >= Dcm_PbCfgNetNumRxPduIds)
#if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
    ||(Dcm_NetGetConnHdlOfRxPduId(rxPduId) >= Dcm_PbCfgNetNumConnections)
#endif
    )
  {
    lResult = FALSE;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetIsTxPduIdValid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsTxPduIdValid(
  PduIdType txPduId
  )
{
  boolean lResult = TRUE;

  if( (txPduId >= Dcm_PbCfgNetNumTxPduIds)
#if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
    ||(Dcm_NetGetConnHdlOfTxPduId(txPduId) >= Dcm_PbCfgNetNumConnections)
#endif
    )
  {
    lResult = FALSE;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetGetComMContext()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_NetComMContextPtrType, DCM_CODE) Dcm_NetGetComMContext(
  Dcm_CfgNetNetIdRefOptType index
  )
{
  Dcm_NetComMContextPtrType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= Dcm_PbCfgNetNumComMChannels))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = &Dcm_PbRamNetComMContext[0];
  }
  else
  {
    lResult = &Dcm_PbRamNetComMContext[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetGetBufferContext()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_NetBufferContextPtrType, DCM_CODE) Dcm_NetGetBufferContext(
  Dcm_CfgNetBufferRefOptType index
  )
{
  Dcm_NetBufferContextPtrType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= Dcm_PbCfgNetNumBuffers))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = &Dcm_PbRamNetBufferContext[0];
  }
  else
  {
    lResult = &Dcm_PbRamNetBufferContext[index];
  }

  return lResult;
}

#if (DCM_NET_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetSetComControlChannelState()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetSetComControlChannelState(
  uint8_least index,
  Dcm_CommunicationModeType value
  )
{
  if(Dcm_DebugDetectRuntimeError(index >= Dcm_PbCfgNetNumAllComMChannels))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    Dcm_PbRamNetComCtrlChannels[index] = value;                                                                                                      /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_WRITE_COMCONTROLCHANNEL */
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetPutToConn2TObjMap()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPutToConn2TObjMap(
  Dcm_NetConnRefOptType index,
  Dcm_CfgNetTObjHandleMemType value
  )
{
  if(Dcm_DebugDetectRuntimeError(index >= Dcm_PbCfgNetNumConnections))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    Dcm_PbRamNetConnHdl2TObjMap[index] = value;                                                                                                      /* SBSW_DCM_POINTER_WRITE_TOBJHANDLE */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetWriteAddBufferU8At()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetWriteAddBufferU8At(
  Dcm_NetTransportObjectPtrType pTranspObj,
  uint8_least index,
  Dcm_MsgItemType value
  )
{
  if(Dcm_DebugDetectRuntimeError(index >= DCM_NET_TOBJ_ADDBUFFER_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    pTranspObj->AddBuffer[index] = value;                                                                                                            /* SBSW_DCM_POINTER_WRITE_TOBJ_ADDBUFFER */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetGetBufferInfo()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_PbCfgNetBufferInfoPtrType, DCM_CODE) Dcm_NetGetBufferInfo(
  Dcm_CfgNetBufferRefOptType index
  )
{
  Dcm_PbCfgNetBufferInfoPtrType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= Dcm_PbCfgNetNumBuffers))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = &Dcm_PbCfgNetBufferInfo[0];
  }
  else
  {
    lResult = &Dcm_PbCfgNetBufferInfo[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetCommonInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetCommonInit(
  void
  )
{
  Dcm_SingletonContext.Network.NumActiveConnections = 0u;
  Dcm_SingletonContext.Network.ActiveProtocol = DCM_NET_INVALID_PROTID;
  Dcm_SingletonContext.Network.ActiveDiagnostic = DCM_NET_COMM_ACTIVE;
#if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.RxAllowed = TRUE;
#endif
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.KeepAlive = FALSE;
#endif
}

/**********************************************************************************************************************
 *  Dcm_NetComMInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetComMInit(
  void
  )
{
  Dcm_CfgNetNetIdRefOptType lNetHandleIter;

  for(lNetHandleIter = 0; lNetHandleIter < Dcm_PbCfgNetNumComMChannels; ++lNetHandleIter)
  {
    Dcm_NetComMContextPtrType pComMContext;

    pComMContext = Dcm_NetGetComMContext(lNetHandleIter);

    pComMContext->ComState           = DCM_NET_COMM_STATE_RX_DIS_TX_DIS;                                                                             /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
    pComMContext->RegisteredNetworks = 0u;                                                                                                           /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetBufferInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetBufferInit(
  void
  )
{
  Dcm_CfgNetBufferRefOptType lBufferIter;

  for(lBufferIter = 0; lBufferIter < Dcm_PbCfgNetNumBuffers; ++lBufferIter)
  {
    Dcm_NetBufferContextPtrType pBufferContext;

    pBufferContext = Dcm_NetGetBufferContext(lBufferIter);

    pBufferContext->IsInUseCnt = 0u;                                                                                                                 /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetConnectionInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetConnectionInit(
  void
  )
{
  Dcm_NetConnRefOptType lConnIter;

  for(lConnIter = 0; lConnIter < Dcm_PbCfgNetNumConnections; ++lConnIter)
  {
    Dcm_NetPutToConn2TObjMap(lConnIter, DCM_NET_INVALID_TOBJID);
  }
}

/**********************************************************************************************************************
 *  Dcm_NetTranspObjInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTranspObjInit(
  void
  )
{
  Dcm_CfgNetTObjHandleOptType lTObjIter;

  for(lTObjIter = 0; lTObjIter < Dcm_PbCfgNetNumTransportObjects; ++lTObjIter)
  {
    Dcm_NetTransportObjectPtrType pTranspObj;

    pTranspObj = Dcm_NetGetTransportObject(lTObjIter);

    pTranspObj->ResType  = DCM_NET_TOBJ_RESTYPE_NONE;                                                                                                /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    pTranspObj->State    = DCM_NET_TOBJ_STATE_FREE;                                                                                                  /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    pTranspObj->Flags    = DCM_NET_TOBJ_FLAG_NONE;                                                                                                   /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    Dcm_NetWriteAddBufferU8At(pTranspObj, 0, 0x7Fu); /* always used for negative responses */                                                        /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    pTranspObj->Handle   = (Dcm_CfgNetTObjHandleMemType)lTObjIter;                                                                                   /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
  }
}

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgInit(
  void
  )
{
  /* Initialize periodic transmission manager state machine */
  Dcm_NetPeriodicMsgResetConnection();
  Dcm_NetPeriodicMsgInitDelayCntr();
  Dcm_NetPeriodicMsgInitFastestRate();
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  {
    /* Initialization of delay timers */
    uint8_least lDelayTmrIter;
    for (lDelayTmrIter = 0; lDelayTmrIter < DCM_NET_DELAY_BULK_TRANSMISSION; ++lDelayTmrIter)
    {
      Dcm_NetDelayTimerSet(lDelayTmrIter, 0);
    }

    Dcm_NetPeriodicMsgResetNextDelayTimer();
  }
# endif
  {
    Dcm_CfgNetPTxObjHandleOptType lPerTxObjIter;
    for(lPerTxObjIter = 0; lPerTxObjIter < Dcm_PbCfgNetNumPerTxObjects; ++lPerTxObjIter)
    {
      Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj;

      pPeriodicTxObj = Dcm_NetGetPeriodicTxObject(lPerTxObjIter);

      /* Initialize the transport object */
      pPeriodicTxObj->Timer = 0u;                                                                                                                    /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
      pPeriodicTxObj->State = DCM_NET_PERIODIC_TX_STATE_FREE;                                                                                        /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
      pPeriodicTxObj->TxPduInfo.SduDataPtr = pPeriodicTxObj->TxBuffer;                                                                               /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
    }
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetInit(
  void
  )
{
  /* First initialize common variables */
  Dcm_NetCommonInit();
  /* Now initialize all remaining network related sub-elements. The order of execution shall not be relevant */
  Dcm_NetComMInit();                                                                                                                                 /* PRQA S 2987 */ /* MD_Dcm_2987 */
  Dcm_NetBufferInit();
  Dcm_NetConnectionInit();                                                                                                                           /* PRQA S 2987 */ /* MD_Dcm_2987 */
  Dcm_NetTranspObjInit();
#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
  Dcm_NetPeriodicMsgInit();
#endif
}

/**********************************************************************************************************************
 *  Dcm_NetComposeAddNegResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetComposeAddNegResponse(                                                                                  /* COV_DCM_RTM_NO_RCR_RP_TX */
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_NetResponseType resType,
  Dcm_NegativeResponseCodeType nrc
  )
{
  Dcm_NetWriteAddBufferU8At(pTranspObj, 2, nrc); /* NRC = nrc, 0x7F and SID are already copied! */                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  pTranspObj->BuffInfo.SduDataPtr = pTranspObj->AddBuffer; /* use the temp buffer to free the main buffer now */                                     /* SBSW_DCM_PARAM_PTR_WRITE */
  pTranspObj->BuffInfo.SduLength  = 3u;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
  pTranspObj->ResType             = resType;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  pTranspObj->State               = DCM_NET_TOBJ_STATE_PREPTX;                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
}

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetOnRequestDetection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetOnRequestDetection(
  Dcm_NetConnRefMemType connHdl
  )
{
  Dcm_NetTransportObjectPtrType pTranspObj;
  BufReq_ReturnType             lBufReqResult;

  /* Retrieve the transport object from the given connection */
  lBufReqResult = Dcm_NetGetTranspObjOfConnection(connHdl, &pTranspObj);                                                                             /* SBSW_DCM_POINTER_FORWARD_STACK */

  /* Check whether a transport object is in use */
  if(lBufReqResult == BUFREQ_OK)
  {
    /* Enter critical section (Reason: the transport object may not be modified from outside (e.g. Dcm_TpTxConfirmation releases it) */
    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    /*  Retrieve again the transport object from connection to guarantee it has still the same state */
    lBufReqResult = Dcm_NetGetTranspObjOfConnection(connHdl, &pTranspObj);                                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */

    /* Check the connection still uses the same transport object (it is always 1:1 association between connection and a transport object) */
    if(lBufReqResult == BUFREQ_OK)                                                                                                                   /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
    {
      /* Check whether the connection is free */
      if(pTranspObj->State != DCM_NET_TOBJ_STATE_FREE)
      {
        /* Check if suppression of responses on functional addressed requests is enabled */
        if( (Dcm_NetIsPropertieSet(pTranspObj, DCM_NET_CONN_PROP_TX_ON_FUNC_RX))
          &&(Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE) )
        {
          /*
           * Interruption of functional addressed request is not necessary because response will already be
           * suppressed
           */
        }
        /* Otherwise, interrupt ongoing service processing */
        else
        {
          /* If a new request is being received: */
          if(pTranspObj->State == DCM_NET_TOBJ_STATE_ONRX)
          {
            /* Isolate this connection */
            pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_CANCELED;                                                                                         /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */

            /* Terminate the ongoing reception immediately */
            (void)PduR_DcmCancelReceive(pTranspObj->RxPduId);
          }
          /* Otherwise, let the task cancel any pending jobs */
          else
          {
            /* Mark transport object as obsolete. This is used to distinguish between two allocations of the same transport object before the Dcm_NetTaskTaMonitor is called */
            pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_OBSOLETE;                                                                                         /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
            Dcm_TskSetEvent(DCM_TSK_ID_NET_TA_MONITOR, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle));
          }
        }
      }/* else - nothing to interrupt */
    }/* else - request no more in progress -> ignore */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    /* Leave critical section */
    Dcm_UtiLeaveCriticalSection();
  }/* else - no request in progress or different tester -> ignore */
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

/**********************************************************************************************************************
 *  Dcm_NetExecStartProtocolOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetExecStartProtocolOp(
  Dcm_ProtocolType newProtocol
  )
{
  boolean      lResult = TRUE;
  uint16_least lIter;

  for (lIter = 0u; Dcm_CfgNetProtocolNotificationInfo[lIter].StartFunc != NULL_PTR; ++lIter)                                                         /* PRQA S 2842 */ /* MD_Dcm_DerefInvalidPointer */
  {
    if(Dcm_CfgNetProtocolNotificationInfo[lIter].StartFunc(newProtocol) != DCM_E_OK)                                                                 /* SBSW_DCM_CALL_FUNCPTR_TERMINATED_LIST */
    {
      lResult = FALSE;
      break;
    }
  }
  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetProcessStartProtocol()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetProcessStartProtocol(
  Dcm_NetTransportObjectPtrType pTranspObj
  )
{
  boolean startProtocolAllowed;

  startProtocolAllowed = Dcm_NetExecStartProtocolOp(Dcm_PbCfgNetProtocolInfo[Dcm_NetGetProtIdOfTranspObj(pTranspObj)].Id);
  if(startProtocolAllowed == FALSE)
  {
    Dcm_NetBufferContextPtrType pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
    /* Neg response 0x22 */
    Dcm_NetComposeAddNegResponse(pTranspObj
                                ,DCM_NET_TOBJ_RESTYPE_SIMPLE
                                ,DCM_E_CONDITIONSNOTCORRECT);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                               /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_USDT);
  }
  else
  {
#if (DCM_NET_PROTOCOL_PARALLELISATION_ENABLED == STD_ON)
    if( (Dcm_NetGetThreadIdOfTranspObj(pTranspObj) == DCM_THREAD_ID_BASIC)
      ||(Dcm_StateGetPendingSession() != DCM_STATE_VALUE_SESSION_INIT) )
#endif
    {
      if(Dcm_DiagIsCancellationNeeded(pTranspObj) == TRUE)                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      {
        Dcm_DiagCancelProcessing(pTranspObj);                                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */

        /* According to AR DCM SWS the session switch is executed at start protocol, not at stop! */
        Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF);
      }/* else - no protocol enabled -> no need to reset anything in case that parallelization is not enabled */
    }

#if (DCM_NET_PROTOCOL_PARALLELISATION_ENABLED == STD_ON)
    if(Dcm_NetGetThreadIdOfTranspObj(pTranspObj) == DCM_THREAD_ID_BASIC)
#endif
    {
      Dcm_SingletonContext.Network.ActiveProtocol = Dcm_NetGetProtIdOfTranspObj(pTranspObj); /* Set new active protocol */
    }

    /* Update P2 timings at once */
    Dcm_DiagSetP2Timings(0, Dcm_NetGetProtIdOfTranspObj(pTranspObj), Dcm_NetGetThreadIdOfTranspObj(pTranspObj));

    Dcm_DiagRxIndication(pTranspObj);                                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisationFindWinner()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetTObjHandleOptType, DCM_CODE) Dcm_NetRxPrioritisationFindWinner(
  Dcm_TskTaskEvOptType ev,
  Dcm_TskTaskEvPtrType pBusyEvents
  )
{
  Dcm_TskTaskEvOptType lEv = ev;
  uint16 lMaxPrio = 0x100u;/* lower than the lowest configurable priority (256 > 255) */

  Dcm_CfgNetTObjHandleOptType lTObjCntr = 0u;
  Dcm_CfgNetTObjHandleOptType lTranspObjWinnerId = DCM_NET_INVALID_TOBJID;

  *pBusyEvents = 0;                                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */

  DCM_TSK_EVENT_SCAN_LOOP(lEv)
  {
    /* Scan all arrived transport objects */
    if (Dcm_TskIsLocalEventSet(lEv, 0x01u)) /* start scan from the LSB since TObjects are allocated by reversed iteration and thus -> first allocated (last checked here) will be the winner */
    {
      uint8 tmpProtPrio = Dcm_NetGetProtObjOfTranspObj(Dcm_NetGetTransportObject(lTObjCntr))->Priority;

      /* Higher priority */
      if(lMaxPrio <= tmpProtPrio)
      {
        /* Lower priority than current request/pending response */
        *pBusyEvents |= Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, lTObjCntr);                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      else
      {
        if(lTranspObjWinnerId < DCM_NET_INVALID_TOBJID)
        {
          /* Mark busy for the last winner */
          *pBusyEvents |= Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, lTranspObjWinnerId);                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
        }

        /* Update maximum priority */
        lMaxPrio = tmpProtPrio;

        /* potential winner found */
        lTranspObjWinnerId = lTObjCntr;
      }
    }
    ++lTObjCntr;
  }
  return lTranspObjWinnerId;
}

/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisationProcessWinner()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRxPrioritisationProcessWinner(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_TskTaskEvPtrType pBusyEvents
  )
{
  if(Dcm_NetGetProtIdOfActiveProtocol() != Dcm_NetGetProtIdOfTranspObj(pTranspObj))/* the winner is a different protocol as the old one -> interrupt the old protocol */
  {
    if( (Dcm_NetGetProtIdOfActiveProtocol() >= DCM_NET_INVALID_PROTID) /* very first protocol activation - start the protocol/send NRC 0x21 responses */
      ||(Dcm_PbCfgNetProtocolInfo[Dcm_NetGetProtIdOfTranspObj(pTranspObj)].Priority
         < Dcm_PbCfgNetProtocolInfo[Dcm_NetGetProtIdOfActiveProtocol()].Priority) /* new one is higher priority */
      ||( (((DCM_DIAG_QUEUE_FLAG_IS_ACTIVE | DCM_DIAG_QUEUE_FLAG_IS_WAITING)
            & pContext->Thread->Diag.QueuedSet.Flags) == 0u ) /* if idle or post-processing (considered for back-to-back requests) ... */
        &&((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) != 0u) ) /* ... still default session - continue with new request */
      )
    {
      Dcm_NetProcessStartProtocol(pTranspObj);                                                                                                       /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    }
    else
    {
      /* Mark busy for the winner */
      *pBusyEvents |= Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle);                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
  else /* same protocol - proceed with the new request/NRC 0x21 responses */
  {
    Dcm_DiagRxIndication(pTranspObj);                                                                                                                /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisationProcessLoosers()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRxPrioritisationProcessLoosers(
  Dcm_TskTaskEvOptType BusyEvents
  )
{
  Dcm_CfgNetTObjHandleOptType lTObjCntr = 0u;
  Dcm_TskTaskEvOptType        lBusyEvents = BusyEvents;

  DCM_TSK_EVENT_SCAN_LOOP(lBusyEvents)
  {
    /* Check who did just loose */
    if (Dcm_TskIsLocalEventSet(lBusyEvents, 0x01u))
    {
      Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTransportObject(lTObjCntr);
      Dcm_NetBufferContextPtrType pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);

      Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                             /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
#if (DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      pTranspObj->Flags |= (Dcm_NetTransportObjectFlagType)(DCM_NET_TOBJ_FLAG_BUSY | DCM_NET_TOBJ_FLAG_IGNORE);                                      /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_USDT);
#else
# if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
      if ((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) == 0u) /* internal requests do not manage the ComM state */
# endif
      {
        Dcm_NetUnRegisterComMActivity(pTranspObj->ConnHdl);
      }
      Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                               /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
#endif
    }
    ++lTObjCntr;
  }
}

/**********************************************************************************************************************
 *  Dcm_NetRegisterActiveConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRegisterActiveConnection(
  Dcm_NetTransportObjectPtrType pTranspObj                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) == 0u)/* internal requests do not manage the S3 timer */
#endif
  {
    Dcm_DebugAssert((Dcm_SingletonContext.Network.NumActiveConnections != Dcm_UtiMaxValueOfUintType(uint8)), DCM_SID_INTERNAL, DCM_E_PARAM);         /* COV_DCM_RTM_DEV_DEBUG XF */

    /* Enter critical section (Reason: protect the statistic counter against parallel request notifications or transmission confirmations, executed from within interrupts ) */
    Dcm_UtiEnterCriticalSection();
    /*=================================*
     BEGIN CRITICAL SECTION
     *=================================*/
    /* Reset the idle connection deauthentication timer for this connection */
#if (DCM_AUTHMGR_DEFAULT_SESSION_TIMEOUT_ENABLED == STD_ON)
    /* Check if authentication restriction is supported for this connection */
    if(Dcm_NetGetAuthInfoRef(pTranspObj->ConnHdl) != DCM_AUTHMGR_INVALID_AUTH_INFO_REF)
    {
      Dcm_AuthMgrTimerReset(Dcm_NetGetAuthInfoRef(pTranspObj->ConnHdl));
    }
#endif

    if(Dcm_SingletonContext.Network.NumActiveConnections == 0u)
    {
      Dcm_TmrStopTimer(DCM_TMR_ID_S3);
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
      Dcm_TmrStopTimer(DCM_TMR_ID_KEEP_ALIVE);
#endif
    }

    /* Register a new active connection */
    ++Dcm_SingletonContext.Network.NumActiveConnections;
    /*=================================*
     END CRITICAL SECTION
     *=================================*/
    Dcm_UtiLeaveCriticalSection();
  }
}

/**********************************************************************************************************************
 *  Dcm_NetTransmitUsdtResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTransmitUsdtResponse(
  Dcm_NetTransportObjectPtrType pTranspObj
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  boolean doCallTxConfirmation = TRUE;

  /* The Tx path must be still "ready" here. if not, check the caller - it shall take care about this state! */
  Dcm_DebugAssert((pTranspObj->State == DCM_NET_TOBJ_STATE_PREPTX), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                          /* COV_DCM_RTM_DEV_DEBUG XF */

  /* Prepare the given transport object for USDT response transmission (set all relevant attributes to their initial values) */
  pTranspObj->BuffPos = 0u;                                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  pTranspObj->State = DCM_NET_TOBJ_STATE_ONTX;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

  /* If the USDT response shall be suppressed for any non-diagnostic but transport protocol reasons (e.g. no response on functional requests or no TxPduId configured), do: */
  if( (Dcm_NetIsPropertieSet(pTranspObj, DCM_NET_CONN_PROP_TX_ON_FUNC_RX))
    &&(Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE)
#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
    &&(pTranspObj->ResType != DCM_NET_TOBJ_RESTYPE_UNSOLICITED)
#endif
    )
  {
    lStdResult = DCM_E_OK; /* No response on functional requests required -> leave with success */
  }
  else if (Dcm_NetIsPropertieSet(pTranspObj, DCM_NET_CONN_PROP_NO_MAIN_TX))
  {
    lStdResult = DCM_E_OK; /* No associated TxPduId -> leave with success */
  }
  else
  {
    /* Otherwise, if the communication mode on the ComM channel associated with the transport object still allows any response transmissions: */
    if((DCM_NET_COMM_STATE_FLAG_TX_EN & Dcm_NetGetComStateByTranspObject(pTranspObj)) != 0u)
    {
      PduInfoType    lTpTransmitData;
#if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
      uint8          lMetaData[DCM_NET_METADATA_LENGTH];
#endif

#if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
      /* In case of generic connection, the transmit data references the meta data, otherwise, it references the payload. */
      if(Dcm_NetIsGenericConnection(pTranspObj->ConnHdl))
      {
        lMetaData[DCM_NET_METADATA_SA_OFFSET] = Dcm_NetGetNodeAddress(pTranspObj->ConnHdl);                                                          /* SBSW_DCM_LOCAL_ARRAY_WRITE */
        lMetaData[DCM_NET_METADATA_TA_OFFSET] = (uint8)pTranspObj->ClientSrcAddr; /* safe cast, since ClientSrcAddr is source address of MetaData because ConnHdl is generic */ /* SBSW_DCM_LOCAL_ARRAY_WRITE */
        lTpTransmitData.SduDataPtr = &lMetaData[0];
      }
      else
#endif
      {
        lTpTransmitData.SduDataPtr = pTranspObj->BuffInfo.SduDataPtr;
      }

      /* The length of the Sdu does not consider the meta data. */
      lTpTransmitData.SduLength = pTranspObj->BuffInfo.SduLength;

      lStdResult = PduR_DcmTransmit(Dcm_PbCfgNetConnectionInfo[pTranspObj->ConnHdl].TxPduIdMain
                                   ,&lTpTransmitData);                                                                                               /* SBSW_DCM_POINTER_FORWARD_STACK */

      /* If this transmission request was accepted, wait for the Tx-Confirmation from the XxxTp */
      if(lStdResult == E_OK)
      {
        doCallTxConfirmation = FALSE;
      }
    }
  }
  /* Otherwise, take the shortcut and loop-back through the USDT message confirmation with failed result (this response had to be sent, but couldn't and no retry is allowed (SWS)) */

  /* Make a loop-back and finalize transmission */
  if(doCallTxConfirmation == TRUE)
  {
    Dcm_NetUsdtTxConfirmation(pTranspObj, lStdResult);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}

#if (DCM_NET_CONN_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetLockConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetLockConnection(
  Dcm_NetConnRefMemType connHdl,
  CONSTP2VAR(Dcm_NetTransportObjectPtrType, AUTOMATIC, AUTOMATIC) pTranspObj
  )
{
  BufReq_ReturnType lResult;

  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Try allocating a new or getting an already allocated transport object */
  lResult = Dcm_NetAllocateOrGetTranspObject(connHdl, pTranspObj);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lResult == BUFREQ_OK)
  {
    if((*pTranspObj)->State == DCM_NET_TOBJ_STATE_FREE)
    {
      Dcm_NetBufferContextPtrType pBufferContext;

      /* Setup the transport object */
      (*pTranspObj)->ConnHdl = connHdl;                                                                                                              /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
      (*pTranspObj)->BufferHdl = Dcm_NetGetProtObjOfConnection(connHdl)->RxTxBufferRef;                                                              /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */

      pBufferContext = Dcm_NetGetBufferContext((*pTranspObj)->BufferHdl);

      /* Is the buffer still free ? */
      if(Dcm_NetBufferIsFree(pBufferContext))
      {
        Dcm_NetBufferLock(pBufferContext); /* the buffer is in use now */                                                                            /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
        (*pTranspObj)->State = DCM_NET_TOBJ_STATE_RESERVED;                                                                                          /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        lResult = BUFREQ_OK;
      }
      else
      {
        Dcm_NetTranspObjRelease(*pTranspObj);                                                                                                        /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        lResult = BUFREQ_E_NOT_OK;
      }
    }
    else
    {
      lResult = BUFREQ_E_NOT_OK;
    }
  }/* else - nothing found to be free */
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiLeaveCriticalSection();

  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndicationNotOk()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndicationNotOk(
  Dcm_NetTransportObjectPtrType pTranspObj
  )
{
#if (DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) == 0u) /* consider only real buffer usage */                                                       /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
#endif
  {
    Dcm_NetBufferContextPtrType pBufferContext;

    pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);

    Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                               /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
  }
  Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
}

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndicationOk()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndicationOk(
  Dcm_NetTransportObjectPtrType pTranspObj
  )
{
#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) != 0u) /* CancelReceive was called before -> ignore request although reception couldn't be canceled */
  {
    Dcm_NetBufferContextPtrType pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
    Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                               /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
#endif
  {
    boolean keepTranspObj;
    keepTranspObj = Dcm_DiagAcceptNewRequest(pTranspObj);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
    pTranspObj->State = DCM_NET_TOBJ_STATE_RX_END;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */

    if(keepTranspObj == TRUE)
    {
      Dcm_NetRegisterComMActivity(pTranspObj);                                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
#if (DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) != 0u)
      {
        Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_USDT);
      }
      else
#endif
      {
        /* Store SID for RCR-RP/busy on protocol prioritisation responses */
        Dcm_NetWriteAddBufferU8At(pTranspObj, 1u, pTranspObj->RxData[0]);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
        /* Signal processing start */
        Dcm_TskSetEventByThread(DCM_TSK_ID_NET_RX, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle), Dcm_NetGetThreadIdOfTranspObj(pTranspObj)); /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */
      }
    }
    else
    {
      if (Dcm_NetIsKeepAliveTimeStartOnFunc3E80Enabled())
      {
        if ((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_IGNORE) == 0u)
        {
          /* Register at ComM */
          Dcm_NetRegisterComMActivity(pTranspObj);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
          Dcm_SingletonContext.Network.KeepAlive = TRUE;
          /* Unregister at ComM */
          Dcm_NetUnRegisterComMActivity(pTranspObj->ConnHdl);
        }
      }
      Dcm_NetTpRxIndicationNotOk(pTranspObj);                                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetDelayTimerGet()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_TmrTimerCntrOptType, DCM_CODE) Dcm_NetDelayTimerGet(
  uint8_least timer
  )
{
  return Dcm_SingletonContext.Network.PeriodicTxContext.DelayTimer[timer];
}
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetDelayTimerSet()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetDelayTimerSet(
  uint8_least timer,
  Dcm_TmrTimerCntrOptType timeout
  )
{
  if (Dcm_DebugDetectRuntimeError(timer >= DCM_NET_DELAY_BULK_TRANSMISSION))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    Dcm_SingletonContext.Network.PeriodicTxContext.DelayTimer[timer] = (Dcm_TmrTimerCntrMemType)timeout;                                             /* SBSW_DCM_POINTER_WRITE_DELAYTIMER */
  }
}
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetDelayTimerExpired()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetDelayTimerExpired(
  uint8_least timer
  )
{
  return (boolean)(Dcm_SingletonContext.Network.PeriodicTxContext.DelayTimer[timer] == 0u);                                                          /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxObjTimerSet()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxObjTimerSet(
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj,
  Dcm_TmrTimerCntrMemType timeout
  )
{
  Dcm_SplitTaskEnterCS();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  pPeriodicTxObj->Timer = timeout;                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_SplitTaskLeaveCS();
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxObjTimerStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxObjTimerStart(
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj,
  Dcm_TmrTimerCntrMemType timeout
  )
{
  Dcm_NetPTxObjTimerSet(pPeriodicTxObj, timeout);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

  if (!Dcm_TmrIsTimerRunning(DCM_TMR_CONTEXT_ID_PERIODIC_TX))
  {
    Dcm_TmrStartTimer(DCM_TMR_ID_PERIODIC_TX, 1u);
  }
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxObjTimerStop()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxObjTimerStop(
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj
  )
{
  Dcm_NetPTxObjTimerSet(pPeriodicTxObj, 0u);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
}
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgIncNextDelayTimer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgIncNextDelayTimer(
  void
  )
{
  ++Dcm_SingletonContext.Network.PeriodicTxContext.NextDelayTimer;
  if (Dcm_NetPeriodicMsgGetNextDelayTimer() >= DCM_NET_DELAY_BULK_TRANSMISSION)
  {
    Dcm_NetPeriodicMsgResetNextDelayTimer();
  }
}
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgSetFastestRate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgSetFastestRate(
  Dcm_Svc2ASchedRateOptType Rate
  )
{
  /* If the new rate differs from the previous rate */
  if (Dcm_NetPeriodicMsgGetFastestRate() != Rate)
  {
    Dcm_TmrTimerCntrMemType lRateDiff;
    uint8_least lDelayTmrIter;

    /* If changing to a faster rate */
    if (Rate > Dcm_NetPeriodicMsgGetFastestRate())
    {
      lRateDiff = (Dcm_TmrTimerCntrMemType) ( Dcm_NetGetPeriodicDelayTime(Dcm_NetPeriodicMsgGetFastestRate())
                                            - Dcm_NetGetPeriodicDelayTime(Rate) );

      for (lDelayTmrIter = 0; lDelayTmrIter < DCM_NET_DELAY_BULK_TRANSMISSION; ++lDelayTmrIter)
      {
        /*=================================*
          BEGIN CRITICAL SECTION
         *=================================*/
        Dcm_SplitTaskEnterCS(); /* Protect against interrupt from timer task */
        /* If delay timer is set */
        if (Dcm_NetDelayTimerExpired(lDelayTmrIter) == FALSE)
        {
          if (Dcm_NetDelayTimerGet(lDelayTmrIter) <= lRateDiff)
          {
            Dcm_NetDelayTimerSet(lDelayTmrIter, 1); /* immediate timeout */
          }
          else
          {
            /* decrease timer value by rate difference */
            Dcm_NetDelayTimerSet(lDelayTmrIter, (Dcm_TmrTimerCntrOptType)(Dcm_NetDelayTimerGet(lDelayTmrIter) - lRateDiff));
          }
        }
        Dcm_SplitTaskLeaveCS();
        /*=================================*
          END CRITICAL SECTION
         *=================================*/
      }
    }
    else /* Otherwise (changing to a slower rate) */
    {
      lRateDiff = (Dcm_TmrTimerCntrMemType) ( Dcm_NetGetPeriodicDelayTime(Rate)
                                            - Dcm_NetGetPeriodicDelayTime(Dcm_NetPeriodicMsgGetFastestRate()) );

      for (lDelayTmrIter = 0; lDelayTmrIter < DCM_NET_DELAY_BULK_TRANSMISSION; ++lDelayTmrIter)
      {
        /*=================================*
          BEGIN CRITICAL SECTION
         *=================================*/
        Dcm_SplitTaskEnterCS(); /* Protect against interrupt from timer task */
        /* If delay timer is set */
        if (Dcm_NetDelayTimerExpired(lDelayTmrIter) == FALSE)
        {
          /* increase timer value by rate difference */
          Dcm_NetDelayTimerSet(lDelayTmrIter, (Dcm_TmrTimerCntrOptType)(Dcm_NetDelayTimerGet(lDelayTmrIter) + lRateDiff));
        }
        Dcm_SplitTaskLeaveCS();
        /*=================================*
          END CRITICAL SECTION
         *=================================*/
      }
    }

    Dcm_SingletonContext.Network.PeriodicTxContext.FastestRate = (Dcm_Svc2ASchedRateMemType)Rate;
  }
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxDelayTimerStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxDelayTimerStart(
  void
  )
{
  Dcm_NetDelayTimerSet(Dcm_NetPeriodicMsgGetNextDelayTimer()
                      ,Dcm_NetGetPeriodicDelayTime(Dcm_NetPeriodicMsgGetFastestRate()));
  Dcm_NetPeriodicMsgIncNextDelayTimer();

  /* Make sure system timer for periodic tx is running */
  Dcm_TmrStartTimer(DCM_TMR_ID_PERIODIC_TX, 1u);
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutTxObjectHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_OnTimeoutTxObjectHandler(
  void
  )
{
  Dcm_CfgNetPTxObjHandleOptType lPerTxObjIter;
  boolean                       lReloadTimer = FALSE;

  for(lPerTxObjIter = 0; lPerTxObjIter < Dcm_PbCfgNetNumPerTxObjects; ++lPerTxObjIter)
  {
    Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj;

    pPeriodicTxObj = Dcm_NetGetPeriodicTxObject(lPerTxObjIter);
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    Dcm_UtiEnterCriticalSection(); /* protect against high level interrupts from the network interface */
    if(!Dcm_NetPTxObjTimerExpired(pPeriodicTxObj))
    {
      Dcm_NetPTxObjTimerSet(pPeriodicTxObj, (Dcm_TmrTimerCntrMemType)(Dcm_NetPTxObjTimerGet(pPeriodicTxObj) - 1u));                                  /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
      if(Dcm_NetPTxObjTimerExpired(pPeriodicTxObj))
      {
        (void)PduR_DcmCancelTransmit(Dcm_NetPeriodicMsgGetTxPduIdCurrConn(lPerTxObjIter)); /* try to cancel still ongoing Tx */                      /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */
        Dcm_NetPeriodicMsgRelease(pPeriodicTxObj);                                                                                                   /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
      }
      else
      {
        lReloadTimer = TRUE; /* at least one active timer - reload timer */
      }
    }
    Dcm_UtiLeaveCriticalSection();
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
  }

  return lReloadTimer;
}
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutDelayTimerHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_OnTimeoutDelayTimerHandler(
  void
  )
{
  uint8_least lDelayTmrIter;
  boolean     lReloadTimer = FALSE;
  boolean     lSetTxEvent = FALSE;
  for(lDelayTmrIter = 0; lDelayTmrIter < DCM_NET_DELAY_BULK_TRANSMISSION; ++lDelayTmrIter)
  {
    if(Dcm_NetDelayTimerExpired(lDelayTmrIter) == FALSE)
    {
      Dcm_NetDelayTimerSet(lDelayTmrIter, (Dcm_TmrTimerCntrOptType)(Dcm_NetDelayTimerGet(lDelayTmrIter)-1u));
      if(Dcm_NetDelayTimerExpired(lDelayTmrIter) == TRUE)
      {
        Dcm_NetPeriodicMsgIncDelayCntr();
        lSetTxEvent = TRUE;
      }
      else
      {
        lReloadTimer = TRUE; /* at least one active timer - reload timer */
      }
    }
  }

  if (lSetTxEvent == TRUE)
  {
    Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_UUDT);
  }

  return lReloadTimer;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetGetPeriodicTxObject()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_NetPeriodicTxObjectPtrType, DCM_CODE) Dcm_NetGetPeriodicTxObject(
  Dcm_CfgNetPTxObjHandleOptType index
  )
{
  Dcm_NetPeriodicTxObjectPtrType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= Dcm_PbCfgNetNumPerTxObjects))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = &Dcm_PbRamNetPeriodicTxObject[0];
  }
  else
  {
    lResult = &Dcm_PbRamNetPeriodicTxObject[index];
  }

  return lResult;
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgResetConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgResetConnection(
  void
  )
{
  Dcm_NetPeriodicMsgResetNextMsgHdl();
  Dcm_NetPeriodicMsgResetTxObjectSentCntr();
  Dcm_NetPeriodicMsgSetConnection(DCM_NET_INVALID_CONNHDL);
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgStopDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgStopDid(
  uint16 Did
  )
{
  Dcm_CfgNetPTxObjHandleOptType lPerTxObjIter;
  for (lPerTxObjIter = 0; lPerTxObjIter < Dcm_NetPeriodicMsgGetNextMsgHdl(); lPerTxObjIter++)
  {
    Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj;

    pPeriodicTxObj = Dcm_NetGetPeriodicTxObject(lPerTxObjIter);

    if (  (pPeriodicTxObj->State != DCM_NET_PERIODIC_TX_STATE_FREE)
       && (pPeriodicTxObj->Did == Did))
    {
      /*=================================*
        BEGIN CRITICAL SECTION
       *=================================*/
      Dcm_UtiEnterCriticalSection(); /* Enter critical section (Reason: Protect against high level interrupts from the network interface) */
      switch (pPeriodicTxObj->State)
      {
        case DCM_NET_PERIODIC_TX_STATE_ONTX:
          (void)PduR_DcmCancelTransmit(Dcm_NetPeriodicMsgGetTxPduIdCurrConn(lPerTxObjIter)); /* try to cancel still ongoing Tx */                    /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */
          /* fall through */
        case DCM_NET_PERIODIC_TX_STATE_RESERVED:                                                                                                     /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
        case DCM_NET_PERIODIC_TX_STATE_QUEUED:
# endif
          Dcm_NetPeriodicMsgRelease(pPeriodicTxObj);                                                                                                 /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
          break;
        default:
          /* nothing to do */
          break;
      }
      Dcm_UtiLeaveCriticalSection();
      /*=================================*
        END CRITICAL SECTION
       *=================================*/
    }
  }
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgGetTxBuffer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_MsgType, DCM_CODE) Dcm_NetPeriodicMsgGetTxBuffer(
  Dcm_CfgNetPTxObjHandleOptType perTxObjHandle
  )
{
  return Dcm_NetGetPeriodicTxObject(perTxObjHandle)->TxBuffer;
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgTransmitTxObj()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgTransmitTxObj(
  Dcm_CfgNetPTxObjHandleOptType perTxObjHandle
  )
{
  Std_ReturnType lStdResult;
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj;

  pPeriodicTxObj = Dcm_NetGetPeriodicTxObject(perTxObjHandle);

  if ((DCM_NET_COMM_STATE_FLAG_TX_EN & Dcm_NetGetComStateByConnection(Dcm_NetPeriodicMsgGetConnection())) != 0u)
  {
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
    if (Dcm_NetPeriodicMsgGetDelayCntr() == 0u)
    {
      /* Retry sending */
      lStdResult = DCM_E_OK;
    }
    else
# endif
    {
      P2CONST(PduInfoType, AUTOMATIC, PDUR_APPL_DATA) pPduInfo;

      Dcm_NetPeriodicMsgDecDelayCntr();

      pPeriodicTxObj->State = DCM_NET_PERIODIC_TX_STATE_ONTX;                                                                                        /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
      /* Note: In case the following two lines are not executed within 100ms, the timeout may occur before the message
       * was sent (only if split tasks used). This may lead to inconsistent periodic data, since the transmitted
       * message is free to be reused again while it is on transmission. The design avoiding this very rare scenario
       * will increase the software complexity unnecessarily. Entering such conditions means that the ECU is not
       * capable of holding the periodic rates too.
       */
      Dcm_NetPTxObjTimerStart(pPeriodicTxObj, Dcm_PbCfgNetConnectionInfo[Dcm_NetPeriodicMsgGetConnection()].PeriodicTxConfTimeout);                  /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */

      pPduInfo = &(pPeriodicTxObj->TxPduInfo);
      lStdResult = PduR_DcmTransmit(Dcm_NetPeriodicMsgGetTxPduIdCurrConn(perTxObjHandle), pPduInfo);                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }
  else
  {
    lStdResult = DCM_E_NOT_OK;
  }

  if(lStdResult != DCM_E_OK)
  {
    /* Do not retry transmission -> make a loop-back and finalize transmission */
    Dcm_NetPeriodicMsgRelease(pPeriodicTxObj);                                                                                                       /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetIsPduInfoValid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsPduInfoValid(
  P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info
  )
{
  boolean lResult;

  if(info == NULL_PTR)
  {
    lResult = FALSE;
  }
  else if( (info->SduLength  != 0u)
         &&(info->SduDataPtr == NULL_PTR) )
  {
    lResult = FALSE;
  }
  else
  {
    lResult = TRUE;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetCopyRxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyRxData(
  Dcm_NetTransportObjectPtrType pTranspObj,
  P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info,
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr
  )
{
  BufReq_ReturnType lResult  = BUFREQ_E_NOT_OK;                                                                                                      /* PRQA S 2981 */ /* MD_Dcm_RetVal */
  uint8             lErrorId = DCM_E_NO_ERROR;

  /* If the XxxTp (e.g. CanTp or FrTp) requests Dcm to copy any data: */
  if(info->SduLength != 0u) /* any payload now? */
  {
    /* ----- Development Error Checks -------------------------------------- */
    if (Dcm_DebugDetectError(pTranspObj->BuffPos >= pTranspObj->RxLength))
    {
      lErrorId = DCM_E_PARAM;
    }
    else if(Dcm_DebugDetectError(((PduLengthType)(pTranspObj->RxLength) - (PduLengthType)(pTranspObj->BuffPos)) < info->SduLength))
    {
      lErrorId = DCM_E_PARAM;
    }
    else
    {
      /* ----- Implementation ---------------------------------------------- */
#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
      /* If connection has been yet canceled (if RxPath supports cancellation), do return failed copy data result */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) != 0u)
      {
        lResult = BUFREQ_E_NOT_OK;
      }
      else
#endif
      {

        /* If the transmission is for a main-client (full request reception), do copy the data portion provided by the XxxTp */
#if (DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
        if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) != 0u)
        {
          /* For the very first call of this function for this request reception, do copy the request head (SID and SubFunction) for later usage (i.e. for 0x3E 0x80 detection) */
          if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_COPYHEAD) != 0u)
          {
            Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, DCM_NET_TOBJ_FLAG_COPYHEAD);  /* Toggle flag for next calls to not extract any SID/SUBSID data */ /* SBSW_DCM_PARAM_PTR_WRITE */
            Dcm_NetWriteAddBufferU8At(pTranspObj, 1, info->SduDataPtr[0]); /* copy the SID */                                                        /* PRQA S 2822 */ /* MD_Dcm_2822 */ /* SBSW_DCM_PARAM_PTR_FORWARD */
            Dcm_NetWriteAddBufferU8At(pTranspObj, 2, info->SduDataPtr[1]); /* copy the SUBSID */                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
          }
        }
        else
#endif
        {
          Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;

          lBufferInfo = Dcm_NetGetBufferInfo(pTranspObj->BufferHdl);

          Dcm_UtiMemCopySafe(info->SduDataPtr
                            ,lBufferInfo->BufferPtr
                            ,pTranspObj->BuffPos
                            ,lBufferInfo->Size
                            ,info->SduLength);                                                                                                       /* SBSW_DCM_POINTER_WRITE_BUFFERINFO */
        }
        /* Update the transport object's buffer-copy-progress */
        pTranspObj->BuffPos += (Dcm_CfgNetBufferSizeMemType)(info->SduLength);                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

        /* Report the remaining available DCM buffer size to the XxxTp */
        *bufferSizePtr = (PduLengthType)(pTranspObj->RxLength) - (PduLengthType)(pTranspObj->BuffPos);                                               /* SBSW_DCM_PARAM_PTR_WRITE */
        lResult = BUFREQ_OK;
      }
    }
    /* Otherwise if connection has been canceled, return negative result to signal the XxxTp to abort the transmission (if RxPath supports cancellation) */
  }
  else
  {
    /* Otherwise, the XxxTp requests Dcm only to report the available buffer size  */
    *bufferSizePtr = (PduLengthType)(pTranspObj->RxLength) - (PduLengthType)(pTranspObj->BuffPos); /* Notify lower layer about available buffer space */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = BUFREQ_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_COPYRXDATA, lErrorId);

  return lResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndication(
  PduIdType rxPduId,
  Std_ReturnType result
  )
{
  Dcm_NetTransportObjectPtrType pTranspObj;
  BufReq_ReturnType             lBufReqResult;
  lBufReqResult = Dcm_NetGetTranspObjOfConnection(Dcm_NetGetConnHdlOfRxPduId(rxPduId), &pTranspObj);                                                 /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_FORWARD_STACK */

  /* If no transport object has been associated with this connection yet, do ignore this indication */
  if(lBufReqResult == BUFREQ_OK)
  {
    /* Otherwise, if the transport object is determined to belong to the expected request, that means: */
    if( (pTranspObj->State == DCM_NET_TOBJ_STATE_ONRX) /* expected state for Rx indication? */
      &&(rxPduId == pTranspObj->RxPduId) ) /* Consider also any nested request on different TP connection but from the same tester! */
    {
      if(result != DCM_NET_ARENV_NTFRSLT_OK)
      {
        Dcm_NetTpRxIndicationNotOk(pTranspObj);                                                                                                      /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
      }
      else
      {
        Dcm_NetTpRxIndicationOk(pTranspObj);                                                                                                         /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
      }
    }/* Otherwise, just ignore this call since this API call is most probably due to a (concurrent request (i.e. 0x3E 0x80) from the same tester) OR
      * (indication of unexpected connection) */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetCopyLinearTxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyLinearTxData(
  Dcm_NetTransportObjectPtrType pTranspObj,
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info ,                                                                                                /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr
  )
{
  BufReq_ReturnType lResult  = BUFREQ_E_NOT_OK;                                                                                                      /* PRQA S 2981 */ /* MD_Dcm_RetVal */
  uint8             lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError( (info->SduLength != 0u)
                         &&(pTranspObj->BuffPos >= pTranspObj->BuffInfo.SduLength) ))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError((PduLengthType)(pTranspObj->BuffInfo.SduLength - pTranspObj->BuffPos) < info->SduLength))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    /* Copy requested amount of data to the XxxTp */
    Dcm_UtiMemCopySafe(&(pTranspObj->BuffInfo.SduDataPtr[pTranspObj->BuffPos])
                      ,info->SduDataPtr
                      ,0u
                      ,info->SduLength
                      ,info->SduLength);                                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
    /* Update Tx-buffer read progress */
    pTranspObj->BuffPos += (Dcm_CfgNetBufferSizeMemType)(info->SduLength);                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */

    /* Report remaining amount of data in the Tx-buffer */
    *availableDataPtr = (PduLengthType)(pTranspObj->BuffInfo.SduLength - pTranspObj->BuffPos);                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = BUFREQ_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_COPYTXDATA, lErrorId);

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetCopyTxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyTxData(
  Dcm_NetTransportObjectPtrType pTranspObj,
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info ,                                                                                                /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr
  )
{
  BufReq_ReturnType lResult;

  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) != 0u)
  {
    lResult = BUFREQ_E_NOT_OK;
  }
  else
  {
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
    if(pTranspObj->ResType == DCM_NET_TOBJ_RESTYPE_PAGED)
    {
      lResult = Dcm_PagedBufferCopyData(pTranspObj, info, availableDataPtr);                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
#endif
    {
      lResult = Dcm_NetCopyLinearTxData(pTranspObj, info, availableDataPtr);                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }

  return lResult;
}
/**********************************************************************************************************************
 *  Dcm_RepeaterNextStep()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_RepeaterNextStep(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_RepeaterProgressType nextStep
  )
{
  pContext->Thread->Repeater.Contexts.Progress    = nextStep;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  pContext->Thread->Repeater.Contexts.SubProgress = DCM_REPEATER_PROGRESS_INITIAL;                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */

  Dcm_RepeaterResetOpStatus(pContext);                                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
}

/**********************************************************************************************************************
 *  Dcm_CfgDiagServiceInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgDiagServiceInfoGetEntry(
  uint8_least SidIndex,
  CONSTP2VAR(Dcm_CfgDiagServiceInfoPtrType, AUTOMATIC, AUTOMATIC) pServiceInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if (Dcm_DebugDetectRuntimeError(SidIndex >= DCM_CFGDIAGSERVICEINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pServiceInfo = &Dcm_CfgDiagServiceInfo[SidIndex];                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}
#if (DCM_MODE_COMMCTRL_ENABLED == STD_ON) || \
    (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeInit(
  void
  )
{
  /* Initialize ControlDTCsetting internal mode */
  Dcm_ModeSetControlDtcSettingGroup(DEM_DTC_GROUP_ALL_DTCS);
  Dcm_ModeSetControlDtcSettingMode(RTE_MODE_DcmControlDtcSetting_ENABLEDTCSETTING);

# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
  /* Initialize CommunicationControl internal mode */
  {
    uint8_least channelIter;
    for(channelIter = 0; channelIter < Dcm_PbCfgNetNumAllComMChannels; ++channelIter)
    {
      Dcm_ModeSetCommControlState(channelIter, DCM_ENABLE_RX_TX_NORM_NM);
    }
  }
# endif
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
  Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.LastDisableDTCClientID = DCM_NET_DEFAULT_DEM_CLIENTID;
# endif
}
#endif

#if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgModeMgrRulesGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgModeMgrRulesGetEntry(
  Dcm_CfgModeMgrRuleRefOptType modeRuleRef,
  CONSTP2VAR(Dcm_ModeRuleFuncType, AUTOMATIC, AUTOMATIC) pModeRuleFunc,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if (Dcm_DebugDetectRuntimeError(modeRuleRef >= DCM_CFGMODEMGRRULES_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pModeRuleFunc = Dcm_CfgModeMgrRules[modeRuleRef];                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}
#endif

#if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeCheck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeCheck(
  Dcm_CfgModeMgrRuleRefOptType modeRuleRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType       lStdReturn;
  Dcm_ModeRuleFuncType lModeRuleFunc;

  /* Retrieve mode rule verification handler */
  lStdReturn = Dcm_CfgModeMgrRulesGetEntry(modeRuleRef, &lModeRuleFunc, ErrorCode);                                                                  /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lStdReturn == DCM_E_OK)                                                                                                                        /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    Dcm_NegativeResponseCodeType lNrc = DCM_E_CONDITIONSNOTCORRECT;/* default NRC in case no rule specifies any NRC */

    /* Execute the mode-rule handler and return the result */
    if (lModeRuleFunc(&lNrc) == FALSE)                                                                                                               /* SBSW_DCM_CALL_FUNCPTR_MODEMGRRULES */
    {
      *ErrorCode = lNrc;                                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
  }

  return lStdReturn;
}
#endif

#if (DCM_MODE_CTRLDTCSETTING_MONITOR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeMonitorControlDtcSetting()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeMonitorControlDtcSetting(
  Dcm_TskEventContextPtrType pEventContext
  )
{
  Dcm_NegativeResponseCodeType lNrc;/* the value is not used, just the standard API requires it */
  Dcm_ModeRuleFuncType         lModeRuleFunc;
  Std_ReturnType               lResult;

  lResult = Dcm_CfgModeMgrRulesGetEntry(DCM_MODE_CTRLDTCSETTING_MONITOR_MODERULE_REF, &lModeRuleFunc, &lNrc);                                        /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lResult == DCM_E_OK)                                                                                                                           /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    if (lModeRuleFunc(&lNrc) == TRUE)                                                                                                                /* SBSW_DCM_CALL_FUNCPTR_MODEMGRRULES */
    {
      Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_MODE_MON_SVC85);                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      /* fire and forget */
      (void)Dcm_Svc85EnableDtcSetting(Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.LastDisableDTCClientID);
    }
  }
}
#endif

#if (DCM_MODE_COMMCTRL_MONITOR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeMonitorCommunicationControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeMonitorCommunicationControl(
  Dcm_TskEventContextPtrType pEventContext
  )
{
  Dcm_NegativeResponseCodeType lNrc;/* the value is not used, just the standard API requires it */
  Dcm_ModeRuleFuncType         lModeRuleFunc;
  Std_ReturnType               lResult;

  lResult = Dcm_CfgModeMgrRulesGetEntry(DCM_MODE_COMMCTRL_MONITOR_MODERULE_REF, &lModeRuleFunc, &lNrc);                                              /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lResult == DCM_E_OK)                                                                                                                           /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    if (lModeRuleFunc(&lNrc) == TRUE)                                                                                                                /* SBSW_DCM_CALL_FUNCPTR_MODEMGRRULES */
    {
      Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_MODE_MON_SVC28);                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      Dcm_Svc28EnableCommunication();
    }
  }
}
#endif

#if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)   || \
    (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckResultInterpreter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckResultInterpreter(
  Std_ReturnType modeSwitchAckResult
  )
{
  Std_ReturnType lStdResult;

  switch(modeSwitchAckResult)
  {
  case RTE_E_TRANSMIT_ACK:
    /* switch accomplished */
    lStdResult = DCM_E_OK;
    break;
  case RTE_E_NO_DATA:
    lStdResult = DCM_E_PENDING;
    break;
  default: /* any error situation */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
#endif

#if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckEcuReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckEcuReset(
  void
  )
{
  Std_ReturnType lStdResult;

  lStdResult = Rte_SwitchAck_DcmEcuReset_DcmEcuReset();

  return Dcm_ModeSwitchAckResultInterpreter(lStdResult);
}
#endif

#if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckRapidShutDown()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckRapidShutDown(
  void
  )
{
  Std_ReturnType lStdResult;

  lStdResult = Rte_SwitchAck_DcmModeRapidPowerShutDown_DcmModeRapidPowerShutDown();

  return Dcm_ModeSwitchAckResultInterpreter(lStdResult);
}
#endif

#if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchEcuReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchEcuReset(
  Rte_ModeType_DcmEcuReset mode
  )
{
  Std_ReturnType lStdResult;

  lStdResult = Rte_Switch_DcmEcuReset_DcmEcuReset(mode);

  return lStdResult;
}
#endif

#if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchRapidShutDown()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchRapidShutDown(
  Rte_ModeType_DcmModeRapidPowerShutDown mode
  )
{
  Std_ReturnType lStdResult;

  lStdResult = Rte_Switch_DcmModeRapidPowerShutDown_DcmModeRapidPowerShutDown(mode);

  return lStdResult;
}
#endif
/**********************************************************************************************************************
 *  Dcm_StateInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateInit(
  void
  )
{
  Dcm_SingletonContext.StateMgr.Preconditions.Session  = DCM_STATE_VALUE_SESSION_INIT;
#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  Dcm_SingletonContext.StateMgr.Preconditions.Security = DCM_STATE_VALUE_SECURITY_INIT;
#endif
  Dcm_StateSyncPendingSession();
}

/**********************************************************************************************************************
 *  Dcm_StateExecOnStateChangeFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateExecOnStateChangeFunc(
  Dcm_CfgStateNotificationInfoPtrType notifList,                                                                                                     /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  uint8 formerStateId,
  uint8 newStateId
  )
{
  Dcm_CfgStateNotificationInfoPtrType lNotifList = notifList;
  /* Iterate over all with the diagnostic state group state change related notifications, as long as the EndOfList marker is not reached */
  while (lNotifList->OnChgFunc != NULL_PTR)
  {
    /* Invoke the configured notification function */
    lNotifList->OnChgFunc(formerStateId, newStateId);                                                                                                /* SBSW_DCM_PARAM_FUNCPTR_CALL */
    Dcm_UtiNextItemByPtr(lNotifList, 1u);/* take next function */
  }
}

#if (DCM_STATE_SECURITY_LOOKUP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateFindStateIndexFromSecLevel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(sint8_least, DCM_CODE) Dcm_StateFindStateIndexFromSecLevel(
  Dcm_SecLevelType secLevel
  )
{
  sint8_least lResult;

  /* If "locked" level: */
  if(secLevel == DCM_SEC_LEV_LOCKED)
  {
    /* Return the only possible index - 0 */
    lResult = 0;
  }
  else
  {
    /* Otherwise locate the index of the security level value in the security info table */
    uint8_least lSecLvlIter;

    lResult = -1;
    for(lSecLvlIter = 0; lSecLvlIter < DCM_STATE_SECURITY_NUM_LEVELS; ++lSecLvlIter)
    {
      if (Dcm_CfgStateSecurityInfo[lSecLvlIter].Value == secLevel)
      {
        /* Found the correct index into the table - compensate zero offset for locked level */
        lResult = (sint8_least)((sint16_least)lSecLvlIter + 1);
        break;
      }
    }
    /* If the security level is not found, return -1 */
  }
  return lResult;
}
#endif

#if ((DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)  &&  (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON))
/**********************************************************************************************************************
 *  Dcm_StateVsgGetSecurityFixedByteStateIdx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_StateVsgGetSecurityFixedByteStateIdx(
  P2VAR(sint32_least, AUTOMATIC, DCM_APPL_DATA) pStateIndex
  )
{
  Std_ReturnType lStdResult;
  Dcm_CfgVarMgrDiagVariantIdOptType varRowIter;
  Dcm_VsgSizeType lNumberOfFixedBytes;
  sint32_least lRefToVsg;

  lRefToVsg = (sint32) Dcm_StateGetVsgMaskInfoIdx(*pStateIndex);
  lStdResult = DCM_E_NOT_OK;

  /* If there is any Securtiy Level with more than 1 security fixed byte configured */
  lNumberOfFixedBytes = Dcm_StateGetNumberOfVsgs((uint16)(*pStateIndex));                                                                            /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */

  /* Iterate over all securtiy fixed bytes that are assigned to referenced security level */
  /* If lNumberOfFixedBytes is 0 -> no security fixed byte is configured for securtiy level */
  for (; lNumberOfFixedBytes > 0u; --lNumberOfFixedBytes)
  {
    varRowIter = Dcm_VarMgrBitSetCalcSize(DCM_VARMGR_NUM_CFG_VARIANTS);

    /* scan all variants (at least 8 way scan) for at least one match */
    do
    {
      --varRowIter;
      if ((Dcm_CfgStateVsgMaskSecurityFixedByte[lRefToVsg][varRowIter] & Dcm_SingletonContext.VarMgr.ActiveCfgVariants[varRowIter]) != 0u)
      {
        lStdResult = DCM_E_OK;/* at least one matched variant */
        *pStateIndex = lRefToVsg;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
        break;
      }/* else - continue searching */
    } while (varRowIter != 0u);                                                                                                                      /* PRQA S 2993 */ /* MD_Dcm_ConstExpr */

    /* If security level is assigned to active VSG */
    if (lStdResult == DCM_E_OK)
    {
      /* stop iterating over fixed bytes */
      break;
    }

    ++lRefToVsg;                                                                                                                                     /* PRQA S 2983 */ /* MD_Dcm_Redundant_2983 */
  }

  return lStdResult;
}
#endif

#if (DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateGetSecurityLevelFixedBytes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_StateGetSecurityLevelFixedBytes(
  Dcm_SecLevelType secLevel,
  P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) fixedBytes,
  P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) bufferSize
  )
{
  Std_ReturnType  lResult;
  sint32_least    lStateIdx;

  lStateIdx = Dcm_StateFindStateIndexFromSecLevel(secLevel);
  if (lStateIdx <= 0)
  {
    /* Locked, or unsupported security level */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    uint8 lFixedByteSize;
    --lStateIdx; /* norm to zero index (excluded locked state offset) */

# if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
    lResult = Dcm_StateVsgGetSecurityFixedByteStateIdx(&lStateIdx);                                                                                  /* SBSW_DCM_POINTER_FORWARD_STACK */
    if (lResult == DCM_E_NOT_OK)
    {
      lFixedByteSize = 0;
      lResult = E_OK;
    }
    else
# endif
    {
      lFixedByteSize = (uint8)(Dcm_CfgStateSecurityFixedByteInfo[lStateIdx + 1]
                             - Dcm_CfgStateSecurityFixedByteInfo[lStateIdx + 0]);                                                                    /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */
      if (lFixedByteSize > *bufferSize)
      {
        lResult = DCM_E_BUFFERTOOLOW;
      }
      else
      {
        Dcm_UtiMemCopySafe(&Dcm_CfgStateSecurityFixedBytes[Dcm_CfgStateSecurityFixedByteInfo[lStateIdx]]
                          ,fixedBytes
                          ,0u
                          ,*bufferSize
                          ,lFixedByteSize);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
        lResult = E_OK;
      }
    }
    *bufferSize = lFixedByteSize;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  return lResult;
}
#endif

#if (DCM_STATE_NOTIFY_SVC_PRO_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateNotifyServiceProcessors()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateNotifyServiceProcessors(
  void
  )
{
  /* now process session/security state updates:
    - on any session transition: security is always changed
    - on security state transition: security is always changed
  */
# if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc27OnStateChanged();
# endif
# if (DCM_DIDMGR_DYNDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
  Dcm_Svc2COnStateChanged();
# endif
# if (DCM_DIDMGR_PERIODICDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
  Dcm_Svc2AOnStateChanged();
# endif
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
  Dcm_Svc2FOnStateChanged();
# endif
}
#endif
/**********************************************************************************************************************
 *  Dcm_TmrGetTimerInfo()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_TmrTimerInfoPtrType, DCM_CODE) Dcm_TmrGetTimerInfo(
  Dcm_TmrTimerIdOptType index
  )
{
  Dcm_TmrTimerInfoPtrType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= DCM_TMR_NUM_TIMERS_CASTED))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = &Dcm_TmrTimerInfo[0];
  }
  else
  {
    lResult = &Dcm_TmrTimerInfo[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_TmrGetTimerContext()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_TmrTimerContextPtrType, DCM_CODE) Dcm_TmrGetTimerContext(
  Dcm_TmrTimerIdOptType index
  )
{
  Dcm_TmrTimerContextPtrType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= DCM_TMR_NUM_TIMER_CONTEXTS_CASTED))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = &Dcm_SingletonContext.TimerMgr.TimerContext[0];
  }
  else
  {
    lResult = &Dcm_SingletonContext.TimerMgr.TimerContext[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_TmrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TmrInit(
  void
  )
{
  Dcm_TmrTimerIdMemType  lTimerInfoIter;
  Dcm_TmrTimerIdOptType  lTimerContextIter;

  lTimerInfoIter    = DCM_TMR_NUM_TIMERS_CASTED - 1u;
  lTimerContextIter = DCM_TMR_NUM_TIMER_CONTEXTS_CASTED;

  do
  {
    --lTimerContextIter;

    Dcm_SingletonContext.TimerMgr.TimerContext[lTimerContextIter].TimerInfoRef = lTimerInfoIter;                                                     /* SBSW_DCM_LOOP */

#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
    if(Dcm_TmrTimerInfo[lTimerInfoIter].TimerContextRef == lTimerContextIter)
#endif
    {
      --lTimerInfoIter;
    }
  }
  while(lTimerContextIter != 0u);

  Dcm_SingletonContext.TimerMgr.ControlMask = 0; /* mark all timers as not running */
}
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgRidMgrOpInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgRidMgrOpInfoGetEntry(
  Dcm_CfgRidMgrOpHandleOptType ridOpInfoIdx,
  CONSTP2VAR(Dcm_RidMgrOpInfoPtrType, AUTOMATIC, AUTOMATIC) pRidOpInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if (Dcm_DebugDetectRuntimeError(ridOpInfoIdx >= DCM_CFGRIDMGROPINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pRidOpInfo = &Dcm_CfgRidMgrOpInfo[ridOpInfoIdx];                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_RidMgrExecuteRoutine()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrExecuteRoutine(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc31RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType           lStdResult;
  Dcm_RidMgrOpInfoPtrType  pRidOpInfo;

  lStdResult = Dcm_CfgRidMgrOpInfoGetEntry(pRepContext->RidOpInfoIdx, &pRidOpInfo, ErrorCode);                                                       /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = Dcm_UtiMsgContextVerifySize(pMsgContext, pRidOpInfo->ResMaxLength, ErrorCode);                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)                                                                                                                       /* COV_DCM_RTM_RUNTIME_CHECK TX */
    {
      Dcm_RidMgrRidLengthType lReqResLen = (Dcm_RidMgrRidLengthType)(pMsgContext->reqDataLen - pRidOpInfo->ReqMinLength);

      /* Call appropriate function prototype */
      switch(pRidOpInfo->OpType)
      {
      case DCM_RIDMGR_OPTYPE_NONE:
        lStdResult = ((Dcm_RidMgrOpFuncNoParamsType)pRidOpInfo->OpFunc)(opStatus                                                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                       ,ErrorCode);                                                                  /* SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC */
        break;
      case DCM_RIDMGR_OPTYPE_REQ:
        lStdResult = ((Dcm_RidMgrOpFuncReqType)pRidOpInfo->OpFunc)(Dcm_UtiGetReqData(pMsgContext)                                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                  ,opStatus
                                                                  ,ErrorCode);                                                                       /* SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC */
        break;
      case DCM_RIDMGR_OPTYPE_REQ_RES:
        lStdResult = ((Dcm_RidMgrOpFuncReqResType)pRidOpInfo->OpFunc)(Dcm_UtiGetReqData(pMsgContext)                                                 /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                     ,opStatus
                                                                     ,Dcm_UtiGetResData(pMsgContext)                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                     ,ErrorCode);                                                                    /* SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC */
        break;
      case DCM_RIDMGR_OPTYPE_RES:
        lStdResult = ((Dcm_RidMgrOpFuncResType)pRidOpInfo->OpFunc)(opStatus                                                                          /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                  ,Dcm_UtiGetResData(pMsgContext)                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                  ,ErrorCode);                                                                       /* SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC */
        break;
      case DCM_RIDMGR_OPTYPE_REQ_DYNLEN:
        lStdResult = ((Dcm_RidMgrOpFuncReqDynLenType)pRidOpInfo->OpFunc)(Dcm_UtiGetReqData(pMsgContext)                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                        ,opStatus
                                                                        ,lReqResLen
                                                                        ,ErrorCode);                                                                 /* SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC */
        break;
      case DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES:
        lStdResult = ((Dcm_RidMgrOpFuncReqDynLenResType)pRidOpInfo->OpFunc)(Dcm_UtiGetReqData(pMsgContext)                                           /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                           ,opStatus
                                                                           ,Dcm_UtiGetResData(pMsgContext)                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                           ,lReqResLen
                                                                           ,ErrorCode);                                                              /* SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC */
        break;
      case DCM_RIDMGR_OPTYPE_RES_DYNLEN:
        lStdResult = ((Dcm_RidMgrOpFuncResDynLenType)pRidOpInfo->OpFunc)(opStatus                                                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                        ,Dcm_UtiGetResData(pMsgContext)                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                        ,&lReqResLen
                                                                        ,ErrorCode);                                                                 /* SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC */
        break;
      case DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES_DYNLEN:
        /* fall through */
      case DCM_RIDMGR_OPTYPE_REQ_RES_DYNLEN:                                                                                                         /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
        lStdResult = ((Dcm_RidMgrOpFuncReqAnyLenResDynLenType)pRidOpInfo->OpFunc)(Dcm_UtiGetReqData(pMsgContext)                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                 ,opStatus
                                                                                 ,Dcm_UtiGetResData(pMsgContext)                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                                 ,&lReqResLen
                                                                                 ,ErrorCode);                                                        /* SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC */
        break;
      case DCM_RIDMGR_OPTYPE_WRAPPER:
        lStdResult = ((Dcm_RidMgrOpFuncWrapperType)pRidOpInfo->OpFunc)(opStatus                                                                      /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                      ,pMsgContext
                                                                      ,&lReqResLen
                                                                      ,ErrorCode);                                                                   /* SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC */
        break;
      default:
        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG);                                                                                /* COV_DCM_RTM_DEV_DEBUG XF */
        break;
      }

      /* If the operation result is success: */
      if(lStdResult == DCM_E_OK)
      {
        /* Provide the data to the response message, including the variable length part */
        Dcm_UtiProvideResData(pMsgContext, Dcm_CfgRidMgrOpInfoResMinLength(pRepContext->RidOpInfoIdx));                                              /* SBSW_DCM_PARAM_PTR_FORWARD */

        if(pRidOpInfo->ResMinLength != pRidOpInfo->ResMaxLength)
        {
          Dcm_UtiProvideResData(pMsgContext, lReqResLen); /* Register response length of the last signal  */                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
      }

      /* Catch any RTE specific or unexpected errors in order to return a valid value to the core */
      if( (lStdResult != DCM_E_OK)
        &&(lStdResult != DCM_E_PENDING)
        &&(lStdResult != DCM_E_NOT_OK)
        &&(lStdResult != DCM_E_FORCE_RCRRP) )
      {
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }

      Dcm_UtiHandleApplNrc(lStdResult, ErrorCode, DCM_E_CONDITIONSNOTCORRECT);                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL */
/**********************************************************************************************************************
 *  Dcm_RidMgrGetOpInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrGetOpInfo(
  Dcm_CfgRidMgrInfoHandleOptType ridInfoIdx,
  Dcm_RidMgrOpType ridOp,
  Dcm_CfgRidMgrOpHandlePtrType pRidOpInfoIdx
  )
{
  Std_ReturnType lResult = DCM_E_NOT_OK;
  Dcm_RidMgrOpType lRidOp = ridOp;

  /* If the requested operation is supported at all */
  if ((Dcm_CfgRidMgrRidInfoOperations(ridInfoIdx) & lRidOp) != 0u)
  {
    Dcm_CfgRidMgrOpHandleOptType opHandle = Dcm_CfgRidMgrRidInfoOpBaseIdx(ridInfoIdx);
    do
    {
      lRidOp >>= 1;/* pre-decrement! */
      if ((Dcm_CfgRidMgrRidInfoOperations(ridInfoIdx) & lRidOp) != 0u)
      {
        ++opHandle;
      }
    }
    while (lRidOp != 0u);
    *pRidOpInfoIdx = opHandle;                                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_RidMgrRidLookUpFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrRidLookUpFilter(
  uint16 rid,
  Dcm_CfgRidMgrInfoHandleOptType ridInfoIdx
  )
{
  Std_ReturnType lStdReturn = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(rid);                                                                                                                       /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ridInfoIdx);                                                                                                                /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
# if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
  if (Dcm_VarMgrIsEnabledInActiveVariants(Dcm_CfgRidMgrRidInfoExecCondRef(ridInfoIdx)) == FALSE)                                                     /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
  {
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
  /* check session state */
  if (!Dcm_StateIsSupportedInSession(Dcm_StateGetPreconditionStates(Dcm_CfgRidMgrRidInfoExecCondRef(ridInfoIdx))))
  {
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  {
# if (DCM_SVC_31_OBD_CALIBRATION_ENABLED == STD_ON) && (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
    if( (rid >= (uint16)0xE000u)
      &&(rid <= (uint16)0xE1FFu) )
    {
      if(Dcm_ObdIdMgrIsIdEnabled(Dcm_UtiGetLoByte(rid),
                                     &Dcm_CfgSvc31SupportedIdMask[Dcm_CfgSvc31SupportedIdMaskOffset[Dcm_UtiGetHiByte(rid)-(uint8)0xE0u]]) == FALSE)  /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
      {
        lStdReturn = DCM_E_NOT_OK;
      }/* else - an enabled (WWH-)OBD RID */
    }/* else - a non (WWH-)OBD RID */
# endif
  }
  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_RidMgrRidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrRidLookUp(
  Dcm_OpStatusType opStatus,
  uint16 rid,
  Dcm_CfgRidMgrInfoHandlePtrType pRidInfoIdx
  )
{
  Std_ReturnType lStdReturn;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdReturn = DCM_E_OK;

# if (DCM_RIDMGR_EXTENDED_LOOKUP_ENABLED == STD_ON)
  if(opStatus == DCM_INITIAL)
# endif
  {
    sint16_least lResult;

    lResult = Dcm_UtiLookUpUint16(Dcm_CfgRidMgrRidLookUpTable, rid);                                                                                 /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
    if(lResult >= 0)
    {
      *pRidInfoIdx = (Dcm_CfgRidMgrInfoHandleOptType)lResult;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      lStdReturn = DCM_E_NOT_OK;
    }
  }

# if (DCM_RIDMGR_EXTENDED_LOOKUP_ENABLED == STD_ON)
  if(lStdReturn == DCM_E_OK)
  {
    /* If RID is suppressed by application filter: */
    lStdReturn = Dcm_FilterRidLookUpResult(opStatus, rid);

    /* If that was last call (DCM_CANCEL), skip any further processing and return any valid value */
    if(opStatus == DCM_CANCEL)
    {
      /* Skip any further processing */
      lStdReturn = DCM_E_NOT_OK;
    }

    /* Catch any unexpected errors in order to return a valid value to the core */
    if(Dcm_DebugDetectError( (lStdReturn != DCM_E_OK)
                           &&(lStdReturn != DCM_E_PENDING)
                           &&(lStdReturn != DCM_E_NOT_OK) ))
    {
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
      lStdReturn = DCM_E_NOT_OK;
    }
  }/* else - DCM_E_NOT_OK */
# endif

  if(lStdReturn == DCM_E_OK)
  {
    lStdReturn = Dcm_RidMgrRidLookUpFilter(rid, *pRidInfoIdx);
  }/* else - DCM_E_NOT_OK, DCM_E_PENDING */
  return lStdReturn;
}
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrSetNextStep()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ObdDtcMgrSetNextStep(
  Dcm_RepeaterProgressType NextStep,
  Dcm_ObdDtcManagerContextPtrType pRepContext
  )
{
  pRepContext->DcmObdDtcManagerProgress = NextStep;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
}

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrGetNextStep()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_RepeaterProgressType, DCM_CODE) Dcm_ObdDtcMgrGetNextStep(
  Dcm_ObdDtcManagerContextPtrType pRepContext                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  return pRepContext->DcmObdDtcManagerProgress;
}

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrDemGetNumFltrdDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrDemGetNumFltrdDtc(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_ObdDtcManagerContextPtrType pRepContext                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnGetNumberOfFilteredDTCType demResult;
  uint16 lNumDtc;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_DEM_API_421_ENABLED == STD_ON)
  demResult = Dcm_DemAPI(GetNumberOfFilteredDTC)(&lNumDtc);                                                                                          /* SBSW_DCM_POINTER_FORWARD_STACK */
# else
  demResult = Dcm_DemAPI(GetNumberOfFilteredDTC)(pRepContext->DemClientId
                                                ,&lNumDtc);                                                                                          /* SBSW_DCM_POINTER_FORWARD_STACK */
# endif

  switch(demResult)
  {
  case DCM_DEM_RET_NUMBER_OK:
    if(lNumDtc <= 0xFFu)
    {
      Dcm_UtiProvideResDataAsU8(pMsgContext, Dcm_UtiGetLoByte(lNumDtc));                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */ /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
      Dcm_PagedBufferStart(pMsgContext, (Dcm_MsgLenType)lNumDtc * 2u);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_STOP_REPEATER;
# else
      Dcm_ObdDtcMgrSetNextStep(DCM_OBDDTCMGR_PROGRESS_COPYLINEARDATA, pRepContext);                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_LOOP;
# endif
    }
    else
    {
      /* else - NRC 0x22 */
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    break;
  case DCM_DEM_RET_NUMBER_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:/* DEM_NUMBER_FAILED or unknown */
    *ErrorCode  = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_DemApiNrcMapGetNumberOfFilteredDTC);                                                 /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrCopyLinearData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrCopyLinearData(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_ObdDtcManagerContextPtrType pRepContext
  )
{
  Std_ReturnType           lStdResult;
  Dcm_DiagDataContextType  lDataContext;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  Dcm_UtiInitDataContext(&lDataContext, Dcm_UtiGetResData(pMsgContext), pMsgContext->resMaxDataLen);                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

  lStdResult = Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc(&lDataContext, ErrorCode, pRepContext);                                                             /* SBSW_DCM_COMB_PTR_FORWARD */

  /* Commit copied data */
  Dcm_UtiProvideResData(pMsgContext, lDataContext.Usage);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */

  switch (lStdResult)
  {
  case DCM_E_BUFFERTOOLOW:
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;/* for OBD send (suppress with) NRC 0x31 since 0x14 (ResponseTooLong is not defined!) */                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  case DCM_E_DATA_READY_PADDING:
    lStdResult = DCM_E_OK;
    break;
  default:
    /* ErrorCode already set */
    break;
  }

  return lStdResult;
}
# endif
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_InitContext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_InitContext(
  Dcm_ContextPtrType pContext,
  Dcm_ThreadIdOptType threadId
  )
{
  pContext->Thread = Dcm_GetThreadContext(threadId);                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
}

/**********************************************************************************************************************
 *  Dcm_GetThreadContext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_ThreadContextPtrType, DCM_CODE) Dcm_GetThreadContext(
  Dcm_ThreadIdOptType threadId
  )
{
  Dcm_ThreadContextPtrType pThreadContext;

  if (Dcm_DebugDetectRuntimeError(threadId >= DCM_NUM_THREADS))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    pThreadContext = &Dcm_ThreadContext[0];
  }
  else
  {
    pThreadContext = &Dcm_ThreadContext[threadId];
  }

  return pThreadContext;
}
/**********************************************************************************************************************
 *  Dcm_TskGetTaskInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_TskGetTaskInfo(
  Dcm_TskTaskIdOptType index,
  CONSTP2VAR(Dcm_TskTaskInfoPtrType, AUTOMATIC, AUTOMATIC) pTaskInfo
  )
{
  Std_ReturnType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= DCM_TSK_NUM_TASKS))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pTaskInfo = &Dcm_TskTaskInfo[index];                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_TskGetTaskContext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_TskGetTaskContext(
  Dcm_TskTaskIdOptType taskId,
  CONSTP2VAR(Dcm_TskTaskContextPtrType, AUTOMATIC, AUTOMATIC) pTaskContext
  )
{
  Std_ReturnType lResult;

  if(Dcm_DebugDetectRuntimeError(taskId >= DCM_TSK_NUM_TASKS_CONTEXT))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pTaskContext = &Dcm_SingletonContext.TaskMgr.TaskContext[taskId];                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

#if (DCM_TSK_TRACING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskRegisterActiveTask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskRegisterActiveTask(
  Dcm_TskTaskIdOptType taskId
  )
{
  /* Enter critical section (Reason: To guarantee safe reentrancy policy for the task stack when split-tasks interrupt each other.) */
  Dcm_SplitTaskEnterCS();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  if(Dcm_DebugDetectRuntimeError(Dcm_TskTraceIsFull()))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    Dcm_TskTraceTskPush(taskId);                                                                                                                     /* PRQA S 3387, 3440 */ /* MD_Dcm_OptimizedInlineCode_3387, MD_Dcm_OptimizedInlineCode_3440 */ /* SBSW_DCM_POINTER_WRITE_CURRENT_TASK_PRIO_STACK */
  }

  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_SplitTaskLeaveCS();
}
#endif

#if (DCM_TSK_TRACING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskUnRegisterActiveTask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskUnRegisterActiveTask(
  void
  )
{
  /* Enter critical section (Reason: To guarantee safe reentrancy policy for the task stack when split-tasks interrupt each other.) */
  Dcm_SplitTaskEnterCS();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  if(Dcm_DebugDetectRuntimeError(Dcm_TskTraceIsEmpty()))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    Dcm_TskTraceTskPop();                                                                                                                            /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_SplitTaskLeaveCS();
}
#endif

/**********************************************************************************************************************
 *  Dcm_TskGetSchedulerContext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_TskGetSchedulerContext(
  Dcm_TskTaskPrioOptType schedulerPrio,
  CONSTP2VAR(Dcm_TskSchedulerContextPtrType, AUTOMATIC, AUTOMATIC) pSchedulerContext
  )
{
  Std_ReturnType lResult;

  if(Dcm_DebugDetectRuntimeError(schedulerPrio >= DCM_TSK_NUM_PRIOS))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pSchedulerContext = &Dcm_SingletonContext.TaskMgr.TaskScheduler[schedulerPrio];                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_TskInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskInit(
  void
  )
{
  /* Initialize task activity tracer */
  Dcm_TskTraceInit();

  /* Initialize priority related states */
  {
    Dcm_TskTaskPrioOptType tskPrioIter;

    for(tskPrioIter = 0; tskPrioIter < DCM_TSK_NUM_PRIOS; ++tskPrioIter)
    {
      Dcm_TskSchedulerContextPtrType pSchedulerContext;

      if(Dcm_TskGetSchedulerContext(tskPrioIter, &pSchedulerContext) == DCM_E_OK)                                                                    /* COV_DCM_RTM_RUNTIME_CHECK TX */ /* SBSW_DCM_POINTER_FORWARD_STACK */
      {
        pSchedulerContext->SchdIsActive = FALSE;                                                                                                     /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_WRITE_SCHEDULERCONTEXT */
      }
    }
  }

  /* Initialize task related events */
  {
    Dcm_TskTaskIdOptType tskIter;

    for(tskIter = 0; tskIter < DCM_TSK_NUM_TASKS_CONTEXT; ++tskIter)
    {
      Dcm_TskTaskContextPtrType pTaskContext;

      if(Dcm_TskGetTaskContext(tskIter, &pTaskContext) == DCM_E_OK)                                                                                  /* COV_DCM_RTM_RUNTIME_CHECK TX */ /* SBSW_DCM_POINTER_FORWARD_STACK */
      {
        pTaskContext->TaskEvents = DCM_TSK_EV_NONE;                                                                                                  /* SBSW_DCM_POINTER_WRITE_TASKCONTEXT */
      }
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_TskKillTask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskKillTask(
  Dcm_TskTaskIdOptType tskIter
  )
{
  Dcm_TskTaskContextPtrType pTaskContext;

  if(Dcm_TskGetTaskContext(Dcm_TskTaskInfo[tskIter].TaskContextRef, &pTaskContext) == DCM_E_OK)                                                      /* COV_DCM_RTM_RUNTIME_CHECK TX */ /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    pTaskContext->TaskEvents &= Dcm_TskTaskInfo[tskIter].NonKillEvents; /* clear only killable events */                                             /* SBSW_DCM_POINTER_WRITE_TASKCONTEXT */

#if (DCM_TSK_TASK_COMPLEX_KILL_ENABLED == STD_ON)
    Dcm_TskSetFlag(pTaskContext, DCM_TSK_TASK_FLAG_KILLED);                                                                                          /* SBSW_DCM_POINTER_WRITE_TASKCONTEXT */
#endif
  }
}

/**********************************************************************************************************************
 *  Dcm_TskKillAllTasks()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskKillAllTasks(
  void
  )
{
  Dcm_TskTaskIdOptType tskIter;

  /* Enter critical section (Reason: A task event can be set during any ISR processing.) */
  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/

   for(tskIter = 0; tskIter < DCM_TSK_NUM_TASKS; ++tskIter)
   {
     if((Dcm_TskTaskInfo[tskIter].TskAtr & DCM_TSK_ATR_KILL_ALWAYS) != 0u)
     {
       Dcm_TskKillTask(tskIter);
     }
   }

  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiLeaveCriticalSection();
}

#if (DCM_TSK_TASK_COMPLEX_KILL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskReviveAllTasks()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskReviveAllTasks(
  void
  )
{
   Dcm_TskTaskIdOptType tskIter;

   /* Revive only basic thread since this is the only killable one */
   for(tskIter = 0; tskIter < DCM_TSK_NUM_TASKS; ++tskIter)
   {
     Dcm_TskTaskContextPtrType pTaskContext;

     if(Dcm_TskGetTaskContext(Dcm_TskTaskInfo[tskIter].TaskContextRef, &pTaskContext) == DCM_E_OK)                                                   /* COV_DCM_RTM_RUNTIME_CHECK TX */ /* SBSW_DCM_POINTER_FORWARD_STACK */
     {
       Dcm_TskClrFlag(pTaskContext, DCM_TSK_TASK_FLAG_KILLED);                                                                                       /* SBSW_DCM_POINTER_WRITE_TASKCONTEXT */
     }
   }
}
#endif

/**********************************************************************************************************************
 *  Dcm_TskExecuteActiveTask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskExecuteActiveTask(
  Dcm_TskTaskIdOptType taskId,
  Dcm_TskTaskEvOptType taskEv,
  Dcm_ThreadIdOptType threadId
  )
{
  Dcm_TskTaskInfoPtrType pTaskInfo;
  Std_ReturnType         lResult;

  lResult = Dcm_TskGetTaskInfo(taskId, &pTaskInfo);                                                                                                  /* SBSW_DCM_POINTER_FORWARD_STACK */

  if(lResult == DCM_E_OK)                                                                                                                            /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    Dcm_TskEventContextType  lEventContext;
    Dcm_ContextType          lContext;

    Dcm_InitContext(&lContext, threadId);                                                                                                            /* SBSW_DCM_POINTER_INIT_CONTEXT */

    lEventContext.Ev = (Dcm_TskTaskEvMemType)taskEv;
    lEventContext.PostEv = DCM_TSK_EV_NONE;

    /* Handle task execution: */
    do
    {
      /* Clear all already known global events */
      Dcm_TskClrEventByThread(taskId, lEventContext.Ev, threadId);

      /* Register the taskID to the task trace */
      Dcm_TskRegisterActiveTask(taskId);

      /* Execute the task */
      pTaskInfo->TskFunc(&lContext, &lEventContext);                                                                                                 /* SBSW_DCM_CALL_FUNCPTR_TASKINFO */ /* SBSW_DCM_COMB_PTR_FORWARD */

      /* Unregister the taskID from the task trace */
      Dcm_TskUnRegisterActiveTask();

      /* If the task supports multiple activations per scheduler invocation, do get any new events sent to this task */
      if((pTaskInfo->TskAtr & DCM_TSK_ATR_EXEC_MULTI) != 0u)
      {
        lEventContext.Ev = Dcm_TskGetEventByThread(taskId, threadId);
      }
      else
      {
        /* Otherwise do not re-activate the task in this scheduler invocation */
        lEventContext.Ev = DCM_TSK_EV_NONE;
      }
    }
    /* As long as the task needs the be re-activated */
    while (lEventContext.Ev != DCM_TSK_EV_NONE);

    /* Register any new events of the already finished task that are scheduled for its next activation */
    if(lEventContext.PostEv != DCM_TSK_EV_NONE)
    {
      Dcm_TskSetEventByThread(taskId, lEventContext.PostEv, threadId);
    }
  }
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
/**********************************************************************************************************************
 *  Dcm_DiagSetNewReqBaseToCurProgress()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetNewReqBaseToCurProgress(
  Dcm_MsgContextPtrType pMsgContext
  )
{
  if (Dcm_DebugDetectRuntimeError(pMsgContext->reqIndex >= pMsgContext->reqBufSize))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    pMsgContext->reqBufSize -= pMsgContext->reqIndex;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_UtiNextItemByPtr(pMsgContext->reqData, pMsgContext->reqIndex);                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
    pMsgContext->reqIndex = 0;                                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagSetQueuedTranspObj()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetQueuedTranspObj(
  Dcm_ThreadContextPtrType pThreadContext,                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NetTransportObjectPtrType pTranspObj                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  pThreadContext->Diag.QueuedSet.TObjHdl = pTranspObj->Handle;                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
#if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
  Dcm_UtiBitOpSet(Dcm_TskTaskEvMemType                                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
                 ,pThreadContext->Diag.QueuedSet.QueuedTObjects
                 ,Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle));                                                                 /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif
}

/**********************************************************************************************************************
 *  Dcm_DiagSetNewResBaseToCurProgress()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetNewResBaseToCurProgress(
  Dcm_MsgContextPtrType pMsgContext
  )
{
  if (Dcm_DebugDetectRuntimeError(pMsgContext->resIndex >= pMsgContext->resBufSize))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    pMsgContext->resBufSize -= pMsgContext->resIndex;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    pMsgContext->resMaxDataLen = pMsgContext->resBufSize;                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    pMsgContext->resProtHeadLen += pMsgContext->resDataLen;                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
    pMsgContext->resDataLen = 0;                                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_UtiNextItemByPtr(pMsgContext->resData, pMsgContext->resIndex);                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
    pMsgContext->resIndex = 0;                                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagGetPostProcessorFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcConfirmationFuncType, DCM_CODE) Dcm_DiagGetPostProcessorFunc(
  uint8_least index
  )
{
  Dcm_DiagSvcConfirmationFuncType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= DCM_CFGDIAGSVCPOSTPROCESSORS_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = Dcm_CfgDiagSvcPostProcessors[0];
  }
  else
  {
    lResult = Dcm_CfgDiagSvcPostProcessors[index];
  }

  return lResult;
}

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetUpdateFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcUpdateFuncType, DCM_CODE) Dcm_DiagGetUpdateFunc(
  uint8_least index
  )
{
  Dcm_DiagSvcUpdateFuncType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= DCM_CFGDIAGSVCUPDATERS_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = Dcm_CfgDiagSvcUpdaters[0];
  }
  else
  {
    lResult = Dcm_CfgDiagSvcUpdaters[index];
  }

  return lResult;
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetCancelFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcCancelFuncType, DCM_CODE) Dcm_DiagGetCancelFunc(
  uint8_least index
  )
{
  Dcm_DiagSvcCancelFuncType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= DCM_CFGDIAGSVCCANCELLERS_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = Dcm_CfgDiagSvcCancellers[0];
  }
  else
  {
    lResult = Dcm_CfgDiagSvcCancellers[index];
  }

  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInit(
  void
  )
{
#if (DCM_STATE_SECURITY_BYPASS_ENABLED == STD_ON)
  Dcm_SingletonContext.Diag.IsSecurityBypass = FALSE;
#endif

  /* Initialize all processors */
  {
    uint8_least lIter;

    for(lIter = 0u; Dcm_CfgDiagSvcInitializers[lIter] != NULL_PTR; ++lIter)                                                                          /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
    {
      Dcm_CfgDiagSvcInitializers[lIter]();                                                                                                           /* SBSW_DCM_CALL_FUNCPTR_TERMINATED_LIST */
    }
  }

  {
    Dcm_ThreadIdOptType lThreadIter;

    /* Initialize all P2 Timers */
    for(lThreadIter = 0u; lThreadIter < DCM_NUM_THREADS; ++lThreadIter)
    {
      Dcm_ThreadContextPtrType pThreadContext = Dcm_GetThreadContext(lThreadIter);

      pThreadContext->Diag.QueuedSet.Flags = DCM_DIAG_QUEUE_FLAG_NONE;                                                                               /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
#if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
      pThreadContext->Diag.QueuedSet.QueuedTObjects = 0;                                                                                             /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
#endif
      pThreadContext->Diag.State = DCM_DIAG_STATE_IDLE;                                                                                              /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */

      Dcm_DiagSetP2Timings(0, 0, pThreadContext->ThreadId);
    }
  }

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.RxAllowed = FALSE;
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_RECOVERY, DCM_TSK_EV_DIAG_RECOVERY_GETSTATE);
#endif

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
  /* Delegate to the first task activation */
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_FBLRES, DCM_TSK_EV_DIAG_FBLRES_SEND);
#endif
}

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagPutStartUpFblResBuffer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagPutStartUpFblResBuffer(
  uint8_least index,
  Dcm_MsgItemType value
  )
{
  if(Dcm_DebugDetectRuntimeError(index >= DCM_DIAG_START_UP_FBL_RES_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    Dcm_SingletonContext.Diag.StartUpFbl.ResBuffer[index] = value;                                                                                   /* SBSW_DCM_POINTER_WRITE_START_UP_FBL_RES_BUFFER */
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagExecConfirmationFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagExecConfirmationFunc(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_CfgDiagNotificationInfoPtrType notifList,                                                                                                      /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_ConfirmationStatusType confStatus
  )
{
  uint16_least lIter;

  for(lIter = 0u; notifList[lIter].ConfFunc != NULL_PTR; ++lIter)                                                                                    /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
  {
    (void)notifList[lIter].ConfFunc(pContext->Thread->Diag.PostProcessorContext.Sid
                                   ,pContext->Thread->Diag.PostProcessorContext.ReqType
                                   ,pContext->Thread->Diag.PostProcessorContext.SrcAddr
                                   ,confStatus);                                                                                                     /* SBSW_DCM_CALL_FUNCPTR_TERMINATED_LIST */
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagGetPostProcessResult()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_ConfirmationStatusType, DCM_CODE) Dcm_DiagGetPostProcessResult(
  Dcm_ContextPtrType pContext                                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_ConfirmationStatusType confStatus  = DCM_DIAG_RES_ANY_OK;

  if(pContext->Thread->Diag.TxStatus != DCM_E_OK)                                                                                                    /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
  {
    /* Set Tx error flag */
    confStatus |= DCM_DIAG_RES_ANY_NOT_OK;
  }

  if(pContext->Thread->Diag.ErrorRegister != DCM_E_POSITIVERESPONSE)
  {
    /* Set neg response flag */
    confStatus |= DCM_DIAG_RES_NEG_ANY;
  }
  return confStatus;
}

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetRecoverySignature()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(uint32, DCM_CODE) Dcm_DiagGetRecoverySignature(
  void
  )
{
  uint32 lResult;

  lResult = Dcm_PbCfgNetNumComMChannels;

# if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
  lResult |= Dcm_UtiMake32Bit(0u, 0u, Dcm_PbCfgNetNumAllComMChannels, 0u);                                                                           /* PRQA S 2985, 2986 */ /* MD_Dcm_Redundant_2985, MD_Dcm_Redundant_2986 */
# endif

  lResult |= Dcm_UtiMake32Bit(Dcm_UtiGetHiNibble(Dcm_PbCfgNetNumProtocols) /* Since at most 32 protocols are allowed the high nibble never exceeds 1 bit */ /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */
                             ,Dcm_UtiGetLoNibble(Dcm_PbCfgNetNumProtocols)
                             ,0u
                             ,0u);

  lResult |= Dcm_UtiGetBitFromIndex(uint32, 21u);

# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  lResult |= Dcm_UtiGetBitFromIndex(uint32, 22u);
# endif

# if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
  lResult |= Dcm_UtiGetBitFromIndex(uint32, 23u);
# endif

# if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
  lResult |= Dcm_UtiGetBitFromIndex(uint32, 24u);
# endif

# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
  lResult |= Dcm_UtiGetBitFromIndex(uint32, 25u);
# endif

  lResult |= Dcm_UtiMake32Bit(0x08, 0x00, 0u, 0u);

  lResult |= Dcm_UtiMake32Bit(0xA0, 0u, 0u, 0u);

  return lResult;
}
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagProvideRecoveryStates()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagProvideRecoveryStates(
  P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo
  )
{
  /* Retrieve ComM channel states */
  Dcm_CfgNetNetIdRefOptType lNetHandleIter;
  Dcm_RecoveryInfoComMChannelStatePtrType pChannelState;
  for(lNetHandleIter = 0; lNetHandleIter < Dcm_PbCfgNetNumComMChannels; ++lNetHandleIter)
  {
    pChannelState = Dcm_DiagGetRecoveryInfoComMChannelState(RecoveryInfo, lNetHandleIter);                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    *pChannelState = (boolean)(Dcm_PbRamNetComMContext[lNetHandleIter].RegisteredNetworks != 0u);                                                    /* SBSW_DCM_POINTER_WRITE_RECOVERYINFOCOMMCHANNELSTATE */ /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
  }

  /* Retrieve session state */
  RecoveryInfo->SessionLevel = Dcm_UtiGetBitPosition(Dcm_StateGetSession());                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */

  /* Retrieve session connection and tester */
  RecoveryInfo->SessionConnection = Dcm_NetGetSessionConnection();                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  RecoveryInfo->SessionClientSrcAddr = Dcm_NetGetSessionClientSrcAddr();                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */

  /* Retrieve active protocol */
  RecoveryInfo->ActiveProtocol = Dcm_NetGetProtIdOfActiveProtocol();                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */

  /* Retrieve security state */
# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
#  if (DCM_STATE_SECURITY_BYPASS_ENABLED == STD_ON)
  if(Dcm_SingletonContext.Diag.IsSecurityBypass == TRUE)
  {
    /* Store locked security */
    RecoveryInfo->SecurityLevel = 0u;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
#  endif
  {
    RecoveryInfo->SecurityLevel = Dcm_UtiGetBitPosition(Dcm_StateGetSecurity());                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
  }
# endif

  /* Retrieve DTC settings state */
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
#  if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
  RecoveryInfo->ControlDTCSettingDTCGroup = Dcm_ModeGetControlDtcSettingGroup();                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
#  endif
  RecoveryInfo->ControlDTCSettingDisabled = (boolean)(Dcm_ModeGetControlDtcSettingMode() == RTE_MODE_DcmControlDtcSetting_DISABLEDTCSETTING);        /* SBSW_DCM_PARAM_PTR_WRITE */ /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
# endif

  /* Retrieve communication control state */
# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
  {
    uint8_least lChannelIter;
    Dcm_RecoveryInfoCommControlStatePtrType pControlState;
    for(lChannelIter = 0; lChannelIter < Dcm_PbCfgNetNumAllComMChannels; ++lChannelIter)
    {
      pControlState = Dcm_DiagGetRecoveryInfoCommControlState(RecoveryInfo, lChannelIter);                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      *pControlState = Dcm_ModeGetCommControlState(lChannelIter);                                                                                    /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_WRITE_RECOVERYINFOCOMMCONTROLSTATE */
    }
  }
# endif

  RecoveryInfo->Signature = Dcm_DiagGetRecoverySignature();                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
}
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagProcessRecoveryInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagProcessRecoveryInfo(
  P2CONST(Dcm_RecoveryInfoType, AUTOMATIC, DCM_VAR_NOINIT) RecoveryInfo,
  Dcm_OpStatusType opStatus
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  if (opStatus == DCM_INITIAL)
  {
    /* If a non-default session was active: */
    if(RecoveryInfo->SessionLevel != 0u)
    {
      /* Activate ComM channels */
      Dcm_CfgNetNetIdRefOptType lNetHandleIter;
      for(lNetHandleIter = 0; lNetHandleIter < Dcm_PbCfgNetNumComMChannels; ++lNetHandleIter)
      {
        if(RecoveryInfo->ComMChannelState[lNetHandleIter] == TRUE)
        {
          ComM_DCM_ActiveDiagnostic(Dcm_PbCfgNetAllComMChannelMap[Dcm_PbCfgNetConnComMChannelMap[lNetHandleIter]]);
        }
      }

      /* Recover session state */
      Dcm_StateSetSession(RecoveryInfo->SessionLevel);

      /* Recover active protocol */
      Dcm_SingletonContext.Network.ActiveProtocol = RecoveryInfo->ActiveProtocol;

      /* Update P2 timings at once */
      Dcm_DiagSetP2Timings(RecoveryInfo->SessionLevel, Dcm_NetGetProtIdOfActiveProtocol(), DCM_THREAD_ID_BASIC);

      /* Recover session connection */
      Dcm_NetSetSessionConnection(RecoveryInfo->SessionConnection);
      Dcm_NetSetSessionClientSrcAddr(RecoveryInfo->SessionClientSrcAddr);

      Dcm_TmrStartTimer(DCM_TMR_ID_S3, DCM_DIAG_TIME_S3);
    }

# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
    /* If any security level was unlocked: */
    if(RecoveryInfo->SecurityLevel != 0u)
    {
      /* Recover security state */
      Dcm_StateSetSecurity(RecoveryInfo->SecurityLevel);
    }
# endif
  }

# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
  /* If DTC settings were disabled: */
  if(RecoveryInfo->ControlDTCSettingDisabled == TRUE)
  {
    /* Recover DTC updating state */
    lStdResult = Dcm_Svc85DisableDtcSetting(
#  if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
                                            RecoveryInfo->ControlDTCSettingDTCGroup
#  else
                                            DEM_DTC_GROUP_ALL_DTCS
#  endif
                                           ,Dcm_DiagGetDemClientId(Dcm_NetGetProtIdOfActiveProtocol())                                               /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */
                                           );

  }
# endif

# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
#  if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
  /* If no DTC settings update was necessary or it succeeded */
  if (lStdResult == DCM_E_OK)
#  endif
  /* Recover communication control states */
  {
    uint8_least lChannelIter;
    for(lChannelIter = 0; lChannelIter < Dcm_PbCfgNetNumAllComMChannels; ++lChannelIter)
    {
      if(RecoveryInfo->CommControlState[lChannelIter] != DCM_ENABLE_RX_TX_NORM_NM)
      {
        Dcm_ModeSwitchCommControl(lChannelIter, RecoveryInfo->CommControlState[lChannelIter]);
      }
    }
  }
# endif
  return lStdResult;
}
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagSafeProcessRecoveryInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSafeProcessRecoveryInfo(
  P2CONST(Dcm_RecoveryInfoType, AUTOMATIC, DCM_VAR_NOINIT) RecoveryInfo,
  Dcm_OpStatusType opStatus
  )
{
  uint8          lErrorId   = DCM_E_NO_ERROR;
  Std_ReturnType lStdResult = DCM_E_NOT_OK;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(RecoveryInfo->Signature != Dcm_DiagGetRecoverySignature()))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError(RecoveryInfo->SessionLevel >= DCM_STATE_NUM_SESSION))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError( (RecoveryInfo->SessionLevel != 0u) /* non-default session */
                              &&(RecoveryInfo->ActiveProtocol >= DCM_NET_INVALID_PROTID) ))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError( (RecoveryInfo->SessionLevel != 0u) /* non-default session */
                              &&(RecoveryInfo->SessionConnection >= DCM_NET_INVALID_CONNHDL) ))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError( (RecoveryInfo->SessionLevel != 0u) /* non-default session */
                              &&(Dcm_NetGetProtIdOfConnection(RecoveryInfo->SessionConnection) != RecoveryInfo->ActiveProtocol) ))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  if(Dcm_DebugDetectError(RecoveryInfo->SecurityLevel >= DCM_STATE_NUM_SECURITY))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    lStdResult = Dcm_DiagProcessRecoveryInfo(RecoveryInfo, opStatus);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_GETRECOVERYSTATES, lErrorId);

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DCM_DIAG_SPECIFIC_CAUSE_CODE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagSetSpecificCauseCode()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetSpecificCauseCode(
  Dcm_SpecificCauseCodeType specificCauseCode
  )
{
  if(Dcm_SingletonContext.Diag.CauseCodeContext.SendCauseCode == FALSE)
  {
    Dcm_SingletonContext.Diag.CauseCodeContext.CauseCode = specificCauseCode;
    Dcm_SingletonContext.Diag.CauseCodeContext.SendCauseCode = TRUE;
  }
}
#endif

#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagIsSessionChangeAllowed()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagIsSessionChangeAllowed(
  Dcm_ContextPtrType pContext                                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  /* If a non-default session will be active: */
  if((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) == 0u)
  {
    Dcm_ThreadIdOptType lThreadIter;

    for(lThreadIter = 0u; lThreadIter < DCM_NUM_THREADS; ++lThreadIter)
    {
      /* Skip own thread */
      if(lThreadIter != pContext->Thread->ThreadId)
      {
        Dcm_ThreadContextConstPtrType pThreadContext = Dcm_GetThreadContext(lThreadIter);

        if( (pThreadContext->Diag.State != DCM_DIAG_STATE_IDLE)
          ||(pThreadContext->Diag.QueuedSet.Flags != DCM_DIAG_QUEUE_FLAG_NONE) )
        {
          lStdResult = DCM_E_NOT_OK;
        }
      }
    }
  }

  return lStdResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcCancelOpenJobs()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoCancelProcCancelOpenJobs(
  Dcm_ContextPtrType pContext
  )
{
  /* #10 If any diagnostic job still open (PagedBuffer transfers are not part of them), call the job handle one last time with DCM_CANCEL signal */
  if(pContext->Thread->Diag.State == DCM_DIAG_STATE_PROCESS)
  {
    Dcm_NegativeResponseCodeType lNrc = DCM_E_PANIC_NRC; /* to avoid compiler warnings */
    pContext->Thread->Repeater.Contexts.OpStatus = DCM_CANCEL;/* Override any other opStatus values up to now */                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    (void)Dcm_RepeaterExecute(pContext, &lNrc);/* signal cancellation */                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
    Dcm_SetNegResponse(lNrc, pContext->Thread->ThreadId); /* register negative result */
  }

  /* #20 If any diagnostic job still open (including PagedBuffer transfers) or already on transmission: */
  if(((DCM_DIAG_STATE_PROCESS | DCM_DIAG_STATE_ON_TX) & pContext->Thread->Diag.State) != 0u) /* any open diagnostic job? (optimize interrupt lock times) */
  {
    /* Immediately cancel any ongoing transmission (RCR-RP, final response (RoE or external)) */
    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    if(((DCM_DIAG_STATE_PROCESS | DCM_DIAG_STATE_ON_TX) & pContext->Thread->Diag.State) != 0u) /* STILL any open diagnostic job -> diagnostic transport object is still in use -> try cancel it */ /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
    {
      Dcm_NetTransportObjectPtrType pTranspObj;

      pTranspObj = Dcm_DiagGetTranspObj(pContext->Thread);

      /* #30 If any USDT response transmission is still ongoing (incl. RCR-RPs): */
      if(pTranspObj->State == DCM_NET_TOBJ_STATE_ONTX)
      {
        pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_CANCELED;/* isolate this connection */                                                                /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        /* Short cut to speed up the service processing finalization - RCR-RP responses will just end with the cancellation below */
        Dcm_DiagTxFinalization(pTranspObj, DCM_E_NOT_OK);                                                                                            /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */

        /* Try cancel any ongoing response. The return value does not matter:
          * OK -> there will be a confirmation for this cancellation
          * N_OK -> request rejected, but there will be a confirmation due to the ongoing transmission */
        (void)PduR_DcmCancelTransmit(Dcm_PbCfgNetConnectionInfo[pTranspObj->ConnHdl].TxPduIdMain);
        /* Any response (final, RCR-RP, etc) will just end with releasing the connection assigned to the tObject! No confirmation post-processing will be performed! */
      }
      /* Otherwise, if there is no USDT response initiated yet, just notify the diagnostic kernel for the transmission finalization to accomplish the diagnostic job cycle */
      else if (pTranspObj->State == DCM_NET_TOBJ_STATE_READY)                                                                                        /* COV_DCM_RTM_UNREACHABLE TX */
      {
        /* no transmission yet started -> just loop back the diagnostic confirmation immediately. Note: no other Tx-confirmation type is expected here */
        Dcm_DiagTxFinalization(pTranspObj, DCM_E_NOT_OK);                                                                                            /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      }
      else
      {
        /* Otherwise, unexpected transport object state reached (inconsistent in the context of diagnostic kernel state, showing a job is still in progress) */
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                 /* COV_DCM_RTM_DEV_DEBUG XF */
      }
    }
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiLeaveCriticalSection();
  }
  /* Otherwise, diagnostic kernel is in "post processing" or "idle" state and they are to be handled in a normal way
         Note: This case can be reached since the prioritization just fires a cancellation event, disregarding any internal states of the diagnostic kernel */
}                                                                                                                                                    /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcReviveKilledTasks()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoCancelProcReviveKilledTasks(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(pEventContext);                                                                                                             /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* All cancellation activities are done now - revive all killed tasks to allow normal processing of the newly received diagnostic job (the one caused the interruption) */
  /* Look ahead: Any nested kill job received? If so, no task revival! */
  if((DCM_TSK_EV_DIAG_WORK_KILL_JOBS & Dcm_TskGetEventByThread(DCM_TSK_ID_DIAG_WORK, pContext->Thread->ThreadId)) == 0u)                             /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
  {
#if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
    Dcm_TskTaskEvOptType queuedTObjBitSet = 0; /* nothing to clean (for now) */
#endif
    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
     /* STILL no nested kill job received? */
    if((DCM_TSK_EV_DIAG_WORK_KILL_JOBS & Dcm_TskGetEventByThread(DCM_TSK_ID_DIAG_WORK, pContext->Thread->ThreadId)) == 0u)                           /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
    {
      Dcm_TskReviveAllTasks();/* from now on enable tasks for working */
#if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
      queuedTObjBitSet = pContext->Thread->Diag.QueuedSet.QueuedTObjects;

# if (DCM_MULTI_THREAD_ENABLED == STD_ON)
      /* The queued transport object is only initialized if a request was received (and not e.g. by state recovery). */
      if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_NEW_REQ))
# endif
      {
        /* Clear all except the last queued one  */
        Dcm_UtiBitOpClr(Dcm_TskTaskEvOptType, queuedTObjBitSet, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, Dcm_DiagGetQueuedTranspObj(pContext->Thread)->Handle));
      }

      /* Remove all processed transport objects from the queue (the last queued one will be removed from the queue once transfered to the active tObject or canceled by higher prio request here again) */
      Dcm_UtiBitOpClr(Dcm_TskTaskEvMemType, pContext->Thread->Diag.QueuedSet.QueuedTObjects, queuedTObjBitSet);                                      /* SBSW_DCM_PARAM_PTR_WRITE */
#endif
    }
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiLeaveCriticalSection();
#if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
    if(queuedTObjBitSet > 0u)
    {
      /* Some connections to clean up (in background)? */
      Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_GARB_COL, (Dcm_TskTaskEvMemType)queuedTObjBitSet, pContext->Thread->ThreadId);
    }
#endif
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoCancelProcessing(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_DiagWorkerDoCancelProcCancelOpenJobs(pContext); /* Cancel open diagnostic jobs */                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Sync with TxEnd events set above OR Tx confirmation. No ISR lock since:
   * - No Tx confirmation can occur from now on
   * - If above Tx confirmation executed -> no other changes of the state are possible!
   * - If there was already a Tx Confirmation (above code not executed) -> the task will just be re-triggered
   */
  /* If the Dcm_DiagTaskWorker() has (by finished transmission or through the above cancellation activity) already received a post-processing event: */
  if((DCM_TSK_EV_DIAG_WORK_TX_END_FINAL & Dcm_TskGetEventByThread(DCM_TSK_ID_DIAG_WORK, pContext->Thread->ThreadId)) != 0u)
  {
    Dcm_TskClrEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL, pContext->Thread->ThreadId);/* clear any potentially globally set Tx-end-response (from the above Tx cancellation code) */
    Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL);/* set/transfer the Tx end event */                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  /* Otherwise, either no Tx-end event OR nothing to do OR it is already set in the local "ev" -> will be post-processed in next task stages */

  Dcm_DiagWorkerDoCancelProcReviveKilledTasks(pContext, pEventContext); /* Revive killed tasks */                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
}

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoPostProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoPostProcessing(
  Dcm_ContextPtrType pContext
  )
{
  Dcm_ConfirmationStatusType   confStatus;
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  Dcm_NegativeResponseCodeType lNrc = DCM_E_PANIC_NRC; /* to avoid compiler warnings */
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  /* Reset any pending PB processing */
  if(Dcm_PagedBufferCancel(pContext, &lNrc) == DCM_E_NOT_OK)                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
  {
    Dcm_SetNegResponse(lNrc, pContext->Thread->ThreadId);/* Set NRC now to affect the post-processor confirmation status */
  }
#endif

  confStatus = Dcm_DiagGetPostProcessResult(pContext);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
  /* First process any diagnostic service post-handler (e.g. to perform any state transitions at this stage): */
  if((DCM_DIAG_APPL_NOTIFICATION_POSTPROCESSOR & pContext->Thread->Diag.ApplNotification) != 0u)
  {
    Dcm_DiagSvcConfirmationFuncType lPostProcessorFunc;
    lPostProcessorFunc = Dcm_DiagGetPostProcessorFunc(Dcm_CfgDiagServiceInfo[pContext->Thread->Diag.SidIndex].ConfFuncRef);

    lPostProcessorFunc(pContext, confStatus);/* execute any internal service processor post-handlers */                                              /* SBSW_DCM_CALL_FUNCPTR_SVCPOSTPROCESSORS */
  }

  /* Process the application notification confirmation */
  if((DCM_DIAG_APPL_NOTIFICATION_CONFIRMATION & pContext->Thread->Diag.ApplNotification) != 0u)
  {
    Dcm_Confirmation(0, pContext->Thread->Diag.MsgContext.rxPduId, confStatus);/* notify the application about transmission end (of any service) */
  }

  /* At next process any system supplier and OEM notification (e.g. to perform any additional state transitions at this stage): */
  if((DCM_DIAG_APPL_NOTIFICATION_SYS & pContext->Thread->Diag.ApplNotification) != 0u)
  {
    Dcm_DiagExecConfirmationFunc(pContext, Dcm_CfgDiagSysNotificationInfo, confStatus);                                                              /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  }

  if((DCM_DIAG_APPL_NOTIFICATION_OEM & pContext->Thread->Diag.ApplNotification) != 0u)
  {
    Dcm_DiagExecConfirmationFunc(pContext, Dcm_CfgDiagOemNotificationInfo, confStatus);                                                              /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  }

#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if(pContext->Thread->Diag.IsInternRequest == FALSE)/* manage ComM states only on processed requests from external clients */
#endif
  {
    /* Process here to take a potentially new session change into account */
    Dcm_NetUnRegisterComMActivity(Dcm_NetGetConnHdlOfRxPduId(pContext->Thread->Diag.MsgContext.rxPduId));                                            /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
  }
  pContext->Thread->Diag.State = DCM_DIAG_STATE_IDLE;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_DiagWorkerSetDefSessionExtern()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerSetDefSessionExtern(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
  /* If diagnostic kernel is still busy with a diagnostic job, retry next task activation if there is no other such request yet */
  if(pContext->Thread->Diag.State != DCM_DIAG_STATE_IDLE)
  {
    if(!Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF))                                                                 /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY XX */
    {
      Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_DIAG_WORK_EXT_SET2DEF); /* retry later again */                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
  else
  {
    /* Redirect the external request for resetting the session to the internal request handler (same activity) */
    Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF);                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

    /* If non-default session is active the current protocol id is unequal to DCM_NET_INVALID_PROTID */
    if(!Dcm_StateIsDefaultSessionActive())
    {
      Dcm_DiagSetP2Timings(0, Dcm_NetGetProtIdOfActiveProtocol(), pContext->Thread->ThreadId);
    }/* else - P2 timings of default session already set */

#if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
    Dcm_SingletonContext.Network.RxAllowed = TRUE;
#endif
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagSwitchProcessingContext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSwitchProcessingContext(
  Dcm_ContextPtrType pContext                                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  Dcm_SplitTaskEnterCS();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
#if (DCM_DIAG_GARB_COL_ENABLED == STD_ON) && \
    (DCM_SPLIT_TASKS_ENABLED == STD_ON)
  if((DCM_TSK_EV_DIAG_WORK_KILL_JOBS & Dcm_TskGetEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_THREAD_ID_BASIC)) != 0u)/* STILL no (nested) kill job received? */
  {
    lStdResult = DCM_E_NOT_OK; /* skip any further processing in this Dcm_DiagTaskWorker() activation (i.e. return immediately) */
  }
  else
#endif
  {
    Dcm_NetTransportObjectConstPtrType pQueuedTObj;

    pQueuedTObj = Dcm_DiagGetQueuedTranspObj(pContext->Thread);

    Dcm_UtiBitOpClr(Dcm_DiagProcessorFlagType, pContext->Thread->Diag.QueuedSet.Flags, DCM_DIAG_QUEUE_FLAG_IS_CANCELING);                            /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_UtiBitOpClr(Dcm_DiagProcessorFlagType, pContext->Thread->Diag.QueuedSet.Flags, DCM_DIAG_QUEUE_FLAG_IS_WAITING);                              /* SBSW_DCM_PARAM_PTR_WRITE */

    Dcm_UtiBitOpSet(Dcm_DiagProcessorFlagType, pContext->Thread->Diag.QueuedSet.Flags, DCM_DIAG_QUEUE_FLAG_IS_ACTIVE);                               /* SBSW_DCM_PARAM_PTR_WRITE */

    Dcm_DiagSetTranspObj(pContext->Thread, pQueuedTObj); /* switch work contexts! RCR-RP will be sent also from this one (QueuedCtxt) */             /* SBSW_DCM_PARAM_PTR_WRITE */

#if (DCM_DIAG_GARB_COL_ENABLED ==STD_ON)
    Dcm_UtiBitOpClr(Dcm_TskTaskEvMemType, pContext->Thread->Diag.QueuedSet.QueuedTObjects, (Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pQueuedTObj->Handle))); /* SBSW_DCM_PARAM_PTR_WRITE */
#endif
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_SplitTaskLeaveCS();

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_DiagInitMsgContextBufferInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_GLOBAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInitMsgContextBufferInfo(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_CfgNetBufferRefOptType index
  )
{
  Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;

  lBufferInfo = Dcm_NetGetBufferInfo(index);

  pMsgContext->reqData = &(lBufferInfo->BufferPtr[0]);                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resData = &(lBufferInfo->BufferPtr[0]);                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->reqDataLen = 0;                                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resDataLen = 0u;                                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->reqBufSize = lBufferInfo->Size;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resBufSize = lBufferInfo->Size;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resMaxDataLen = lBufferInfo->Size;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resProtHeadLen = 0;                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->reqIndex = 0u;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resIndex = 0u;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
}

/**********************************************************************************************************************
 *  Dcm_DiagInitiateServiceProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInitiateServiceProcessing(
  Dcm_ContextPtrType pContext                                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_NetTransportObjectConstPtrType pTranspObj;
  Dcm_MsgContextPtrType              pMsgContext;

  /* Now take the active transport object */
  pTranspObj = Dcm_DiagGetTranspObj(pContext->Thread);
  pMsgContext = &(pContext->Thread->Diag.MsgContext);

  /* Compose message context (skip SID byte) */
  Dcm_DiagInitMsgContextBufferInfo(pMsgContext, pTranspObj->BufferHdl);                                                                              /* SBSW_DCM_POINTER_INIT_MESSAGE_CONTEXT */

  pMsgContext->reqDataLen = pTranspObj->RxLength;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->rxPduId = pTranspObj->RxPduId;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->msgAddInfo.reqType  = (uint8)((Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE)?1u:0u);                                  /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->msgAddInfo.suppressPosResponse = 0;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->threadId = pContext->Thread->ThreadId;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */

  /* Update diagnostic kernel context */
#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  pContext->Thread->Diag.IsInternRequest    = (boolean)((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) != 0u);                                     /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */ /* SBSW_DCM_PARAM_PTR_WRITE */
#endif
  pContext->Thread->Diag.ErrorRegister      = DCM_E_POSITIVERESPONSE;                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
  pContext->Thread->Diag.ApplNotification   = DCM_DIAG_APPL_NOTIFICATION_NONE;                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  pContext->Thread->Diag.DoSuppressResponse = FALSE;                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
  pContext->Thread->Diag.State              = DCM_DIAG_STATE_PROCESS;                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */

#if (DCM_DIAG_SPECIFIC_CAUSE_CODE_ENABLED == STD_ON)
  /* Initialize cause code context */
  Dcm_SingletonContext.Diag.CauseCodeContext.CauseCode = 0x00;
  Dcm_SingletonContext.Diag.CauseCodeContext.SendCauseCode = FALSE;
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  Dcm_PagedBufferInitByThread(pContext->Thread->ThreadId);
#endif
}

/**********************************************************************************************************************
 *  Dcm_DiagHandleSuppressBit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagHandleSuppressBit(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NetTransportObjectPtrType pTranspObj,                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_MsgContextPtrType pMsgContext
  )
{
  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Check if the new service supports sub-function parameter */
  if((Dcm_CfgDiagServiceInfo[pContext->Thread->Diag.SidIndex].Props & DCM_DIAG_SVC_CFG_PROP_HAS_SUBFUNC)  != 0u)
  {
    uint8 reqSf = Dcm_UtiGetReqDataAsU8(pMsgContext);                                                                                                /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */
    /* If so, deal with the SPRMIB: extract and store */
    if ((reqSf & 0x80u) != 0u)
    {
      Dcm_UtiSetReqDataAsU8(pMsgContext, (uint8)(reqSf & 0x7Fu));/* mask out the SPRMIB */                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

      Dcm_SplitTaskEnterCS();/* protect against hi-priority Dcm_DiagTaskRx/Tx */
      /*=================================*
        BEGIN CRITICAL SECTION
       *=================================*/
#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
      /* On split task it could happen that RCR-RP is already on transmission */
      if((pTranspObj->Flags & (DCM_NET_TOBJ_FLAG_RCRRP_ON_TX | DCM_NET_TOBJ_FLAG_RCRRP_SENT)) == 0u)/* RCR-RP is NOT on transmission or was sent */
#endif
      {
        pMsgContext->msgAddInfo.suppressPosResponse = 1;                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      /*=================================*
        END CRITICAL SECTION
       *=================================*/
      Dcm_SplitTaskLeaveCS();
    }
    /* copy the sub-function byte once split Rx/Tx buffers are supported.
    pMsgContext->resData[0] = pMsgContext->reqData[0];
    */
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagHandleDispatching()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagHandleDispatching(
  uint8 sid,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_ContextPtrType pContext                                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(sid);                                                                                                                       /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  pContext->Thread->Diag.ProcessServiceExtern = FALSE;                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */

#if (DCM_DIAG_SERVICE_DISPATCHER_ENABLED == STD_ON)
  /*  Check for necessity of service dispatching (service supports the dispatching parameter) */
  if((Dcm_CfgDiagServiceInfo[pContext->Thread->Diag.SidIndex].Props & DCM_DIAG_SVC_CFG_PROP_CALL_SVC_DISPATCHER) != 0u)
  {
    boolean lResult;

    /* Execute the call-out to the application and verify the result */
    lResult = Dcm_HandleServiceExtern(sid
                                     ,pMsgContext->reqData
                                     ,(uint16)pMsgContext->reqDataLen
                                     ,(uint8) pMsgContext->msgAddInfo.reqType
                                     ,Dcm_DiagGetTranspObj(pContext->Thread)->ClientSrcAddr);                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */

    if (Dcm_DebugDetectError((lResult != TRUE) && (lResult != FALSE)))
    {
      Dcm_DebugReportError(DCM_SID_SVCDISPATCHER, DCM_E_INTERFACE_RETURN_VALUE);                                                                     /* PRQA S 2880 */ /* MD_MSR_Unreachable */
    }
    else
    {
      pContext->Thread->Diag.ProcessServiceExtern = lResult;                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  /* Set the flags for post processing on internal service handling */
  if(pContext->Thread->Diag.ProcessServiceExtern == FALSE)
#endif
  {
    if(Dcm_CfgDiagServiceInfo[pContext->Thread->Diag.SidIndex].ConfFuncRef != 0u)
    {
      pContext->Thread->Diag.ApplNotification |= DCM_DIAG_APPL_NOTIFICATION_POSTPROCESSOR; /* mark application post processor */                     /* SBSW_DCM_PARAM_PTR_WRITE */
    }

    if(Dcm_CfgDiagServiceInfo[pContext->Thread->Diag.SidIndex].FastConfFuncRef != 0u)
    {
      pContext->Thread->Diag.ApplNotification |= DCM_DIAG_APPL_NOTIFICATION_FASTPOSTPROCESSOR; /* mark application fast post processor */            /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  /* From now on, mark application calls for post-processing later */
  pContext->Thread->Diag.ApplNotification |= DCM_DIAG_APPL_NOTIFICATION_CONFIRMATION; /* mark application notification at last here */               /* SBSW_DCM_PARAM_PTR_WRITE */
}

/**********************************************************************************************************************
 *  Dcm_DiagValidateAndDispatchService()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagValidateAndDispatchService(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_ContextPtrType pContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  Dcm_MsgItemType lSid;

  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &lSid);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_UtiProvideResDataAsU8(pMsgContext, (uint8)(lSid + 0x40u));                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Skip SID data, since already processed */
  Dcm_DiagSetNewReqBaseToCurProgress(pMsgContext);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_DiagSetNewResBaseToCurProgress(pMsgContext);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Execute manufacturer specific environment checks */
  if(Dcm_DiagExecIndicationFunc(pContext, lSid, DCM_DIAG_APPL_NOTIFICATION_OEM, Dcm_CfgDiagOemNotificationInfo, ErrorCode) == DCM_E_OK)              /* SBSW_DCM_COMB_PTR_FORWARD */
  {
    sint16_least sidIter = Dcm_DiagLookUpFilter(pMsgContext
                                               ,Dcm_UtiLookUpUint8(Dcm_CfgDiagSvcIdLookUpTable, lSid)
                                               ,Dcm_CfgDiagSvcIdExecPrecondTable
                                               ,DCM_DIAG_CHK_LVL_SERVICE_ID
                                               ,ErrorCode);                                                                                          /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_COMB_PTR_FORWARD */
    /* Service found? */
    if(sidIter >= 0)
    {
      pContext->Thread->Diag.SidIndex = (uint8)sidIter;                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */

      if((Dcm_CfgDiagServiceInfo[pContext->Thread->Diag.SidIndex].Props & DCM_DIAG_SVC_CFG_PROP_CALL_POST_HDLR_ALWAYS)  != 0u)
      {
        /* mark application notification once the SID is identified! */
        pContext->Thread->Diag.ApplNotification |= DCM_DIAG_APPL_NOTIFICATION_POSTPROCESSOR;                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
      }

#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
      /* Check authentication access rights */
      lStdResult = Dcm_AuthMgrCheckDispatcherLevel(lSid
                                                  ,Dcm_CfgDiagSvcIdExecPrecondTable[pContext->Thread->Diag.SidIndex]
                                                  ,pMsgContext
                                                  ,Dcm_AuthMgrGetAuthInfoRef(pMsgContext)
                                                  ,ErrorCode);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */

      if(lStdResult == DCM_E_OK)
#endif
      {
        /* Check SID pre-conditions */
        lStdResult = Dcm_StateCheck(Dcm_CfgDiagSvcIdExecPrecondTable[pContext->Thread->Diag.SidIndex]
                                   ,DCM_DIAG_CHK_LVL_SERVICE_ID
                                   ,ErrorCode);                                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */

        if(lStdResult == DCM_E_OK)
        {
          /* Execute supplier specific environment checks */
          lStdResult = Dcm_DiagExecIndicationFunc(pContext, lSid, DCM_DIAG_APPL_NOTIFICATION_SYS, Dcm_CfgDiagSysNotificationInfo, ErrorCode);        /* SBSW_DCM_COMB_PTR_FORWARD */

          if(lStdResult == DCM_E_OK)
          {
            /* Check for available minimum length */
            if(pMsgContext->reqDataLen >= Dcm_CfgDiagServiceInfo[pContext->Thread->Diag.SidIndex].MinLength)
            {
              /* Handle SPRMIB */
              Dcm_DiagHandleSuppressBit(pContext, Dcm_DiagGetTranspObj(pContext->Thread), pMsgContext);                                              /* SBSW_DCM_COMB_PTR_FORWARD */

              /* Handle service dispatching and set the flags for post-processing */
              Dcm_DiagHandleDispatching(lSid, pMsgContext, pContext);                                                                                /* SBSW_DCM_COMB_PTR_FORWARD */
            }
            else
            {
              /* Minimum length is not reached  */
              *ErrorCode = (Dcm_NegativeResponseCodeType)( (lSid < 0x10u)
                                                          ? DCM_E_REQUESTOUTOFRANGE
                                                          : DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT);                                            /* SBSW_DCM_PARAM_PTR_WRITE */
              lStdResult = DCM_E_NOT_OK;
            }
          } /* else - NRC already set - finalize processing */
        }/* else - NRC already set - finalize processing */
      }/* else - NRC already set - finalize processing */
    }/* else - already written "Unsupported service requested" */
  }/* else - NRC already set - finalize processing */

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_DiagWorkerProcessNewRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerProcessNewRequest(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType               lStdResult;
  Dcm_NegativeResponseCodeType lNrc = DCM_E_PANIC_NRC; /* to avoid compiler warnings */

  lStdResult = Dcm_DiagSwitchProcessingContext(pContext);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)                                                                                                                         /* PRQA S 2991, 2995 */ /* MD_Dcm_ConstExpr, MD_Dcm_ConstExpr */
  {
    Dcm_DiagInitiateServiceProcessing(pContext);                                                                                                     /* SBSW_DCM_POINTER_INIT_MESSAGE_CONTEXT */

    /* Validate received diagnostic service on SID level */
    lStdResult = Dcm_DiagValidateAndDispatchService(&(pContext->Thread->Diag.MsgContext)
                                                   ,pContext
                                                   ,&lNrc);                                                                                          /* SBSW_DCM_COMB_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)
    {
      /* Set repeater per default to be no specific service */
      Dcm_RepeaterSetUser(pContext, DCM_REPEATER_USER_NONE);                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
      /* Execute Main-Handler (register it and it will be called immediately) */
      Dcm_RepeaterSetCallee(pContext, pContext->Thread->Diag.SidIndex);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      /* Let the service processor take over immediately */
      Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_REPEAT);                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      /* DCM_E_NOT_OK */
      Dcm_SetNegResponse(lNrc, pContext->Thread->ThreadId);
      Dcm_ProcessingDone(pContext->Thread->ThreadId);
    }
  }
  else
  {
    /* DCM_E_NOT_OK */
#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
    if(pContext->Thread->ThreadId != DCM_THREAD_ID_BASIC)
    {
      Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_DIAG_WORK_NEW_REQ); /* Retry next time */                                               /* PRQA S 2880 */ /* MD_MSR_Unreachable */ /* SBSW_DCM_PARAM_PTR_WRITE */
    }
#endif

    /* skip any further processing in this Dcm_DiagTaskWorker() activation (i.e. return immediately) */
    pEventContext->Ev = 0;                                                                                                                           /* PRQA S 2880 */ /* MD_MSR_Unreachable */ /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagWorkerProcessRcrRpTxEnd()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerProcessRcrRpTxEnd(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_DiagGetTranspObj(pContext->Thread);

  if((DCM_NET_TOBJ_FLAG_RCRRP_TYPE_APPL & pTranspObj->Flags) != 0u)/* this is a RCR-RP response - check which kind */
  {
    Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_TYPE_APPL);                                           /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    pContext->Thread->Repeater.Contexts.OpStatus = (Dcm_OpStatusType)((pContext->Thread->Diag.TxStatus != DCM_E_OK)
                                                                        ?DCM_FORCE_RCRRP_NOT_OK
                                                                        :DCM_FORCE_RCRRP_OK);                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_REPEAT); /* notify immediately */                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON) && \
    (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerCancelOperation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerCancelOperation(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_NegativeResponseCodeType lNrc;

  DCM_IGNORE_UNREF_PARAM(pEventContext);                                                                                                             /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(Dcm_PagedBufferCancel(pContext, &lNrc) == DCM_E_NOT_OK)                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
  {
    /* Stop polling and wait for confirmation */
    Dcm_SetNegResponse(lNrc, pContext->Thread->ThreadId);
    Dcm_ProcessingDone(pContext->Thread->ThreadId);
  }
}
#endif

#if (DCM_STATE_SECURITY_BYPASS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerSetSecurityBypass()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerSetSecurityBypass(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  /* Enforce bypass mode if no service is in processing! */
  if(pContext->Thread->Diag.State != DCM_DIAG_STATE_IDLE)
  {
    Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_DIAG_WORK_EXT_SETSECBYPASS); /* retry later again */                                      /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    if(Dcm_SingletonContext.Diag.IsSecurityBypass == TRUE)
    {
      /* Unlock security (excluding locked level = 0x00) */
      Dcm_SingletonContext.StateMgr.Preconditions.Security = (Dcm_CfgStateGroupMemType)(Dcm_UtiMaxValueOfUintType(Dcm_CfgStateGroupMemType) - 1u);
    }
    else
    {
      /* Lock security */
      Dcm_StateSetSecurity(0);
    }
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoRepeat()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoRepeat(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  )
{
  Std_ReturnType lStdResult;
  Dcm_NegativeResponseCodeType lNrc = DCM_E_CONDITIONSNOTCORRECT;
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_DiagGetTranspObj(pContext->Thread);

#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_CANCEL_OP))
  {
    pContext->Thread->Repeater.Contexts.OpStatus = DCM_CANCEL; /* override any other opStatus values up to now */                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
#endif
  lStdResult = Dcm_RepeaterExecute(pContext, &lNrc);                                                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */

  switch(lStdResult)
  {
  case DCM_E_NOT_OK:
    Dcm_SetNegResponse(lNrc, pContext->Thread->ThreadId);
    /* fall through */
  case DCM_E_OK:                                                                                                                                     /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
  case DCM_E_PROCESSINGDONE:
    Dcm_ProcessingDone(pContext->Thread->ThreadId);
    break;
  case DCM_E_PENDING:
    pContext->Thread->Repeater.Contexts.OpStatus = DCM_PENDING;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    /* fall through - keep the last opStatus on "pending" forced by Dcm_RepeaterExecute code */
  case DCM_E_PENDING_LIMITER:                                                                                                                        /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
    /* Retry next cycle with the same parameter */
    Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_DIAG_WORK_REPEAT);                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  case DCM_E_FORCE_RCRRP:
    Dcm_UtiEnterCriticalSection();/* protect against Dcm_TpTxConfirmation or hi-priority Dcm_DiagTaskRx */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_RCRRP_TYPE_APPL;                                                                                          /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    if((pTranspObj->Flags & (DCM_NET_TOBJ_FLAG_RCRRP_ON_TX | DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ))  == 0u)/* no RCR-RP already requested for transmission/ongoing? */
    {
      Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_RX, DCM_TSK_EV_DIAG_RX_TMR_P2_TO, pContext->Thread->ThreadId);/* trigger a RCR-RP event timeout */
    }/* else - just wait for confirmation signal */

    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiLeaveCriticalSection();
    break;
  default: /* DCM_E_STOP_REPEATER */
    Dcm_RepeaterSetCallee(pContext, DCM_DIAG_SERVICEINFO_REPEATEREND_IDX); /* any other return value leads to a dead end */                          /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  }
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DCM_TSK_NUM_DIAG_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoGetProgCond()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagFblResDoGetProgCond(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
  /* Read the programming conditions of the pre-boot cycle */
  /* #10 If the ECU boot type is marked as a transition from the bootloader: */
  if(Dcm_GetProgConditions(&Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions) == DCM_WARM_START)                                                  /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  {
    sint16_least sesSfIter = -1;

# if (DCM_DIAG_NOTIF_BSWM_APPL_UPDATED_ENABLED == STD_ON)
    /* #20 If the application has been updated, notify the BswM (if enabled BswM notification) */
    if(Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.ApplUpdated == TRUE)
    {
      BswM_Dcm_ApplicationUpdated();
    }
# endif

    /* Check the diagnostic service identifier to be processed here: */

    /* #30 If the SID is for "DiagnosticSessionControl": */
    if(Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.Sid == 0x10u)
    {
      sesSfIter = Dcm_VarMgrLookUpFilter(Dcm_UtiLookUpUint8(Dcm_CfgSvc10SubFuncLookUpTable, Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.SubFuncId) /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
                                        ,Dcm_CfgSvc10SubFuncExecPrecondTable);                                                                       /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
    }
    /* Otherwise, send a response with any other SID and sub-function directly */

    if( (Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.ResponseRequired == TRUE) /* a response is to be sent */
      ||(sesSfIter > 0) ) /* OR a non-default session is to be activated (need ComM active) */
    {
      Dcm_NetConnRefMemType lConnHdl;

# if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
      lConnHdl = Dcm_NetGetConnHdlByConnectionId(Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.ConnectionId);
# else
      lConnHdl = Dcm_NetGetConnHdlByTesterAddress(Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.TesterSourceAddr);
# endif

      if( (lConnHdl < DCM_NET_INVALID_CONNHDL)
# if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
        &&( ( (Dcm_NetIsGenericConnection(lConnHdl))
            &&(Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.TesterSourceAddr <= DCM_NET_MAX_VAL_GENERIC_SRC_ADDRESS) )
          ||( (!Dcm_NetIsGenericConnection(lConnHdl))
            &&(Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.TesterSourceAddr == Dcm_NetGetTesterAddress(lConnHdl)) ) )
# endif
         )
      {
        Dcm_NetTransportObjectPtrType pTranspObj; /* use a local copy to avoid collision with a RxIndication! */
        BufReq_ReturnType             lResult;

        lResult = Dcm_NetLockConnection(lConnHdl, &pTranspObj);                                                                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

        if(lResult == BUFREQ_OK) /* try to lock the connection to this tester */
        {
          Dcm_SingletonContext.Diag.StartUpFbl.ConnHdl = pTranspObj->ConnHdl;
          /* Source address of the request shall be the target address of the response. */
          pTranspObj->ClientSrcAddr = Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.TesterSourceAddr;                                          /* SBSW_DCM_POINTER_WRITE_RESERVEDTOBJ */
          Dcm_DiagSetTranspObj(pContext->Thread, pTranspObj);/* store working context */                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
          Dcm_TmrStartTimer(DCM_TMR_ID_FBLRES, pContext->Thread->Diag.P2Timings.P2Star); /* wait at most P2 star to finalize the FBL positive response */
          /* Start communication */
          Dcm_NetRegisterActiveConnection(pTranspObj);                                                                                               /* SBSW_DCM_POINTER_WRITE_RESERVEDTOBJ */
          Dcm_NetRegisterComMActivity(pTranspObj);                                                                                                   /* SBSW_DCM_POINTER_WRITE_RESERVEDTOBJ */
          Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_FBLRES_WAITTXCOMM);/* Try immediately */                                           /* SBSW_DCM_PARAM_PTR_WRITE */
        }
        /* else - there is a problem locking the channel (there is already a tester request) */
      }
      else
      {
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_PARAM);
      }
    }
    /* In any case store any analysis results for later use (i.e. during the clear response required flag) */
    Dcm_SingletonContext.Diag.StartUpFbl.SessStateRef = (sint8)sesSfIter;
    Dcm_SingletonContext.Diag.StartUpFbl.IsResponseRequired = Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.ResponseRequired;
    /* Signal the current task to start immediately the parallel job for clearing the response required flag, to avoid re-triggering of this sequence at next power on cycle */
    Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_FBLRES_RSTFLAGS);                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}                                                                                                                                                    /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL */ /* MD_MSR_STMIF */
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoWaitTxComm()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagFblResDoWaitTxComm(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_DiagGetTranspObj(pContext->Thread);

  /* If the corresponding ComM channel state is in "FullComMode": */
  if((DCM_NET_COMM_STATE_FLAG_TX_EN & Dcm_NetGetComStateByTranspObject(pTranspObj)) != 0u)
  {
    Dcm_TmrStopTimer(DCM_TMR_ID_FBLRES);

    if(Dcm_SingletonContext.Diag.StartUpFbl.IsResponseRequired == FALSE) /* is final response required ? */
    {
      Dcm_DiagOnFblResTxFinished(pTranspObj, DCM_E_OK);/* Loop-back to the confirmation (successful "virtual" transmission) to clean up transportObject and ComM */ /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    }
    else
    {
      pTranspObj->State   = DCM_NET_TOBJ_STATE_PREPTX;                                                                                               /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_UNSOLICITED;                                                                                        /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      pTranspObj->BuffInfo.SduDataPtr = &Dcm_SingletonContext.Diag.StartUpFbl.ResBuffer[0];                                                          /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      pTranspObj->BuffInfo.SduLength  = 2u; /* only service and a sub-function to be sent */                                                         /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      /* Prepare final response to be sent */
      Dcm_DiagPutStartUpFblResBuffer(0, (uint8)(Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.Sid + 0x40u));
      Dcm_DiagPutStartUpFblResBuffer(1, Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.SubFuncId);

      if(Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.Sid == 0x10u)
      {
        if(Dcm_SingletonContext.Diag.StartUpFbl.SessStateRef >= 0)
        {
          Dcm_DiagPutStartUpFblResBuffer(2, Dcm_UtiGetHiByte(Dcm_CfgSvc10SubFuncInfo[Dcm_SingletonContext.Diag.StartUpFbl.SessStateRef].ResponseTime.P2));
          Dcm_DiagPutStartUpFblResBuffer(3, Dcm_UtiGetLoByte(Dcm_CfgSvc10SubFuncInfo[Dcm_SingletonContext.Diag.StartUpFbl.SessStateRef].ResponseTime.P2));
          Dcm_DiagPutStartUpFblResBuffer(4, Dcm_UtiGetHiByte(Dcm_CfgSvc10SubFuncInfo[Dcm_SingletonContext.Diag.StartUpFbl.SessStateRef].ResponseTime.P2Star));
          Dcm_DiagPutStartUpFblResBuffer(5, Dcm_UtiGetLoByte(Dcm_CfgSvc10SubFuncInfo[Dcm_SingletonContext.Diag.StartUpFbl.SessStateRef].ResponseTime.P2Star));
          pTranspObj->BuffInfo.SduLength = 6u;                                                                                                       /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        }
        else
        {
          Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_PARAM);
        }
      }/* else - for SID 0x11 or other it is not critical to send any response - it will be up to the application to use the API! */

      Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_USDT);
    }
  }
  else
  { /* Otherwise, check if still shall wait for ComM (deadline not yet expired): */
    if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_FBLRES_CANCEL))/* stop polling since time is up */
    {
      /* Loop-back to the confirmation (failed transmission) to clean up transportObject and ComM */
      Dcm_DiagOnFblResTxFinished(pTranspObj, DCM_E_NOT_OK);                                                                                          /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    }
    else
    {
      Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_DIAG_FBLRES_WAITTXCOMM); /* Retry next time */                                          /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
}
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoResetFlags()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagFblResDoResetFlags(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Reset all programming condition fields to their inactive states */
  Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.ReprogrammingRequest = FALSE;
  Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.ApplUpdated      = FALSE;
  Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.ResponseRequired = FALSE;

  /* Write the updated pre-conditions */
  lStdResult = Dcm_SetProgConditions(&Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions);                                                          /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  switch(lStdResult)
  {
  case DCM_E_OK:
    break;
  case DCM_E_PENDING:
    Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_DIAG_FBLRES_RSTFLAGS);/* Retry next time */                                               /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default:                                                                                                                                           /* PRQA S 2016 */ /* MD_MSR_EmptyClause */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }
}
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoProcessTxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagFblResDoProcessTxConfirmation(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(pEventContext);                                                                                                             /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* If the final response was for a non-default session and was successfully sent: */
  if( (Dcm_SingletonContext.Diag.StartUpFbl.TxStatus == DCM_E_OK) /* only if successfully sent response ... */
    &&(Dcm_SingletonContext.Diag.StartUpFbl.SessStateRef > 0) )/* ... of diagnostic session control for a non-default session ... */
  {
    /* Enter critical section (Reason: Protect against Dcm_StartOfReception) */
    Dcm_UtiEnterCriticalSection();

    /* Register the diagnostic client for this session */
    Dcm_NetSetSessionConnection(Dcm_SingletonContext.Diag.StartUpFbl.ConnHdl); /* set connection for the session */
    Dcm_NetSetSessionClientSrcAddr(Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.TesterSourceAddr); /* set tester for the session */

    /* Register new active protocol */
    Dcm_SingletonContext.Network.ActiveProtocol = Dcm_NetGetProtIdOfConnection(Dcm_SingletonContext.Diag.StartUpFbl.ConnHdl);

    /* Leave critical section */
    Dcm_UtiLeaveCriticalSection();

    /* Perform the corresponding session transition */
    Dcm_StateSetSession((Dcm_StateIndexMemType)Dcm_SingletonContext.Diag.StartUpFbl.SessStateRef);

    /* Update P2 timings at once */
    Dcm_DiagSetP2Timings((Dcm_StateIndexMemType)Dcm_SingletonContext.Diag.StartUpFbl.SessStateRef
                        ,Dcm_NetGetProtIdOfActiveProtocol()
                        ,pContext->Thread->ThreadId);
  }
  /* Unregister diagnostic client in order to consider any non-default session activated above */
  Dcm_NetUnRegisterComMActivity(Dcm_SingletonContext.Diag.StartUpFbl.ConnHdl);
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagTxPostponeFinalPagedResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagTxPostponeFinalPagedResponse(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
  /* Wait for RCR-RP if SPRMIB was set */
  if (pContext->Thread->Diag.MsgContext.msgAddInfo.suppressPosResponse != 0u)
  {
    /* wait for P2 timeout and RCR-RP response transmission */
    Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_DIAG_TX_SEND_PAGED); /* retry later */                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_TskClrLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_TX_SEND_PAGED); /* avoid transmit attempt now */                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagTxStartFinalResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagTxStartFinalResponse(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_DiagGetTranspObj(pContext->Thread);

  /* kill any pending RCR-RP orders */
  Dcm_TskClrLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_TX_SEND_RCRRP);                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  /* stop in any case since from now on only the service will be finalized (either with or without response) */
  Dcm_TmrStopTimerByThread(DCM_TMR_ID_P2, pContext->Thread->ThreadId);

  if ( (pContext->Thread->Diag.DoSuppressResponse == TRUE)                 /* No response to send */
      &&(0u == (pTranspObj->Flags & (DCM_NET_TOBJ_FLAG_RCRRP_SENT | DCM_NET_TOBJ_FLAG_RCRRP_ON_TX /* Suppress only if RcrRp was not sent or not waiting for RCR-RP confirmation. If just attempted -> skip RCR-RP transmission */
                              /* | DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ - since DCM_TSK_EV_DIAG_TX_SEND_RCRRP cleared -> RCR-RP will not be sent. Instead finish the service processing at P2 time */))) )
  {
    Dcm_DiagTxFinalization(pTranspObj, DCM_E_OK);/* always OK */                                                                                     /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
  }
  else
  {
    /* prepare final response transmission */
    if(pTranspObj->State == DCM_NET_TOBJ_STATE_READY)
    {
      Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;

      lBufferInfo = Dcm_NetGetBufferInfo(pTranspObj->BufferHdl);

      /* clear flag */
      Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, (DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ | DCM_NET_TOBJ_FLAG_RCRRP_ON_TX));          /* PRQA S 4399 */ /* MD_Dcm_BitNegation_4399 */ /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      pTranspObj->State = DCM_NET_TOBJ_STATE_PREPTX;                                                                                                 /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      pTranspObj->BuffInfo.SduDataPtr = lBufferInfo->BufferPtr;/* reassign the worker buffer */                                                      /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */

      if(pContext->Thread->Diag.ErrorRegister == DCM_E_POSITIVERESPONSE)
      {
        /* Positive response */
        pTranspObj->BuffInfo.SduLength = (PduLengthType)(pContext->Thread->Diag.MsgContext.resDataLen
                                                       + pContext->Thread->Diag.MsgContext.resProtHeadLen); /* don't forget the SID or/and SF bytes */ /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
        if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_TX_SEND_PAGED))
        {
          pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_PAGED;                                                                                          /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        }
        else
#endif
        {
          pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_LINEAR;                                                                                         /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        }
      }
      else
      {
        /* Neg response */
        Dcm_NetComposeAddNegResponse(pTranspObj
                                    ,DCM_NET_TOBJ_RESTYPE_LINEAR
                                    ,pContext->Thread->Diag.ErrorRegister);                                                                          /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */

#if (DCM_DIAG_SPECIFIC_CAUSE_CODE_ENABLED == STD_ON)
        if(Dcm_SingletonContext.Diag.CauseCodeContext.SendCauseCode == TRUE)
        {
          /* Provide specific cause code to negative response */
          Dcm_NetWriteAddBufferU8At(pTranspObj, 3, Dcm_SingletonContext.Diag.CauseCodeContext.CauseCode);                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
          /* Add the additional byte of the cause code to the SduLength */
          pTranspObj->BuffInfo.SduLength = 4u;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
          Dcm_SingletonContext.Diag.CauseCodeContext.SendCauseCode = FALSE;
        }
#endif
      }

      Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_USDT);
    }
    else
    {
      /* retry later */
      Dcm_TskSetLocalEvent(pEventContext->PostEv, (pEventContext->Ev & (Dcm_TskTaskEvOptType)(DCM_TSK_EV_DIAG_TX_SEND_PAGED | DCM_TSK_EV_DIAG_TX_SEND_LINEAR))); /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagTxStartRcrRpResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagTxStartRcrRpResponse(
  Dcm_ContextPtrType pContext                                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_NetTransportObjectPtrType pQueuedTObj;

  pQueuedTObj = Dcm_DiagGetQueuedTranspObj(pContext->Thread);

  /*
   * Don't start the P2* timer within the RCR-RP confirmation but here because of prioritization and synchronization
   * issues which could occur otherwise.
   * Start now to cover also the application triggered RCR-RPs.
   */
  Dcm_TmrStartTimerByThread(DCM_TMR_ID_P2, pContext->Thread->Diag.P2Timings.P2Star, pContext->Thread->ThreadId);

  pContext->Thread->Diag.MsgContext.msgAddInfo.suppressPosResponse = 0; /* reset the suppress bit and send final response */                         /* SBSW_DCM_PARAM_PTR_WRITE */

  Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pQueuedTObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ);                                               /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */
  Dcm_UtiBitOpSet(Dcm_NetTransportObjectFlagType, pQueuedTObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_ON_TX); /* mark transmission flag */                   /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */

#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if((pQueuedTObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) != 0u)
  {
    /* suppress any RCR-RP responses on RoE - just do loop back ! */
    Dcm_DiagRcrRpTxFinished(pQueuedTObj, DCM_E_OK); /* always OK */                                                                                  /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */
  }
  else
#endif
  {
    Dcm_NetComposeAddNegResponse(pQueuedTObj
                                ,DCM_NET_TOBJ_RESTYPE_RCRRP
                                ,DCM_E_REQUESTCORRECTLYRECEIVEDRESPONSEPENDING);                                                                     /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */

    Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_USDT); /* delegate job */
  }
}

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetRecoveryInfoComMChannelState()
*********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_RecoveryInfoComMChannelStatePtrType, DCM_CODE) Dcm_DiagGetRecoveryInfoComMChannelState(
  P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo ,                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_CfgNetNetIdRefOptType index
  )
{
  Dcm_RecoveryInfoComMChannelStatePtrType lResult;

  if (Dcm_DebugDetectRuntimeError(index >= DCM_NET_MAX_NUM_COMM_CHANNELS))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = &(RecoveryInfo->ComMChannelState[0]);
  }
  else
  {
    lResult = &(RecoveryInfo->ComMChannelState[index]);
  }
  return lResult;
}
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON && DCM_MODE_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetRecoveryInfoCommControlState()
*********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_RecoveryInfoCommControlStatePtrType, DCM_CODE) Dcm_DiagGetRecoveryInfoCommControlState(
  P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo ,                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_CfgNetNetIdRefOptType index
  )
{
  Dcm_RecoveryInfoCommControlStatePtrType lResult;

  if (Dcm_DebugDetectRuntimeError(index >= DCM_NET_MAX_NUM_ALL_COMM_CHANNELS))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = &(RecoveryInfo->CommControlState[0]);
  }
  else
  {
    lResult = &(RecoveryInfo->CommControlState[index]);
  }
  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagIsCancellationNeeded()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_DiagIsCancellationNeeded(
  Dcm_NetTransportObjectPtrType pTranspObj                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  boolean lResult = TRUE;

  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(Dcm_NetGetProtIdOfActiveProtocol() >= DCM_NET_INVALID_PROTID)
  {
    lResult = FALSE;
  }
#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
  else
  {
    Dcm_ThreadContextConstPtrType pThreadContext = Dcm_GetThreadContext(DCM_THREAD_ID_BASIC);

    /*
     * In case that multiple winners are detected during non-default session and one of the winners is from
     * basic thread, the cancellation procedure shall be executed only once.
     * Otherwise the P2 timer of new basic thread winner would be stopped (the P2 timers are thread specific and not
     * protocol specific). Since the DCM_TSK_EV_DIAG_WORK_NEW_REQ event is unkillable, Dcm would proceed with
     * parallel service processing in default session, although NRC 0x78 can no longer be send for basic thread.
     * Note: The problem does not occur for multiple non-basic thread winner, because they are unkillable.
     */
    if( (Dcm_NetGetThreadIdOfTranspObj(pTranspObj) != DCM_THREAD_ID_BASIC)
      &&((DCM_DIAG_QUEUE_FLAG_IS_CANCELING & pThreadContext->Diag.QueuedSet.Flags) != 0u) )
    {
      lResult = FALSE;
    }
  }
#endif

  return lResult;
}
#if (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_VarMgrInit(
  Dcm_ConfigPtrType configPtr
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;
  boolean lResult;

# if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
  Dcm_VarMgrInitActiveCfgVariants();
# endif

# if (DCM_VARMGR_MODE_POSTBUILD_ANY_ENABLED == STD_ON)
  /* Check plausibility of the configuration pointer parameter */
  if (configPtr == NULL_PTR)
  {
    Dcm_EcuMErrorNotification(ECUM_BSWERROR_NULLPTR);
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#  if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
  if (configPtr->FinalMagicNumber != DCM_CFG_FINAL_MAGIC_NUMBER)
  {
    Dcm_EcuMErrorNotification(ECUM_BSWERROR_MAGICNUMBER);
    lErrorId = DCM_E_INVALID_CONFIG;
  }
  else if (configPtr->GenOutputType != DCM_CFG_GEN_COMPATIBILITY_VERSION)
  {
    Dcm_EcuMErrorNotification(ECUM_BSWERROR_COMPATIBILITYVERSION);
    lErrorId = DCM_E_INVALID_CONFIG;
  }
  else
#  endif
  {
    /* If the passed configuration variant is valid: */

    /* Store currently active variant(s) */
#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
    Dcm_SingletonContext.VarMgr.ActiveComVariant = configPtr->ComVariant;
#  endif
    /* Set bridge */
    Dcm_SingletonContext.VarMgr.ActiveBridgeVariant = configPtr->BridgeVariant;

#  if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
    Dcm_SingletonContext.VarMgr.ActiveRamVariant = *(configPtr->RamVariant);
    Dcm_SingletonContext.VarMgr.ActiveRomVariant = *(configPtr->RomVariant);
#  endif

    /* Store currently active CFG-criteria(s) */
#  if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
#   if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_OFF)
    Dcm_SingletonContext.VarMgr.ActiveCfgVariantId = configPtr->DiagVariantId;
#   endif
#  endif
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_INIT, lErrorId);
# endif

# if (DCM_VARMGR_MODE_POSTBUILD_ANY_ENABLED == STD_ON)
  lResult = (boolean) (lErrorId == DCM_E_NO_ERROR);                                                                                                  /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
# else
  lResult = TRUE;
# endif

  DCM_IGNORE_UNREF_PARAM(configPtr);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return lResult;
}
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrInitActiveCfgVariants()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrInitActiveCfgVariants(
  void
  )
{
  Dcm_CfgVarMgrDiagVariantIdOptType lVariantIter;
  /* Deactivate all Variants in ActiveCfgVariant Bitmap */
  for (lVariantIter = 0; lVariantIter < Dcm_VarMgrBitSetCalcSize(DCM_VARMGR_NUM_CFG_VARIANTS); ++lVariantIter)
  {
    Dcm_SingletonContext.VarMgr.ActiveCfgVariants[lVariantIter] = 0u;                                                                                /* SBSW_DCM_POINTER_WRITE_VSGACTIVECFGVARIANTS */
  }

  Dcm_VarMgrBitSetSetBit(Dcm_SingletonContext.VarMgr.ActiveCfgVariants, 0u);/* activate base variant */                                              /* SBSW_DCM_POINTER_WRITE_BITSET */
}
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrVsgSetSingle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrVsgSetSingle(
  Dcm_VsgIdentifierType VsgId,
  Dcm_VsgStateType State
  )
{
  if(State == DCM_VSG_ENABLED)
  {
    Dcm_VarMgrBitSetSetBit(Dcm_SingletonContext.VarMgr.ActiveCfgVariants, VsgId);                                                                    /* SBSW_DCM_POINTER_WRITE_BITSET */
  } /* else State == DCM_VSG_DISABLED */
  else
  {
    Dcm_VarMgrBitSetClrBit(Dcm_SingletonContext.VarMgr.ActiveCfgVariants, VsgId);                                                                    /* SBSW_DCM_POINTER_WRITE_BITSET */
  }
}
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrVsgIsActive()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrVsgIsActive(
  Dcm_VsgIdentifierType VsgId,
  P2VAR(Dcm_VsgStateType, AUTOMATIC, DCM_APPL_DATA) State
  )
{
  /* If Bit assigned to VsgId is set */
  if ((boolean)Dcm_VarMgrBitSetTestBit(Dcm_SingletonContext.VarMgr.ActiveCfgVariants, VsgId) == TRUE)                                                /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
  {
    /* Set out parameter to enabled */
    *State = DCM_VSG_ENABLED;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  /* If Bit assigned to VsgId is cleared */
  else
  {
    /* Set out parameter to disabled */
    *State = DCM_VSG_DISABLED;                                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}
#endif
#if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc01ServiceInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc01ServiceInfoGetEntry(
  uint8_least index,
  CONSTP2VAR(Dcm_CfgSvc01ServiceInfoPtrType, AUTOMATIC, AUTOMATIC) pServiceInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= DCM_CFGSVC01SERVICEINFOTABLE_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pServiceInfo = &Dcm_CfgSvc01ServiceInfoTable[index];                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc01Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc01Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc01RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  pRepContext->ParserDesc.LookUpTable       = Dcm_CfgSvc01LookUpTable;                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ParserDesc.LookUpFilterTable = Dcm_CfgSvc01ExecPrecondTable;                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ParserDesc.MaskData          = Dcm_CfgSvc01SupportedIdMask;                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */

  if(Dcm_ObdIdMgrIsAvailabilityId(pMsgContext->reqData[0]))
  {
    lStdResult = Dcm_ObdIdMgrProcessSupportedIdRequest(pMsgContext, &(pRepContext->ParserDesc), ErrorCode);                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    if(pMsgContext->reqDataLen <= 6u)
    {
      uint8_least lIdIter;

      for(lIdIter = 0; lIdIter < pMsgContext->reqDataLen; lIdIter++)
      {
        if(Dcm_ObdIdMgrIsAvailabilityId(pMsgContext->reqData[lIdIter]))
        {
          /* Otherwise return NRC 0x31 (Mix of Data and Availability IDs is not allowed) */
          *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
          break;
        }
      }

      if(lStdResult == DCM_E_OK)
      {
        Dcm_RepeaterNextStep(pContext, DCM_SVC01_PROGRESS_REPEATERPROXY);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
        lStdResult = DCM_E_LOOP;
      }
    }
    else
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc01_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc01_XX_RepeaterProxy(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc01RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  uint8_least    lNumberOfIds = (uint8_least)pMsgContext->reqDataLen;
  uint8          lIdList[DCM_OBDIDMGR_MAX_NUMBER_OF_IDS];
  uint8_least    lIdIter;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Copy all requested IDs to local list. This allows to write into response buffer during parsing. */
  Dcm_UtiConsumeReqDataAsUN(pMsgContext, lIdList, DCM_OBDIDMGR_MAX_NUMBER_OF_IDS, pMsgContext->reqDataLen);                                          /* SBSW_DCM_COMB_PTR_FORWARD */

  for(lIdIter = 0; lIdIter < lNumberOfIds; lIdIter++)
  {
    uint8 lId = lIdList[lIdIter];

    if(Dcm_ObdIdMgrIdLookUp(lId, &(pRepContext->ParserDesc)) == DCM_E_OK)                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
    {
      Dcm_CfgSvc01ServiceInfoPtrType pServiceInfo;

      lStdResult = Dcm_CfgSvc01ServiceInfoGetEntry(pRepContext->ParserDesc.Handle, &pServiceInfo, ErrorCode);                                        /* SBSW_DCM_COMB_PTR_FORWARD */

      Dcm_UtiProvideResDataAsU8(pMsgContext, lId);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

      if(lStdResult == DCM_E_OK)                                                                                                                     /* COV_DCM_RTM_RUNTIME_CHECK TX */
      {
        lStdResult = Dcm_UtiMsgContextVerifySize(pMsgContext, pServiceInfo->ResLength, ErrorCode);                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

        if(lStdResult == DCM_E_OK)                                                                                                                   /* COV_DCM_RTM_RUNTIME_CHECK TX */
        {
          lStdResult = pServiceInfo->OpFunc(Dcm_UtiGetResData(pMsgContext));                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_CALL_FUNCPTR_SVC01SERVICEINFO */

          if(lStdResult == DCM_E_OK)
          {
            Dcm_UtiProvideResData(pMsgContext, pServiceInfo->ResLength);                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
          }
          else
          {
            *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
            lStdResult = DCM_E_NOT_OK;
          }
        }

        if (lStdResult == DCM_E_NOT_OK)
        {
          break;
        }
      }
    }
  }

  /* If no requested ID was supported: */
  if (pMsgContext->resDataLen == 0u)
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */
#endif /* (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc02Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc02Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc02RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* At maximum 3 PID + 3 FF can be requested */
  if( (pMsgContext->reqDataLen <= 6u)
    &&(Dcm_UtiIsEven(pMsgContext->reqDataLen)) )
  {
    pRepContext->ParserDesc.LookUpTable       = Dcm_CfgSvc02LookUpTable;                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->ParserDesc.LookUpFilterTable = Dcm_CfgSvc02ExecPrecondTable;                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->ParserDesc.MaskData          = Dcm_CfgSvc02SupportedIdMask;                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->DemClientId = Dcm_DiagGetDemClientId(Dcm_NetGetProtIdOfMsgContext(pMsgContext));                                                    /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_PARAM_PTR_WRITE */

    Dcm_RepeaterNextStep(pContext, DCM_SVC02_PROGRESS_REPEATERPROXY);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc02_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc02_XX_RepeaterProxy(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc02RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  Dcm_ObdIdMgrHandleOptType lPidIter = (Dcm_ObdIdMgrHandleOptType)pMsgContext->reqDataLen;
  uint8_least lPidTypeMask = 0x00u;
  uint8 lPidList[6];
  uint8 lFreezeFrameId;
  uint8 lPid;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Store the requested data */
  Dcm_UtiConsumeReqDataAsUN(pMsgContext, lPidList, 6u, pMsgContext->reqDataLen);                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

  do
  {
    /* OBD specification does not specify the order of PIDs in the response, thus it is ok to scan the requested PIDs backwards */
    --lPidIter;      /* navigate to the FF */
    lFreezeFrameId = lPidList[lPidIter];
    --lPidIter;      /* navigate to the PID */
    lPid = lPidList[lPidIter];

    lPidTypeMask |= (uint8)(Dcm_ObdIdMgrIsAvailabilityId(lPid) ? 0x01u : 0x02u);  /* mark availability/DATA PID found (never matter whether it is supported or not!) */

    if (lPidTypeMask != 0x03u)
    {
      if( (Dcm_ObdIdMgrIdLookUp(lPid, &(pRepContext->ParserDesc)) == DCM_E_OK)                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
        &&(lFreezeFrameId == 0x00u) ) /* Accept only FF = 0 */
      {
        if(Dcm_Svc02ReadPidData(lPid, pMsgContext, pRepContext) == DCM_E_OK)                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
        {
          lStdResult = DCM_E_OK;
        }
      }/* else:
       - FreezeFrame != 0 --> ignore
       - PID not supported --> ignore */
    }
    else
    {
      /* Otherwise return NRC 0x31 (Mix of Data and Availability PIDs is not allowed) */
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      break;
    }
  } while (lPidIter != 0u);

  /* If no PID was read send NRC 0x31 */
  if(lStdResult == DCM_E_NOT_OK)
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  return lStdResult;
}
/**********************************************************************************************************************
 *  Dcm_Svc02ReadPidData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc02ReadPidData(
  uint8 pid,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_Svc02RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  /*
   * Check for sufficent buffer - It is ensured by the buffer size validation,
   * that the buffer is large enough to hold three availability PIDs plus data in the response
   */
  if(pMsgContext->resMaxDataLen < 4u)
  {
    lStdResult = DCM_E_NOT_OK;
  }
  else if(Dcm_ObdIdMgrIsAvailabilityId(pid))
  {
    Dcm_UtiProvideResDataAsU8(pMsgContext, pid);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_UtiProvideResDataAsU8(pMsgContext, 0x00u); /* Only FF 0x00 is supported */                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_UtiProvideResDataAsU32(pMsgContext, Dcm_ObdIdMgrGetAvailabilityMask(pid, &(pRepContext->ParserDesc)));                                       /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else if(pid == 0x02u)
  {
    uint32 lDtc;

    Dcm_UtiProvideResDataAsU8(pMsgContext, 0x02u);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_UtiProvideResDataAsU8(pMsgContext, 0x00u); /* Only FF 0x00 is supported */                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

    if (Dcm_DemApiGetDTCOfOBDFreezeFrame(0x00u, &lDtc, DEM_DTC_FORMAT_OBD) != E_OK)                                                                  /* SBSW_DCM_POINTER_FORWARD_STACK */
    {
      lDtc = 0x0000u;
    }

    /* PID 0x02: DTC that stored the freeze frame */
    Dcm_UtiProvideResDataAsU8(pMsgContext, Dcm_UtiGetHiLoByte(lDtc));                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_UtiProvideResDataAsU8(pMsgContext, Dcm_UtiGetLoHiByte(lDtc));                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    /* other PID: get data from freeze frame */
    Std_ReturnType lStdReturn;
    Dcm_MsgLenType lBufSize;
    Dcm_MsgType    lFreezeFrameDataBuffer;

    lBufSize = Dcm_UtiGetRemainingResLenWithOffset(pMsgContext, 2u);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    lFreezeFrameDataBuffer = Dcm_UtiGetResDataRel(pMsgContext, 2u);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdReturn = Dcm_DemApiReadDataOfOBDFreezeFrame(pid
                                                   ,0x00u /* DCM does not know the data index, so 0x00 is used here */
                                                   ,lFreezeFrameDataBuffer
                                                   ,&lBufSize);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

    if( (lStdReturn == E_OK)
      &&(lBufSize > 0u) )
    {
      Dcm_UtiProvideResDataAsU8(pMsgContext, pid);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_UtiProvideResDataAsU8(pMsgContext, 0x00u); /* Only FF 0x00 is supported */                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

      /* PID have been successfully read */
      Dcm_UtiProvideResData(pMsgContext, lBufSize);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      /* else - PID can not be read or no data stored --> ignore */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif /* (DCM_SVC_02_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc03Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc03Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_ObdDtcManagerContextPtrType pRepContext                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if (pMsgContext->reqDataLen == 0u)
  {
    pRepContext->DemClientId = Dcm_DiagGetDemClientId(Dcm_NetGetProtIdOfMsgContext(pMsgContext));                                                    /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_RepeaterNextStep(pContext, DCM_SVC03_PROGRESS_SETDTCFILTER);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc03UtiDemSetDTCFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc03UtiDemSetDTCFilter(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_ObdDtcManagerContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_ObdDtcMgrDemSetDTCFilter(DCM_DTC_BIT_CONF_DTC
# if (DCM_DEM_API_421_ENABLED == STD_ON)
                                           ,DEM_DTC_ORIGIN_PRIMARY_MEMORY
# else
                                           ,DEM_DTC_ORIGIN_OBD_RELEVANT_MEMORY
# endif
                                           ,pMsgContext
                                           ,ErrorCode
                                           ,pRepContext);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_RepeaterNextStep(pContext, DCM_SVC03_PROGRESS_READDTCBYSTATUSMASK);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */

  return lStdResult;
}
#endif /* (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc04Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc04Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc04RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  )
{
  Std_ReturnType lStdResult;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(pMsgContext->reqDataLen == 0u)
  {
    Dcm_RepeaterSetUser(pContext, DCM_REPEATER_USER_DEM); /* set user for central repeater handling */                                               /* SBSW_DCM_PARAM_PTR_WRITE */
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
    Dcm_RepeaterNextStep(pContext, DCM_SVC04_PROGRESS_REPEATERPROXY_SELECT_DTC);                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
# else
    Dcm_RepeaterNextStep(pContext, DCM_SVC04_PROGRESS_REPEATERPROXY);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
# endif
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc04_XX_RepeaterProxy_SelectDTC()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc04_XX_RepeaterProxy_SelectDTC(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc04RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;
  Std_ReturnType lDemResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lDemResult = Dcm_DemAPI(SelectDTC)(pRepContext->DemClientId
                                    ,DEM_DTC_GROUP_ALL_DTCS
                                    ,DEM_DTC_FORMAT_OBD
                                    ,DEM_DTC_ORIGIN_OBD_RELEVANT_MEMORY);

  switch(lDemResult)
  {
  case E_OK:
    lStdResult = DCM_E_LOOP;
    Dcm_RepeaterNextStep(pContext, DCM_SVC04_PROGRESS_REPEATERPROXY);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_DEM_RET_SELECT_BUSY:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc04_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc04_XX_RepeaterProxy(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc04RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnClearDTCType lResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lResult = Dcm_DemAPI(ClearDTC)(
# if (DCM_DEM_API_421_ENABLED == STD_ON)
                                 DEM_DTC_GROUP_ALL_DTCS
                                ,DEM_DTC_FORMAT_OBD
                                ,DEM_DTC_ORIGIN_PRIMARY_MEMORY
# else
                                 pRepContext->DemClientId
# endif
                                );

  switch(lResult)
  {
  case DCM_DEM_RET_CLEAR_OK:
    lStdResult = DCM_E_OK;
    break;
  case DCM_DEM_RET_CLEAR_PENDING:
    lStdResult = DCM_E_PENDING; /* try again later */
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lResult, Dcm_Svc04NrcMapClearDTC);                                                                   /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc06Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc06Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc06RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;
  uint8 lObdMid = pMsgContext->reqData[0];

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if (Dcm_ObdIdMgrIsAvailabilityId(lObdMid))
  {
    lStdResult = Dcm_Service06ProcessSupportedMidRequest(pMsgContext, ErrorCode);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else if (pMsgContext->reqDataLen == 1u)
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC06_PROGRESS_REPEATERPROXY);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc06_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc06_XX_RepeaterProxy(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc06RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint8 lObdMid = pMsgContext->reqData[0];
  uint8 lNumOfTIDs;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Request number of TIDs for MID from Dem */
  if (Dem_DcmGetNumTIDsOfOBDMID(lObdMid, &lNumOfTIDs) == E_OK)                                                                                       /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    /* #10 If request is successful */
    uint8 lTidIter;
    uint8 lTIDValue;
    uint8 lUaSID;
    uint16 lTestValue;
    uint16 lTestValueMin;
    uint16 lTestValueMax;

    /* Request Test Result of each TID from Dem */
    for (lTidIter = 0; lTidIter < lNumOfTIDs; lTidIter++)
    {
      if (Dem_DcmGetDTRData(lObdMid
                           ,lTidIter
                           ,&lTIDValue
                           ,&lUaSID
                           ,&lTestValue
                           ,&lTestValueMin
                           ,&lTestValueMax) == E_OK)                                                                                                 /* SBSW_DCM_POINTER_FORWARD_STACK */
      {

        /* #20 If request is successful for a TID */

        /* #30 If response data buffer has not enough space */
        if (pMsgContext->resMaxDataLen < 9u)
        {
          /* Set NRC DCM_E_REQUESTOUTOFRANGE */
          *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
        /* Otherwise copy response data to response buffer */
        else
        {
          Dcm_UtiProvideResDataAsU8(pMsgContext, lObdMid);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

          Dcm_UtiProvideResDataAsU8(pMsgContext, lTIDValue);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

          Dcm_UtiProvideResDataAsU8(pMsgContext, lUaSID);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */

          Dcm_UtiProvideResDataAsU16(pMsgContext, lTestValue);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
          Dcm_UtiProvideResDataAsU16(pMsgContext, lTestValueMin);                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
          Dcm_UtiProvideResDataAsU16(pMsgContext, lTestValueMax);                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
      }
      else
      {
        /* Otherwise set NRC DCM_E_CONDITIONSNOTCORRECT */
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }

      /* #40 If any unexpected error occurred */
      if( lStdResult != DCM_E_OK)
      {
        /* Exit service processing */
        break;
      }
    }
  }
  else
  {
    /* Otherwise set NRC DCM_E_REQUESTOUTOFRANGE */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service06ProcessSupportedMidRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service06ProcessSupportedMidRequest(
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint8_least lMidIter;
  uint8_least lNumberOfMids = (uint8) pMsgContext->reqDataLen;

  if (pMsgContext->reqDataLen <= DCM_OBDIDMGR_MAX_NUMBER_OF_IDS) /* Up to 6 IDs possible */
  {
    /* Check if any MID in request is not an availability MID (0x00, 0x20, 0x40...) */
    for (lMidIter = 0; lMidIter < lNumberOfMids; lMidIter++)
    {
      if (!Dcm_ObdIdMgrIsAvailabilityId(pMsgContext->reqData[lMidIter]))
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
        break;
      }
    }

    if (lStdResult == DCM_E_OK)
    {
      lStdResult = Dcm_Service06Process_SupportedMids(pMsgContext, ErrorCode);                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service06Process_SupportedMids()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service06Process_SupportedMids(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint8_least lMidIter;
  uint8_least lNumberOfMids = (uint8) pMsgContext->reqDataLen;

  uint8 lMidList[DCM_OBDIDMGR_MAX_NUMBER_OF_IDS];
  /* Copy all requested IDs to local list. This allows to write into response buffer during parsing. */
  Dcm_UtiConsumeReqDataAsUN(pMsgContext, lMidList, DCM_OBDIDMGR_MAX_NUMBER_OF_IDS, pMsgContext->reqDataLen);                                         /* SBSW_DCM_COMB_PTR_FORWARD */

  /* Request from Dem value of each MID */
  for (lMidIter = 0; lMidIter < lNumberOfMids; lMidIter++)
  {
    uint32 lObdMidAvailMask;
    if (Dem_DcmGetAvailableOBDMIDs((lMidList[lMidIter]), &lObdMidAvailMask) == E_OK)                                                                 /* SBSW_DCM_POINTER_FORWARD_STACK */
    {
      /* If response data buffer has not enough space */
      if (pMsgContext->resMaxDataLen < 5u)
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
        break;
      }
      /* Otherwise copy MID and MID value to response buffer */
      else
      {
        Dcm_UtiProvideResDataAsU8(pMsgContext, (lMidList[lMidIter]));                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_UtiProvideResDataAsU32(pMsgContext, lObdMidAvailMask);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
    }
    /* else NRC will be set later if response length equal 0 -> none of the OBD MIDs could be read */
  }

  /* If response data buffer is empty  */
  if (pMsgContext->resDataLen == 0u)
  {
    /* return NRC DCM_E_REQUESTOUTOFRANGE */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc06MidTidInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc06MidTidInfoGetEntry(
  uint8_least index,
  CONSTP2VAR(Dcm_CfgSvc06MidTidInfoPtrType, AUTOMATIC, AUTOMATIC) pMidTidInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= DCM_CFGSVC06MIDTIDINFOTABLE_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pMidTidInfo = &Dcm_CfgSvc06MidTidInfoTable[index];                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc06Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc06Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc06RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  pRepContext->ParserDesc.LookUpTable       = Dcm_CfgSvc06LookUpTable;                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ParserDesc.LookUpFilterTable = Dcm_CfgSvc06ExecPrecondTable;                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ParserDesc.MaskData          = Dcm_CfgSvc06SupportedIdMask;                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */

  if(Dcm_ObdIdMgrIsAvailabilityId(pMsgContext->reqData[0]))
  {
    lStdResult = Dcm_ObdIdMgrProcessSupportedIdRequest(pMsgContext, &(pRepContext->ParserDesc), ErrorCode);                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    if(pMsgContext->reqDataLen == 1u)
    {
      if(Dcm_ObdIdMgrIdLookUp(pMsgContext->reqData[0], &(pRepContext->ParserDesc)) == DCM_E_OK)                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
      {
        Dcm_RepeaterNextStep(pContext, DCM_SVC06_PROGRESS_REPEATERPROXY);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
        lStdResult = DCM_E_LOOP;
      }
      else
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
    else
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc06_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc06_XX_RepeaterProxy(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc06RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType                 lStdResult = DCM_E_OK;
  uint16                         lTestValue;
  uint16                         lMinLimit;
  uint16                         lMaxLimit;
  Dcm_DTRStatusType              lStatus;
  Dcm_CfgSvc06Mid2TidRefOptType  lHandle    = Dcm_CfgSvc06Mid2TidRefMap[pRepContext->ParserDesc.Handle];
  Dcm_CfgSvc06Mid2TidRefOptType  lMaxHandle = Dcm_CfgSvc06Mid2TidRefMap[pRepContext->ParserDesc.Handle + 1u];
  Dcm_CfgSvc06MidTidInfoPtrType  pMidTidInfo;

  for(; lHandle<lMaxHandle; lHandle++)
  {
    lStdResult = Dcm_CfgSvc06MidTidInfoGetEntry(lHandle, &pMidTidInfo, ErrorCode);                                                                   /* SBSW_DCM_COMB_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)                                                                                                                       /* COV_DCM_RTM_RUNTIME_CHECK TX */
    {
      if(pMidTidInfo->OpFunc(opStatus, &lTestValue, &lMinLimit, &lMaxLimit, &lStatus) == DCM_E_OK)                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */ /* SBSW_DCM_CALL_FUNCPTR_SVC06MIDTIDINFO */
      {
        if(lStatus == DCM_DTRSTATUS_INVISIBLE)
        {
          lTestValue = 0;
          lMinLimit  = 0;
          lMaxLimit  = 0;
        }

        /* Copy data */
        Dcm_UtiProvideResDataAsU8(pMsgContext, pMsgContext->reqData[0]);                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_UtiProvideResDataAsU8(pMsgContext, pMidTidInfo->Tid);                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_UtiProvideResDataAsU8(pMsgContext, pMidTidInfo->Uasid);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_UtiProvideResDataAsU16(pMsgContext, lTestValue);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_UtiProvideResDataAsU16(pMsgContext, lMinLimit);                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_UtiProvideResDataAsU16(pMsgContext, lMaxLimit);                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      else
      {
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }

    if (lStdResult != DCM_E_OK)
    {
      break;
    }
  }
  return lStdResult;
}
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_07_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc07Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc07Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_ObdDtcManagerContextPtrType pRepContext                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if (pMsgContext->reqDataLen == 0u)
  {
    pRepContext->DemClientId = Dcm_DiagGetDemClientId(Dcm_NetGetProtIdOfMsgContext(pMsgContext));                                                    /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_RepeaterNextStep(pContext, DCM_SVC07_PROGRESS_SETDTCFILTER);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc07UtiDemSetDTCFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc07UtiDemSetDTCFilter(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_ObdDtcManagerContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_ObdDtcMgrDemSetDTCFilter(DCM_DTC_BIT_PNDG_DTC
# if (DCM_DEM_API_421_ENABLED == STD_ON)
                                           ,DEM_DTC_ORIGIN_PRIMARY_MEMORY
# else
                                           ,DEM_DTC_ORIGIN_OBD_RELEVANT_MEMORY
# endif
                                           ,pMsgContext
                                           ,ErrorCode
                                           ,pRepContext);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_RepeaterNextStep(pContext, DCM_SVC07_PROGRESS_READDTCBYSTATUSMASK);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */

  return lStdResult;
}
#endif /* (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc08ServiceInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc08ServiceInfoGetEntry(
  uint8_least index,
  CONSTP2VAR(Dcm_CfgSvc08ServiceInfoPtrType, AUTOMATIC, AUTOMATIC) pServiceInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= DCM_CFGSVC08SERVICEINFOTABLE_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pServiceInfo = &Dcm_CfgSvc08ServiceInfoTable[index];                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc08Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc08Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc08RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  pRepContext->ParserDesc.LookUpTable       = Dcm_CfgSvc08LookUpTable;                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ParserDesc.LookUpFilterTable = Dcm_CfgSvc08ExecPrecondTable;                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ParserDesc.MaskData          = Dcm_CfgSvc08SupportedIdMask;                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */

  if(Dcm_ObdIdMgrIsAvailabilityId(pMsgContext->reqData[0]))
  {
    lStdResult = Dcm_ObdIdMgrProcessSupportedIdRequest(pMsgContext, &(pRepContext->ParserDesc), ErrorCode);                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    if(Dcm_ObdIdMgrIdLookUp(pMsgContext->reqData[0], &(pRepContext->ParserDesc)) == DCM_E_OK)                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    {
      Dcm_RepeaterNextStep(pContext, DCM_SVC08_PROGRESS_REPEATERPROXY);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_LOOP;
    }
    else
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc08_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc08_XX_RepeaterProxy(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc08RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType                  lStdResult;
  Dcm_CfgSvc08ServiceInfoPtrType  pServiceInfo;

  lStdResult = Dcm_CfgSvc08ServiceInfoGetEntry(pRepContext->ParserDesc.Handle, &pServiceInfo, ErrorCode);                                            /* SBSW_DCM_COMB_PTR_FORWARD */

  if(opStatus == DCM_INITIAL)
  {
    /* Move pointer to request and response buffer to correct position */
    Dcm_UtiConsumeReqData(pMsgContext, 1u);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_UtiProvideResData(pMsgContext, 1u);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = Dcm_UtiMsgContextVerifySize(pMsgContext, pServiceInfo->ResLength, ErrorCode);                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)                                                                                                                       /* COV_DCM_RTM_RUNTIME_CHECK TX */
    {
      /* Data TID -> only one possible */
      if(pMsgContext->reqDataLen == pServiceInfo->ReqLength)
      {
        lStdResult = pServiceInfo->OpFunc(Dcm_UtiGetResData(pMsgContext)
                                         ,Dcm_UtiGetReqData(pMsgContext));                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_CALL_FUNCPTR_SVC08SERVICEINFO */

        if(lStdResult == DCM_E_OK)
        {
          /* Prepare for positive response with specific length of the data (TID is already provided) */
          Dcm_UtiProvideResData(pMsgContext, pServiceInfo->ResLength);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
        else
        {
          *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
      else
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
  }

  return lStdResult;
}
#endif /* (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc09ServiceInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc09ServiceInfoGetEntry(
  uint8_least index,
  CONSTP2VAR(Dcm_CfgSvc09ServiceInfoPtrType, AUTOMATIC, AUTOMATIC) pServiceInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= DCM_CFGSVC09SERVICEINFOTABLE_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pServiceInfo = &Dcm_CfgSvc09ServiceInfoTable[index];                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}


/**********************************************************************************************************************
 *  Dcm_Svc09Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc09Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc09RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  pRepContext->ParserDesc.LookUpTable       = Dcm_CfgSvc09LookUpTable;                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ParserDesc.LookUpFilterTable = Dcm_CfgSvc09ExecPrecondTable;                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ParserDesc.MaskData          = Dcm_CfgSvc09SupportedIdMask;                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */

  if(Dcm_ObdIdMgrIsAvailabilityId(pMsgContext->reqData[0]))
  {
    lStdResult = Dcm_ObdIdMgrProcessSupportedIdRequest(pMsgContext, &(pRepContext->ParserDesc), ErrorCode);                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    if(pMsgContext->reqDataLen == 1u)
    {
      if(Dcm_ObdIdMgrIdLookUp(pMsgContext->reqData[0], &(pRepContext->ParserDesc)) == DCM_E_OK)                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
      {
        Dcm_RepeaterNextStep(pContext, DCM_SVC09_PROGRESS_CHECKACCESS);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
        lStdResult = DCM_E_LOOP;
      }
      else
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
    else
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc09CheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc09CheckAccess(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc09RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;
  uint16         lVID = Dcm_UtiMake16Bit((uint8)0xF8u, pMsgContext->reqData[0]);

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_RsrcMgrGetDidLock(opStatus, lVID, DCM_RSRCMGR_DIDLOCK_OWNER_SID09);

  if(lStdResult == DCM_E_OK)
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC09_PROGRESS_REPEATERPROXY); /* delegate job */                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc09_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc09_XX_RepeaterProxy(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc09RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType                  lStdResult;
  Dcm_CfgSvc09ServiceInfoPtrType  pServiceInfo;

  lStdResult = Dcm_CfgSvc09ServiceInfoGetEntry(pRepContext->ParserDesc.Handle, &pServiceInfo, ErrorCode);                                            /* SBSW_DCM_COMB_PTR_FORWARD */

  if(opStatus == DCM_INITIAL)
  {
    /* Write the VID first, then the response data */
    Dcm_UtiProvideResDataAsU8(pMsgContext, pMsgContext->reqData[0]);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = Dcm_UtiMsgContextVerifySize(pMsgContext, pServiceInfo->ResLength, ErrorCode);                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)                                                                                                                       /* COV_DCM_RTM_RUNTIME_CHECK TX */
    {
      uint8 lVidDataLength = pServiceInfo->ResLength;

      /* compose response record */
      lStdResult = pServiceInfo->OpFunc(opStatus
                                       ,Dcm_UtiGetResData(pMsgContext)                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
# if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
                                       ,&lVidDataLength
# endif
                                       );                                                                                                            /* SBSW_DCM_COMB_PTR_FORWARD */ /* SBSW_DCM_CALL_FUNCPTR_SVC09SERVICEINFO */

      if(opStatus == DCM_CANCEL)
      {
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }

      if (lStdResult == DCM_E_OK)
      {
# if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
        /* Update final response length only in positive/final case */
        if (Dcm_DebugDetectError(lVidDataLength > pServiceInfo->ResLength))
        {
          lStdResult = DCM_E_NOT_OK;
          *ErrorCode = DCM_E_PANIC_NRC;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
          Dcm_DebugReportError(DCM_SID_SVCPORT_DATASVCS_OP_READVID, DCM_E_INTERFACE_BUFFER_OVERFLOW);
        }
        else
# endif
        {
          /* VID reading finished with OK -> check for next */
          Dcm_UtiProvideResData(pMsgContext, lVidDataLength); /* data size */                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
      }
      else if(lStdResult == DCM_E_PENDING)
      {
        /* Retry later */
      }
      else
      {
        Dcm_DebugAssert((lStdResult == DCM_E_NOT_OK), DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);

        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }

    if(lStdResult != DCM_E_PENDING)
    {
      Dcm_RsrcMgrReleaseDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID09);
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc0AHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc0AHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_ObdDtcManagerContextPtrType pRepContext                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if (pMsgContext->reqDataLen == 0u)
  {
    pRepContext->DemClientId = Dcm_DiagGetDemClientId(Dcm_NetGetProtIdOfMsgContext(pMsgContext));                                                    /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_RepeaterNextStep(pContext, DCM_SVC0A_PROGRESS_SETDTCFILTER);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc0AUtiDemSetDTCFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc0AUtiDemSetDTCFilter(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_ObdDtcManagerContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_ObdDtcMgrDemSetDTCFilter(DCM_DTC_BIT_DONT_CARE, DEM_DTC_ORIGIN_PERMANENT_MEMORY, pMsgContext, ErrorCode, pRepContext);            /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_RepeaterNextStep(pContext, DCM_SVC0A_PROGRESS_READDTCBYSTATUSMASK);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */

  return lStdResult;
}
#endif /* (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_TriggerReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_TriggerReset(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;
  Dcm_NetTransportObjectConstPtrType pTranspObj = Dcm_DiagGetTranspObj(pContext->Thread);

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Prepare programming conditions */
  (void)Dcm_GetActiveProtocol(&pRepContext->ProgConditions.ProtocolId);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
# if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
  pRepContext->ProgConditions.ConnectionId = Dcm_PbCfgNetConnectionInfo[pTranspObj->ConnHdl].ConnectionId;                                           /* SBSW_DCM_PARAM_PTR_WRITE */
# endif
  pRepContext->ProgConditions.TesterSourceAddr = pTranspObj->ClientSrcAddr;                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ProgConditions.Sid = 0x10u;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ProgConditions.SubFuncId = Dcm_CfgSvc10SubFuncLookUpTable[pRepContext->SesStateIdx+1u];                                               /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ProgConditions.ReprogrammingRequest = TRUE;                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
  /* This flag shall be initialized from the FBL, not the DCM!
  pRepContext->ProgConditions.ApplUpdated = TRUE; */
  /* To be set once the Dcm_setProgCond API is called in order to consider the current RCR-RP status!
    * pRepContext->ProgConditions.ResponseRequired = ...; */
  pRepContext->ResetMode = (Rte_ModeType_DcmEcuReset)( (Dcm_CfgSvc10SubFuncInfo[pRepContext->SesStateIdx].BootType == DCM_SVC10_BOOT_TYPE_OEM)
                                                      ? RTE_MODE_DcmEcuReset_JUMPTOBOOTLOADER
                                                      : RTE_MODE_DcmEcuReset_JUMPTOSYSSUPPLIERBOOTLOADER);                                           /* SBSW_DCM_PARAM_PTR_WRITE */

  if(Dcm_ModeSwitchEcuReset(pRepContext->ResetMode) == DCM_E_OK)                                                                                     /* PRQA S 2991, 2995 */ /* MD_Dcm_ConstExpr, MD_Dcm_ConstExpr */
  {
    /* Determine entry point - with or without RCR-RP */
    Dcm_RepeaterNextStep(pContext, DCM_SVC10_PROGRESS_WAIT_RESET_ACK);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP; /* start immediately */
  }
  else
  {
    /* for some reason, no mode switch is possible - exit with NRC */
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */ /* PRQA S 2880 */ /* MD_MSR_Unreachable */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
#endif

#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_WaitForResetAck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_WaitForResetAck(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Check mode switch state */
  lStdResult = Dcm_ModeSwitchAckEcuReset();
  switch(lStdResult)
  {
  case DCM_E_PENDING:                                                                                                                                /* PRQA S 2880 */ /* MD_MSR_Unreachable */
    break;
  case DCM_E_OK:
    Dcm_RepeaterNextStep(pContext, DCM_SVC10_PROGRESS_WAIT_RCRRP_ACK);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    if(Dcm_NetGetProtObjOfTranspObj(Dcm_DiagGetTranspObj(pContext->Thread))->HasRespPendOnBoot == TRUE)                                              /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */ /* COV_DCM_RTM_DEPENDS_ON_UNSUPPORTED TX */
    {
      lStdResult = DCM_E_FORCE_RCRRP;
    }
    else
    {
      lStdResult = DCM_E_LOOP;
    }
    break;/* go on with next step - fall through */
  default:
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }

  return lStdResult;
}
#endif

#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_WaitForRcrRpAck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_WaitForRcrRpAck(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(opStatus == DCM_FORCE_RCRRP_NOT_OK)
  {
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
  {
# if (DCM_SVC_10_RST2BOOT_HIS_ENABLED == STD_ON)
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    Dcm_SplitTaskEnterCS();/* avoid interrupt from the Dcm_DiagTaskTx */
    if(pMsgContext->msgAddInfo.suppressPosResponse != 0u)
    {
      pRepContext->ProgConditions.ResponseRequired = FALSE;                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      /* Stop to avoid inconsistency between P2 timer and the SetProgCond asynchronous API's "ResponseRequired" value */
      Dcm_TmrStopTimerByThread(DCM_TMR_ID_P2, pContext->Thread->ThreadId);
    }
    else
    {
      pRepContext->ProgConditions.ResponseRequired = TRUE;                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    Dcm_SplitTaskLeaveCS();/* avoid interrupt from the Dcm_DiagTaskTx */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
# else
    pRepContext->ProgConditions.ResponseRequired = FALSE;/* no response required since DCM sends the final response */                               /* SBSW_DCM_PARAM_PTR_WRITE */
# endif

    Dcm_RepeaterNextStep(pContext, DCM_SVC10_PROGRESS_SET_PRGCOND);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }
  return lStdResult;
}
#endif

#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_SetProgConditions()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_SetProgConditions(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Consider the SPRMIB now in order to take any sent RCR-RP response */
  lStdResult = Dcm_SetProgConditions(&pRepContext->ProgConditions);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
  switch(lStdResult)
  {
  case DCM_E_OK:
# if (DCM_SVC_10_RST2BOOT_HIS_ENABLED == STD_ON)
    lStdResult = Dcm_ModeSwitchEcuReset(RTE_MODE_DcmEcuReset_EXECUTE);
    if(lStdResult == DCM_E_OK)/* fire and forget */                                                                                                  /* PRQA S 2991, 2995 */ /* MD_Dcm_ConstExpr, MD_Dcm_ConstExpr */
    {
      /* just wait for reset */
      lStdResult = DCM_E_STOP_REPEATER;
    }
    else
    {
      /* This code shall not be reached, since the programming conditions are already set! */
      *ErrorCode = DCM_E_PANIC_NRC; /* Use panic NRC since the first mode switch has succeeded, and this one shall too */                            /* SBSW_DCM_PARAM_PTR_WRITE */ /* PRQA S 2880 */ /* MD_MSR_Unreachable */
      lStdResult = DCM_E_NOT_OK;
    }
# endif
    break; /* send final response and if applicable - do reset */
  case DCM_E_PENDING:
    /* already set */
    break;
  case DCM_E_NOT_OK:
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default:
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */
#endif

/**********************************************************************************************************************
 *  Dcm_Svc10Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10Handler(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext
  )
{
  Dcm_DiagSubServiceRefOptType  subSvcRef;
  Std_ReturnType                lStdResult;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                    ,Dcm_CfgSvc10SubFuncLookUpTable
                                                    ,Dcm_CfgSvc10SubFuncExecPrecondTable
                                                    ,Dcm_DiagSvcWithOnlySubFuncReqLengthGetter
                                                    ,Dcm_DiagNoSequenceChecker
                                                    ,&subSvcRef
                                                    ,ErrorCode);                                                                                     /* SBSW_DCM_COMB_PTR_FORWARD */
  if(lStdResult == DCM_E_OK)
  {
    /* Compose positive response */
    Dcm_UtiProvideResDataAsU16(pMsgContext, Dcm_CfgSvc10SubFuncInfo[subSvcRef].ResponseTime.P2);                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_UtiProvideResDataAsU16(pMsgContext, Dcm_CfgSvc10SubFuncInfo[subSvcRef].ResponseTime.P2Star);                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

    pRepContext->SesStateIdx = (uint8)subSvcRef;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */

    Dcm_RepeaterNextStep(pContext, DCM_SVC10_PROGRESS_CHECK_ACCESS);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP; /* start immediately */
  } /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc10CheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10CheckAccess(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  if(opStatus == DCM_INITIAL)
  {
    Dcm_NetTransportObjectConstPtrType pTranspObj = Dcm_DiagGetTranspObj(pContext->Thread);
    Dcm_StateSetPendingSession(Dcm_UtiGetBitFromIndex(Dcm_CfgStateGroupMemType, pRepContext->SesStateIdx));

    /*
     * Set always a potential tester owner: In case of failed positive response confirmation or negative response,
     * the session will remain in its old state (default) -> the set value does not matter!
     * The situation that the session was a non-default one and another client has requested SID 0x10 is not possible:
     * - Each protocol switch invokes session transition to the default one!
     * - As long as a non-default session is active, no other client with the same priority can access the ECU!
     */
    Dcm_NetSetSessionConnection(pTranspObj->ConnHdl);
    Dcm_NetSetSessionClientSrcAddr(pTranspObj->ClientSrcAddr);
  }

#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
  lStdResult = Dcm_DiagIsSessionChangeAllowed(pContext);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
#endif
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiLeaveCriticalSection();

#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
  if(lStdResult == DCM_E_NOT_OK)
  {
    lStdResult = DCM_E_PENDING;
  }
  else
#endif
  {
#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
    pRepContext->ResetMode = RTE_MODE_DcmEcuReset_NONE;                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    if(Dcm_CfgSvc10SubFuncInfo[pRepContext->SesStateIdx].BootType != DCM_SVC10_BOOT_TYPE_NONE)
    {
      Dcm_RepeaterNextStep(pContext, DCM_SVC10_PROGRESS_TRIGGER_RESET);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_LOOP;
    }
    else
#endif
    {
      /* Just send the final response */
      lStdResult = DCM_E_OK;
    }
  }

  return lStdResult;
}
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc11SubFuncInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc11SubFuncInfoGetEntry(
  Dcm_DiagSubServiceRefOptType SubSvcRef,
  CONSTP2VAR(Dcm_CfgSvc11SubFuncInfoPtrType, AUTOMATIC, AUTOMATIC) pSubFuncInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if (Dcm_DebugDetectRuntimeError(SubSvcRef >= DCM_CFGSVC11SUBFUNCINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pSubFuncInfo = &Dcm_CfgSvc11SubFuncInfo[SubSvcRef];                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc11Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc11RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  pRepContext->SubFuncId = Dcm_UtiGetReqDataAsU8(pMsgContext);                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */ /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */

  /* Min Length already checked in DiagDispatcher and expected to be 1 !!! */
  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc11SubFuncLookUpTable
                                                   ,Dcm_CfgSvc11SubFuncExecPrecondTable
                                                   ,Dcm_DiagSvcWithOnlySubFuncReqLengthGetter
                                                   ,Dcm_DiagNoSequenceChecker
                                                   ,&lSubSvcRef
                                                   ,ErrorCode);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
    pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)lSubSvcRef;                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */

    Dcm_RepeaterNextStep(pContext, DCM_SVC11_PROGRESS_SUBFUNCTION); /* delegate job */                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  } /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc11SubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11SubFuncHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc11RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType                 lStdResult;
  Dcm_CfgSvc11SubFuncInfoPtrType pSubFuncInfo;

  lStdResult = Dcm_CfgSvc11SubFuncInfoGetEntry(pRepContext->SubSvcRef, &pSubFuncInfo, ErrorCode);                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lStdResult == DCM_E_OK)                                                                                                                        /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(pContext, opStatus, pMsgContext, ErrorCode);                                                               /* SBSW_DCM_CALL_FUNCPTR_SVC11SUBFUNC */
  }

  return lStdResult;
}

# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_EcuRst_WaitForAck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_EcuRst_WaitForAck(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc11RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_ModeSwitchAckEcuReset();
  switch(lStdResult)
  {
  case DCM_E_OK:
    /* switch accomplished */
    break;
  case DCM_E_PENDING:                                                                                                                                /* PRQA S 2880 */ /* MD_MSR_Unreachable */
    /* Result already set
      lStdResult = DCM_E_PENDING; */
    break;
  default: /* any error situation */
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_11_RAPID_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_RapPwrDwn_WaitForAck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_RapPwrDwn_WaitForAck(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc11RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_ModeSwitchAckRapidShutDown();
  switch(lStdResult)
  {
  case DCM_E_OK:
    /* switch accomplished */
    break;
  case DCM_E_PENDING:                                                                                                                                /* PRQA S 2880 */ /* MD_MSR_Unreachable */
    /* Result already set
      lStdResult = DCM_E_PENDING; */
    break;
  default: /* any error situation */
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc14Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc14RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(pMsgContext->reqDataLen == 3u)
  {
    pRepContext->DemClientId = Dcm_DiagGetDemClientId(Dcm_NetGetProtIdOfMsgContext(pMsgContext));                                                    /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_GLOBAL_PTR_WRITE */

    /* Store requested DTC for asynchronous processing */
    Dcm_UtiConsumeReqDataAsU24(pMsgContext, &(pRepContext->Dtc));                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

    Dcm_RepeaterSetUser(pContext, DCM_REPEATER_USER_DEM); /* set user for central repeater handling */                                               /* SBSW_DCM_PARAM_PTR_WRITE */
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
    Dcm_RepeaterNextStep(pContext, DCM_SVC14_PROGRESS_REPEATERPROXY_SELECT_DTC);                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
# else
    Dcm_RepeaterNextStep(pContext, DCM_SVC14_PROGRESS_REPEATERPROXY);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
# endif

    lStdResult = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc14_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14_XX_RepeaterProxy(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc14RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType            lStdResult;
  Dcm_DemReturnClearDTCType lResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_DEM_API_421_ENABLED == STD_ON)
  lResult = Dcm_DemAPI(ClearDTC)(pRepContext->Dtc
                                ,DEM_DTC_FORMAT_UDS
                                ,DEM_DTC_ORIGIN_PRIMARY_MEMORY);
# else
  lResult = Dcm_DemAPI(ClearDTC)(pRepContext->DemClientId);
# endif

  switch(lResult)
  {
  case DCM_DEM_RET_CLEAR_OK:
    lStdResult = DCM_E_OK;
    break;
  case DCM_DEM_RET_CLEAR_PENDING:
    lStdResult = DCM_E_PENDING; /* try again later */
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lResult, Dcm_Svc14NrcMapClearDTC);                                                                   /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }

  return lStdResult;
}

# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc14_XX_RepeaterProxySelectDTC()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14_XX_RepeaterProxySelectDTC(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc14RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;
  Std_ReturnType lDemResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lDemResult = Dcm_DemAPI(SelectDTC)(pRepContext->DemClientId
                                    ,pRepContext->Dtc
                                    ,DEM_DTC_FORMAT_UDS
                                    ,DEM_DTC_ORIGIN_PRIMARY_MEMORY);

  switch(lDemResult)
  {
  case E_OK:
    lStdResult = DCM_E_LOOP;
    Dcm_RepeaterNextStep(pContext, DCM_SVC14_PROGRESS_REPEATERPROXY_CHECK_SELECTION_RESULT);                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_DEM_RET_SELECT_BUSY:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}
# endif

# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc14_XX_RepeaterProxyCheckSelectionResult()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14_XX_RepeaterProxyCheckSelectionResult(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc14RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType            lStdResult;
  Dcm_DemReturnClearDTCType lResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lResult = Dcm_DemAPI(GetDTCSelectionResult)(pRepContext->DemClientId);

  switch(lResult)
  {
  case DCM_DEM_RET_CLEAR_OK:
    lStdResult = DCM_E_LOOP;
    Dcm_RepeaterNextStep(pContext, DCM_SVC14_PROGRESS_REPEATERPROXY);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_DEM_RET_CLEAR_PENDING:
    lStdResult = DCM_E_PENDING; /* try again later */
    break;
  case DCM_DEM_RET_CLEAR_W_DTC:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  case DCM_DEM_RET_CLEAR_BUSY:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}
# endif
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc19SubFuncInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc19SubFuncInfoGetEntry(
  Dcm_DiagSubServiceRefOptType SubSvcRef,
  CONSTP2VAR(Dcm_CfgSvc19SubFuncInfoPtrType, AUTOMATIC, AUTOMATIC) pSubFuncInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if (Dcm_DebugDetectRuntimeError(SubSvcRef >= DCM_CFGSVC19SUBFUNCINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pSubFuncInfo = &Dcm_CfgSvc19SubFuncInfo[SubSvcRef];                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc19Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType                lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc19SubFuncLookUpTable
                                                   ,Dcm_CfgSvc19SubFuncExecPrecondTable
                                                   ,Dcm_Svc19ReqLengthGetter
                                                   ,Dcm_DiagNoSequenceChecker
                                                   ,&lSubSvcRef
                                                   ,ErrorCode);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

  pRepContext->DemClientId = Dcm_DiagGetDemClientId(Dcm_NetGetProtIdOfMsgContext(pMsgContext));                                                      /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_GLOBAL_PTR_WRITE */

  if(lStdResult == DCM_E_OK)
  {
    pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)lSubSvcRef;                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */

    Dcm_RepeaterSetUser(pContext, DCM_REPEATER_USER_DEM); /* set user for central repeater handling */                                               /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_RepeaterNextStep(pContext, DCM_SVC19_PROGRESS_SUBFUNCTION); /* delegate job */                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

    Dcm_ExtSvc19UtiPatchDtcStatusInit(pContext);                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  } /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc19SubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19SubFuncHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType                 lStdResult;
  Dcm_CfgSvc19SubFuncInfoPtrType pSubFuncInfo;

  lStdResult = Dcm_CfgSvc19SubFuncInfoGetEntry(pRepContext->SubSvcRef, &pSubFuncInfo, ErrorCode);                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lStdResult == DCM_E_OK)                                                                                                                        /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(pContext, opStatus, pMsgContext, ErrorCode);                                                               /* SBSW_DCM_CALL_FUNCPTR_SVC19SUBFUNC */
  }

  return lStdResult;
}
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSelectDTC()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSelectDTC(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_DemAPI(SelectDTC)(pRepContext->DemClientId
                                    ,pRepContext->Dtc
                                    ,DEM_DTC_FORMAT_UDS
                                    ,pRepContext->Origin);

  switch (lStdResult)
  {
    case E_OK:
      lStdResult = Dcm_Svc19UtiChainNext(pContext, pRepContext);                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
    default:
      *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_DemApiNrcMapSelectDTC);                                                            /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      break;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_SETDTCFILTER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSetDTCFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSetDTCFilter(
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19DemSetFilterClassType DsfClass,
  uint8 DtcStatusMask,
  Dem_DTCSeverityType DtcSeverityMask,
  Dcm_DemFilterForFDCType FilterForFDC,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;
  Dem_DTCOriginType lDtcOrigin;
  Dcm_DemReturnSetFilterType demResultSetFilter;
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#  if (DCM_DEM_API_431_ENABLED == STD_ON)
  if (Dcm_Svc19DemDtcFilterInfo[DsfClass].Origin == DCM_DEM_DTC_ORIGIN_USER_MEMORY)
  {
    /* Origin has to be extracted of the request */
    lDtcOrigin = pRepContext->Origin;
  }
  else
#  endif
  {
    lDtcOrigin = Dcm_Svc19DemDtcFilterInfo[DsfClass].Origin;
  }

  demResultSetFilter = Dcm_DemAPI(SetDTCFilter)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON)
                                                pRepContext->DemClientId,
#  endif
                                                DtcStatusMask
#  if (DCM_DEM_API_421_ENABLED == STD_ON)
                                               ,Dcm_Svc19DemDtcFilterInfo[DsfClass].Kind
#  endif
                                               ,DEM_DTC_FORMAT_UDS
                                               ,lDtcOrigin
                                               ,Dcm_Svc19DemDtcFilterInfo[DsfClass].ConsiderSeverity
                                               ,DtcSeverityMask
                                               ,FilterForFDC);

  if(demResultSetFilter == DCM_DEM_RET_FILTER_ACCEPTED)
  {
    lStdResult = DCM_E_OK;
  }
  else
  {
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResultSetFilter, Dcm_DemApiNrcMapSetDTCFilter);                                                   /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6060 */ /* MD_MSR_STPAR */
# endif

# if (DCM_DEMAPI_SVC_19_GETDTCSTATUSAVAILABILITYMASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask(
  Dcm_Svc19DemDtcStatusAvailMaskPtrType pDtcStatusAvailMask,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

    /* Gather the configured DEM Status Availability Mask */
#  if (DCM_DEM_API_421_ENABLED == STD_ON)
    lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(pDtcStatusAvailMask);                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
#  else
    lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(pRepContext->DemClientId
                                                         ,pDtcStatusAvailMask);                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
#  endif

  if(lStdResult != DCM_E_OK)
  {
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_Svc19NrcMapStdReturnType);                                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Sv19UtiStartReporting()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Sv19UtiStartReporting(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  uint8 subUpdater,
  Dcm_MsgLenType reportSize,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  DCM_IGNORE_UNREF_PARAM(reportSize);                                                                                                                /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  pRepContext->SubUpdater = subUpdater;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */

#  if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
  Dcm_PagedBufferStart(pMsgContext, reportSize);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
  return DCM_E_STOP_REPEATER;
#  else
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  Dcm_RepeaterNextStep(pContext, DCM_SVC19_PROGRESS_UTI_COPYLINEARDATA);                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
  return DCM_E_LOOP;
#  endif
}
# endif

# if (DCM_SVC_19_ABSTRACT_RECORD_ITER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Sv19UtiRecordIterNext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_Svc19UtiRecordIterResultType, DCM_CODE) Dcm_Svc19UtiRecordIterNext(
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  Dcm_Svc19UtiRecordIterResultType lRecIterResult;

  lRecIterResult = DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS;

  if(pRepContext->RecordNumList != NULL_PTR)
  {
    Dcm_UtiNextItemByPtr(pRepContext->RecordNumList, 1u);                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->RecordNum = pRepContext->RecordNumList[0];                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
    if(pRepContext->RecordNum != DCM_SVC_19_RECLIST_END)
    {
      lRecIterResult = DCM_SVC19_UTI_REC_ITER_RSLT_OK;
    }
  }

  return lRecIterResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemDisableRecordUpdate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemDisableRecordUpdate(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnDisableDTCRecordUpdateType demResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#  if (DCM_DEM_API_421_ENABLED == STD_ON)
  demResult = Dcm_DemAPI(DisableDTCRecordUpdate)(pRepContext->Dtc
                                                ,pRepContext->Origin);
#  else
  demResult = Dcm_DemAPI(DisableDTCRecordUpdate)(pRepContext->DemClientId);
#  endif
  switch(demResult)
  {
  case DCM_DEM_RET_DISABLE_DTC_REC_UP_OK:
    lStdResult = Dcm_Svc19UtiChainNext(pContext, pRepContext);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_DEM_RET_DISABLE_DTC_REC_UP_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapAnyAbleRecordUpdate);                                                      /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_GETSTATUSOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetStatusOfDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetStatusOfDtc(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnGetStatusOfDTCType demResult;
  uint8 dtcStatusMask;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#  if (DCM_DEM_API_421_ENABLED == STD_ON)
  demResult = Dcm_DemAPI(GetStatusOfDTC)(pRepContext->Dtc
                                        ,pRepContext->Origin
                                        ,&dtcStatusMask);                                                                                            /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  demResult = Dcm_DemAPI(GetStatusOfDTC)(pRepContext->DemClientId
                                        ,&dtcStatusMask);                                                                                            /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif
  switch(demResult)
  {
  case DCM_DEM_RET_STATUS_OK:
    Dcm_ExtSvc19UtiPatchDtcStatusApplyByResult(&dtcStatusMask);                                                                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

    Dcm_UtiProvideResDataAsU24(pMsgContext, pRepContext->Dtc);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_UtiProvideResDataAsU8(pMsgContext, dtcStatusMask);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdResult = Dcm_Svc19UtiChainNext(pContext, pRepContext);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
#  if defined (DCM_DEM_RET_STATUS_NO_SUCH_ELEMENT)
  case DCM_DEM_RET_STATUS_NO_SUCH_ELEMENT:
    /* Skip committing data (SWS_Dcm_01409) */
    lStdResult = Dcm_Svc19UtiChainNext(pContext, pRepContext);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
#  endif
  case DCM_DEM_RET_STATUS_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetStatusOfDTC);                                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFFFRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSizeOfFFRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSizeOfFFRecord(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnGetSizeOfFFRByDTCType demResult;
  uint16 dataLen;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#  if (DCM_DEM_API_421_ENABLED == STD_ON)
  demResult = Dcm_DemAPI(GetSizeOfFreezeFrameByDTC)(pRepContext->Dtc
                                                   ,pRepContext->Origin
                                                   ,pRepContext->RecordNum
                                                   ,&dataLen);                                                                                       /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  demResult = Dcm_DemAPI(GetSizeOfFreezeFrameSelection)(pRepContext->DemClientId
                                                       ,&dataLen);                                                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif
  switch(demResult)
  {
  case DCM_DEM_RET_SIZEOFFFR_OK:
    if(dataLen != 0u) /* consider only stored records */
    {
      if(pRepContext->RecordNumList != NULL_PTR)
      {
        pRepContext->RecordNum = pRepContext->RecordNumList[0]; /* take first one */                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
#  if (DCM_DEM_API_421_ENABLED == STD_ON)
        Dcm_DebugAssert((DCM_SVC_19_RECNUM_ALL != pRepContext->RecordNum), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                   /* COV_DCM_RTM_DEV_DEBUG XF */
#  endif
      }

      lStdResult = Dcm_Sv19UtiStartReporting(pContext
                                            ,pMsgContext
                                            ,DCM_SVC_19_UPDATE_GET_FF_RECORD
                                            ,dataLen
                                            ,pRepContext);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      /* Otherwise, proceed with response transmission with no further data */
      lStdResult = DCM_E_OK;
    }
    break;
  case DCM_DEM_RET_SIZEOFFFR_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetSizeOfFreezeFrameByDTC);                                                /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_DEM_API_SELECT_EDR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSelectExtRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSelectExtRecord(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnSelectExtRecordType lDemResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lDemResult = Dcm_DemAPI(SelectExtendedDataRecord)(pRepContext->DemClientId
                                                   ,pRepContext->RecordNum);

  switch (lDemResult)
  {
  case DCM_DEM_RET_SELECT_EXT_DATAREC_OK:
    lStdResult = Dcm_Svc19UtiChainNext(pContext, pRepContext);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_DEM_RET_SELECT_EXT_DATAREC_BUSY:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  }

  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFEXTRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSizeOfExtRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSizeOfExtRecord(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn;
  Dcm_DemReturnGetSizeOfEDRByDTCType demResult;
  uint16 dataLen;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#  if (DCM_DEM_API_421_ENABLED == STD_ON)
  demResult = Dcm_DemAPI(GetSizeOfExtendedDataRecordByDTC)(pRepContext->Dtc
                                                          ,pRepContext->Origin
                                                          ,pRepContext->RecordNum
                                                          ,&dataLen);                                                                                /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  demResult = Dcm_DemAPI(GetSizeOfExtendedDataRecordSelection)(pRepContext->DemClientId
                                                              ,&dataLen);                                                                            /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif
  switch(demResult)
  {
  case DCM_DEM_RET_SIZEOFEDR_OK:
    if(dataLen != 0u) /* consider only stored records */
    {
      if(pRepContext->RecordNumList != NULL_PTR)
      {
        pRepContext->RecordNum = pRepContext->RecordNumList[0];/* take first one */                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
#  if (DCM_DEM_API_421_ENABLED == STD_ON)
        Dcm_DebugAssert((DCM_SVC_19_RECNUM_ALL != pRepContext->RecordNum), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                   /* COV_DCM_RTM_DEV_DEBUG XF */
#  endif
      }
      lStdReturn = Dcm_Sv19UtiStartReporting(pContext
                                            ,pMsgContext
                                            ,DCM_SVC_19_UPDATE_GET_EXT_RECORD
                                            ,dataLen
                                            ,pRepContext);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      /* Otherwise, proceed with response transmission with no further data */
      lStdReturn = DCM_E_OK;
    }
    break;
  case DCM_DEM_RET_SIZEOFEDR_PENDING:
    lStdReturn = DCM_E_PENDING;
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetSizeOfExtendedDataRecordByDTC);                                         /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
    break;
  }
  return lStdReturn;
}
# endif

# if (DCM_DEMAPI_SVC_19_GETNUMFILTEREDDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNumFltrdDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNumFltrdDtc(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnGetNumberOfFilteredDTCType demResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#  if (DCM_DEM_API_421_ENABLED == STD_ON)
  demResult = Dcm_DemAPI(GetNumberOfFilteredDTC)(&pRepContext->NumDtc);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
#  else
  demResult = Dcm_DemAPI(GetNumberOfFilteredDTC)(pRepContext->DemClientId
                                                ,&pRepContext->NumDtc);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
#  endif
  switch(demResult)
  {
  case DCM_DEM_RET_NUMBER_OK:
    lStdResult = Dcm_Svc19UtiChainNext(pContext, pRepContext);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_DEM_RET_NUMBER_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:/* DEM_NUMBER_FAILED or unknown */
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_DemApiNrcMapGetNumberOfFilteredDTC);                                                  /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdSeverity(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_Sv19UtiStartReporting(pContext
                                  ,pMsgContext
                                  ,DCM_SVC_19_UPDATE_GET_NXT_FLTRD_SEVERITY
                                  ,(Dcm_MsgLenType)((Dcm_MsgLenType)(pRepContext->NumDtc) * 6u)
                                  ,pRepContext);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSeverityOfDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSeverityOfDtc(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnGetSeverityOfDTCType demResultSeverity;
  uint8 dtcSeverity;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#  if (DCM_DEM_API_421_ENABLED == STD_ON)
  demResultSeverity = Dcm_DemAPI(GetSeverityOfDTC)(pRepContext->Dtc
                                                  ,&dtcSeverity);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  demResultSeverity = Dcm_DemAPI(GetSeverityOfDTC)(pRepContext->DemClientId
                                                  ,&dtcSeverity);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

  switch(demResultSeverity)
  {
#  if defined (DCM_DEM_RET_GET_SEVERITY_OF_DTC_NOSEVERITY)
  case DCM_DEM_RET_GET_SEVERITY_OF_DTC_NOSEVERITY:
    dtcSeverity = 0; /* set to NO SEVERITY as specified in ISO14229-1 and go on with the remained part */
#  endif
    /* fall through */
  case DCM_DEM_RET_GET_SEVERITY_OF_DTC_OK:                                                                                                           /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
    Dcm_UtiProvideResDataAsU8(pMsgContext, dtcSeverity);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = Dcm_Svc19UtiChainNext(pContext, pRepContext);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_DEM_RET_GET_SEVERITY_OF_DTC_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResultSeverity, Dcm_Svc19NrcMapGetSeverityOfDTC);                                                 /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetFuncUnitOfDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetFuncUnitOfDtc(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;
  uint8 functionalUnit;
  Dcm_DemReturnGetFunctionalUnitOfDTCType lDemResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#  if (DCM_DEM_API_421_ENABLED == STD_ON)
  lDemResult = Dcm_DemAPI(GetFunctionalUnitOfDTC)(pRepContext->Dtc
                                                 ,&functionalUnit);                                                                                  /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  lDemResult = Dcm_DemAPI(GetFunctionalUnitOfDTC)(pRepContext->DemClientId
                                                 ,&functionalUnit);                                                                                  /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

  switch(lDemResult)
  {
    case DCM_DEM_RET_GET_FUNCTIONALUNITOFDTC_OK:
      Dcm_UtiProvideResDataAsU8(pMsgContext, functionalUnit);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = Dcm_Svc19UtiChainNext(pContext, pRepContext);                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  if defined (DCM_DEM_RET_GET_FUNCTIONALUNITOFDTC_PENDING)
    case DCM_DEM_RET_GET_FUNCTIONALUNITOFDTC_PENDING:
      lStdResult = DCM_E_PENDING;
      break;
#  endif
    default:
      *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lDemResult, Dcm_Svc19NrcMapGetFunctionalUnitOfDTC);                                                /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      break;
  }

  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_GETNEXTFILTEREDDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdDtc(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_Sv19UtiStartReporting(pContext
                                  ,pMsgContext
                                  ,DCM_SVC_19_UPDATE_GET_NXT_FLTRD_DTC
                                  ,(Dcm_MsgLenType)((Dcm_MsgLenType)(pRepContext->NumDtc) * 4u)
                                  ,pRepContext);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiPutNumFilteredDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiPutNumFilteredDtc(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  Dcm_UtiProvideResDataAsU16(pMsgContext, pRepContext->NumDtc);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */

  return DCM_E_OK;
}
# endif

# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdFDC()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdFDC(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_Sv19UtiStartReporting(pContext
                                  ,pMsgContext
                                  ,DCM_SVC_19_UPDATE_GET_NXT_FLTRD_FDC
                                  ,(Dcm_MsgLenType)((Dcm_MsgLenType)(pRepContext->NumDtc) * 4u)
                                  ,pRepContext);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_56_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSetReadinessGroupIdentifierFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSetReadinessGroupIdentifierFilter(
  Dem_EventOBDReadinessGroupType readinessGroupNumber,
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;
  Std_ReturnType lDemResult;

  lDemResult = Dem_SetDTCFilterByReadinessGroup(pRepContext->DemClientId
                                               ,readinessGroupNumber);

  switch (lDemResult)
  {
  case E_OK:
    lStdResult = DCM_E_OK;
    break;
  case E_NOT_OK:
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  default:
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_19_16_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSetExtDataRecordFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSetExtDataRecordFilter(
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;
  Std_ReturnType lDemResult;

  lDemResult = Dem_SetExtendedDataRecordFilter(pRepContext->DemClientId
                                              ,pRepContext->RecordNum
                                              ,DEM_DTC_ORIGIN_PRIMARY_MEMORY
                                              ,DEM_DTC_FORMAT_UDS);

  switch (lDemResult)
  {
  case E_OK:
    lStdResult = DCM_E_OK;
    break;
  case DEM_BUSY:
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  case E_NOT_OK:
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  default:
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_19_16_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdExtRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdExtRecord(
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult = DCM_E_BUFFERTOOLOW;

  while (pDataContext->AvailLen > 4u)
  {
    Std_ReturnType  lDemResult;
    uint32          lDtc;
    uint8           lDtcStatus;
    uint16          lRecordSize;

    /* Move four byte up to reserve place for the DTCAndStatusRecord */
    Dcm_UtiCommitData(pDataContext, 4u);                                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

    lRecordSize = (uint16)pDataContext->AvailLen;

    lDemResult = Dem_GetNextFilteredExtendedDataRecord(pRepContext->DemClientId
                                                      ,&lDtc
                                                      ,&lDtcStatus
                                                      ,Dcm_UtiGetDataContextBuffer(pDataContext)                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                      ,&lRecordSize);                                                                                /* SBSW_DCM_COMB_PTR_FORWARD */

    /* Move back to original position to write now the data */
    Dcm_UtiRevertData(pDataContext, 4);                                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */

    if (lDemResult == DCM_DEM_RET_FILTERED_OK)
    {
      Dcm_UtiProvideDataAsU24(pDataContext, lDtc);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_UtiProvideDataAsU8(pDataContext, lDtcStatus);                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_UtiCommitData(pDataContext, lRecordSize);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(lDemResult, ErrorCode);                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
# endif

# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiWwhObdDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiWwhObdDemGetNxtFltrdSeverity(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_Sv19UtiStartReporting(pContext
                                  ,pMsgContext
                                  ,DCM_SVC_19_UPDATE_GET_NXT_FLTRD_SEVERITY_WWHOBD
                                  ,(Dcm_MsgLenType)((Dcm_MsgLenType)(pRepContext->NumDtc) * 5u)
                                  ,pRepContext);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdRecord(
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  uint32                                lDtc;
  uint8                                 recordNumber;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;

  lStdResult = DCM_E_BUFFERTOOLOW;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  while (pDataContext->AvailLen >= 4u)                                                                                                               /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  {
    demResult = Dcm_DemAPI(GetNextFilteredRecord)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON)
                                                  pRepContext->DemClientId,
#  endif
                                                  &lDtc
                                                 ,&recordNumber);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      Dcm_UtiProvideDataAsU24(pDataContext, lDtc);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_UtiProvideDataAsU8(pDataContext, recordNumber);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult, ErrorCode);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
    }

    if (Dcm_UtiRuntimeLimitReached() == TRUE)
    {
      lStdResult = DCM_E_PENDING_LIMITER;
      break;
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  uint32                                lDtc;
  uint8                                 dtcStatus;
  uint8                                 dtcFuncUnit;
  Dem_DTCSeverityType                   dtcSeverity;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;

  lStdResult = DCM_E_BUFFERTOOLOW;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  while (pDataContext->AvailLen >= 6u)                                                                                                               /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  {
    demResult = Dcm_DemAPI(GetNextFilteredDTCAndSeverity)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON)
                                                          pRepContext->DemClientId,
#  endif
                                                          &lDtc
                                                         ,&dtcStatus
                                                         ,&dtcSeverity
                                                         ,&dtcFuncUnit);                                                                             /* SBSW_DCM_POINTER_FORWARD_STACK */
    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      Dcm_ExtSvc19UtiPatchDtcStatusApplyByRequest(pContext, &dtcStatus);                                                                             /* SBSW_DCM_POINTER_FORWARD_STACK */

      Dcm_UtiProvideDataAsU8(pDataContext, (Dcm_MsgItemType)dtcSeverity);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_UtiProvideDataAsU8(pDataContext, dtcFuncUnit);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_UtiProvideDataAsU24(pDataContext, lDtc);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_UtiProvideDataAsU8(pDataContext, dtcStatus);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult, ErrorCode);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
    }

    if (Dcm_UtiRuntimeLimitReached() == TRUE)
    {
      lStdResult = DCM_E_PENDING_LIMITER;
      break;
    }
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdFDC()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdFDC(
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  uint32                                lDtc;
  sint8                                 dtcFDC;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;

  lStdResult = DCM_E_BUFFERTOOLOW;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  while (pDataContext->AvailLen >= 4u)                                                                                                               /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  {
    demResult = Dcm_DemAPI(GetNextFilteredDTCAndFDC)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON)
                                                     pRepContext->DemClientId,
#  endif
                                                     &lDtc, &dtcFDC);                                                                                /* SBSW_DCM_POINTER_FORWARD_STACK */
    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      Dcm_UtiProvideDataAsU24(pDataContext, lDtc);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_UtiProvideDataAsU8(pDataContext, (uint8)dtcFDC);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult, ErrorCode);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
    }

    if (Dcm_UtiRuntimeLimitReached() == TRUE)
    {
      lStdResult = DCM_E_PENDING_LIMITER;
      break;
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  uint32                                lDtc;
  uint8                                 dtcStatus;
  uint8                                 dtcFuncUnit;
  Dem_DTCSeverityType                   dtcSeverity;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;

  lStdResult = DCM_E_BUFFERTOOLOW;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  while (pDataContext->AvailLen >= 5u)                                                                                                               /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  {
    demResult = Dcm_DemAPI(GetNextFilteredDTCAndSeverity)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON)
                                                          pRepContext->DemClientId,
#  endif
                                                          &lDtc
                                                         ,&dtcStatus
                                                         ,&dtcSeverity
                                                         ,&dtcFuncUnit);                                                                             /* SBSW_DCM_POINTER_FORWARD_STACK */
    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      Dcm_ExtSvc19UtiPatchDtcStatusApplyByRequest(pContext, &dtcStatus);                                                                             /* SBSW_DCM_POINTER_FORWARD_STACK */

      Dcm_UtiProvideDataAsU8(pDataContext, (Dcm_MsgItemType)dtcSeverity);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_UtiProvideDataAsU24(pDataContext, lDtc);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_UtiProvideDataAsU8(pDataContext, dtcStatus);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult, ErrorCode);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
    }

    if (Dcm_UtiRuntimeLimitReached() == TRUE)
    {
      lStdResult = DCM_E_PENDING_LIMITER;
      break;
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_DEMAPI_SVC_19_GETNEXTFILTEREDDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdDtc(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  uint32                                lDtc;
  uint8                                 dtcStatus;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;

  lStdResult = DCM_E_BUFFERTOOLOW;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  while (pDataContext->AvailLen >= 4u)                                                                                                               /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  {
    demResult = Dcm_DemAPI(GetNextFilteredDTC)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON)
                                               pRepContext->DemClientId,
#  endif
                                               &lDtc, &dtcStatus);                                                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */
    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      Dcm_ExtSvc19UtiPatchDtcStatusApplyByRequest(pContext, &dtcStatus);                                                                             /* SBSW_DCM_POINTER_FORWARD_STACK */

      Dcm_UtiProvideDataAsU24(pDataContext, lDtc);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_UtiProvideDataAsU8(pDataContext, dtcStatus);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult, ErrorCode);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
    }

    if (Dcm_UtiRuntimeLimitReached() == TRUE)
    {
      lStdResult = DCM_E_PENDING_LIMITER;
      break;
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON)
#  if (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetExtRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetExtRecord(
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType  demResult;
  Std_ReturnType  lStdResult;
  uint16          dcmBufferSize;
  boolean         readNextData = TRUE;

  do
  {
    dcmBufferSize = (uint16) pDataContext->AvailLen;

    demResult = Dcm_DemAPI(GetNextExtendedDataRecord)(pRepContext->DemClientId
                                                     ,Dcm_UtiGetDataContextBuffer(pDataContext)                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                     ,&dcmBufferSize);                                                                               /* SBSW_DCM_COMB_PTR_FORWARD */

    switch (demResult)
    {
    case DCM_DEM_RET_GET_EXT_DATA_REC_OK:
      Dcm_UtiCommitData(pDataContext, dcmBufferSize);                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_OK;
      break;
    case DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_NUMBER:
      lStdResult = DCM_E_OK;
      readNextData = FALSE;
      break;
    case DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_BUFFERSIZE:
      lStdResult = DCM_E_BUFFERTOOLOW;
      readNextData = FALSE;
      break;
    case DCM_DEM_RET_GET_EXT_DATA_REC_PENDING:
      lStdResult = DCM_E_PENDING;/* signal retry */
      readNextData = FALSE;
      break;
    default:
      *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetExtendedDataRecordByDTC);                                             /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      readNextData = FALSE;
      break;
    }
  }
  while (readNextData == TRUE);

  /* If record data processing finished in this call (with or without success), enable DTC record update immediately */
  if((lStdResult == DCM_E_OK) || (lStdResult == DCM_E_NOT_OK))
  {
    (void)Dcm_DemAPI(EnableDTCRecordUpdate)(pRepContext->DemClientId);
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */
#  else
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetExtRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetExtRecord(
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  Dem_ReturnGetExtendedDataRecordByDTCType demResult;
  Std_ReturnType                           lStdResult;
  uint16                                   dcmBufferSize;
  Dcm_Svc19UtiRecordIterResultType         dcmNextRecordResult;

  do
  {
    /* Move one byte up to reserve place for the record number */
    Dcm_UtiCommitData(pDataContext, 1);                                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */

    dcmBufferSize = (uint16) pDataContext->AvailLen;

    demResult = Dcm_DemAPI(GetExtendedDataRecordByDTC)(pRepContext->Dtc
                                                      ,pRepContext->Origin
                                                      ,pRepContext->RecordNum
                                                      ,Dcm_UtiGetDataContextBuffer(pDataContext)                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                      ,&dcmBufferSize);                                                                              /* SBSW_DCM_COMB_PTR_FORWARD */

    /* Move back to original position to write now the data */
    Dcm_UtiRevertData(pDataContext, 1);                                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */

    if(demResult == DCM_DEM_RET_GET_EXT_DATA_REC_OK)
    {
      if(dcmBufferSize != 0u)/* consider only stored records */
      {
        Dcm_UtiProvideDataAsU8(pDataContext, pRepContext->RecordNum);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_UtiCommitData(pDataContext, dcmBufferSize);                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      }

      dcmNextRecordResult = Dcm_Svc19UtiRecordIterNext(pRepContext);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_OK;
    }
    else if(demResult == DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_NUMBER)
    {
      if(pRepContext->RecordNumList == NULL_PTR)/* single record query */
      {
        dcmNextRecordResult = DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS;
        *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetExtendedDataRecordByDTC);                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
      else
      {
        dcmNextRecordResult = Dcm_Svc19UtiRecordIterNext(pRepContext);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
        lStdResult = DCM_E_OK;
      }
    }
    else
    {
      dcmNextRecordResult = DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS;
      switch (demResult)
      {
      case DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_BUFFERSIZE:
        lStdResult = DCM_E_BUFFERTOOLOW;
        break;
      case DCM_DEM_RET_GET_EXT_DATA_REC_PENDING:
        lStdResult = DCM_E_PENDING;/* signal retry */
        break;
      default:
        *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetExtendedDataRecordByDTC);                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
        break;
      }
    }

    /* If no more records to be reported or current iteration detected an error, stop iteration */
    if(dcmNextRecordResult == DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS)
    {
      break;
    }
  }
  while (pDataContext->AvailLen != 0u);

  if ( (pDataContext->AvailLen == 0u)
     &&(dcmNextRecordResult != DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS) )
  {
    lStdResult = DCM_E_BUFFERTOOLOW;
  }

  /* If record data processing finished in this call (with or without success), enable DTC record update immediately */
  if((lStdResult == DCM_E_OK) || (lStdResult == DCM_E_NOT_OK))
  {
    (void)Dcm_DemAPI(EnableDTCRecordUpdate)();
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */
#  endif
# endif

# if (DCM_DEM_API_SELECT_FFR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSelectFFData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSelectFFData(
  Dcm_ContextPtrType pContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnSelectFFDataType lDemResult;

  lDemResult = Dcm_DemAPI(SelectFreezeFrameData)(pRepContext->DemClientId
                                                ,pRepContext->RecordNum);

  switch (lDemResult)
  {
  case DCM_DEM_RET_SELECT_FF_DATA_OK:
    lStdResult = Dcm_Svc19UtiChainNext(pContext, pRepContext);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_DEM_RET_SELECT_FF_DATA_BUSY:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  }

  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED == STD_ON)
#  if (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetFFRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetFFRecord(
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType  demResult;
  Std_ReturnType  lStdResult;
  uint16          dcmBufferSize;
  boolean         readNextData = TRUE;

  do
  {
    dcmBufferSize = (uint16)pDataContext->AvailLen;

    demResult =  Dcm_DemAPI(GetNextFreezeFrameData)(pRepContext->DemClientId
                                                   ,Dcm_UtiGetDataContextBuffer(pDataContext)                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                   ,&dcmBufferSize);                                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */

    switch (demResult)
    {
    case DCM_DEM_RET_FFDATABYDTC_OK:
      if(dcmBufferSize != 0u)/* consider only stored records */
      {
        Dcm_UtiCommitData(pDataContext, dcmBufferSize);                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      lStdResult = DCM_E_OK;
      break;
    case DCM_DEM_RET_FFDATABYDTC_W_RNUM:
      lStdResult = DCM_E_OK;
      readNextData = FALSE;
      break;
    case DCM_DEM_RET_FFDATABYDTC_W_BUFSIZE:
      lStdResult = DCM_E_BUFFERTOOLOW;
      readNextData = FALSE;
      break;
    case DCM_DEM_RET_FFDATABYDTC_PENDING:
      lStdResult = DCM_E_PENDING;/* signal retry */
      readNextData = FALSE;
      break;
    default:
      *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetFreezeFrameDataByDTC);                                                /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;/* finish processing */
      readNextData = FALSE;
      break;
    }
  }
  while (readNextData == TRUE);

  /* If record data processing finished in this call (with or without success), enable DTC record update immediately */
  if((lStdResult == DCM_E_OK) || (lStdResult == DCM_E_NOT_OK))
  {
    (void)Dcm_DemAPI(EnableDTCRecordUpdate)(pRepContext->DemClientId);
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#  else
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetFFRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetFFRecord(
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  Dem_ReturnGetFreezeFrameDataByDTCType demResult;
  Std_ReturnType                        lStdResult;
  uint16                                dcmBufferSize;
  Dcm_Svc19UtiRecordIterResultType      dcmNextRecordResult;

  do
  {
    dcmBufferSize = (uint16)pDataContext->AvailLen;

    demResult =  Dcm_DemAPI(GetFreezeFrameDataByDTC)(pRepContext->Dtc
                                                    ,pRepContext->Origin
                                                    ,pRepContext->RecordNum
                                                    ,Dcm_UtiGetDataContextBuffer(pDataContext)                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                    ,&dcmBufferSize);                                                                                /* SBSW_DCM_COMB_PTR_FORWARD */
    if(demResult == DCM_DEM_RET_FFDATABYDTC_OK)
    {
      Dcm_UtiCommitData(pDataContext, dcmBufferSize);                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
      dcmNextRecordResult = Dcm_Svc19UtiRecordIterNext(pRepContext);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_OK;
    }
    else if(demResult == DCM_DEM_RET_FFDATABYDTC_W_RNUM)
    {
      if(pRepContext->RecordNumList == NULL_PTR)/* single record query */
      {
        dcmNextRecordResult = DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS;
        *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetFreezeFrameDataByDTC);                                              /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
      else
      {
        dcmNextRecordResult = Dcm_Svc19UtiRecordIterNext(pRepContext);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
        lStdResult = DCM_E_OK;
      }
    }
    else
    {
      switch (demResult)
      {
      case DCM_DEM_RET_FFDATABYDTC_W_BUFSIZE:
        lStdResult = DCM_E_BUFFERTOOLOW;
        break;
      case DCM_DEM_RET_FFDATABYDTC_PENDING:
        lStdResult = DCM_E_PENDING;/* signal retry */
        break;
      default:
        *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetFreezeFrameDataByDTC);                                              /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;/* finish processing */
        break;
      }
      /* Finished for this cycle or error occurred */
      dcmNextRecordResult = DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS;
    }

    if(dcmNextRecordResult == DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS)
    {
      break;
    }
  }
  while(pDataContext->AvailLen != 0u);

  if( (pDataContext->AvailLen == 0u)
    &&(dcmNextRecordResult != DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS) )
  {
    lStdResult = DCM_E_BUFFERTOOLOW;
  }

  /* If record data processing finished in this call (with or without success), enable DTC record update immediately */
  if((lStdResult == DCM_E_OK) || (lStdResult == DCM_E_NOT_OK))
  {
    (void)Dcm_DemAPI(EnableDTCRecordUpdate)();
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#  endif
# endif

# if (DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19UtiCopyData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service19UtiCopyData(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  switch(pRepContext->SubUpdater)
  {
#  if (DCM_DEMAPI_SVC_19_GETNEXTFILTEREDDTC_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_NXT_FLTRD_DTC:
      lStdResult = Dcm_Svc19UtiCpyDemGetNxtFltrdDtc(pContext, pDataContext, ErrorCode, pRepContext);                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
#  if (DCM_SVC_19_03_SUPPORT_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_NXT_FLTRD_RECORD:
      lStdResult = Dcm_Svc19UtiCpyDemGetNxtFltrdRecord(pDataContext, ErrorCode, pRepContext);                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
#  if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_NXT_FLTRD_FDC:
      lStdResult = Dcm_Svc19UtiCpyDemGetNxtFltrdFDC(pDataContext, ErrorCode, pRepContext);                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
#  if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_NXT_FLTRD_SEVERITY:
      lStdResult = Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity(pContext, pDataContext, ErrorCode, pRepContext);                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
#  if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_NXT_FLTRD_SEVERITY_WWHOBD:
      lStdResult = Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity(pContext, pDataContext, ErrorCode, pRepContext);                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
#  if (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_EXT_RECORD:
      lStdResult = Dcm_Svc19UtiCpyDemGetExtRecord(pDataContext, ErrorCode, pRepContext);                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
#  if (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_FF_RECORD:
      lStdResult = Dcm_Svc19UtiCpyDemGetFFRecord(pDataContext, ErrorCode, pRepContext);                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
#  if (DCM_SVC_19_16_SUPPORT_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_NXT_FLTRD_EXT_RECORD:
      lStdResult = Dcm_Svc19UtiCpyDemGetNxtFltrdExtRecord(pDataContext, ErrorCode, pRepContext);                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
    default:
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
      break;
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
# endif

# if (DCM_SVC_19_COPY_LINEAR_DATA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCopyLinearData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCopyLinearData(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType           lStdResult;
  Dcm_DiagDataContextType  lDataContext;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  Dcm_UtiInitDataContext(&lDataContext, Dcm_UtiGetResData(pMsgContext), pMsgContext->resMaxDataLen);                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

  lStdResult = Dcm_Service19UtiCopyData(pContext, &lDataContext, ErrorCode, pRepContext);                                                            /* SBSW_DCM_COMB_PTR_FORWARD */

  /* Commit copied data */
  Dcm_UtiProvideResData(pMsgContext, lDataContext.Usage);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(  (lStdResult != DCM_E_PENDING)
    && (lStdResult != DCM_E_PENDING_LIMITER)
    && (lStdResult != DCM_E_NOT_OK))
  {
    if(lStdResult == DCM_E_BUFFERTOOLOW)
    {
      *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    else
    {
      lStdResult = DCM_E_OK;
    }
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_1A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSetDTCFilterByExtendedDataRecordNumber()
 *********************************************************************************************************************/
 /*!
  * Internal comment removed.
 *
 *
  */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSetDTCFilterByExtendedDataRecordNumber(
  uint8 ExtendedDataRecordNumber,
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
)
{
  Std_ReturnType lStdResult;
  Std_ReturnType lDemResult;

  lDemResult = Dem_SetDTCFilterByExtendedDataRecordNumber(pRepContext->DemClientId, ExtendedDataRecordNumber);

  switch (lDemResult)
  {
  case E_OK:
    lStdResult = DCM_E_OK;
    break;
  case E_NOT_OK:
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  default:
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22GetDidInfoContext()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_DidMgrDidInfoContextPtrType, DCM_CODE) Dcm_Svc22GetDidInfoContext(
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_DidMgrDidInfoContextPtrType lResult;

  if(Dcm_DebugDetectRuntimeError(pRepContext->DidInfoContextIdx >= DCM_SVC_22_MAX_DID_LIST_LEN))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = &(pRepContext->DidInfoContextList[0]);
  }
  else
  {
    lResult = &(pRepContext->DidInfoContextList[pRepContext->DidInfoContextIdx]);
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc22Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* If the request length is even (SID is already extracted) and does not exceed the capacity of the ECU: */
  if( (Dcm_UtiIsEven(pMsgContext->reqDataLen))
    &&(pMsgContext->reqDataLen <= (Dcm_MsgLenType)(DCM_SVC_22_MAX_DID_LIST_LEN * 2u)) )
  {
    pRepContext->DidInfoContextIdx = 0u;                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->NumDids           = 0u;                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->DidIter           = 0u;                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->ActualLength      = 0u;                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->ReservedLength    = 0u;                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */

    Dcm_RepeaterNextStep(pContext, DCM_SVC22_PROGRESS_DIDLOOKUP);                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }
  else
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc22ReadDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22ReadDid(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  /* Try to read the DID data */
  lStdResult = Dcm_DidMgrReadDid(opStatus
                                ,pDataContext
                                ,pDidInfoContext
                                ,pDidOpTypeContext
                                ,ErrorCode);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

  switch(lStdResult)
  {
  case DCM_E_PENDING:
    /* Try it the next task cycle */
    break;
# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
  case DCM_E_BUFFERTOOLOW:
    /* Notify the page buffer and try it later */
    break;
# endif
# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
  case DCM_E_FORCE_RCRRP:
    break;
# endif
  case DCM_E_OK:
    /* Go on with next DID */
    Dcm_RsrcMgrReleaseDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID22);
    break;
  default: /* DCM_E_NOT_OK */
    /* Finish service processing immediately by sending the appropriate NRC */
    Dcm_RsrcMgrReleaseDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID22);
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc22UtiReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22UtiReadData(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType                   lStdResult;
  Dcm_DidMgrDidInfoContextPtrType  pDidInfoContext;

  pDidInfoContext = Dcm_Svc22GetDidInfoContext(pRepContext);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(Dcm_RsrcMgrHasDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID22) == FALSE)
  {
# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
    if(pDataContext->AvailLen < 2u)
    {
      lStdResult = DCM_E_BUFFERTOOLOW;
    }
    else
# endif
    {
      lStdResult = Dcm_RsrcMgrGetDidLock(opStatus, pDidInfoContext->Did, DCM_RSRCMGR_DIDLOCK_OWNER_SID22);

      if(lStdResult == DCM_E_OK)
      {
        Dcm_UtiProvideDataAsU16(pDataContext, pDidInfoContext->Did);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_DidMgrInitOpClassInfo(pDidInfoContext, DCM_DIDMGR_OPTYPE_READ);                                                                          /* SBSW_DCM_POINTER_WRITE_DIDINFOCONTEXT */
        lStdResult = DCM_E_LOOP;
      }
    }
  }
  else
  {
    /*
     *  Action/Return value | DCM_E_PENDING | DCM_E_BUFFERTOOLOW | DCM_E_OK
     * ---------------------+---------------+--------------------+----------
     *  call again          |      yes      |        yes         |   no
     *  data committed      |      no       |        yes         |   yes
     *  ready               |      no       |        no          |   yes
     */

    /* Try to read the DID data */
    lStdResult = Dcm_Svc22ReadDid(opStatus
                                 ,pDataContext
                                 ,pDidInfoContext
                                 ,&(pRepContext->DidOpTypeContext)
                                 ,ErrorCode);                                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)
    {
      --pRepContext->NumDids;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
      if(pRepContext->NumDids != 0u)
      {
        /* Read next Did */
        pRepContext->DidInfoContextIdx++;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */

        lStdResult = DCM_E_LOOP;
      }
    }
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc22DidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22DidLookUp(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType                   lStdReturn;
  Dcm_DidMgrDidInfoContextPtrType  pDidInfoContext;

  pDidInfoContext = Dcm_Svc22GetDidInfoContext(pRepContext);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(opStatus == DCM_INITIAL)
  {
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &(pDidInfoContext->Did));                                                                                /* SBSW_DCM_COMB_PTR_FORWARD */
  }

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,pDidInfoContext
                                   ,&(pRepContext->DidOpTypeContext)
                                   ,DCM_DIDMGR_OP_READ);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */

  switch(lStdReturn)
  {
    case DCM_E_OK:
      ++(pRepContext->NumDids); /* register a supported DID */                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

      lStdReturn = Dcm_DidMgrDynDidStateCheck(Dcm_NetGetConnHdlOfRxPduId(pMsgContext->rxPduId), pDidInfoContext, ErrorCode);                         /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_COMB_PTR_FORWARD */
      if(lStdReturn == DCM_E_OK)
      {
        ++(pRepContext->DidInfoContextIdx); /* next DID */                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdReturn = DCM_E_LOOP; /* proceed with next DID */
      } /* else DCM_E_NOT_OK (ErrorCode already set) */
      break;
    case DCM_E_PENDING:
      /* Try it the next task cycle */
      break;
    default: /* DCM_E_NOT_OK */
      /* Just skip this DID - request a new look-up loop */
      lStdReturn = DCM_E_LOOP;
      break;
  }

  /* If next DID look-up is requested: */
  if(lStdReturn == DCM_E_LOOP)
  {
    /* If all DIDs are validated: */
    if(pMsgContext->reqDataLen == 0u)
    {
      if(pRepContext->NumDids != 0u) /* any DID to process? */
      {
        pRepContext->DidIter           = pRepContext->NumDids;                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
        pRepContext->DidInfoContextIdx = 0u;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */

        Dcm_RepeaterNextStep(pContext, DCM_SVC22_PROGRESS_CHECKCONDITION); /* delegate job */                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      else
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdReturn = DCM_E_NOT_OK;
      }
    }
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc22CheckCondition()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CheckCondition(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType                   lStdResult = DCM_E_OK;
  Dcm_DidMgrDidInfoContextPtrType  pDidInfoContext;

  pDidInfoContext = Dcm_Svc22GetDidInfoContext(pRepContext);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext), DCM_DIDMGR_OPTYPE_READCHKCOND))
  {
    Dcm_DidMgrInitOpClassInfo(pDidInfoContext, DCM_DIDMGR_OPTYPE_READCHKCOND);                                                                       /* SBSW_DCM_POINTER_WRITE_DIDINFOCONTEXT */

    /* check conditions */
    lStdResult = Dcm_DidMgrReadCheckCond(opStatus
                                        ,pDidInfoContext
                                        ,&(pRepContext->DidOpTypeContext)
                                        ,ErrorCode);                                                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
  }/* else - not supported operation - go on with getLength */

  if(lStdResult == DCM_E_OK)
  {
    /* DCM_E_OK - go on with next DID */
    Dcm_RepeaterNextStep(pContext, DCM_SVC22_PROGRESS_GETLENGTH); /* next job */                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc22GetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22GetLength(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType                   lStdReturn = DCM_E_OK;
  Dcm_DidMgrDidInfoContextPtrType  pDidInfoContext;

  pDidInfoContext = Dcm_Svc22GetDidInfoContext(pRepContext);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext), DCM_DIDMGR_OPTYPE_READLENGTH))
  {
    Dcm_DidMgrInitOpClassInfo(pDidInfoContext, DCM_DIDMGR_OPTYPE_READLENGTH);                                                                        /* SBSW_DCM_POINTER_WRITE_DIDINFOCONTEXT */

    lStdReturn = Dcm_DidMgrReadLength(opStatus
                                     ,pDidInfoContext
                                     ,&(pRepContext->DidOpTypeContext)
                                     ,ErrorCode);                                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
  }

  if(lStdReturn == DCM_E_OK)
  {
    Dcm_MsgLenType lMaxLength;

    pRepContext->ActualLength   += 2u; /* cumulate DID length + DID itself */                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->ActualLength   += pDidInfoContext->DidLength;                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

    pRepContext->ReservedLength += 2u;                                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->ReservedLength += pDidInfoContext->ReservedLength;                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
    /* Note: Protocol->MaxLength includes the SID, so subtract it */
    lMaxLength = (Dcm_MsgLenType)(Dcm_NetGetProtObjOfTranspObj(Dcm_DiagGetTranspObj(pContext->Thread))->MaxLength) - 1u;                             /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */
# else
    /* Note: pMsgContext->resMaxDataLen excludes the SID already */
    lMaxLength = pMsgContext->resMaxDataLen;
# endif

    /* Check for buffer overrun */
    if(pRepContext->ReservedLength <= lMaxLength)
    {
      pRepContext->DidIter--;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
      if(pRepContext->DidIter == 0u)
      {
        /* All DIDs processed without any errors. Prepare for reading
         * Now pRepContext->NumDids will be used as counter -> didIter not needed anymore!
         * pRepContext->DidIter = pRepContext->NumDids;
         */
        pRepContext->DidInfoContextIdx = 0u;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */

        Dcm_RepeaterNextStep(pContext, DCM_SVC22_PROGRESS_READDATA); /* delegate job */                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      else
      {
        pRepContext->DidInfoContextIdx++; /* next DID */                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */

        Dcm_RepeaterNextStep(pContext, DCM_SVC22_PROGRESS_CHECKCONDITION); /* start again with next DID  */                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      lStdReturn = DCM_E_LOOP; /* speed up processing */
    }
    else
    {
      /* the configured buffer will not be able to hold all of the data -> notify the client */
      *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK; /* finish service processing immediately */
    }
  }/* else - DCM_E_PENDING, DCM_E_NOT_OK (ErrorCode already set) */

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc22ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22ReadData(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  Dcm_DebugAssert((pMsgContext->resDataLen == 0u), DCM_SID_INTERNAL, DCM_E_PARAM);                                                                   /* COV_DCM_RTM_DEV_DEBUG XF */

  /* Start the paged-buffer to copy the DID data */
  Dcm_PagedBufferStart(pMsgContext, pRepContext->ActualLength);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  return DCM_E_STOP_REPEATER;
# else
  Std_ReturnType           lStdResult;
  Dcm_DiagDataContextType  lDataContext;

  Dcm_UtiInitDataContext(&lDataContext, Dcm_UtiGetResData(pMsgContext), pMsgContext->resMaxDataLen);                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

  lStdResult = Dcm_Svc22UtiReadData(opStatus, &lDataContext, ErrorCode, pRepContext);                                                                /* SBSW_DCM_COMB_PTR_FORWARD */

  /* Commit copied data */
  Dcm_UtiProvideResData(pMsgContext, lDataContext.Usage);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */

  return lStdResult;
# endif
}
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc23Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc23RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;
  uint8          lAlfid;
  uint8          lBlockLength;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* dispatcher guarantees for minimum length of 3 bytes (ALFID + MEM + SIZE) available */
  lStdResult = Dcm_MemMgrValidateAndGetAlfid(pMsgContext, &lAlfid, &lBlockLength, ErrorCode);                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  if(lStdResult == DCM_E_OK)
  {
    /* check for exact length match */
    if(pMsgContext->reqDataLen == lBlockLength)
    {
      Dcm_MemMgrParseMemStream(lAlfid
                              ,pMsgContext
                              ,&pRepContext->MemBlock);                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */

      lStdResult = Dcm_MemMgrCheckMemBlock(&pRepContext->MemBlock, DCM_MEMMGR_OP_READ, ErrorCode);                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      if(lStdResult == DCM_E_OK)
      {
        /* Check for overflow */
        if(pRepContext->MemBlock.Length <= pMsgContext->resMaxDataLen)
        {
          Dcm_RepeaterNextStep(pContext, DCM_SVC23_PROGRESS_CHECKACCESS);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
          lStdResult = DCM_E_LOOP;/* speed up processing */
        }
        else
        {
          *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }/* else DCM_E_NOT_OK - ErrorCode is already set */
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }/* else DCM_E_NOT_OK - ErrorCode is already set */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc23CheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23CheckAccess(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc23RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_RsrcMgrGetMemLock(opStatus, DCM_RSRCMGR_MEM_ACCESS_REQ_EXT);

  if (lStdResult == DCM_E_OK)
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC23_PROGRESS_READMEMORY); /* delegate job */                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc23ReadMemory()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23ReadMemory(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc23RepeaterProxyContextConstPtrType pRepContext
  )
{
  Std_ReturnType          lStdResult;
  Dcm_DiagDataContextType lDataContext;

  Dcm_UtiInitDataContext(&lDataContext, Dcm_UtiGetResData(pMsgContext), pMsgContext->resMaxDataLen);                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

  lStdResult = Dcm_MemMgrReadMemory(opStatus
                                   ,&(pRepContext->MemBlock)
                                   ,&lDataContext
                                   ,ErrorCode);                                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
    Dcm_UtiProvideResData(pMsgContext, pRepContext->MemBlock.Length);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  /*  Otherwise - any other result to be delegated to the core
   *  No DET monitoring needed since the Dcm_MemMgrReadMemory has already one!
   */
  return lStdResult;
}
#endif /* (DCM_SVC_23_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc24Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc24RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType                lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* If valid service request length: */
  if(pMsgContext->reqDataLen == 2u)
  {
    /* Prepare for DID look up */
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &(pRepContext->DidInfoContext.Did));                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Initialize DID look up */
    Dcm_RepeaterNextStep(pContext, DCM_SVC24_PROGRESS_DIDLOOKUP);                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }
  else
  {
    /* Invalid length detected -> send NRC 0x13 */
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  /* Return control to DCM core */
  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc24ExecuteOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24ExecuteOp(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc24RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_DidMgrGetScalingInfo(opStatus
                                       ,pMsgContext
                                       ,&(pRepContext->DidInfoContext)
                                       ,&(pRepContext->DidOpTypeContext)
                                       ,ErrorCode);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc24DidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24DidLookUp(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc24RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn;

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&(pRepContext->DidInfoContext)
                                   ,&(pRepContext->DidOpTypeContext)
                                   ,DCM_DIDMGR_OP_SCALINGINFO);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
  if(lStdReturn == DCM_E_OK)
  {
    /*
     * Currently no state checks are possible on scaling DIDs in AR 4.x:
     * lStdReturn = Dcm_DidMgrStaticDidStateCheck(Dcm_NetGetConnHdlOfRxPduId(pMsgContext->rxPduId), Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext)->ExecCondRef, ErrorCode);
     * if(lStdReturn == DCM_E_OK)
     */
    {
      Dcm_UtiProvideResData(pMsgContext, 2);    /* commit the DID only. The scaling record size will be calculated on the fly */                     /* SBSW_DCM_PARAM_PTR_FORWARD */

      Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_GETSCALING);                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_RepeaterNextStep(pContext, DCM_SVC24_PROGRESS_EXECUTEOP); /* delegate job */                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdReturn = DCM_E_LOOP;/* speed up processing */
    }/* else - ErrorCode already assigned */
  }
  else if(lStdReturn == DCM_E_PENDING)
  {
    /* DID verification takes longer -> retry later */
  }
  else
  {
    /* DID is not supported -> send NRC 0x31 */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }

  return lStdReturn; /* finish service processing immediately */
}
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc27SecLevelInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc27SecLevelInfoGetEntry(
  uint8_least secLev,
  CONSTP2VAR(Dcm_CfgSvc27SecLevelInfoPtrType, AUTOMATIC, AUTOMATIC) pSecLevelInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if (Dcm_DebugDetectRuntimeError(secLev >= DCM_CFGSVC27SECLEVELINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pSecLevelInfo = &Dcm_CfgSvc27SecLevelInfo[secLev];                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc27CounterSet()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27CounterSet(
  uint8_least secLev,
  uint8 value
  )
{
  uint8_least lCounterIdx = Dcm_Svc27GetCounterIdx(secLev);

  DCM_IGNORE_UNREF_PARAM(secLev);                                                                                                                    /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_SVC_27_MULTI_ATTEMPT_COUNTER_ENABLED == STD_ON)
  if (Dcm_DebugDetectRuntimeError(lCounterIdx >= DCM_SVC_27_NUM_ATTEMPT_COUNTERS))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
# endif
  {
    Dcm_SingletonContext.Diag.Services.Svc27.AttemptCount[lCounterIdx] = value;                                                                      /* SBSW_DCM_POINTER_WRITE_ATTEMPTCOUNT */
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc27CounterInc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27CounterInc(
  uint8_least secLev
  )
{
  uint8 lValue = Dcm_Svc27CounterGet(secLev);

  if(lValue < Dcm_UtiMaxValueOfUintType(uint8))
  {
    Dcm_Svc27CounterSet(secLev, (uint8)(lValue + 1u));
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc27TimerSet()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27TimerSet(
  uint8_least secLev,
  Dcm_TmrTimerCntrMemType value
  )
{
  uint8_least lTimerIdx = Dcm_Svc27GetTimerIdx(secLev);

  DCM_IGNORE_UNREF_PARAM(secLev);                                                                                                                    /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_SVC_27_MULTI_DELAY_TIMER_ENABLED == STD_ON)
  if(Dcm_DebugDetectRuntimeError(lTimerIdx >= DCM_SVC_27_NUM_DELAY_TIMERS))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
# endif
  {
    /* Enter critical section (Reason: Avoid interrupt from Dcm_OnTimeoutSecurityAccess) */
    Dcm_SplitTaskEnterCS();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/

    Dcm_SingletonContext.Diag.Services.Svc27.DelayTime[lTimerIdx] = value;                                                                           /* SBSW_DCM_POINTER_WRITE_DELAYTIME_SEC */

    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_SplitTaskLeaveCS();
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc27TimerStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27TimerStart(
  uint8_least secLev,
  Dcm_TmrTimerCntrMemType value
  )
{
  /* Start the appropriate security timer */
  Dcm_Svc27TimerSet(secLev, value);

  if(!Dcm_TmrIsTimerRunning(DCM_TMR_CONTEXT_ID_SECURITY))
  {
    /* Start the base security timer */
    Dcm_TmrStartTimer(DCM_TMR_ID_SECURITY, 1u);
  }
}

/**********************************************************************************************************************
 *  Dcm_Service27Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType                lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc27SubFuncLookUpTable
                                                   ,Dcm_CfgSvc27SubFuncExecPrecondTable
                                                   ,Dcm_Svc27ReqLengthGetter
                                                   ,Dcm_Svc27SubFuncSequenceChecker
                                                   ,&lSubSvcRef
                                                   ,ErrorCode);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

  /* Initialize service processor context for further processing */
  pRepContext->ErrorCode = DCM_E_POSITIVERESPONSE;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)lSubSvcRef;/* Store working sub-function reference (also in negative response cases) */     /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->SecLvlRef = Dcm_Svc27GetSecLvlRef(lSubSvcRef);                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */

  if(lStdResult == DCM_E_OK)
  {
    if(Dcm_Svc27IsSeedRequest(pRepContext->SubSvcRef) == TRUE)                                                                                       /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
    {
      Dcm_RepeaterNextStep(pContext, DCM_SVC27_PROGRESS_SEEDPROCESSOR);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      Dcm_RepeaterNextStep(pContext, DCM_SVC27_PROGRESS_KEYPROCESSOR);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    }

    lStdResult = DCM_E_LOOP; /* Speed up processing */
  }
  /* If the requested key has wrong length or the sub-function sequence was not correct: */
  else if( (*ErrorCode == DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT)
    ||(*ErrorCode == DCM_E_REQUESTSEQUENCEERROR))
  {
    if( (Dcm_Svc27IsKeyRequest(pRepContext->SubSvcRef) == TRUE) /* wrong key length is an invalid key! */                                            /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
      &&(Dcm_Svc27IsKeyRequestExpected() == TRUE) )                                                                                                  /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
    {
      Dcm_Svc27CounterInc(pRepContext->SecLvlRef);
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
      Dcm_RepeaterNextStep(pContext, DCM_SVC27_PROGRESS_SETATTEMPTCNTR);                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
      pRepContext->ErrorCode = *ErrorCode; /* used in next step */                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_LOOP;/* Speed up processing */
# endif
    }
    /* Send prepared NRC immediately */
  }
  else
  {
    /* Send prepared NRC immediately */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service27SeedProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service27SeedProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* If the attempt counters are currently read or written by the application: */
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  if(Dcm_TskGetEvent(DCM_TSK_CONTEXT_ID_SVC27) != 0u)
  {
    lStdResult = DCM_E_PENDING;
  }
  else
# endif
  {
    pRepContext->IsZeroSeed = FALSE;                                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */

    /* If the security timer is active: */
    if(Dcm_Svc27TimerActive(pRepContext->SecLvlRef) == TRUE)                                                                                         /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
    {
      /* Send the NRC 0x37 */
      *ErrorCode = DCM_E_REQUIREDTIMEDELAYNOTEXPIRED;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    else
    {
      /* If seed level not yet unlocked: */
      if (0u == (Dcm_StateGetSecurity() & Dcm_UtiGetBitFromIndex(Dcm_CfgStateGroupMemType, (pRepContext->SecLvlRef + 1u))))
      {
        /* New seed request / repetition of the same seed request. Get application generated seed */
        Dcm_RepeaterNextStep(pContext, DCM_SVC27_PROGRESS_SEEDREPEATER);                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
        lStdResult = DCM_E_LOOP;/* Speed up processing */
      }
      else
      {
        Dcm_CfgNetBufferSizeMemType lSeedSize = Dcm_CfgSvc27SecLevelInfo[pRepContext->SecLvlRef].SeedResLength;

        lStdResult = Dcm_UtiMsgContextVerifySize(pMsgContext, lSeedSize, ErrorCode);                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

        if(lStdResult == DCM_E_OK)                                                                                                                   /* COV_DCM_RTM_RUNTIME_CHECK TX */
        {
          /* return zero seed */
          pRepContext->IsZeroSeed = TRUE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
          Dcm_UtiMemSetUintX(Dcm_UtiGetResData(pMsgContext), Dcm_MsgItemType, 0x00u, lSeedSize);                                                     /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */ /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_WRITE_MESSAGE_CONTEXT_RESBUFFER */
          Dcm_UtiProvideResData(pMsgContext, lSeedSize);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
          lStdResult = DCM_E_OK;
        }
      }
    }
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_Service27KeyProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service27KeyProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* If the attempt counters are currently read or written by the application: */
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  if(Dcm_TskGetEvent(DCM_TSK_CONTEXT_ID_SVC27) != 0u)
  {
    lStdResult = DCM_E_PENDING;
  }
  else
# endif
  {
    /* Get application key comparator */
    Dcm_RepeaterNextStep(pContext, DCM_SVC27_PROGRESS_KEYREPEATER);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP; /* Speed up processing */
  }
  return lStdResult;
}

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27UtiGetAttemptCntr()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27UtiGetAttemptCntr(
  Dcm_OpStatusType opStatus,
  P2VAR(uint32, AUTOMATIC, DCM_VAR_NOINIT) levelMask
  )
{
  Std_ReturnType  lResult;
  uint8           lAttemptCount;
  uint8_least     lSecLvlIter;

  /* For each security level: */
  for (lSecLvlIter = 0u; lSecLvlIter < DCM_CFGSVC27SECLEVELINFO_SIZE; ++lSecLvlIter)
  {
    /* If the attempt counter for that specific security level is not already read: */
    if(Dcm_UtiBitOpTest(uint32, *levelMask, Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter)))
    {
      Dcm_CfgSvc27SecLevelInfoPtrType pSecLevelInfo;
      Dcm_NegativeResponseCodeType    lNrc;

      lResult = Dcm_CfgSvc27SecLevelInfoGetEntry(lSecLvlIter, &pSecLevelInfo, &lNrc);                                                                /* SBSW_DCM_COMB_PTR_FORWARD */

      if(lResult == DCM_E_OK)                                                                                                                        /* COV_DCM_RTM_RUNTIME_CHECK TX */
      {
        /* Try to read the attempt counter from the application */
        lResult = pSecLevelInfo->GetAttemptCntrFunc(opStatus, &lAttemptCount);                                                                       /* SBSW_DCM_CALL_FUNCPTR_SVC27SECLEVEL */

        if(lResult == DCM_E_OK)
        {
          /*
           * Note: Using critical sections is not necessary here because the features "power on delay" and
           *       "external attempt counter storage" are used mutually exclusive per security level.
           */

          /* Mark the security level to prevent that this API is called again */
          Dcm_UtiBitOpClr(uint32, *levelMask, Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter));                                                          /* SBSW_DCM_PARAM_PTR_WRITE */

          /* If the already initialized attempt counter has to be updated: */
          if(lAttemptCount != 0u)
          {
            /* Store the attempt counter */
            Dcm_Svc27CounterSet(lSecLvlIter, lAttemptCount);

            /* If the current attempt counter value exceeded the maximum number of allowed attempts: */
            if(lAttemptCount >= Dcm_CfgStateSecurityInfo[lSecLvlIter].NumAttempts)
            {
              /* Set the delay timer value. The timer will be started later with that value */
              Dcm_Svc27TimerSet(lSecLvlIter, Dcm_CfgStateSecurityInfo[lSecLvlIter].DelayTimeInvKey);
            }
          }
        }/* If more time needed: */
        else if (lResult == DCM_E_PENDING)
        {
          /* Try it later */
        }
        else /* If something went wrong: */
        {
          Dcm_DebugAssert((lResult == DCM_E_NOT_OK), DCM_SID_GETSECURITYATTEMPTCOUNTER, DCM_E_INTERFACE_RETURN_VALUE);

          /* Mark the security level to prevent that this API is called again */
          Dcm_UtiBitOpClr(uint32, *levelMask, Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter));                                                          /* SBSW_DCM_PARAM_PTR_WRITE */

          /* Reset the attempt counter */
          Dcm_Svc27CounterReset(lSecLvlIter);

          /* If delay time on failed read of attempt counter is enabled: */
          if(Dcm_CfgStateSecurityInfo[lSecLvlIter].ReloadOnZeroDelay == TRUE)
          {
            /* If the configured delay time is zero: */
            if(Dcm_CfgStateSecurityInfo[lSecLvlIter].ReloadTime == 0u)
            {
              /* Set the delay timer value to infinity */
              Dcm_Svc27ReloadReadFailedSet(lSecLvlIter);
              Dcm_Svc27TimerSet(lSecLvlIter, 1u);
            }
            else
            {
              /* Otherwise set the configured delay timer value */
              Dcm_Svc27TimerSet(lSecLvlIter, Dcm_CfgStateSecurityInfo[lSecLvlIter].ReloadTime);
            }
          }
        }
      }
    }
  }
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27ReadAttemptCounter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27ReadAttemptCounter(
  Dcm_TskEventContextPtrType pEventContext
  )
{
  /* Restore the attempt counter values from the application */
  Dcm_Svc27UtiGetAttemptCntr(Dcm_SingletonContext.Diag.Services.Svc27.GetAttOpStatus
                            ,&Dcm_SingletonContext.Diag.Services.Svc27.GetAttCntrEventMask);                                                         /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  /* If all attempt counters were read */
  if(Dcm_SingletonContext.Diag.Services.Svc27.GetAttCntrEventMask == 0u)
  {
    uint8_least lTmrIter;

    for(lTmrIter = 0; lTmrIter < DCM_SVC_27_NUM_DELAY_TIMERS; ++lTmrIter)
    {
      /* If the corresponding security timer value is not zero: */
      if(Dcm_Svc27TimerGet(lTmrIter) != 0u)
      {
        /* Start the base timer which starts the appropriate security timers */
        Dcm_TmrStartTimer(DCM_TMR_ID_SECURITY, 1u);
        break;
      }
    }
    /* Reset operation status */
    Dcm_SingletonContext.Diag.Services.Svc27.GetAttOpStatus = DCM_INITIAL;
  }
  else
  {
    /* Otherwise resume the job next task cycle */
    Dcm_TskSetLocalEvent(pEventContext->PostEv, pEventContext->Ev);                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_SingletonContext.Diag.Services.Svc27.GetAttOpStatus = DCM_PENDING;
  }
}
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27WriteAttemptCounter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27WriteAttemptCounter(
  Dcm_TskEventContextPtrType pEventContext
  )
{
  /* Notify the application about changed attempt counters */
  Dcm_Svc27UtiSetAttemptCntr(Dcm_SingletonContext.Diag.Services.Svc27.SetAttOpStatus
                            ,&Dcm_SingletonContext.Diag.Services.Svc27.SetAttCntrEventMask);                                                         /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  /* If all attempt counters were written: */
  if(Dcm_SingletonContext.Diag.Services.Svc27.SetAttCntrEventMask == 0u)
  {
    /* Finish the job and reset the opStatus for next write cycle */
    Dcm_SingletonContext.Diag.Services.Svc27.SetAttOpStatus = DCM_INITIAL;
  }
  else
  {
    /* Otherwise resume the job next task cycle and notify application for the subsequent call via opStatus parameter */
    Dcm_TskSetLocalEvent(pEventContext->PostEv, pEventContext->Ev);                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_SingletonContext.Diag.Services.Svc27.SetAttOpStatus = DCM_PENDING;
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_Service27SeedRepeater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SeedRepeater(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType                  lResult;
  Dcm_CfgSvc27SecLevelInfoPtrType pSecLevelInfo;

  lResult = Dcm_CfgSvc27SecLevelInfoGetEntry(pRepContext->SecLvlRef, &pSecLevelInfo, ErrorCode);                                                     /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lResult == DCM_E_OK)                                                                                                                           /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lResult = Dcm_UtiMsgContextVerifySize(pMsgContext, pSecLevelInfo->SeedResLength, ErrorCode);                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

    if (lResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
    {
      /* Read the seed of the appropriate security level */
      switch (pSecLevelInfo->GetSeedFuncClass)
      {
      case DCM_SVC27_OPCLS_SEED_WITHOUT_ADR:
        lResult = ((Dcm_Svc27OpFuncSeedWoAdr)pSecLevelInfo->GetSeedFunc)(opStatus                                                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
          , Dcm_UtiGetResData(pMsgContext)                                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
          , ErrorCode);                                                                                                                              /* SBSW_DCM_CALL_FUNCPTR_SVC27GETSEED */
        break;
      case DCM_SVC27_OPCLS_SEED_WITH_ADR:
        lResult = ((Dcm_Svc27OpFuncSeedWAdr)pSecLevelInfo->GetSeedFunc)(Dcm_UtiGetReqData(pMsgContext)                                               /* PRQA S 0313 */ /* MD_Dcm_0313 */
          , opStatus
          , Dcm_UtiGetResData(pMsgContext)                                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
          , ErrorCode);                                                                                                                              /* SBSW_DCM_CALL_FUNCPTR_SVC27GETSEED */
        break;
      default:                                                                                                                                       /* COV_DCM_RTM_UNREACHABLE X */
        DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                            /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lResult = DCM_E_NOT_OK;
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG);                                                                                /* COV_DCM_RTM_DEV_DEBUG XF */
        break;
      }

      switch (lResult)
      {
      case DCM_E_OK:
        /* Send response */
        Dcm_UtiProvideResData(pMsgContext, pSecLevelInfo->SeedResLength);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
        break;
      case DCM_E_PENDING:
        /* Retry later */
        break;
      case DCM_E_NOT_OK:
        Dcm_UtiHandleApplNrc(lResult, ErrorCode, DCM_E_CONDITIONSNOTCORRECT);                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
        break;
      default:
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lResult = DCM_E_NOT_OK;
        break;
      }
    }
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Service27KeyRepeater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27KeyRepeater(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_ReadOnlyMsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType                  lResult;
  Dcm_NegativeResponseCodeType    lNrc;
  Dcm_CfgSvc27SecLevelInfoPtrType pSecLevelInfo;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lResult = Dcm_CfgSvc27SecLevelInfoGetEntry(pRepContext->SecLvlRef, &pSecLevelInfo, ErrorCode);                                                     /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lResult == DCM_E_OK)                                                                                                                           /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lNrc = DCM_E_POSITIVERESPONSE;

    /* Let the application compare the given key data */
    lResult = pSecLevelInfo->CompareKeyFunc(Dcm_UtiGetReqData(pMsgContext)                                                                           /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                           ,opStatus
                                           ,&lNrc
                                           );                                                                                                        /* SBSW_DCM_CALL_FUNCPTR_SVC27SECLEVEL */

    switch(lResult)
    {
      /*---------------------------*/
      case DCM_E_OK:
      /*---------------------------*/
        /* Reset the attempt counter of this security level */
        Dcm_Svc27CounterReset(pRepContext->SecLvlRef);

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
        /* Notify application about new attempt counter */
        Dcm_RepeaterNextStep(pContext, DCM_SVC27_PROGRESS_SETATTEMPTCNTR);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
        lResult = DCM_E_LOOP;
# endif
        break;
      /*---------------------------*/
      case DCM_E_PENDING:
      /*---------------------------*/
        /* Try later */
        break;
      /*---------------------------*/
      case DCM_E_NOT_OK:
      /*---------------------------*/
        /* If an error occurred set the NRC given by the application */
        Dcm_UtiHandleApplNrc(lResult, &lNrc, DCM_E_CONDITIONSNOTCORRECT);                                                                            /* SBSW_DCM_POINTER_FORWARD_STACK */
        pRepContext->ErrorCode = lNrc; /* will be used in next step */                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
        /* fall through */
      case DCM_E_COMPARE_KEY_FAILED:                                                                                                                 /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
        /* Increment the attempt counter */
        Dcm_Svc27CounterInc(pRepContext->SecLvlRef);

        /* Notify application about new attempt counter */
        Dcm_RepeaterNextStep(pContext, DCM_SVC27_PROGRESS_CHECKATTEMPTSEXCEEDED);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
        lResult = DCM_E_LOOP;
        break;
      /*---------------------------*/
      default:
      /*---------------------------*/
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);

        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lResult = DCM_E_NOT_OK;
        break;
    }
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Service27CheckAttemptsExceededRepeater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27CheckAttemptsExceededRepeater(
  Dcm_OpStatusType opStatus,
  Dcm_ReadOnlyMsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType  lResult;
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  uint32          lMask = Dcm_UtiGetBitFromIndex(uint32, pRepContext->SecLvlRef);
# endif

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  /* Notify the application about the new attempt counter value */
  Dcm_Svc27UtiSetAttemptCntr(opStatus, &lMask);                                                                                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

  /* If the setting of the attempt counter was not successful: */
  if(lMask != 0u)
  {
    /* Try it later */
    lResult = DCM_E_PENDING;
  }
  else
# endif
  {
    /* If the number of allowed attempt were exceeded: */
    if( (Dcm_CfgStateSecurityInfo[pRepContext->SecLvlRef].NumAttempts != 0u) /* Consider only levels with attempt monitoring */
      && (Dcm_Svc27CounterGet(pRepContext->SecLvlRef) >= Dcm_CfgStateSecurityInfo[pRepContext->SecLvlRef].NumAttempts))
    {
      /* Set NRC 0x36 if not already set and start the timer */
      /* This NRC will be ignored if ErrorCode is already set due to failed compare key function */
      *ErrorCode = DCM_E_EXCEEDNUMBEROFATTEMPTS;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */

      Dcm_Svc27TimerStart(pRepContext->SecLvlRef, Dcm_CfgStateSecurityInfo[pRepContext->SecLvlRef].DelayTimeInvKey);
    }
    else
    {
      /* Otherwise set NRC 0x35 if not already set */
      /* This NRC will be ignored if ErrorCode is already set due to failed compare key function */
      *ErrorCode = DCM_E_INVALIDKEY;                                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
    }

    if (pRepContext->ErrorCode != DCM_E_POSITIVERESPONSE)
    {
      /* Use previously set ErrorCode if available */
      *ErrorCode = pRepContext->ErrorCode;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
    }

    lResult = DCM_E_NOT_OK;
  }

  return lResult;
}

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27SetAttemptCntrRepeater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SetAttemptCntrRepeater(
  Dcm_OpStatusType opStatus,
  Dcm_ReadOnlyMsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType  lResult;
  uint32          lMask = Dcm_UtiGetBitFromIndex(uint32, pRepContext->SecLvlRef);

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Notify the application about the new attempt counter value */
  Dcm_Svc27UtiSetAttemptCntr(opStatus, &lMask);                                                                                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

  /* If the setting of the attempt counter was successful: */
  if(lMask == 0u)
  {
    /* Finish the job */
    if (pRepContext->ErrorCode == DCM_E_POSITIVERESPONSE)
    {
      lResult = DCM_E_OK;
    }
    else
    {
      *ErrorCode = pRepContext->ErrorCode;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      lResult = DCM_E_NOT_OK;
    }
  }
  else
  {
    /* Otherwise try it later */
    lResult = DCM_E_PENDING;
  }

  return lResult;
}
# endif
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc28SubFuncInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc28SubFuncInfoGetEntry(
  Dcm_DiagSubServiceRefOptType SubSvcRef,
  CONSTP2VAR(Dcm_CfgSvc28SubFuncInfoPtrType, AUTOMATIC, AUTOMATIC) pSubFuncInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if (Dcm_DebugDetectRuntimeError(SubSvcRef >= DCM_CFGSVC28SUBFUNCINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pSubFuncInfo = &Dcm_CfgSvc28SubFuncInfo[SubSvcRef];                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc28Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc28Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc28RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType                lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Prepare all generic part (independently of the SF validation result!) */
  pRepContext->IsInternallyProcessed = FALSE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->SubServiceId = Dcm_UtiGetReqDataAsU8(pMsgContext);                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */ /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc28SubFuncLookUpTable
                                                   ,Dcm_CfgSvc28SubFuncExecPrecondTable
                                                   ,Dcm_Svc28ReqLengthGetter
                                                   ,Dcm_DiagNoSequenceChecker
                                                   ,&lSubSvcRef
                                                   ,ErrorCode);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

  pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)lSubSvcRef;                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */

  if (lStdResult == DCM_E_OK)
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC28_PROGRESS_SUBFUNCTION); /* delegate job */                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  } /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc28SubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc28SubFuncHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc28RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType                 lStdResult;
  Dcm_CfgSvc28SubFuncInfoPtrType pSubFuncInfo;

  lStdResult = Dcm_CfgSvc28SubFuncInfoGetEntry(pRepContext->SubSvcRef, &pSubFuncInfo, ErrorCode);                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lStdResult == DCM_E_OK)                                                                                                                        /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(pContext, opStatus, pMsgContext, ErrorCode);                                                               /* SBSW_DCM_CALL_FUNCPTR_SVC28SUBFUNC */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc28ApplyCommControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc28ApplyCommControl(
  Dcm_CfgNetNetIdRefMemType networkRef,
  Dcm_CommunicationModeType mode
  )
{
  DCM_IGNORE_UNREF_PARAM(networkRef);                                                                                                                /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_SVC_28_CURNET_SUPPORT_ENABLED == STD_ON) && \
     (DCM_NET_COMCTRL_ALLNET_SUPPORT_ENABLED == STD_ON)
  if(networkRef == DCM_SVC_28_NETWORK_ALL)
# endif
  {
# if (DCM_NET_COMCTRL_ALLNET_SUPPORT_ENABLED == STD_ON)
    uint8_least lChannelIter;

    for(lChannelIter = Dcm_PbCfgNetComCtrlChannelListAll[0]; lChannelIter != 0u; --lChannelIter)
    {
      Dcm_ModeSwitchCommControl(Dcm_PbCfgNetComCtrlChannelListAll[lChannelIter], mode);
    }
# endif
  }
# if (DCM_SVC_28_CURNET_SUPPORT_ENABLED == STD_ON) && \
     (DCM_NET_COMCTRL_ALLNET_SUPPORT_ENABLED == STD_ON)
  else
# endif
  {
# if (DCM_SVC_28_CURNET_SUPPORT_ENABLED == STD_ON)
    Dcm_ModeSwitchCommControl(networkRef, mode);
# endif
  }
}
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc29SubFuncInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc29SubFuncInfoGetEntry(
  Dcm_DiagSubServiceRefOptType subSvcRef,
  CONSTP2VAR(Dcm_CfgSvc29SubFuncInfoPtrType, AUTOMATIC, AUTOMATIC) pSubFuncInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if (Dcm_DebugDetectRuntimeError(subSvcRef >= DCM_CFGSVC29SUBFUNCINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pSubFuncInfo = &Dcm_CfgSvc29SubFuncInfo[subSvcRef];                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc29Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType                lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Check if callback processing state is idle */
  if(Dcm_Svc29GetCbkProcessingState() != DCM_SVC29_CBK_PROC_STATE_IDLE)
  {
    /* The asynchronous callback processing is still active for another tester */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    /* Get subfunction id before it gets consumed */
    pRepContext->SubFuncId = Dcm_UtiGetReqDataAsU8(pMsgContext);                                                                                     /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */ /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_RepeaterSetUser(pContext, DCM_REPEATER_USER_AUTHENTICATION); /* set user for central repeater handling */                                    /* SBSW_DCM_PARAM_PTR_WRITE */

    lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                     ,Dcm_CfgSvc29SubFuncLookUpTable
                                                     ,Dcm_CfgSvc29SubFuncExecPrecondTable
                                                     ,Dcm_Svc29ReqLengthGetter
                                                     ,Dcm_Svc29SubFuncSequenceChecker
                                                     ,&lSubSvcRef
                                                     ,ErrorCode);                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

    /* Initialize service processor context for further processing */
    pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)lSubSvcRef; /* Store working sub-function reference (also in negative response cases) */  /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->AuthInfoHdl = Dcm_NetGetAuthInfoRef(Dcm_DiagGetTranspObj(pContext->Thread)->ConnHdl);                                               /* SBSW_DCM_PARAM_PTR_WRITE */

    Dcm_Svc29SetRxPduId(pMsgContext->rxPduId);

    if (lStdResult == DCM_E_OK)
    {
      Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_SUBFUNCTION); /* delegate job */                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_LOOP; /* speed up processing */
    }
  }
  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc29CbkResultDispatcher()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29CbkResultDispatcher(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult = DCM_E_LOOP;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  switch(Dcm_Svc29GetCbkProcessingState())
  {
  case DCM_SVC29_CBK_PROC_STATE_VERIFY_CERT_DONE:
    Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_CERTVERIFIED);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC29_CBK_PROC_STATE_GENERATE_CHALLENGE_DONE:
      Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_CHALLENGEGEN);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
# if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC29_CBK_PROC_STATE_SIGN_CHALLENGE_DONE:
    Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_SUBFUNC02_CHALLENGESIGNED);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
# endif
  case DCM_SVC29_CBK_PROC_STATE_VERIFY_POOW_DONE:
    Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_SUBFUNC03_ROLEREAD);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  default:
    /* Callback not triggered yet, retry later */
    lStdResult = DCM_E_PENDING;
    break;
  }
  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc29SubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29SubFuncHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType                 lStdResult;
  Dcm_CfgSvc29SubFuncInfoPtrType pSubFuncInfo;

  lStdResult = Dcm_CfgSvc29SubFuncInfoGetEntry(pRepContext->SubSvcRef, &pSubFuncInfo, ErrorCode);                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lStdResult == DCM_E_OK)                                                                                                                        /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(pContext, opStatus, pMsgContext, ErrorCode);                                                               /* SBSW_DCM_CALL_FUNCPTR_SVC29SUBFUNC */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_ModeSwitchAuthentication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeSwitchAuthentication(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  uint8 mode
  )
{
  if (Dcm_DebugDetectRuntimeError(authInfoRef >= DCM_CFGAUTHMGRNETCONNINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    (void)Dcm_CfgAuthMgrNetConnInfo[authInfoRef].AuthStateModeSwitchOpFunc(mode);                                                                    /* SBSW_DCM_CALL_FUNCPTR_AUTHMODESWITCH */
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc29KeyMSetCertificate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29KeyMSetCertificate(
  KeyM_CertificateIdType certId,
  P2CONST(KeyM_CertDataType, AUTOMATIC, DCM_APPL_DATA) pCertificateData,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  /* Attempt to store cerificate */
  Std_ReturnType lKeyMResult = KeyM_SetCertificate(certId, pCertificateData);                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Evalute result and respond accordingly */
  switch(lKeyMResult)
  {
  case E_OK:
    lStdResult = DCM_E_OK;
    break;
  case KEYM_E_KEY_CERT_SIZE_MISMATCH:
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  default:
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc29KeyMVerifyCertificate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29KeyMVerifyCertificate(
  Dcm_ContextPtrType pContext,
  KeyM_CertificateIdType certId,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  Std_ReturnType lKeyMResult;

  /* Set callback processing state to verify certificate */
  Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_VERIFY_CERT);

  /* Attempt to start async job to verify the certificate */
  lKeyMResult = KeyM_VerifyCertificate(certId);

  /* Evaluate result and respond accordingly */
  switch(lKeyMResult)
  {
  case E_OK:
    /* If async job was accepted change progress state */
    Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_WAITCERTVERIFY);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_PENDING;
    break;
  case KEYM_E_BUSY:
    *ErrorCode = DCM_E_BUSYREPEATREQUEST;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  default:
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}

# if (DCM_MODE_AUTH_GENERAL_NRC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29GeneralNrcCheck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc29GeneralNrcCheck(
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{

  Dcm_NegativeResponseCodeType lNrcIgnore;

  /* Check if the error pertains to Certificate Verification Failed */
  switch(*ErrorCode)
  {
    case DCM_E_CVF_INVALIDTIMEPERIOD:
    case DCM_E_CVF_INVALIDSIGNATURE:
    case DCM_E_CVF_INVALIDCHAINOFTRUST:
    case DCM_E_CVF_INVALIDTYPE:
    case DCM_E_CVF_INVALIDFORMAT:
    case DCM_E_CVF_INVALIDCONTENT:
    case DCM_E_CVF_INVALIDSCOPE:
    case DCM_E_CVF_INVALIDCERTIFICATEREVOKED:
      /* If mode rule enables General NRC, override Error Code to General NRC */
      if(Dcm_ModeCheck(DCM_MODE_AUTH_SEND_GENERAL_NRC_MODERULE_REF, &lNrcIgnore) == DCM_E_OK)                                                        /* SBSW_DCM_POINTER_FORWARD_STACK */
      {
        *ErrorCode = DCM_AUTHMGR_GENERAL_NRC;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      break;
    default:
      /* Otherwise - proceed with negative response code */
    break;
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc29FinalizeSequenceStartReq()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29FinalizeSequenceStartReq(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  /* If response buffer can hold the EPK length field */
  if(pMsgContext->resMaxDataLen >= DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN)
  {
    /* Append lengthOfEphemeralPublicKeyServer bytes(uint16) on response */
    Dcm_UtiProvideResDataAsU16(pMsgContext, 0x00u);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Get challenge length from request */
    Dcm_Svc29SetLengthChallengeSwapBuffer(Dcm_UtiGetResDataAsU16At(pMsgContext, DCM_SVC29_CHALLENGE_LEN_INDEX));

    /* Copy challenge data from response buffer to special challenge buffer (needed for subfunction 0x03) */
    Dcm_UtiMemCopySafe(Dcm_UtiGetResDataAt(pMsgContext, DCM_SVC29_CHALLENGE_DATA_START_INDEX)
                      ,Dcm_SingletonContext.Diag.Services.Svc29.ChallengeSwapBuffer
                      ,0u
                      ,DCM_AUTHMGR_CHALLENGE_MAX_SIZE
                      ,Dcm_Svc29GetLengthChallengeSwapBuffer());                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_WRITE_CHALLENGE_SWAP_BUFFER */

    /* Set sequence flag and associated pdu ID for request 0x03 */
    Dcm_Svc29SetOwnershipRequestExpected();
  }
  else
  {
    /* Otherwise, send NRC 0x14 (DCM_E_RESPONSETOOLONG) */
    *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

# if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29GetServerCertificate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29GetServerCertificate(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;
  KeyM_CertDataType lEcuCertificate;
  Std_ReturnType lKeyMResult;

  /* Set location to write certificate data */
  lEcuCertificate.certData = Dcm_UtiGetResDataRel(pMsgContext, DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN);                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
  /* Provide KeyM_GetCertificate with all available buffer length (without 2Bytes for the lengthField) */
  lEcuCertificate.certDataLength = pMsgContext->resMaxDataLen - DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN;

  lKeyMResult = KeyM_GetCertificate(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].EcuCertificateId
                                   ,&lEcuCertificate);                                                                                               /* SBSW_DCM_POINTER_WRITE_CERTIFICATE_DATA */


  /* If result is successful continue processing */
  if(lKeyMResult == DCM_E_OK)
  {
    /* Provide size of server certificate in response */
    Dcm_UtiProvideResDataAsU16(pMsgContext, (uint16)lEcuCertificate.certDataLength);                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    /* Notify message context about server certificate data written from KeyM_GetCertificate */
    Dcm_UtiProvideResData(pMsgContext, lEcuCertificate.certDataLength);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else if(lKeyMResult == KEYM_E_KEY_CERT_SIZE_MISMATCH)
  {
    *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
  }

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc29ValidateCsmCbkResult()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29ValidateCsmCbkResult(
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;

  /* Switch according to Csm callback result and set NRC */
  switch(Dcm_SingletonContext.Diag.Services.Svc29.CsmCbkResult)
  {
  case E_OK:
    lStdResult = DCM_E_OK;
    break;
  case E_SMALL_BUFFER:
    *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default:
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc29ValidateKeyMCbkResult()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29ValidateKeyMCbkResult(
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;

  /* Switch according to Key Manager callback result and set NRC if required */
  switch(Dcm_SingletonContext.Diag.Services.Svc29.KeyMCbkResult)
  {
  case KEYM_CERTIFICATE_VALID:
    lStdResult = DCM_E_OK;
    break;
  case KEYM_E_CERTIFICATE_SIGNATURE_FAIL:
    *ErrorCode = DCM_E_CVF_INVALIDSIGNATURE;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  case KEYM_E_CERTIFICATE_INVALID_CHAIN_OF_TRUST:
    *ErrorCode = DCM_E_CVF_INVALIDCHAINOFTRUST;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  case KEYM_E_CERTIFICATE_INVALID_TYPE:
    *ErrorCode = DCM_E_CVF_INVALIDTYPE;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  case KEYM_E_CERTIFICATE_INVALID_FORMAT:
    *ErrorCode = DCM_E_CVF_INVALIDFORMAT;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  case KEYM_E_CERTIFICATE_INVALID_CONTENT:
    *ErrorCode = DCM_E_CVF_INVALIDSCOPE;                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  case KEYM_E_CERTIFICATE_REVOKED:
    *ErrorCode = DCM_E_CVF_INVALIDCERTIFICATEREVOKED;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  case KEYM_E_CERTIFICATE_VALIDITY_PERIOD_FAIL:
    *ErrorCode = DCM_E_CVF_INVALIDTIMEPERIOD;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default:
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdNextEntryIdxInc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdNextEntryIdxInc(
  void
  )
{
  ++Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex;
  if(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex >= DCM_SVC_2A_SCHEDULER_SIZE)
  {
    /* Write always zero (also when only one scheduler element exists, to keep the safe aspect when the wrap-around is
     * detected */
    Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex = 0u;
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_Svc2ASchdEntryPtrType, DCM_CODE) Dcm_Svc2ASchdGetEntry(
  Dcm_Svc2ASchdItemHandleOptType schdHandle
  )
{
  Dcm_Svc2ASchdEntryPtrType pSchdEntry;

  if (Dcm_DebugDetectRuntimeError(schdHandle >= DCM_SVC_2A_SCHEDULER_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    pSchdEntry = &Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.Table[0];
  }
  else
  {
    pSchdEntry = &Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.Table[schdHandle];
  }
  return pSchdEntry;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdUpdateTimers()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdUpdateTimers(
  void
  )
{
  boolean doActivateProcessorTask = FALSE;
  Dcm_Svc2ASchdItemHandleOptType lSchdIter;
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  Dcm_Svc2ASchedRateOptType lFastestRate = DCM_SVC2A_RATE_TYPE_SLOW;
# endif

  for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
  {
    Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);

    if(pSchdEntry->Timer != 0u)
    {
      --(pSchdEntry->Timer);                                                                                                                         /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
      if(pSchdEntry->Timer == 0u)
      {
        if(pSchdEntry->Rate < DCM_SVC2A_RATE_TYPE_STOPPED) /* is it scheduled ? */
        {
          doActivateProcessorTask = TRUE;
        }
      }
    }
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
    if(pSchdEntry->Rate < DCM_SVC2A_RATE_TYPE_STOPPED) /* is it scheduled ? */
    {
      if (pSchdEntry->Rate > lFastestRate)
      {
        lFastestRate = pSchdEntry->Rate;
      }
    }
# endif
  }
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  Dcm_NetPeriodicMsgSetFastestRate(lFastestRate);
# endif
  return doActivateProcessorTask;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdFindFreeOrInUseItemByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdFindFreeOrInUseItemByDid(
  uint16 did,
  P2VAR(Dcm_Svc2ASchdItemHandleOptType, AUTOMATIC, AUTOMATIC) schdHandle
  )
{
  Dcm_Svc2ASchdItemHandleOptType lSchdIter;
  boolean lSlotFound = FALSE;

  for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
  {
    Dcm_Svc2ASchdEntryConstPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);

    if(pSchdEntry->Rate == DCM_SVC2A_RATE_TYPE_STOPPED)
    {
      if(lSlotFound == FALSE)
      {
        *schdHandle = lSchdIter; /* reserve first found free slot */                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
        lSlotFound = TRUE;
      }/* else - already set */
    }
    else if(did == pSchdEntry->DidContext.Did)
    {
      *schdHandle = lSchdIter; /* found already in used or just reserved DID -> use the same slot */                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
      lSlotFound = TRUE;
      break;
    }
    else
    {
      /* do nothing */
    }
  }
  return lSlotFound;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdInitDidMgrResources()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ASchdInitDidMgrResources(
  Dcm_DiagDataContextPtrType pDataContext,
  uint16 did
  )
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_RsrcMgrGetDidLock(DCM_INITIAL, did, DCM_RSRCMGR_DIDLOCK_OWNER_SID2A);

  if(lStdResult == DCM_E_OK)
  {
    /* prepare first time reading */
    Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.OpStatus = DCM_INITIAL;
    Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.WriteIndex = 0u;
    Dcm_UtiProvideDataAsU8(pDataContext, Dcm_UtiGetLoByte(did));                                                                                     /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdProcessEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ASchdProcessEntry(
  Dcm_Svc2ASchdEntryPtrType pSchedTableEntry
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;
  boolean doSendData = FALSE;

  /* allocate buffer for response data */
  /* still nothing reserved for this DID? */
  if(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle == DCM_NET_INVALID_PTXOBJ_HANDLE)
  {
    Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle = Dcm_NetPeriodicMsgAllocate(pSchedTableEntry->DidContext.Did);
    if(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle == DCM_NET_INVALID_PTXOBJ_HANDLE)
    {
      /* no free message buffer try again later */
      lStdResult = DCM_E_PENDING; /* exit loop and task */
    }
  }

  if(lStdResult == DCM_E_OK)
  {
    Dcm_DiagDataContextType lDataContext;

    /* Init data context */
    Dcm_UtiInitDataContext(&lDataContext
                           ,Dcm_NetPeriodicMsgGetTxBuffer(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle)
                           ,(Dcm_MsgLenType)DCM_NET_PERIODIC_BUFFER_SIZE);                                                                           /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

    /* Allocate DID manager resource */
    if(Dcm_RsrcMgrHasDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID2A) == FALSE)
    {
      lStdResult = Dcm_Svc2ASchdInitDidMgrResources(&lDataContext, pSchedTableEntry->DidContext.Did);                                                /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */
    }

    if(lStdResult == DCM_E_OK)
    {
      Dcm_NegativeResponseCodeType lNrc; /* unused since no NR possible */

      /* Write index is initialized in Dcm_Svc2ASchdInitDidMgrResources and thus always valid */
      Dcm_UtiCommitData(&lDataContext, Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.WriteIndex);                                               /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */

      /* read the response data */
      lStdResult = Dcm_DidMgrReadDid(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.OpStatus
                                    ,&lDataContext
                                    ,&(pSchedTableEntry->DidContext)
                                    ,&(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.DidOpTypeContext)
                                    ,&lNrc);                                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */

      Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.WriteIndex = (Dcm_CfgNetBufferSizeMemType)lDataContext.Usage;

      switch(lStdResult)
      {
      case DCM_E_OK:
        doSendData = TRUE; /* now the response can be sent */
        break;
      case DCM_E_PENDING:
        Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.OpStatus = DCM_PENDING; /* prepare for next call */
        break;
      case DCM_E_NOT_OK:
        /* something went wrong - skip this DID */
        break;
      default:                                                                                                                                       /* COV_DCM_RTM_UNREACHABLE X */
        lStdResult = DCM_E_NOT_OK;
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                 /* COV_DCM_RTM_DEV_DEBUG XF */
        break;
      }

      if(lStdResult != DCM_E_PENDING)
      {
        /* reload the period timer from now on (see ISO14229-1 SID 0x2A scheduler example) */
        /*
         * No critical section for split tasks needed since:
         * - The timer that just has been processed is already stopped and will not be decrement in the
         *   Dcm_Svc2ASchdUpdateTimers utility.
         * - This tasks is a low-priority one and cannot interrupt the timer task (Dcm_OnTimeoutSvc2AScheduler). So
         *   setting a non-zero value will not be an issue.
         */
        pSchedTableEntry->Timer = Dcm_Svc2AGetSchedulingTimeOfEntry(pSchedTableEntry);                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

        /* Finish scheduled job */
        Dcm_Svc2ASchdFinishEntryProcessing(doSendData);
      }
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
/**********************************************************************************************************************
 *  Dcm_Service2ASchedulerInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Service2ASchedulerInit(
  void
  )
{
  Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries = 0u;
  Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex = 0u;
  Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle = DCM_NET_INVALID_PTXOBJ_HANDLE;

  {
    Dcm_Svc2ASchdItemHandleOptType lSchdIter;

    for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
    {
      Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);
      pSchdEntry->Timer = 0u;                                                                                                                        /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
      pSchdEntry->Rate = DCM_SVC2A_RATE_TYPE_STOPPED;                                                                                                /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdAddItemByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdAddItemByDid(
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext                                                                                                    /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_Svc2ASchdItemHandleOptType lSchdHandle = DCM_SVC_2A_SCHEDULER_SIZE;
  Dcm_Svc2ASchdEntryPtrType pSchdEntry;

  if (Dcm_Svc2ASchdFindFreeOrInUseItemByDid(pDidInfoContext->Did, &lSchdHandle) == TRUE)                                                             /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    pSchdEntry = Dcm_Svc2ASchdGetEntry((Dcm_Svc2ASchdItemHandleOptType)lSchdHandle);

    pSchdEntry->DidContext  = *pDidInfoContext;                                                                                                      /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
    pSchdEntry->Rate |= DCM_SVC2A_RATE_TYPE_RESERVED;                                                                                                /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
  }
  else
  {
    /* there shall always be free space when this function is called, otherwise check the SID 0x2A processor */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCommit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdCommit(
  Dcm_Svc2ASchedRateMemType rate
  )
{
  Dcm_Svc2ASchdItemHandleOptType lSchdIter;

  Dcm_SplitTaskEnterCS();/* protect against timer task update */

  for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
  {
    Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);
    if((pSchdEntry->Rate & DCM_SVC2A_RATE_TYPE_RESERVED) != 0u)
    {
      if((pSchdEntry->Rate & DCM_SVC2A_RATE_TYPE_STOPPED) != 0u)
      {
        /* update statistic of first activation of this DID */
        ++Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries;
      }
      /* must not exceed the scheduler size */
      Dcm_DebugAssert((Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries <= DCM_SVC_2A_SCHEDULER_SIZE)
                     ,DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                        /* COV_DCM_RTM_DEV_DEBUG XF */

      pSchdEntry->Rate = rate; /* set the new rate */                                                                                                /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
      pSchdEntry->Timer = 0u; /* enforce immediate timeout */                                                                                        /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
    }
  }
  Dcm_SplitTaskLeaveCS();

  if(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
# if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
    Dcm_TmrStartTimer(DCM_TMR_ID_SVC2A_SCHEDULER, 1u);/* start timer updater */
# endif
    /* start updating the timers/processing new DIDs */
    Dcm_TskSetEvent(DCM_TSK_ID_SVC2A_SCHEDULER
                       ,(Dcm_TskTaskEvMemType)(DCM_TSK_EV_SVC2A_SCHEDULER_TMR_UPD|DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS));
  }
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdDiscard()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdDiscard(
  void
  )
{
  Dcm_Svc2ASchdItemHandleOptType lSchdIter;

  for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
  {
    Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);
    Dcm_UtiBitOpClr(Dcm_Svc2ASchedRateMemType, pSchdEntry->Rate, DCM_SVC2A_RATE_TYPE_RESERVED);                                                      /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
  }
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2AStoppedDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AStoppedDidLookUp(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn;

  lStdReturn = Dcm_Svc2ADidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdReturn == DCM_E_OK)
  {
    Dcm_Svc2ASchdStopItemByDid(pRepContext->DidInfoContext.Did);
    lStdReturn = DCM_E_LOOP;/* go on with the next DID  */
  }
  else if (lStdReturn == DCM_E_PROCESSINGDONE)
  {
    lStdReturn = DCM_E_OK;
  }
  else
  {
    /* DCM_E_PENDING, DCM_E_NOT_OK (ErrorCode already set), DCM_E_LOOP */
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2AScheduledDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AScheduledDidLookUp(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn;
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext = &(pRepContext->DidInfoContext);                                                                  /* PRQA S 3679 */ /* MD_Dcm_Design_3679 */

  lStdReturn = Dcm_Svc2ADidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdReturn == DCM_E_OK)
  {
    lStdReturn = Dcm_DidMgrDynDidStateCheck(Dcm_NetGetConnHdlOfRxPduId(pMsgContext->rxPduId), pDidInfoContext, ErrorCode);                           /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_PARAM_PTR_FORWARD */
    if (lStdReturn == DCM_E_OK)
    {
      /* Proceed with next validation step */
      Dcm_RepeaterNextStep(pContext, DCM_SVC2A_PROGRESS_DID_CHECKCONDITION); /* next job */                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdReturn = DCM_E_LOOP;/* speed up processing */
    } /* else DCM_E_NOT_OK (ErrorCode already set) */
  }
  else if (lStdReturn == DCM_E_PROCESSINGDONE)
  {
    lStdReturn = DCM_E_OK;
  }
  else
  {
    /* DCM_E_PENDING, DCM_E_NOT_OK (ErrorCode already set), DCM_E_LOOP */
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ADidCheckCondition()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidCheckCondition(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult = DCM_E_LOOP;

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DidInfoContext))
                                ,DCM_DIDMGR_OPTYPE_READCHKCOND))
  {
    DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                             /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

    /* check condition on this DID */
    Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_READCHKCOND);                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = Dcm_DidMgrReadCheckCond(opStatus
                                        ,&(pRepContext->DidInfoContext)
                                        ,&(pRepContext->DidOpTypeContext)
                                        ,ErrorCode);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

    switch(lStdResult)
    {
    case DCM_E_OK:
      lStdResult = DCM_E_LOOP;
      break; /* go on with next DID */
    case DCM_E_PENDING:
      break;
    default: /* DCM_E_NOT_OK */
      break; /* finish service processing immediately */
    }
  }/* else - not supported operation - go on with getLength */

  if(lStdResult == DCM_E_LOOP)
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC2A_PROGRESS_DID_GETLENGTH);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  return lStdResult; /* speed up processing */
}

/**********************************************************************************************************************
 *  Dcm_Svc2ADidGetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidGetLength(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdReturn = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DidInfoContext))
                                ,DCM_DIDMGR_OPTYPE_READLENGTH))
  {
    Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_READLENGTH);                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Calculate DID data length if applicable */
    lStdReturn = Dcm_DidMgrReadLength(opStatus
                                     ,&(pRepContext->DidInfoContext)
                                     ,&(pRepContext->DidOpTypeContext)
                                     ,ErrorCode);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(lStdReturn == DCM_E_OK)
  {
    /* check for buffer overrun - uudt frame needs to be large enough for the periodic message (1 Byte DID + data) */
    if (pRepContext->DidInfoContext.DidLength >= Dcm_PbCfgNetConnectionInfo[pRepContext->ConnHdl].UudtFrameSize)
    {
      /* the configured buffer will not be able to hold all of the data -> notify the client */
      *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK; /* finish service processing immediately */
    }
    else
    {
      /* Add scheduler job - set the operation now since not changed later */
      Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_READ);                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

      Dcm_Svc2ASchdAddItemByDid(&pRepContext->DidInfoContext);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */

      Dcm_RepeaterNextStep(pContext, DCM_SVC2A_PROGRESS_SCHEDULEDDID_LOOKUP);                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdReturn = DCM_E_LOOP;/* speed up processing */
    }
  }/* else - DCM_E_PENDING, DCM_E_NOT_OK */

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2AIsUdsRateSupported()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc2AIsUdsRateSupported(
  Dcm_Svc2ATransmissionModeType udsRate
  )
{
  sint16_least lLookUpResult;
  boolean      lResult = TRUE;

  lLookUpResult = Dcm_UtiLookUpUint8(Dcm_CfgSvc2ASupportedRatesLookUpTable, udsRate);                                                                /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  if (lLookUpResult < 0)
  {
    lResult = FALSE;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2AStopScheduledDids()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AStopScheduledDids(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext                                                                                                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdReturn = DCM_E_OK;
  if(pMsgContext->reqDataLen == 0u)
  {
    Dcm_Svc2ASchdStopAll();
  }
  else
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC2A_PROGRESS_STOPPED_DID_LOOKUP); /* delegate job */                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdReturn = DCM_E_LOOP;/* speed up processing */
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ADoScheduleDids()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADoScheduleDids(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdReturn = DCM_E_NOT_OK;

  if(pMsgContext->reqDataLen > Dcm_Svc2ASchdGetFreeSpace())
  {
  /*
   * not enough space in the scheduler table
   * (don't consider duplicates and unsupported DIDs in the request -> apply KISS) */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC2A_PROGRESS_SCHEDULEDDID_LOOKUP); /* delegate job */                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdReturn = DCM_E_LOOP;/* speed up processing */
  }

  /* Reaching this point means diagnostic error was found */
  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2AHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType                     lStdReturn;
  Dcm_NetTransportObjectConstPtrType pTranspObj = Dcm_DiagGetTranspObj(pContext->Thread);

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  pRepContext->ConnHdl = pTranspObj->ConnHdl;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */

# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
  /* protected by the session connection ownership */
# else
  /* In case of generic connections, a connection can be used by a pool of testers. Tester address has to be checked as well. */
  if ( (Dcm_NetPeriodicMsgGetConnection() != DCM_NET_INVALID_CONNHDL)
     &&( (Dcm_NetPeriodicMsgGetConnection() != pRepContext->ConnHdl)
#  if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
       ||( (Dcm_NetIsGenericConnection(Dcm_NetPeriodicMsgGetConnection()))
         &&(pTranspObj->ClientSrcAddr != Dcm_NetPeriodicMsgGetClientSrcAddr()) )
#  endif
       ) )
  {
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT; /* the 2A service is currently in use by another client */                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
  if (!Dcm_NetPeriodicMsgSupportedFor(Dcm_DiagGetTranspObj(pContext->Thread)->ConnHdl))
  {
    *ErrorCode = DCM_E_PANIC_NRC; /* current client does not support periodic messages */                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  {
    pRepContext->HasAnySupportedDids = FALSE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_UtiConsumeReqDataAsU8(pMsgContext, &(pRepContext->UdsRate));                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Maximum number of DIDs per single request service shall not be exceeded.
      * Check minimum length for rates excluding stopSending */
    if( (pMsgContext->reqDataLen > DCM_SVC_2A_MAX_DID_LIST_LEN)
      ||((pMsgContext->reqDataLen == 0u) && (pRepContext->UdsRate != DCM_SVC_2A_STOP_SENDING)) )
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
    else
    {
      if(!Dcm_Svc2AIsUdsRateSupported(pRepContext->UdsRate))
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdReturn = DCM_E_NOT_OK;
      }
      else
      {
        if (pRepContext->UdsRate == DCM_SVC_2A_STOP_SENDING)
        {
          lStdReturn = Dcm_Svc2AStopScheduledDids(pContext, pMsgContext);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
        else
        {
          lStdReturn = Dcm_Svc2ADoScheduleDids(pContext, pMsgContext, ErrorCode);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
      }
    }
  }

  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2CDefMgrInit(
  void
  )
{
  Dcm_CfgDidMgrDynDidHandleOptType dynDidIter;

  /* If DynDIDs were restored from non-volatile memory: */
# if (DCM_SVC_2C_NVRAM_SUPPORT_ENABLED == STD_ON)
  if((Dcm_Svc2CNvMData.MagicNumber == DCM_CFG_FINAL_MAGIC_NUMBER)
#  if (DCM_VARMGR_MULTI_SVC_EXCLUSIVE_ENABLED == STD_ON)
   &&(Dcm_Svc2CNvMData.CfgVariantId == Dcm_SingletonContext.VarMgr.ActiveCfgVariantId)
#  endif
    )
  {
    /* Check if preconditions are still fulfilled */
#  if (DCM_DIDMGR_DYNDID_CLR_ON_STATE_CHG_ENABLED == STD_ON) && \
      (DCM_DIAG_STATE_RECOVERY_ENABLED            == STD_OFF)
    /*
     * In case that state recovery feature is enabled, the DynDID preconditions shall be checked after
     * state recovery.
     * In case of jump from FBL (warm start) just clear all DynDIDs which are not supported
     * in default session (KISS principle).
     * After TX confirmation of the unsolicited response, Dcm_Svc2COnStateChanged() will be
     * called again by Dcm_StateSetSession().
     * Please note, that it was always not allowed to use state recovery and warm start at the same time.
     */
    Dcm_Svc2COnStateChanged();
#  endif
  }
  else
# endif
  {
    for(dynDidIter = 0; dynDidIter < DCM_NUM_DYNDIDS; ++dynDidIter)
    {
      Dcm_Svc2CDynDidItemPtrType pItem;

      pItem = Dcm_Svc2CGetItem(dynDidIter);
      pItem->Length = 0u;                                                                                                                            /* SBSW_DCM_POINTER_WRITE_2CITEM */
      pItem->Count  = 0u;                                                                                                                            /* SBSW_DCM_POINTER_WRITE_2CITEM */
    }

# if (DCM_SVC_2C_NVRAM_SUPPORT_ENABLED == STD_ON)
    Dcm_Svc2CNvMData.MagicNumber = DCM_CFG_FINAL_MAGIC_NUMBER;
#  if (DCM_VARMGR_MULTI_SVC_EXCLUSIVE_ENABLED == STD_ON)
    Dcm_Svc2CNvMData.CfgVariantId = Dcm_SingletonContext.VarMgr.ActiveCfgVariantId;
#  endif
# endif
  }

  Dcm_SingletonContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse = DCM_SVC2C_INVALID_DYNDID_HDL;
}

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01DefMgrRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01DefMgrRead(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_Svc2CDynDidProcessContextPtrType pProcessContext
  )
{
  Dcm_OpStatusType lOpStatus = opStatus;
  Std_ReturnType lStdResult = DCM_E_OK;

  Dcm_Svc2CDynDidSrcItemConstPtrType pDidInfo = Dcm_Svc2CGetSrcItem(pProcessContext->ItemInProgress);

  if(lOpStatus == DCM_INITIAL)
  {
    Dcm_Svc2CInitDidInfoFromDidInfoIdx(pDidInfo->DidDescriptor.DidInfoIdx, &(pProcessContext->SrcDidContext));                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(Dcm_RsrcMgrHasDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID2C) == FALSE)
  {
    /* Check for access rights (avoids race conditions) */
    lStdResult = Dcm_RsrcMgrGetDidLock(lOpStatus, pProcessContext->SrcDidContext.Did, DCM_RSRCMGR_DIDLOCK_OWNER_SID2C);

    if(lStdResult == DCM_E_OK)
    {
      lOpStatus = DCM_INITIAL;
      Dcm_SingletonContext.Diag.Services.Svc2C.ReadIndex = 0;
    }
  }

  if(lStdResult == DCM_E_OK)
  {
    Dcm_NegativeResponseCodeType lNrc;
    Dcm_DiagDataContextType lDataContext;

    Dcm_DidMgrInitOpClassInfo(&(pProcessContext->SrcDidContext)
                             ,DCM_DIDMGR_OPTYPE_READ);                                                                                               /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */

    /* Init data context for asynchronous DIDs only initialy (not in pending status) */
    Dcm_UtiInitDataContext(&lDataContext                                                                                                             /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */
                           ,Dcm_SingletonContext.Diag.Services.Svc2C.DynDidAccessContext.Buffer
                           ,DCM_SVC_2C_READ_BUFFER_SIZE);

    Dcm_UtiCommitData(&lDataContext, Dcm_SingletonContext.Diag.Services.Svc2C.ReadIndex);                                                            /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */

    lStdResult = Dcm_DidMgrReadDid(lOpStatus
                                  ,&lDataContext                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
                                  ,&(pProcessContext->SrcDidContext)                                                                                 /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
                                  ,&(pProcessContext->DidOpTypeContext)                                                                              /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
                                  ,&lNrc);                                                                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */

    Dcm_SingletonContext.Diag.Services.Svc2C.ReadIndex = lDataContext.Usage;

    /* Finished processing a DIDSrcItem */
    if(lStdResult != DCM_E_PENDING)
    {
      if(lStdResult == DCM_E_OK)
      {
        Dcm_UtiProvideDataAsUN(pDataContext, &lDataContext.Buffer[pDidInfo->DidDescriptor.Offset], pDidInfo->DidDescriptor.Size);                    /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      Dcm_RsrcMgrReleaseDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID2C);
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C02DefMgrRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C02DefMgrRead(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext
  )
{
  Std_ReturnType lStdResult;
  Dcm_OpStatusType lOpStatus = opStatus;

  lStdResult = DCM_E_OK;

  if(Dcm_RsrcMgrHasMemLock(DCM_RSRCMGR_MEM_ACCESS_REQ_INT) == TRUE)
  {
    /* Proceed with reading */
  }
  else
  {
    /* Still in process getting access! */
    lStdResult = Dcm_RsrcMgrGetMemLock(lOpStatus, DCM_RSRCMGR_MEM_ACCESS_REQ_INT);

    if (lStdResult == DCM_E_OK)
    {
      lOpStatus = DCM_INITIAL; /* prepare for first reading */
    }
  }

  if(lStdResult == DCM_E_OK)
  {
    Dcm_NegativeResponseCodeType lNrc;
    Dcm_CfgDidMgrDynDidSrcItemIdxMemType lItemInProgress;

    lItemInProgress = Dcm_Svc2CGetDDDidProcessContext(DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED)->ItemInProgress;
    lStdResult = Dcm_MemMgrReadMemory(lOpStatus
                                    ,&(Dcm_Svc2CGetSrcItem(lItemInProgress)->MemDescriptor.MemBlock)
                                    ,pDataContext
                                    ,&lNrc);                                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
  }

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadSrcItems()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadSrcItems(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_Svc2CDynDidProcessContextPtrType pProcessContext
  )
{
  Std_ReturnType lStdReturn = DCM_E_OK;
  Dcm_OpStatusType lOpStatus = opStatus;

  for(; pProcessContext->ItemInProgress < pProcessContext->ItemToStop; pProcessContext->ItemInProgress++)                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  {
    if(Dcm_Svc2CIsDidSrcItem(pProcessContext->ItemInProgress))
    {
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
      lStdReturn = Dcm_Svc2C01DefMgrRead(lOpStatus, pDataContext, pProcessContext);                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
# endif
    }
    else
    {
# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
      lStdReturn = Dcm_Svc2C02DefMgrRead(lOpStatus, pDataContext);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
# endif
    }

    if(lStdReturn == DCM_E_OK)
    {
      /* prepare for next item */
      lOpStatus = DCM_INITIAL;
    }
    else
    {
      break;
    }
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadCheckAccessAndInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadCheckAccessAndInit(
  Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle,
  P2VAR(Dcm_OpStatusType, AUTOMATIC, AUTOMATIC) pOpStatus                                                                                            /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(dynDidHandle);                                                                                                              /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /*-----------------------------------------------*
   * DynDID usage check and initialization
   *-----------------------------------------------*/
  if(Dcm_SingletonContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse == DCM_SVC2C_INVALID_DYNDID_HDL)
  {
    if(*pOpStatus == DCM_CANCEL)
    {
      lStdResult = DCM_E_NOT_OK; /* we have waited for too long to get access to the DynDID reader, but it was canceled -> Stop here since no reading has been started yet */
    }
    else
    {
      /*
       * Reset opStatus in case some DCM_E_PENDING had to be returned due to concurrent access (i.e. 0x22 and 0x2A for
       * different DDDIDs)
       */
      *pOpStatus = DCM_INITIAL;                                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
# if (DCM_SVC_2C_RACE_CONDITION_READ_ENABLED == STD_ON)
  else
  {
    if(dynDidHandle != Dcm_SingletonContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse)
    {
      lStdResult = DCM_E_PENDING;
    } /* else - same handle -> process it */
  }
# endif
  return lStdResult;
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc2CSubFuncInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc2CSubFuncInfoGetEntry(
  Dcm_DiagSubServiceRefOptType SubSvcRef,
  CONSTP2VAR(Dcm_CfgSvc2CSubFuncInfoPtrType, AUTOMATIC, AUTOMATIC) pSubFuncInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if (Dcm_DebugDetectRuntimeError(SubSvcRef >= DCM_CFGSVC2CSUBFUNCINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pSubFuncInfo = &Dcm_CfgSvc2CSubFuncInfo[SubSvcRef];                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;
  Dcm_DiagSubServiceRefOptType lSubSvcRef;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc2CSubFuncLookUpTable
                                                   ,Dcm_CfgSvc2CSubFuncExecPrecondTable
                                                   ,Dcm_Svc2CReqLengthGetter
                                                   ,Dcm_DiagNoSequenceChecker
                                                   ,&lSubSvcRef
                                                   ,ErrorCode);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
    pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)lSubSvcRef;                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */

    /* Perform SID specific checks */
    if (Dcm_CfgSvc2CSubFuncInfo[(pRepContext->SubSvcRef)].MinReqLength <= pMsgContext->reqDataLen) /* min length = (DDID, (MEMdef|DIDdef))? */
    {
      Dcm_RepeaterNextStep(pContext, DCM_SVC2C_PROGRESS_SUBFUNCTION); /* delegate job */                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_LOOP; /* speed up processing */
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  } /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CSubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CSubFuncHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType                 lStdResult;
  Dcm_CfgSvc2CSubFuncInfoPtrType pSubFuncInfo;

  lStdResult = Dcm_CfgSvc2CSubFuncInfoGetEntry(pRepContext->SubSvcRef, &pSubFuncInfo, ErrorCode);                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lStdResult == DCM_E_OK)                                                                                                                        /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(pContext, opStatus, pMsgContext, ErrorCode);                                                               /* SBSW_DCM_CALL_FUNCPTR_SVC2CSUBFUNC */
  }

  return lStdResult;
}

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01SrcDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01SrcDidLookUp(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn;

  if(opStatus == DCM_INITIAL)
  {
     /* Extract source DID */
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &(pRepContext->SrcItemDidInfoContext.Did));                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&(pRepContext->SrcItemDidInfoContext)
                                   ,&(pRepContext->DynDidOpTypeContext) /* Use OpTypeContext of DynDID since no more needed at this time! */
                                   ,DCM_DIDMGR_OP_READ);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */

  switch(lStdReturn)
  {
  case DCM_E_OK:
    if(Dcm_DidMgrIsOpSupported(Dcm_CfgDidMgrGetDidInfo(&(pRepContext->SrcItemDidInfoContext)), DCM_DIDMGR_OP_DEFINE))                                /* SBSW_DCM_PARAM_PTR_WRITE */
    {
      /* else - no DynDID may be referenced! */
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
    else
    {
      lStdReturn = Dcm_StateCheckDID(Dcm_NetGetConnHdlOfRxPduId(pMsgContext->rxPduId)                                                                /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
                                    ,pRepContext->SrcItemDidInfoContext.Did
                                    ,DCM_DIDMGR_OP_READ
                                    ,Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->SrcItemDidInfoContext))->ExecCondRef
                                    ,ErrorCode);                                                                                                     /* SBSW_DCM_COMB_PTR_FORWARD */
      if(lStdReturn == DCM_E_OK)
      {
        Dcm_RepeaterNextStep(pContext, DCM_SVC2C_PROGRESS_01SRC_DIDCHECKCONDITIONS); /* next job */                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
        lStdReturn = DCM_E_LOOP;
      } /* else DCM_E_NOT_OK (ErrorCode already set) */
    }
    break;
  case DCM_E_PENDING:
    /* lStdReturn is already set */
    break;
  default: /* DCM_E_NOT_OK */
    /* source DID is not supported */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
    break;
  }

  return lStdReturn;
}
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01SrcDidCheckCondition()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01SrcDidCheckCondition(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->SrcItemDidInfoContext)), DCM_DIDMGR_OPTYPE_READCHKCOND))                   /* SBSW_DCM_PARAM_PTR_WRITE */
  {
    DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                             /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

    /* check condition on this DID */
    Dcm_DidMgrInitOpClassInfo(&(pRepContext->SrcItemDidInfoContext), DCM_DIDMGR_OPTYPE_READCHKCOND);                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = Dcm_DidMgrReadCheckCond(opStatus
                                        ,&(pRepContext->SrcItemDidInfoContext)
                                        ,&(pRepContext->DynDidOpTypeContext) /* Use OpTypeContext of DynDID since no more needed at this time! */
                                        ,ErrorCode);                                                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */

  } /* else - not supported operation - go on with getLength */

  if(lStdResult == DCM_E_OK)
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC2C_PROGRESS_01SRC_DIDGETLENGTH); /* next job */                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP; /* speed up processing */
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01SrcDidGetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01SrcDidGetLength(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  )
{
  Dcm_Svc2CDynDidSrcItemPtrType pSrcItem;
  Std_ReturnType lStdReturn = DCM_E_OK;

  pSrcItem = Dcm_Svc2CGetSrcItem(pRepContext->SrcItemIndex);

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->SrcItemDidInfoContext)), DCM_DIDMGR_OPTYPE_READLENGTH))                    /* SBSW_DCM_PARAM_PTR_WRITE */
  {
    Dcm_DidMgrInitOpClassInfo(&(pRepContext->SrcItemDidInfoContext), DCM_DIDMGR_OPTYPE_READLENGTH);                                                  /* SBSW_DCM_PARAM_PTR_WRITE */

    /* Calculate DID data length if applicable */
    lStdReturn = Dcm_DidMgrReadLength(opStatus
                                     ,&(pRepContext->SrcItemDidInfoContext)
                                     ,&(pRepContext->DynDidOpTypeContext) /* Use OpTypeContext of DynDID since no more needed at this time! */
                                     ,ErrorCode);                                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
  }

  if(lStdReturn == DCM_E_OK)
  {
    uint8 srcDidPos;
    uint8 srcDidSize;

    Dcm_UtiConsumeReqDataAsU8(pMsgContext, &srcDidPos);                                                                                              /* SBSW_DCM_COMB_PTR_FORWARD */
    Dcm_UtiConsumeReqDataAsU8(pMsgContext, &srcDidSize);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */

    if ((srcDidPos == 0u)
      ||(srcDidSize == 0u)
      ||(((Dcm_DidMgrDidLengthType)srcDidPos + (Dcm_DidMgrDidLengthType)srcDidSize - 1u) > pRepContext->SrcItemDidInfoContext.DidLength) )
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE; /* source DID referenced data out of boundary or memory size of 0 */                                     /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK; /* finish service processing immediately */
    } /* check for possible read buffer or response overflow */
    else if ((!Dcm_UtiIsAdditionSafe(Dcm_DidMgrDidLengthType, pRepContext->DynDidLength, srcDidSize))                                                /* PRQA S 2995 */ /* MD_Dcm_ConstExpr */
      || (Dcm_UtiPromotedSum(Dcm_DidMgrDidLengthType, pRepContext->DynDidLength, srcDidSize) > pRepContext->MaxAllowedLength))
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE; /* too much data referenced */                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK; /* finish service processing immediately */
    }
    else /* Add this DID to the definition */
    {
      /* update total length of the DynDID for commitment */
      pRepContext->DynDidLength += srcDidSize;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

      /* store referenced data */
      pSrcItem->DidDescriptor.DidInfoIdx = pRepContext->SrcItemDidInfoContext.Descriptor.DidInfoIdx;                                                 /* SBSW_DCM_POINTER_WRITE_2CSRCITEM */
      pSrcItem->DidDescriptor.Offset = (uint8)(srcDidPos - 1u);                                                                                      /* SBSW_DCM_POINTER_WRITE_2CSRCITEM */
      pSrcItem->DidDescriptor.Size = srcDidSize;                                                                                                     /* SBSW_DCM_POINTER_WRITE_2CSRCITEM */
      Dcm_Svc2CSetDidSrcItem(pRepContext->SrcItemIndex); /* set the type of the source item to DID */                                                /* SBSW_DCM_POINTER_WRITE_BITSET */

      ++(pRepContext->SrcItemIndex); /* next item to be configured */                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
      ++(pRepContext->DynDidItemCount); /* update number of items for commitment */                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */

      --(pRepContext->ReqNumOfItems); /* commit processed item */                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
      if (pRepContext->ReqNumOfItems > 0u) /* any item left? */
      {
        Dcm_RepeaterNextStep(pContext, DCM_SVC2C_PROGRESS_01SRC_DIDLOOKUP); /* next job */                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
        lStdReturn = DCM_E_LOOP; /* speed up processing */
      }
      else
      {
        lStdReturn = DCM_E_OK; /* all source items finished service processing immediately */
      }
    }
  }
  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C02SrcItemsGetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C02SrcItemsGetLength(
  uint8 alfid,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn = DCM_E_NOT_OK;
  Dcm_MemMgrMemBlockType lMemBlock;

  while(pRepContext->ReqNumOfItems > 0u)
  {
    Dcm_MemMgrParseMemStream(alfid, pMsgContext, &lMemBlock);                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */
    lStdReturn = Dcm_MemMgrCheckMemBlock(&lMemBlock, DCM_MEMMGR_OP_READ, ErrorCode);                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */

    if (lStdReturn == DCM_E_NOT_OK)
    {
      /* stop immediately and report the error */
      pRepContext->ReqNumOfItems = 0u; /* break */                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    } /* else - check for definition length overflow */
    else if( (!Dcm_UtiIsAdditionSafe(uint32, pRepContext->DynDidLength, lMemBlock.Length))                                                           /* PRQA S 2995 */ /* MD_Dcm_ConstExpr */
           ||(Dcm_UtiPromotedSum(uint32, pRepContext->DynDidLength, lMemBlock.Length) > pRepContext->MaxAllowedLength) )
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE; /* too much data referenced */                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
      /* finish service processing immediately */
      pRepContext->ReqNumOfItems = 0u; /* break */                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      /* else - add this address to the DynDID definition */
      Dcm_Svc2CDynDidSrcItemPtrType pSrcItem = Dcm_Svc2CGetSrcItem(pRepContext->SrcItemIndex);

      /* update total length of the DynDID for commitment */
      pRepContext->DynDidLength += (Dcm_DidMgrDidLengthType)(lMemBlock.Length);                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */


      pSrcItem->MemDescriptor.MemBlock = lMemBlock;                                                                                                  /* SBSW_DCM_POINTER_WRITE_2CSRCITEM */

      Dcm_Svc2CSetMemSrcItem(pRepContext->SrcItemIndex); /* set the type of the source item to MEMORY */                                             /* SBSW_DCM_POINTER_WRITE_BITSET */
      ++(pRepContext->DynDidItemCount); /* update number of items for commitment */                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      ++(pRepContext->SrcItemIndex);    /* next item to be configured */                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
      --(pRepContext->ReqNumOfItems);   /* commit processed item */                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  return lStdReturn;
}
# endif

# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_Svc2C03DidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C03DidLookUp(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn;

  if(opStatus == DCM_INITIAL)
  {
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &(pRepContext->DynDidInfoContext.Did));                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_UtiProvideResDataAsU16(pMsgContext, pRepContext->DynDidInfoContext.Did); /* positive response contains the DynDID (2Byte) */                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&pRepContext->DynDidInfoContext
                                   ,&pRepContext->DynDidOpTypeContext
                                   ,DCM_DIDMGR_OP_DEFINE);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

  switch(lStdReturn)
  {
  case DCM_E_OK:
    /* clear concrete DynDID */
    Dcm_Svc2CDefMgrClear((Dcm_CfgDidMgrDynDidHandleMemType)(Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DynDidInfoContext))->OpRef));
    break;
  case DCM_E_PENDING:
    /* lStdReturn is already set */
    break;
  default: /* DCM_E_NOT_OK */
    /* source DID is not supported */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  }

  return lStdReturn;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CSetMaxAllowedDynDIDLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2CSetMaxAllowedDynDIDLength(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  )
{
  /* initialize common DynDID request context */
# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
  if (Dcm_Svc2AIsPeriodicDid(pRepContext->DynDidInfoContext.Did))
  {
    Dcm_NetConnRefMemType lConnHdl = Dcm_Svc2AGetConnectionOfDID(pRepContext->DynDidInfoContext.Did);
    if (lConnHdl < DCM_NET_INVALID_CONNHDL)
    {
      pRepContext->MaxAllowedLength = (Dcm_DidMgrDidLengthType)Dcm_PbCfgNetConnectionInfo[lConnHdl].UudtFrameSize;                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      pRepContext->MaxAllowedLength = DCM_SVC2A_MAX_RESPONSE_LEN;                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
  else
# endif
  {
    /*
     * Perform length check based on the current protocol only. Sid 0x22 will do additional checks at read time in
     * case a client from another protocol is trying to access the DynDID!
     */
    Dcm_CfgNetBufferSizeMemType lBufferSize = Dcm_Svc2CGetNetBufferSize(pContext->Thread);
    if (lBufferSize > Dcm_UtiMaxValueOfUintType(Dcm_DidMgrDidLengthType))
    {
      pRepContext->MaxAllowedLength = Dcm_UtiMaxValueOfUintType(Dcm_DidMgrDidLengthType) - 3u;         /* for response: 0x62 DID_H DID_L <DATA> */   /* SBSW_DCM_PARAM_PTR_WRITE */ /* PRQA S 2880 */ /* MD_MSR_Unreachable */
    }
    else
    {
      pRepContext->MaxAllowedLength = (Dcm_DidMgrDidLengthType)lBufferSize - 3u;                       /* for response: 0x62 DID_H DID_L <DATA> */   /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
}

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CInitDidInfoFromDidInfoIdx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2CInitDidInfoFromDidInfoIdx(
  Dcm_CfgDidMgrDidInfoRefType didInfoIdx,
  Dcm_DidMgrDidInfoContextPtrType pSrcDidContext
  )
{
  pSrcDidContext->Did = Dcm_CfgDidMgrDidLookUpTable[didInfoIdx + 1u];                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
  (void)Dcm_DidMgrConcreteDidLookUp(pSrcDidContext, DCM_DIDMGR_OP_READ);                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2EHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2EHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ERepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;
  Dcm_CfgStateRefOptType lStateRef;

  if (opStatus == DCM_INITIAL)
  {
    /* Min Length already checked in DiagDispatcher and expected to be 3 !!! */
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &(pRepContext->DidInfoContext.Did));                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  lStdResult = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&(pRepContext->DidInfoContext)
                                   ,&(pRepContext->DidOpTypeContext)
                                   ,DCM_DIDMGR_OP_WRITE);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */

  if (lStdResult == DCM_E_OK)
  {
    Dcm_UtiProvideResData(pMsgContext, 2u);/* return the DID (shared Rx-Tx buffer) */                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Check DID specific length */
    if ( (pMsgContext->reqDataLen >= Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext))->MinLength)
       && (pMsgContext->reqDataLen <= Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext))->MaxLength) )
    {
      lStateRef = Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DidInfoContext))->ExecCondRef;

      lStdResult = Dcm_DidMgrStaticDidStateCheck(Dcm_NetGetConnHdlOfRxPduId(pMsgContext->rxPduId)                                                    /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_COMB_PTR_FORWARD */
                                                ,pRepContext->DidInfoContext.Did
                                                ,DCM_DIDMGR_OP_WRITE
                                                ,lStateRef
                                                ,ErrorCode);
      if (lStdResult == DCM_E_OK)
      {
        Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_WRITE);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

        Dcm_RepeaterNextStep(pContext, DCM_SVC2E_PROGRESS_CHECKACCESS); /* delegate job */                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

        lStdResult = DCM_E_LOOP;/* speed up processing */
      } /* else DCM_E_NOT_OK - ErrorCode already assigned */
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }
  else if (lStdResult == DCM_E_PENDING)
  {
    /* DCM_E_PENDING -> try again */
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ECheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ECheckAccess(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc2ERepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_RsrcMgrGetDidLock(opStatus, pRepContext->DidInfoContext.Did, DCM_RSRCMGR_DIDLOCK_OWNER_SID2E);

  if(lStdResult == DCM_E_OK)
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC2E_PROGRESS_WRITEDATA); /* delegate job */                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2EWriteData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2EWriteData(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ERepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_DidMgrWrite(opStatus
                              ,pMsgContext
                              ,&(pRepContext->DidInfoContext)
                              ,&(pRepContext->DidOpTypeContext)
                              ,ErrorCode);                                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdResult != DCM_E_PENDING)
  {
    Dcm_RsrcMgrReleaseDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID2E);
  }

  return lStdResult;
}
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FReturnControlToEcu()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FReturnControlToEcu(
  void
  )
{
  if(Dcm_SingletonContext.Diag.Services.Svc2F.HasAnyActiveIoDid == TRUE)
  {
    Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRefPage = 0;
    Dcm_CfgDidMgrIoDidHandleOptType ioDidIter;

    Dcm_SingletonContext.Diag.Services.Svc2F.HasAnyActiveIoDid = FALSE;

    for(ioDidIter = 0; ioDidIter < Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS); ioDidIter++)
    {
      Dcm_UtiBitSetBasePtrType pActiveIoDids = Dcm_Svc2FGetActiveIoDids(ioDidIter);
      Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef = opInfoRefPage;
      DCM_UTI_LOOP_BIT_SCAN(*pActiveIoDids)                                                                                                          /* SBSW_DCM_POINTER_WRITE_2FACTIVEIODIDS */
      {
        if(Dcm_UtiBitOpTest(Dcm_UtiBitSetBaseType, *pActiveIoDids, 0x01u))
        {
          Dcm_DidMgrIoControlRtrnCtrl2Ecu(Dcm_DidMgrGetCtrlOpInfoRef(opInfoRef));
        }
        ++opInfoRef;
      }
      opInfoRefPage += (Dcm_CfgDidMgrDidOpClassHandleOptType)Dcm_UtiGetNumBitsOfXintType(Dcm_UtiBitSetBaseType);/* next bunch of IoDids */           /* PRQA S 2983 */ /* MD_Dcm_Redundant_2983 */
    }
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2FExtractCEMR()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(uint32, DCM_CODE) Dcm_Svc2FExtractCEMR(
  Dcm_ReadOnlyMsgType cemrStream,
  Dcm_CfgDidMgrIoDidCemrLengthMemType cemrSize
  )
{
  uint32 lResult = 0;

  if(cemrSize <= 4u)
  {
    Dcm_CfgDidMgrIoDidCemrLengthOptType lCemrIter;

    /* Extract the CEMR byte-wise */
    for(lCemrIter = 0; lCemrIter < cemrSize; ++lCemrIter)
    {
      lResult <<= 8u;
      lResult |= cemrStream[lCemrIter];
    }

    /* For a 3 byte CEMR a 32bit value will be passed -> move to the MSB to fulfill the IO C/S API convention */
    if(cemrSize == 3u)
    {
      lResult <<= 8u;
    }
  }/* else - leave the result = 0 (invalid value) */

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2FProcessCEMR()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FProcessCEMR(
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  )
{
  Dcm_CfgDidMgrIoDidCemrLengthMemType lCemrSize;

  /* Consider requests with and without CEMR */
  lCemrSize = Dcm_DidMgrGetCtrlEnblMaskLength(Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext)));                                              /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lCemrSize != 0u)
  {
    /*
     * Subtract CEMR length from request length to get only the requested DID size in order to get the concrete length
     * of the last DID signal (if variable length)
     */
    Dcm_UtiUpdateReqLength(pMsgContext, lCemrSize);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    pRepContext->DidOpTypeContext.OpType.Io.EnableMaskPtr = Dcm_UtiGetReqDataRel(pMsgContext, pMsgContext->reqDataLen);                              /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Extract CEMR as a value */
    pRepContext->DidOpTypeContext.OpType.Io.ControlEnableMaskRecord = Dcm_Svc2FExtractCEMR(pRepContext->DidOpTypeContext.OpType.Io.EnableMaskPtr     /* SBSW_DCM_PARAM_PTR_WRITE */ /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                                          ,lCemrSize);
  }
  else
  {
    /* else - the request does not contain any CEMR */
    pRepContext->DidOpTypeContext.OpType.Io.EnableMaskPtr = NULL_PTR;                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc2FCalculateExpectedReqLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FCalculateExpectedReqLength(
  Dcm_DidMgrDidLengthPtrType expLengthMin,
  Dcm_DidMgrDidLengthPtrType expLengthMax,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_CfgDidMgrIoDidCemrLengthMemType lCemrSize;

  if(Dcm_UtiBitOpTest(Dcm_DidMgrOpMemType, pRepContext->OpType, DCM_DIDMGR_OPTYPE_IO_SHRTTRMADJ))
  {
    /* Initialize DID handler */
    Dcm_DidMgrInitOpTypeHandler(&(pRepContext->DidInfoContext), &(pRepContext->DidOpTypeContext));                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* short term adjustment - consider optional enable mask record and the DID data! */
    *expLengthMax = (Dcm_DidMgrDidLengthType)Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext))->MaxLength;                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    *expLengthMin = (Dcm_DidMgrDidLengthType)Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext))->MinLength;                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    if(*expLengthMin == 0u) /* IO DID with dynamic length AND single signal */
    {
      *expLengthMin = 1;                                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
  else
  {
    *expLengthMin = 0u;                                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    *expLengthMax = 0u;                                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  lCemrSize = Dcm_DidMgrGetCtrlEnblMaskLength(Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext)));                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
  *expLengthMin += lCemrSize;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */ /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */
  *expLengthMax += lCemrSize;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */ /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */
}

/**********************************************************************************************************************
 *  Dcm_Svc2FCheckReqLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_Svc2FCheckReqLength(
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  )
{
  Dcm_NegativeResponseCodeType lNrc = DCM_E_POSITIVERESPONSE;
  Dcm_DidMgrDidLengthType expMinReqLen;
  Dcm_DidMgrDidLengthType expMaxReqLen;

  Dcm_Svc2FCalculateExpectedReqLength(&expMinReqLen, &expMaxReqLen, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  /* Check DID specific length */
  if( (pMsgContext->reqDataLen < expMinReqLen)
    ||(pMsgContext->reqDataLen > expMaxReqLen) )
  {
    lNrc = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
  }

  return lNrc;
}

/**********************************************************************************************************************
 *  Dcm_Svc2FIoDidOperationProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FIoDidOperationProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType  lStdResult = DCM_E_NOT_OK;
  Dcm_CfgStateRefOptType lStateRef;

  /* Initialize the IO-Control operation class from now for any checks that may come
   * (i.e. within Dcm_Svc2FCheckReqLength or later for the IO Control execution)  */
  Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext)
                           ,pRepContext->OpType);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Validate request length */
  *ErrorCode = Dcm_Svc2FCheckReqLength(pMsgContext, pRepContext);                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_PARAM_PTR_WRITE */

  if(*ErrorCode == DCM_E_POSITIVERESPONSE)
  {
    lStateRef = Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DidInfoContext))->ExecCondRef;

    /* Validate remaining state preconditions */
    lStdResult = Dcm_DidMgrStaticDidStateCheck(Dcm_NetGetConnHdlOfRxPduId(pMsgContext->rxPduId)                                                      /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_PARAM_PTR_FORWARD */
                                              ,pRepContext->DidInfoContext.Did
                                              ,DCM_DIDMGR_OP_IO
                                              ,lStateRef
                                              ,ErrorCode);
    if(lStdResult == DCM_E_OK)
    {
      /* Process any eventually supported CEMR */
      Dcm_Svc2FProcessCEMR(pMsgContext, pRepContext);                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_RepeaterNextStep(pContext, DCM_SVC2F_PROGRESS_CHECKACCESS); /* delegate job */                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

      lStdResult = DCM_E_LOOP;/* speed up processing */
    }/* else DCM_E_NOT_OK (ErrorCode already set) */
  }/* else DCM_E_NOT_OK (ErrorCode already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2FCheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FCheckAccess(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,                                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_RsrcMgrGetDidLock(opStatus, pRepContext->DidInfoContext.Did, DCM_RSRCMGR_DIDLOCK_OWNER_SID2F);

  if(lStdResult == DCM_E_OK)
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC2F_PROGRESS_EXECUTEOP); /* delegate job */                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2FGetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FGetLength(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DidInfoContext)), DCM_DIDMGR_OPTYPE_READLENGTH))
  {
    Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_READLENGTH);                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdReturn = Dcm_DidMgrReadLength(opStatus
                                     ,&(pRepContext->DidInfoContext)
                                     ,&(pRepContext->DidOpTypeContext)
                                     ,ErrorCode);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(lStdReturn == DCM_E_OK)
  {
    /* Delegate the job to the data reader */
    Dcm_RepeaterNextStep(pContext, DCM_SVC2F_PROGRESS_READDATA);                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdReturn = DCM_E_LOOP;
  } /* else DCM_E_PENDING or DCM_E_NOT_OK (ErrorCode already set) */

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2FReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FReadData(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType          lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* Initialize data context for asynchronous IO DIDs only initially (not in pending status) */
    Dcm_UtiInitDataContext(&Dcm_SingletonContext.Diag.Services.Svc2F.DataContext, Dcm_UtiGetResData(pMsgContext), pMsgContext->resMaxDataLen);       /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* Read DID  */
  Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_READ);                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  lStdResult = Dcm_DidMgrReadDid(opStatus
                                ,&Dcm_SingletonContext.Diag.Services.Svc2F.DataContext
                                ,&(pRepContext->DidInfoContext)
                                ,&(pRepContext->DidOpTypeContext)
                                ,ErrorCode);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
    /* Commit data and go on with response */
    Dcm_UtiProvideResData(pMsgContext, pRepContext->DidInfoContext.DidLength);                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2FExecuteOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FExecuteOp(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_DidMgrIoControl(opStatus
                                  ,pMsgContext
                                  ,&(pRepContext->DidInfoContext)
                                  ,&(pRepContext->DidOpTypeContext)
                                  ,ErrorCode);                                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
    if(pRepContext->OpType != DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU)
    {
      /*
       * After sucessful execution of a control operation other than "ReturnControlToEcu", register the entire IODID for
       * automatic reset on a session/security transition (only if "ReturnControlToEcu" is supported by that IODID)
       */
      if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DidInfoContext)),
                                     DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU))                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      {
        Dcm_CfgDidMgrCombinedOpRefType lOpRef;

        lOpRef = Dcm_DidMgrOpInfoRedirector(Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext))->OpRef, OpRefIoControl);

        /* Must have a valid index! */
        Dcm_DebugAssert(lOpRef < DCM_NUM_IODIDS, DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG);                                                            /* COV_DCM_RTM_DEV_DEBUG XF */ /* SBSW_DCM_PARAM_PTR_FORWARD */

        Dcm_Svc2FSetDidActive(lOpRef);                                                                                                               /* SBSW_DCM_POINTER_WRITE_BITSET */

        Dcm_SingletonContext.Diag.Services.Svc2F.HasAnyActiveIoDid = TRUE;
      }
    }
# endif
    /* Decide whether any response data has to be sent back to the client */
    if(Dcm_DidMgrIsOpSupported(Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext)), DCM_DIDMGR_OP_READ))
    {
      Dcm_DidMgrInitOpInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OP_READ);                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */

      Dcm_RepeaterNextStep(pContext, DCM_SVC2F_PROGRESS_GETLENGTH);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_LOOP;
    } /* Otherwise, IO DID does not support reading operation - continue with an empty positive response */
  } /* DCM_E_PENDING | DCM_E_NOT_OK */

  return lStdResult;
}
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc31Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc31Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc31RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;
  uint8          lRoutineOp;
  uint16         lRid;

  /* Search for the RID in the database */
  lStdResult = Dcm_RidMgrRidLookUp(opStatus
                                  ,Dcm_UtiGetReqDataAsU16Rel(pMsgContext, 1u)                                                                        /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */
                                  ,&(pRepContext->RidInfoIdx));                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  /* If RID found: */
  if(lStdResult == DCM_E_OK)
  {
    Dcm_UtiConsumeReqDataAsU8(pMsgContext, &lRoutineOp); /* Extract SF */                                                                            /* SBSW_DCM_COMB_PTR_FORWARD */
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &lRid);      /* Extract RID for use in RID WL Check */                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    Dcm_UtiProvideResData(pMsgContext, 3u); /* Commit SF and RID in response */                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdResult = Dcm_StateCheckRID(pContext, lRid, lRoutineOp, Dcm_CfgRidMgrRidInfoExecCondRef(pRepContext->RidInfoIdx), ErrorCode);                 /* SBSW_DCM_COMB_PTR_FORWARD */

    /* If the preconditions for the requested RID are fulfilled: */
    if(lStdResult == DCM_E_OK)
    {
      lStdResult = Dcm_RidMgrGetOpInfo(pRepContext->RidInfoIdx
                                      ,Dcm_RidMgrConvOpOfSubFunc(lRoutineOp)
                                      ,&(pRepContext->RidOpInfoIdx));                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

      /* If the requested sub-function is supported: */
      if(lStdResult == DCM_E_OK)
      {
        /* If the length of the request is valid: */
        if( (pMsgContext->reqDataLen >= Dcm_CfgRidMgrOpInfoReqMinLength(pRepContext->RidOpInfoIdx))
          &&(pMsgContext->reqDataLen <= Dcm_CfgRidMgrOpInfoReqMaxLength(pRepContext->RidOpInfoIdx)) )
        {
          if (Dcm_CfgRidMgrOpInfoParamIntegrity(pRepContext->RidOpInfoIdx) == DCM_RIDMGR_INTEGRITY_IN)
          {
            /* Copy the the request data to the integrity buffer */
            Dcm_UtiMemCopySafe(Dcm_UtiGetReqData(pMsgContext)
                              ,Dcm_SingletonContext.Diag.Services.Svc31.IntegrityBuffer
                              ,0u
                              ,DCM_SVC_31_INTEGRITY_BUFFER_SIZE
                              ,pMsgContext->reqDataLen);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
          }

          Dcm_RepeaterNextStep(pContext, DCM_SVC31_PROGRESS_EXECUTEOP);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
          lStdResult = DCM_E_LOOP;
        }
        else
        {
          *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
      else
      {
        *ErrorCode = DCM_E_SUBFUNCTIONNOTSUPPORTED;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }/* else DCM_E_NOT_OK - ErrorCode already assigned */
  }
  /* Otherwise, if RID look-up needs more time: */
  else if (lStdResult == DCM_E_PENDING)
  {
    /* lStdResult is already set */
  }
  /* Otherwise i.e. RID not found, return NRC 0x31 */
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_RidMgrManipulateBuffer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc31RedirectMsgContext(
  Dcm_ReadOnlyMsgContextPtrType pMsgContext,
  Dcm_MsgContextPtrType pMsgContextCopied,
  Dcm_Svc31RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  /* Copy all values as default */
  *pMsgContextCopied = *pMsgContext;                                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */

  switch (Dcm_CfgRidMgrOpInfoParamIntegrity(pRepContext->RidOpInfoIdx))
  {
    case DCM_RIDMGR_INTEGRITY_IN:
      {
        /* Modify the request values */
        pMsgContextCopied->reqData    = Dcm_SingletonContext.Diag.Services.Svc31.IntegrityBuffer;                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
        pMsgContextCopied->reqIndex   = 0;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
        pMsgContextCopied->reqBufSize = DCM_SVC_31_INTEGRITY_BUFFER_SIZE;                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      break;
    case DCM_RIDMGR_INTEGRITY_OUT:
      {
        /* Modify the response values */
        pMsgContextCopied->resData       = Dcm_SingletonContext.Diag.Services.Svc31.IntegrityBuffer;                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
        pMsgContextCopied->resIndex      = 0;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        pMsgContextCopied->resDataLen    = 0;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        pMsgContextCopied->resBufSize    = DCM_SVC_31_INTEGRITY_BUFFER_SIZE;                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
        pMsgContextCopied->resMaxDataLen = DCM_SVC_31_INTEGRITY_BUFFER_SIZE;                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      break;
    default: /* DCM_RIDMGR_INTEGRITY_NONE */
      /* Nothing to do */
      break;
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc31ExecuteRoutine()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc31ExecuteRoutine(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc31RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType                       lStdResult;
  Dcm_MsgContextType                   lMsgContext;
  Dcm_CfgRidMgrRoutineInfoByteMemType  lRoutineInfoByte;

  lRoutineInfoByte = Dcm_CfgRidMgrRidInfoRoutineInfoByte(pRepContext->RidInfoIdx);

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /*
   * If the RID supports routine info byte, reserve 1 byte in response buffer by moving response buffer pointer
   * Note: Do not write the routine info byte yet since this would overwrite the request data (IN-parameter)
   *       Provide the routine info byte as a placeholder before checking the remaining response buffer size
   */
  if( (opStatus == DCM_INITIAL)
    &&(lRoutineInfoByte != DCM_CFGRIDMGR_INVALID_ROUTINEINFOBYTE) )
  {
    Dcm_UtiProvideResData(pMsgContext, 1u);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  Dcm_Svc31RedirectMsgContext(pMsgContext, &lMsgContext, pRepContext);                                                                               /* SBSW_DCM_POINTER_SVC31_REDIRECT_MESSAGE_CONTEXT */

  lStdResult = Dcm_RidMgrExecuteRoutine(opStatus, &lMsgContext, ErrorCode, pRepContext);                                                             /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lStdResult == DCM_E_OK)
  {
    /* Place the routine info byte, if applicable */
    if (lRoutineInfoByte != DCM_CFGRIDMGR_INVALID_ROUTINEINFOBYTE)
    {
      Dcm_UtiSetResDataAsU8At(pMsgContext, DCM_RIDMGR_ROUTINEINFOBYTE_IDX, (uint8)lRoutineInfoByte);                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    }

    if (Dcm_CfgRidMgrOpInfoParamIntegrity(pRepContext->RidOpInfoIdx) == DCM_RIDMGR_INTEGRITY_OUT)
    {
      /* Copy the data from integrity buffer back to original response buffer */
      Dcm_UtiProvideResDataAsUN(pMsgContext, lMsgContext.resData, lMsgContext.resDataLen);                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      /* Just commit the written data */
      Dcm_UtiProvideResData(pMsgContext, (Dcm_MsgLenType)(lMsgContext.resDataLen - pMsgContext->resDataLen));                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }

  return lStdResult;
}
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_34_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc34Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc34Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc34RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;
  uint8          lAlfid;
  uint8          lBlockLength = 0;
  Dcm_FblMgrMemBlockType lMemoryBlock;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* dispatcher guarantees for minimum length of 4 bytes (DataFormatIdentifier, ALFID + MEM + SIZE) available */
  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &pRepContext->DataFormatId);                                                                                /* SBSW_DCM_COMB_PTR_FORWARD */

  lStdResult = Dcm_UtiValidateAndGetAlfid(pMsgContext, Dcm_CfgFblMgrTransferAlfidLookUpTable, &lAlfid, &lBlockLength, ErrorCode);                    /* SBSW_DCM_COMB_PTR_FORWARD */ /* SBSW_DCM_POINTER_FORWARD_STACK */
  if (lStdResult == DCM_E_OK)
  {
    if (lBlockLength != pMsgContext->reqDataLen)
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  if (lStdResult == DCM_E_OK)
  {
# if (DCM_FBLMGR_MID_SUPPORT_ENABLED == STD_ON)
    sint16_least          lMidIdx;
# endif

    Dcm_FblMgrParseMemStream(lAlfid, pMsgContext, &lMemoryBlock);                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

# if (DCM_FBLMGR_MID_SUPPORT_ENABLED == STD_ON)
    lMidIdx = Dcm_UtiLookUpUint8(Dcm_CfgFblMgrTransferMidLookUpTable, lMemoryBlock.Mid);                                                             /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
    if (lMidIdx < 0)
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    else
# endif
    {
      pRepContext->MemoryBlock = lMemoryBlock;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

      Dcm_RepeaterNextStep(pContext, DCM_SVC34_PROGRESS_EXECUTEOP);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_LOOP;/* speed up processing */
    }
  }/* else DCM_E_NOT_OK (ErrorCode already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc34ProcessRequestDownload()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc34ProcessRequestDownload(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc34RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;
  Dcm_FblMgrBlockLengthType lBlockLength;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  pRepContext->MaxBlockLength = (Dcm_FblMgrBlockLengthType)(pMsgContext->resMaxDataLen - 1u); /* SID and BSC are not part of the data */             /* SBSW_DCM_PARAM_PTR_WRITE */
  lBlockLength = pRepContext->MaxBlockLength;

  lStdResult = Dcm_Svc34ProcessRequestDownloadWrapper(opStatus
                                                     ,pRepContext->DataFormatId
                                                     ,pRepContext->MemoryBlock.Mid
                                                     ,pRepContext->MemoryBlock.Address
                                                     ,pRepContext->MemoryBlock.Length
                                                     ,&pRepContext->MaxBlockLength                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                     ,ErrorCode);                                                                                    /* SBSW_DCM_GEN_COMB_PARAM_PTR_FORWARD */

  switch (lStdResult)
  {
  case DCM_E_OK:
    if (opStatus == DCM_CANCEL)
    {
      lStdResult = DCM_E_NOT_OK;
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      {
        if (pRepContext->MaxBlockLength > lBlockLength)
        {
          lStdResult = DCM_E_NOT_OK;
          *ErrorCode = DCM_E_PANIC_NRC;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
          Dcm_DebugReportError(DCM_SID_PROCESSREQUESTDOWNLOAD, DCM_E_INTERFACE_BUFFER_OVERFLOW);
        }
        else
        {
          Dcm_SingletonContext.FblMgr.MaxBlockLength = pRepContext->MaxBlockLength;
          Dcm_SingletonContext.FblMgr.MemoryBlock = pRepContext->MemoryBlock;
          Dcm_SingletonContext.FblMgr.DownloadState = DCM_FBL_DOWNLOAD_STATE_TRANSFER_DATA;
          Dcm_SingletonContext.FblMgr.Start = TRUE;
          Dcm_SingletonContext.FblMgr.BlockSequenceCounterOld = 0u;

          Dcm_UtiProvideResDataAsU8(pMsgContext, DCM_FBL_DATA_IDENTIFIER);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
          Dcm_UtiProvideResDataAsU32(pMsgContext, (pRepContext->MaxBlockLength + 2u)); /* SID and BSC */                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
      }
    }
    break;
  case DCM_E_NOT_OK:
  case DCM_E_PENDING:
    break;
  default:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_PROCESSREQUESTDOWNLOAD, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_34_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_36_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc36Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc36Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc36RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = DCM_E_NOT_OK;
  /* dispatcher guarantees for minimum length of 2 bytes (blockSequenceCounter and 1byte trnasferRequestParameterRecord) available */

  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &pRepContext->BlockSequenceCounterNew);                                                                     /* SBSW_DCM_COMB_PTR_FORWARD */

  if (Dcm_SingletonContext.FblMgr.DownloadState == DCM_FBL_DOWNLOAD_STATE_TRANSFER_DATA)
  {
    if (pMsgContext->reqDataLen <= Dcm_SingletonContext.FblMgr.MaxBlockLength)
    {
      if (Dcm_SingletonContext.FblMgr.Start == TRUE)
      {
        if (pRepContext->BlockSequenceCounterNew == 1u)
        {
          lStdResult = DCM_E_OK;
        }
        else
        {
          *ErrorCode = DCM_E_WRONGBLOCKSEQUENCECOUNTER;                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
        }
      }
      else
      {
        if ((pRepContext->BlockSequenceCounterNew == Dcm_SingletonContext.FblMgr.BlockSequenceCounterOld) /* a frame positive response is not received correctly by client */
          || (pRepContext->BlockSequenceCounterNew == ((Dcm_FblMgrBlockSequenceCounterType)(Dcm_SingletonContext.FblMgr.BlockSequenceCounterOld + 1u)))) /* considers also wrap around case */
        {
          lStdResult = DCM_E_OK;
        }
        else
        {
          *ErrorCode = DCM_E_WRONGBLOCKSEQUENCECOUNTER;                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
        }
      }
    }
    else
    {
      *ErrorCode = DCM_E_TRANSFERDATASUSPENDED;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTSEQUENCEERROR;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  if (lStdResult == DCM_E_OK)
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC36_PROGRESS_EXECUTEOP);                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc36ProcessTransferDataWrite()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc36ProcessTransferDataWrite(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc36RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_ReturnWriteMemoryType opResult;
  Std_ReturnType  lStdResult = DCM_E_OK;
  boolean lUnknown = FALSE;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  *ErrorCode = DCM_E_GENERALPROGRAMMINGFAILURE;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */

  /* If a TransferData request to download data is correctly received and processed in the server but the positive
  * response message does not reach the client.
  */
  if (pRepContext->BlockSequenceCounterNew == Dcm_SingletonContext.FblMgr.BlockSequenceCounterOld)
  {
    Dcm_UtiProvideResDataAsU8(pMsgContext, Dcm_SingletonContext.FblMgr.BlockSequenceCounterOld);                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    opResult = Dcm_Svc36ProcessTransferDataWriteWrapper(opStatus
                                                       ,Dcm_SingletonContext.FblMgr.MemoryBlock.Mid
                                                       ,Dcm_SingletonContext.FblMgr.MemoryBlock.Address
                                                       ,pMsgContext->reqDataLen
                                                       ,Dcm_UtiGetReqData(pMsgContext)
                                                       ,ErrorCode);                                                                                  /* SBSW_DCM_GEN_COMB_PARAM_PTR_FORWARD */

    lStdResult = Dcm_UtiConvMemoryOpResult(opResult, opStatus, &lUnknown, ErrorCode);                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

    if (lUnknown == TRUE)
    {
      *ErrorCode = DCM_E_GENERALPROGRAMMINGFAILURE;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      Dcm_DebugReportError(DCM_SID_PROCESSTRANSFERDATAWRITE, DCM_E_INTERFACE_RETURN_VALUE);
    }

    if (lStdResult == DCM_E_OK)
    {
      Dcm_SingletonContext.FblMgr.Start = FALSE;

      Dcm_SingletonContext.FblMgr.BlockSequenceCounterOld = pRepContext->BlockSequenceCounterNew;
      Dcm_SingletonContext.FblMgr.MemoryBlock.Address += pMsgContext->reqDataLen;
      Dcm_UtiProvideResDataAsU8(pMsgContext, pRepContext->BlockSequenceCounterNew);                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }
  return lStdResult;
}
#endif /* (DCM_SVC_36_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_37_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc37Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc37Handler(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc37RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType  lStdResult = DCM_E_NOT_OK;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if (Dcm_SingletonContext.FblMgr.DownloadState == DCM_FBL_DOWNLOAD_STATE_IDLE)
  {
    *ErrorCode = DCM_E_REQUESTSEQUENCEERROR;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC37_PROGRESS_EXECUTEOP);                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc37ProcessRequestTransferExit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc37ProcessRequestTransferExit(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc37RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType  lStdResult;
  Dcm_MsgLenType  lAvailBufferSize;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lAvailBufferSize = pMsgContext->resMaxDataLen;

  lStdResult = Dcm_Svc37ProcessRequestTransferExitWrapper(opStatus,
                                                          Dcm_UtiGetReqData(pMsgContext),
                                                          pMsgContext->reqDataLen,
                                                          Dcm_UtiGetResData(pMsgContext),                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                          &lAvailBufferSize,
                                                          ErrorCode);                                                                                /* SBSW_DCM_CALL_PROCESSREQUESTTRANSFEREXIT */

  switch (lStdResult)
  {
  case DCM_E_OK:
    if (opStatus == DCM_CANCEL)
    {
      lStdResult = DCM_E_NOT_OK;
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      Dcm_UtiProvideResData(pMsgContext, lAvailBufferSize);                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_FblMgrReset();
    }
    break;
  case DCM_E_NOT_OK:
  case DCM_E_PENDING:
    break;
  default:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_PROCESSREQUESTTRANSFEREXIT, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_37_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc3DHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc3DRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;
  uint8          lAlfid;
  uint8          lBlockLength;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* dispatcher guarantees for minimum length of 4 bytes (ALFID + MEM + SIZE + DATA) available */
  lStdResult = Dcm_MemMgrValidateAndGetAlfid(pMsgContext, &lAlfid, &lBlockLength, ErrorCode);                                                        /* SBSW_DCM_COMB_PTR_FORWARD */ /* SBSW_DCM_POINTER_FORWARD_STACK */
  if (lStdResult == DCM_E_OK)
  {
    /* check for exact length match */
    Dcm_UtiProvideResData(pMsgContext, ((Dcm_MsgLenType)lBlockLength + 1u)); /* (1 byte ALFID + MEM + SIZE) */                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_MemMgrParseMemStream(lAlfid, pMsgContext, &pRepContext->MemBlock);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

    if(pRepContext->MemBlock.Length == pMsgContext->reqDataLen)
    {
      lStdResult = Dcm_MemMgrCheckMemBlock(&pRepContext->MemBlock, DCM_MEMMGR_OP_WRITE, ErrorCode);                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      if (lStdResult == DCM_E_OK)
      {
        Dcm_RepeaterNextStep(pContext, DCM_SVC3D_PROGRESS_CHECKACCESS);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
        lStdResult = DCM_E_LOOP;/* speed up processing */
      }/* else DCM_E_NOT_OK (ErrorCode already set) */
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }/* else DCM_E_NOT_OK (ErrorCode already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc3DCheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DCheckAccess(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_ReadOnlyMsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc3DRepeaterProxyContextConstPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_RsrcMgrGetMemLock(opStatus, DCM_RSRCMGR_MEM_ACCESS_REQ_EXT);

  if (lStdResult == DCM_E_OK)
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC3D_PROGRESS_WRITEMEMORY); /* delegate job */                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP; /* speed up processing */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc3DWriteMemory()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DWriteMemory(
  Dcm_OpStatusType opStatus,
  Dcm_ReadOnlyMsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc3DRepeaterProxyContextConstPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_MemMgrWriteMemory(opStatus
                                    ,&(pRepContext->MemBlock)
                                    ,Dcm_UtiGetReqData(pMsgContext)
                                    ,ErrorCode);                                                                                                     /* SBSW_DCM_COMB_PTR_FORWARD */

  return lStdResult;
}
#endif /* (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc85SubFuncInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc85SubFuncInfoGetEntry(
  Dcm_DiagSubServiceRefOptType SubSvcRef,
  CONSTP2VAR(Dcm_CfgSvc85SubFuncInfoPtrType, AUTOMATIC, AUTOMATIC) pSubFuncInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if (Dcm_DebugDetectRuntimeError(SubSvcRef >= DCM_CFGSVC85SUBFUNCINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pSubFuncInfo = &Dcm_CfgSvc85SubFuncInfo[SubSvcRef];                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc85Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc85RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType                lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc85SubFuncLookUpTable
                                                   ,Dcm_CfgSvc85SubFuncExecPrecondTable
                                                   ,Dcm_Svc85ReqLengthGetter
                                                   ,Dcm_DiagNoSequenceChecker
                                                   ,&lSubSvcRef
                                                   ,ErrorCode);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
    pRepContext->SubSvcRef   = (Dcm_DiagSubServiceRefMemType)lSubSvcRef;                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->ReqMode     = Dcm_CfgSvc85SubFuncInfo[pRepContext->SubSvcRef].Mode;                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->DemClientId = Dcm_DiagGetDemClientId(Dcm_NetGetProtIdOfMsgContext(pMsgContext));                                                    /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_GLOBAL_PTR_WRITE */

# if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
    Dcm_UtiConsumeReqDataAsU24(pMsgContext, &pRepContext->DTCGroup);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
#  if (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON)
    if (pRepContext->DTCGroup != DEM_DTC_GROUP_ALL_DTCS)
    {
      lStdResult = E_NOT_OK;
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    /* else: everything fine -> proceed with service processing */
#  endif
# else
    /* length = 0 -> nothing to extract */
    pRepContext->DTCGroup = DEM_DTC_GROUP_ALL_DTCS;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
# endif
# if (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON)
    if (lStdResult == DCM_E_OK)                                                                                                                      /* PRQA S 2991, 2995 */ /* MD_Dcm_ConstExpr, MD_Dcm_ConstExpr */
# endif
    {
      Dcm_RepeaterSetUser(pContext, DCM_REPEATER_USER_DEM); /* set user for central repeater handling */                                             /* SBSW_DCM_PARAM_PTR_WRITE */
      Dcm_RepeaterNextStep(pContext, DCM_SVC85_PROGRESS_REPEATERPROXY);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_LOOP; /* speed up processing */
    }
  }
  return lStdResult;
}
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc86SubFuncInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc86SubFuncInfoGetEntry(
  Dcm_DiagSubServiceRefOptType SubSvcRef,
  CONSTP2VAR(Dcm_CfgSvc86SubFuncInfoPtrType, AUTOMATIC, AUTOMATIC) pSubFuncInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if (Dcm_DebugDetectRuntimeError(SubSvcRef >= DCM_CFGSVC86SUBFUNCINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pSubFuncInfo = &Dcm_CfgSvc86SubFuncInfo[SubSvcRef];                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc86Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc86Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc86RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType                lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if (Dcm_Svc86IsStorageStateBitPartOfSubFunc() == FALSE)
  {
    uint8 lReqSf = Dcm_UtiGetReqDataAsU8(pMsgContext);                                                                                               /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */

    if ((lReqSf & 0x40u) != 0u)
    {
      Dcm_UtiSetReqDataAsU8(pMsgContext, (uint8)(lReqSf & 0xBFu)); /* mask out the storageState Bit */                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      pRepContext->StoreState = TRUE;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      pRepContext->StoreState = FALSE;                                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc86SubFuncLookUpTable
                                                   ,Dcm_CfgSvc86SubFuncExecPrecondTable
                                                   ,Dcm_Svc86ReqLengthGetter
                                                   ,Dcm_DiagNoSequenceChecker
                                                   ,&lSubSvcRef
                                                   ,ErrorCode);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
    pRepContext->SubSvcRef   = (Dcm_DiagSubServiceRefMemType)lSubSvcRef;                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_RepeaterNextStep(pContext, DCM_SVC86_PROGRESS_SUBFUNCTION); /* delegate job */                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  } /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc86SubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc86SubFuncHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc86RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType                 lStdResult;
  Dcm_CfgSvc86SubFuncInfoPtrType pSubFuncInfo;

  lStdResult = Dcm_CfgSvc86SubFuncInfoGetEntry(pRepContext->SubSvcRef, &pSubFuncInfo, ErrorCode);                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lStdResult == DCM_E_OK)                                                                                                                        /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(pContext, opStatus, pMsgContext, ErrorCode);                                                               /* SBSW_DCM_CALL_FUNCPTR_SVC86SUBFUNC */
  }

  return lStdResult;
}
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */

#define DCM_START_SEC_CODE
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MemMgrCheckMemBlock()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrCheckMemBlock(
  Dcm_MemMgrMemBlockConstPtrType pMemBlock,
  Dcm_MemMgrMemoryOpType memOp,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType             lStdResult;
  sint16_least               lMidIdx;

# if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
  lMidIdx = Dcm_UtiLookUpUint8(Dcm_CfgMemMgrMidLookUpTable, pMemBlock->Mid);                                                                         /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
# else
  lMidIdx = 0;
# endif

# if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
  if(lMidIdx < 0)
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
# endif
  {
    lStdResult = Dcm_MemMgrCheckMemoryRange(pMemBlock, memOp, &Dcm_CfgMemMgrMidInfo[lMidIdx], ErrorCode);                                            /* SBSW_DCM_COMB_PTR_FORWARD */
  }

  return lStdResult;
}

# if (DCM_MEMMGR_MEMOP_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MemMgrReadMemory()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrReadMemory(
  Dcm_OpStatusType opStatus,
  Dcm_MemMgrMemBlockConstPtrType pMemBlock,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType         lResult;
  Dcm_ReturnReadWriteMemoryType memOpResult;
  boolean                lUnknown = FALSE;

  *ErrorCode = DCM_E_GENERALREJECT;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */

  if (Dcm_DebugDetectRuntimeError(pDataContext->AvailLen < pMemBlock->Length))                                                                       /* COV_DCM_RTM_RUNTIME_CHECK XF */
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else /* The data to be read fits into the available buffer */
  {
    memOpResult = Dcm_ReadMemory(opStatus
#  if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
                                ,pMemBlock->Mid
#  else
                                ,0u
#  endif
                                ,pMemBlock->Address
                                ,pMemBlock->Length
                                ,Dcm_UtiGetDataContextBuffer(pDataContext)                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
#  if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
                                ,ErrorCode
#  endif
                                );                                                                                                                   /* SBSW_DCM_CALL_READMEMORY */

    if (memOpResult == DCM_E_OK)
    {
      Dcm_UtiCommitData(pDataContext, pMemBlock->Length);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
    }

    lResult = Dcm_UtiConvMemoryOpResult(memOpResult, opStatus, &lUnknown, ErrorCode);  /* RFC 57196 - return NRC 0x10 */                             /* SBSW_DCM_PARAM_PTR_FORWARD */

    if (lUnknown == TRUE)
    {
      *ErrorCode = DCM_E_GENERALREJECT;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
      Dcm_DebugReportError(DCM_SID_READMEMORY, DCM_E_INTERFACE_RETURN_VALUE);
    }

    if ((lResult != DCM_E_PENDING)
      && (lResult != DCM_E_FORCE_RCRRP))
    {
      /* Release resource */
      Dcm_RsrcMgrReleaseMemLock();
    }
#  if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
    Dcm_UtiHandleApplNrc(lResult, ErrorCode, DCM_E_GENERALREJECT);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
#  endif
  }

  return lResult;
}                                                                                                                                                    /* PRQA S 6050 */ /*  MD_MSR_STCAL */
# endif

# if (DCM_MEMMGR_MEMOP_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MemMgrWriteMemory()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrWriteMemory(
  Dcm_OpStatusType opStatus,
  Dcm_MemMgrMemBlockConstPtrType pMemBlock,
  Dcm_MsgType data,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Dcm_ReturnReadWriteMemoryType memOpResult;
  Std_ReturnType                lResult;
  boolean                       lUnknown = FALSE;

  *ErrorCode = DCM_E_GENERALPROGRAMMINGFAILURE;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */

  memOpResult = Dcm_WriteMemory(opStatus
#  if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
                               ,pMemBlock->Mid
#  else
                               ,0u
#  endif
                               ,pMemBlock->Address
                               ,pMemBlock->Length
                               ,data
#  if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
                               ,ErrorCode
#  endif
                               );                                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

  lResult = Dcm_UtiConvMemoryOpResult(memOpResult, opStatus, &lUnknown, ErrorCode);                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

  if (lUnknown == TRUE)
  {
    *ErrorCode = DCM_E_GENERALPROGRAMMINGFAILURE;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_WRITEMEMORY, DCM_E_INTERFACE_RETURN_VALUE);
  }

  if ((lResult != DCM_E_PENDING)
    && (lResult != DCM_E_FORCE_RCRRP))
  {
    /* Release resource */
    Dcm_RsrcMgrReleaseMemLock();
  }
#  if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
  Dcm_UtiHandleApplNrc(lResult, ErrorCode, DCM_E_GENERALPROGRAMMINGFAILURE);                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
#  endif
  return lResult;
}
# endif
/**********************************************************************************************************************
 *  Dcm_MemMgrValidateAndGetAlfid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrValidateAndGetAlfid(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_Uint8VarDataPtrType pAlfid,
  Dcm_Uint8VarDataPtrType pBlockLength,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_UtiValidateAndGetAlfid(pMsgContext, Dcm_CfgMemMgrAlfidLookUpTable, pAlfid, pBlockLength, ErrorCode);                              /* SBSW_DCM_COMB_PTR_FORWARD */ /* SBSW_DCM_POINTER_FORWARD_STACK */

  if (lStdResult == DCM_E_OK)
  {
    if (*pBlockLength > pMsgContext->reqDataLen)
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_MemMgrParseMemStream()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_MemMgrParseMemStream(
  uint8 alfid,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_MemMgrMemBlockPtrType pMemBlock
  )
{
  uint8_least lAddressLength;

  lAddressLength = Dcm_UtiGetMemBlockAddrSize(alfid);

# if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
  --lAddressLength; /* skip mid */
  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &(pMemBlock->Mid));                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
# endif

  /* extract address */
  pMemBlock->Address = (Dcm_CfgMemMgrReqAddrType)Dcm_UtiDwordExtract(pMsgContext, lAddressLength);                                                   /* SBSW_DCM_PARAM_PTR_WRITE */ /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* extract size  */
  pMemBlock->Length = (Dcm_CfgMemMgrReqSizeType)Dcm_UtiDwordExtract(pMsgContext, Dcm_UtiGetMemBlockLenSize(alfid));                                  /* SBSW_DCM_PARAM_PTR_WRITE */ /* SBSW_DCM_PARAM_PTR_FORWARD */
}
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_22_OBD_CALIBRATION_ENABLED == STD_ON) || \
     (DCM_SVC_31_OBD_CALIBRATION_ENABLED == STD_ON) || \
     (DCM_OBDUDSIDMGR_CALIBRATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrIsIdEnabled()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_ObdIdMgrIsIdEnabled(
  uint8 obdId,
  P2CONST(Dcm_ObdIdMgrMaskValueTableType, AUTOMATIC, DCM_CONST) pMaskData
  )
{
  boolean lResult;

  if (obdId == 0x00u)
  {
    lResult = (boolean)(pMaskData[0] != 0u); /* ID 0x00 is only available if any other IDs are supported too */                                      /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
  }
  else
  {
    lResult = (boolean)Dcm_ObdIdMgrIsIdSupported(pMaskData[Dcm_ObdIdMgrGetAvailabilityIdIdx(obdId - 1u)], obdId); /* else - another ID (i.e. [0x01-0xFF]) is requested */ /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
  }

  return lResult;
}
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrIdLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgrIdLookUp(
  uint8 id,
  Dcm_ObdIdMgrDescPtrType pParserDesc
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  sint16_least   lLookUpResult;

  lLookUpResult = Dcm_VarMgrLookUpFilter(Dcm_UtiLookUpUint8(pParserDesc->LookUpTable, id), pParserDesc->LookUpFilterTable);                          /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lLookUpResult >= 0)
  {
# if (DCM_OBDUDSIDMGR_CALIBRATION_ENABLED == STD_ON)
    if(Dcm_ObdIdMgrIsIdEnabled(id, pParserDesc->MaskData) == TRUE)                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
# endif
    {
      pParserDesc->Handle = (Dcm_ObdIdMgrHandleMemType)((uint16)lLookUpResult - Dcm_ObdIdMgrGetAvailabilityIdIdx(id) - 1u);                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_OK;
    }
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_ObdIdMgrGetAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(uint32, DCM_CODE) Dcm_ObdIdMgrGetAvailabilityMask(
  uint8 id,
  Dcm_ObdIdMgrDescPtrType pParserDesc
  )
{
  uint32       lResultMask;
  sint16_least lLookUpIter;

  lResultMask = 0;
  lLookUpIter = (sint16_least)Dcm_UtiLookUpUint8(pParserDesc->LookUpTable, id);                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Skip the availability Id */
  ++lLookUpIter;

  /* Iterate within the range of the given AID or end of table and calculate bit mask  */
  for(; lLookUpIter < (sint16_least)pParserDesc->LookUpTable[0]; ++lLookUpIter)
  {
    uint8 lId = pParserDesc->LookUpTable[lLookUpIter+1]; /* Consider the leading-size-byte offset in the lookup table */

    if(Dcm_ObdIdMgrIdLookUp(lId, pParserDesc) == DCM_E_OK)                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    {
      Dcm_UtiBitOpSet(uint32, lResultMask, Dcm_ObdIdMgrGetObdIdMaskBit(lId));
    }

    /* Iterate until the next AID is reached. This AID shall be reported in bit0 of the mask too, therefore use post-condition-check */
    if(Dcm_ObdIdMgrIsAvailabilityId(lId))
    {
      break;
    }
  }

  return lResultMask;
}

# if (DCM_OBDIDMGR_REQ_PARSER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrProcessSupportedIdRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgrProcessSupportedIdRequest(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_ObdIdMgrDescPtrType pParserDesc,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult   = DCM_E_OK;
  uint8_least    lNumberOfIds = (uint8_least)pMsgContext->reqDataLen;

  /* If maximal 6 OBD availability IDs are requested: */
  if(lNumberOfIds <= DCM_OBDIDMGR_MAX_NUMBER_OF_IDS)
  {
    uint8        lIdList[DCM_OBDIDMGR_MAX_NUMBER_OF_IDS];
    uint8_least  lIdIter;

    /* Copy all requested IDs to local list. This allows to write into response buffer during parsing. */
    Dcm_UtiConsumeReqDataAsUN(pMsgContext, lIdList, DCM_OBDIDMGR_MAX_NUMBER_OF_IDS, pMsgContext->reqDataLen);                                        /* SBSW_DCM_COMB_PTR_FORWARD */

    /* If any ID in request is not an availability ID (0x00, 0x20, 0x40...): */
    for(lIdIter = 0; lIdIter < lNumberOfIds; lIdIter++)
    {
      if(!Dcm_ObdIdMgrIsAvailabilityId(lIdList[lIdIter]))
      {
        /* Mix of Data and Availability IDs is not allowed */
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
        break;
      }
    }

    if(lStdResult == DCM_E_OK)
    {
      for(lIdIter = 0; lIdIter < lNumberOfIds; lIdIter++)
      {
        uint8 lId = lIdList[lIdIter];

        /* If the given OBD identifier is supported: */
        if(Dcm_ObdIdMgrIdLookUp(lId, pParserDesc) == DCM_E_OK)                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
        {
          Dcm_UtiProvideResDataAsU8(pMsgContext, lId);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
          Dcm_UtiProvideResDataAsU32(pMsgContext, Dcm_ObdIdMgrGetAvailabilityMask(lId, pParserDesc));                                                /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
      }

      /* If no requested ID was supported: */
      if (pMsgContext->resDataLen == 0u)
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif
#endif /* (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckRole()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckRole(
  Dcm_CfgStateRefOptType stateRef,
  Dcm_CfgNetAuthInfoRefMemType authInfoRef
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  /* Check if authentication restriction is supported for this connection */
  if(authInfoRef != DCM_AUTHMGR_INVALID_AUTH_INFO_REF)
  {
# if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
    /* Check if global access has been granted through service whitelist at DSD */
    if(Dcm_AuthMgrIsGlobalAccessGranted())
    {
      lStdResult = DCM_E_OK;
    }
    else
# endif
    {
      if(!Dcm_StateIsSupportedInRole(Dcm_StateGetPreconditionStates(stateRef), authInfoRef))
      {
        lStdResult = DCM_E_NOT_OK;
      }
    }
  }
  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckDispatcherLevel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckDispatcherLevel(
  uint8 sid,
  Dcm_CfgStateRefOptType stateRef,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

# if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
  /* Reset global access flag */
  Dcm_AuthMgrSetGlobalAccess(FALSE);
# endif

  /* Check authentication role */
  lStdResult = Dcm_AuthMgrCheckRole(stateRef, authInfoRef);

# if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
  if(lStdResult == DCM_E_NOT_OK)
  {
    /* If role check fails, try whitelist */
    lStdResult = Dcm_AuthMgrCheckServiceWLDispatcher(sid, pMsgContext, authInfoRef);                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
# else
  DCM_IGNORE_UNREF_PARAM(sid);                                                                                                                       /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
# endif

  if(lStdResult == DCM_E_NOT_OK)
  {
    *ErrorCode = DCM_E_AUTHENTICATIONREQUIRED;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  return lStdResult;
}

# if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckServiceWLDispatcher()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckServiceWLDispatcher(
  uint8 sid,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_CfgNetAuthInfoRefMemType authInfoRef
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;

  uint16_least lIter;

  /* Reset global access flag */
  Dcm_AuthMgrSetGlobalAccess(FALSE);

  /* If requesting connection is authenticated: */
  if(Dcm_AuthMgrAuthenticationState(authInfoRef) == DCM_AUTHENTICATED)
  {
    /* Loop through all service white list elements */
    for(lIter = 0u; lIter < Dcm_AuthMgrNumSvcWLElements(authInfoRef); lIter ++)
    {
      /* If service white list element should be processed in DSP: */
      if(!Dcm_AuthMgrSvcWLElemIsDSP(authInfoRef, lIter))
      {
        uint8_least lElemIter;
        boolean lFound = TRUE;
        /* If SID matches the first byte of element: */
        if(sid == Dcm_AuthMgrSvcWLElemDataAt(authInfoRef, lIter, 0u))
        {
          /* Loop through the rest of the element bytes */
          for(lElemIter = 0u; lElemIter < ((uint8_least)Dcm_AuthMgrSvcWLElemLen(authInfoRef, lIter) - 1u); lElemIter ++)
          {
            /* If the iterator does not exceed request data length: */
            if(lElemIter < pMsgContext->reqDataLen)
            {
              /* If the element byte doesn't match corresponding request byte: */
              if(pMsgContext->reqData[lElemIter] != Dcm_AuthMgrSvcWLElemDataAt(authInfoRef, lIter, (lElemIter + 1u)))
              {
                /* Set found boolean to false and skip element */
                lFound = FALSE;
                break;
              }
            }
            else
            {
              /* Element size needs to be less than or equal to the request length */
              lFound = FALSE;
            }
          }
        }
        else
        {
          /* SID doesn't match */
          lFound = FALSE;
        }

        /* If a matching element is found: */
        if(lFound == TRUE)
        {
          /* Grant global request access (no need to check subfunction or data) */
          Dcm_AuthMgrSetGlobalAccess(TRUE);
          lStdResult = DCM_E_OK;
          break;
        }
      }
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_AUTHMGR_WHITELIST_DID_ENABLED == STD_ON) || \
     (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckDidWL()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckDidWL(
  uint16 did,
  Dcm_DidOpType didOpMask,
  Dcm_CfgNetAuthInfoRefMemType authInfoRef
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  uint16_least lIter;

#  if (DCM_AUTHMGR_WHITELIST_DID_ENABLED == STD_ON)
  /* Loop through entire DID WL */
  for(lIter = 0u; lIter < Dcm_AuthMgrNumDIDWLElements(authInfoRef); lIter++)
  {
    /* If we find the DID we're after */
    if(did == Dcm_AuthMgrDidWLElem(authInfoRef, lIter).DidNumber)
    {
      /* And the right DID op access */
      if(Dcm_UtiBitOpTest(uint8, Dcm_AuthMgrDidWLElem(authInfoRef, lIter).DidAccessMask, didOpMask))
      {
        lStdResult = DCM_E_OK;
        break;
      }
    }
  }
#  endif
#  if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
  /* Check service white list for allowance */
  if(lStdResult == DCM_E_NOT_OK)                                                                                                                     /* PRQA S 2991, 2995 */ /* MD_Dcm_ConstExpr, MD_Dcm_ConstExpr */
  {
    uint8 lSid = Dcm_DidMgrGetSidFromOp(didOpMask);
    if(lSid != DCM_DIDMGR_SVC_NONE)
    {
      /* Loop over all service WL elements */
      for(lIter = 0u; lIter < Dcm_AuthMgrNumSvcWLElements(authInfoRef); lIter ++)
      {
        if(Dcm_AuthMgrSvcWLElemIsDIDWRIO(authInfoRef, lIter))
        {
          /* Check the bytes of the white list element */
          if((lSid == Dcm_AuthMgrSvcWLElemDataAt(authInfoRef, lIter, 0u))
           && (Dcm_UtiGetHiByte(did) == Dcm_AuthMgrSvcWLElemDataAt(authInfoRef, lIter, 1u))
           && (Dcm_UtiGetLoByte(did) == Dcm_AuthMgrSvcWLElemDataAt(authInfoRef, lIter, 2u)))
          {
            /* We have found a matching element to the request! */
            lStdResult = DCM_E_OK;
            /* No need to check further */
            break;
          }
        }
      }
    }
  }
#  endif

  /* Return search result */
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
# endif

# if (DCM_AUTHMGR_DID_CHECK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckDid(
  Dcm_NetConnRefMemType connHdl,
  uint16 did,
  Dcm_DidOpType didOpMask,
  Dcm_CfgStateRefOptType stateRef
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  if(connHdl != DCM_NET_INVALID_CONNHDL)
  {
    Dcm_CfgNetAuthInfoRefMemType lAuthInfoRef = Dcm_NetGetAuthInfoRef(connHdl);

    /* Check authentication role */
    lStdResult = Dcm_AuthMgrCheckRole(stateRef, lAuthInfoRef);

#  if (DCM_AUTHMGR_WHITELIST_DID_ENABLED == STD_ON) || \
      (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
    /* If Role check fails, check DID WL if in authenticated state */
    if((lStdResult == DCM_E_NOT_OK) && (Dcm_AuthMgrAuthenticationState(lAuthInfoRef) == DCM_AUTHENTICATED))
    {
      lStdResult = Dcm_AuthMgrCheckDidWL(did, didOpMask, lAuthInfoRef);
    }
#  else
    DCM_IGNORE_UNREF_PARAM(did);                                                                                                                     /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
    DCM_IGNORE_UNREF_PARAM(didOpMask);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
#  endif
  }

  return lStdResult;
}
# endif

# if (DCM_AUTHMGR_WHITELIST_RID_ENABLED == STD_ON) || \
     (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckRidWL()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckRidWL(
  uint16 rid,
  uint8 ridSubfunc,
  Dcm_CfgNetAuthInfoRefMemType authInfoRef
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  uint16_least lIter;

#  if (DCM_AUTHMGR_WHITELIST_RID_ENABLED == STD_ON)
  /* Loop through entire RID WL */
  for(lIter = 0u; lIter < Dcm_AuthMgrNumRIDWLElements(authInfoRef); lIter++)
  {
    /* If we find the RID we're after */
    if(rid == Dcm_AuthMgrRidWLElem(authInfoRef, lIter).RidNumber)
    {
      /* And the right RID op access */
      if(Dcm_UtiBitOpTest(uint8, Dcm_AuthMgrRidWLElem(authInfoRef, lIter).RidAccessMask, Dcm_RidMgrConvOpOfSubFunc(ridSubfunc)))
      {
        lStdResult = DCM_E_OK;
        break;
      }
    }
  }
#  endif
#  if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
  /* Check service white list for allowance */
  if(lStdResult == DCM_E_NOT_OK)                                                                                                                     /* PRQA S 2991, 2995 */ /* MD_Dcm_ConstExpr, MD_Dcm_ConstExpr */
  {
    /* Loop over all service WL elements */
    for(lIter = 0u; lIter < Dcm_AuthMgrNumSvcWLElements(authInfoRef); lIter++)
    {
      if(Dcm_AuthMgrSvcWLElemIsRID(authInfoRef, lIter))
      {
        /* Check the bytes of the white list element */
        if((ridSubfunc == Dcm_AuthMgrSvcWLElemDataAt(authInfoRef, lIter, 1u))
         && (Dcm_UtiGetHiByte(rid) == Dcm_AuthMgrSvcWLElemDataAt(authInfoRef, lIter, 2u))
         && (Dcm_UtiGetLoByte(rid) == Dcm_AuthMgrSvcWLElemDataAt(authInfoRef, lIter, 3u)))
        {
          /* We have found a matching element to the request! */
          lStdResult = DCM_E_OK;
          /* No need to check further */
          break;
        }
      }
    }
  }
#  endif

  /* Return search result */
  return lStdResult;
}
# endif

# if (DCM_AUTHMGR_RID_CHECK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckRid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckRid(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  uint16 rid,
  uint8 ridSubfunc,
  Dcm_CfgStateRefOptType stateRef
  )
{
  Std_ReturnType lStdResult;

  Dcm_CfgNetAuthInfoRefMemType lAuthInfoRef = Dcm_NetGetAuthInfoRef(Dcm_DiagGetTranspObj(pContext->Thread)->ConnHdl);

  /* Check authentication role */
  lStdResult = Dcm_AuthMgrCheckRole(stateRef, lAuthInfoRef);

#  if (DCM_AUTHMGR_WHITELIST_RID_ENABLED == STD_ON) || \
      (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
  /* If Role check fails, check RID WL if in authenticated state */
  if((lStdResult == DCM_E_NOT_OK) && (Dcm_AuthMgrAuthenticationState(lAuthInfoRef) == DCM_AUTHENTICATED))
  {
    lStdResult = Dcm_AuthMgrCheckRidWL(rid, ridSubfunc, lAuthInfoRef);
  }
#  else
  DCM_IGNORE_UNREF_PARAM(rid);                                                                                                                       /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ridSubfunc);                                                                                                                /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
#  endif

  return lStdResult;
}
# endif

# if (DCM_AUTHMGR_WHITELIST_MEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckMemWL()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckMemWL(
  uint8 memId,
  Dcm_CfgNetAuthInfoRefMemType authInfoRef
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;

  uint16_least lIter;

  /* Loop through entire MEM WL */
  for(lIter = 0u; lIter < Dcm_AuthMgrNumMemWLElements(authInfoRef); lIter++)
  {
    /* If we find the MEM we're after */
    if(memId == Dcm_AuthMgrMemWLElem(authInfoRef, lIter).MemNumber)
    {
      lStdResult = DCM_E_OK;
      break;
    }
  }

  /* Return search result */
  return lStdResult;
}
# endif

# if (DCM_AUTHMGR_MEM_CHECK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckMem()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckMem(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  uint8 memId
  )
{
  Std_ReturnType lStdResult;

  Dcm_CfgNetAuthInfoRefMemType lAuthInfoRef = Dcm_NetGetAuthInfoRef(Dcm_DiagGetTranspObj(pContext->Thread)->ConnHdl);

  /* Check authentication role */
  lStdResult = Dcm_AuthMgrCheckRole(DCM_SVC_19_USERMEM_ID_PRECON_REF, lAuthInfoRef);

#  if (DCM_AUTHMGR_WHITELIST_MEM_ENABLED == STD_ON)
  /* Check the MEM whitelist only in authenticated state */
  if((lStdResult == DCM_E_NOT_OK) && (Dcm_AuthMgrAuthenticationState(lAuthInfoRef) == DCM_AUTHENTICATED))
  {
    lStdResult = Dcm_AuthMgrCheckMemWL(memId, lAuthInfoRef);
  }
#  else
  DCM_IGNORE_UNREF_PARAM(memId);                                                                                                                     /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
#  endif

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_AuthMgrGetCertRole()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrGetCertRole(
  Dcm_OpStatusType opStatus,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lKeyMResult;
  Std_ReturnType lStdResult = DCM_E_OK;

  uint32 lRoleElementLength = DCM_AUTHMGR_CERT_ROLE_SIZE;
  uint8 lRoleReadElement[4];
  Dcm_CfgStateGroupMemType lRoleInLittleEndian;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Extract the role from the certificate */
  lKeyMResult = KeyM_CertElementGet(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].ConnectionCertificateId
                                   ,Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].CertRoleId
                                   ,lRoleReadElement
                                   ,&lRoleElementLength);                                                                                            /* SBSW_DCM_POINTER_WRITE_CERTIFICATE_ROLE */


  /* If role extraction from certificate was successful */
  if(lKeyMResult == E_OK)
  {
    /* If the size of the read role is equal to configured role size */
    if(lRoleElementLength == DCM_AUTHMGR_CERT_ROLE_SIZE)
    {
      /* Store role in role context. Cast to Dcm_CfgStateGroupMemType to truncate unwanted upper bytes */
      lRoleInLittleEndian = ((Dcm_CfgStateGroupMemType)(Dcm_UtiMake32Bit(lRoleReadElement[3]
                                                                        ,lRoleReadElement[2]
                                                                        ,lRoleReadElement[1]
                                                                        ,lRoleReadElement[0])));

      pRepContext->ConnContext.ActiveRole = lRoleInLittleEndian;                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      if(Dcm_DebugDetectError(lRoleElementLength > DCM_AUTHMGR_CERT_ROLE_SIZE))
      {
        /* Send panic NRC */
        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_BUFFER_OVERFLOW);
      }
      else
      {
        /* Otherwise return NRC 55 */
        *ErrorCode = DCM_E_CVF_INVALIDCONTENT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
  }
  else
  {
    /* Role extraction wasn't successful, return Error */
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
  }

  return lStdResult;
}

# if (DCM_AUTHMGR_WHITELISTS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrGetCertWLElement()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrGetCertWLElement(
  uint16 certificateId,
  uint16 certElementId,
  Dcm_MsgType pElementData,
  Dcm_Uint32VarDataPtrType pElementDataLength,
  Dcm_OpStatusType opStatus,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  Std_ReturnType lKeyMResult;

    /* If first element to be read: */
  if(opStatus == DCM_INITIAL)
  {
    /* Retrieve first element with KeyM_CertElementGetFirst, which sets up KeyM iterator struct */
    lKeyMResult = KeyM_CertElementGetFirst(certificateId
                                          ,certElementId
                                          ,&pRepContext->CertElementIterator
                                          ,pElementData
                                          ,pElementDataLength);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    /* Retrieve remeining elements with KeyM_CertElementGetNext */
    lKeyMResult = KeyM_CertElementGetNext(&pRepContext->CertElementIterator
                                         ,pElementData
                                         ,pElementDataLength);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* If KeyM_CertElementGet[First/Next] returns E_OK: */
  if(lKeyMResult == E_OK)
  {
    lStdResult = DCM_E_LOOP;
  }
  /* Otherwise, if KeyM function returns E_NOT_OK: */
  else if(lKeyMResult == E_NOT_OK) /* End of list */
  {
    /* End of elements list, return success */
    lStdResult = DCM_E_OK;
  }
  /* Otherwise, send panic NRC */
  else
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6060 */ /* MD_MSR_STPAR */
# endif

# if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrServiceWLReadList()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrServiceWLReadList(
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                     lStdResult;
  Dcm_OpStatusType                   lOpStatus = DCM_INITIAL;
  Dcm_AuthMgrWLServiceContextPtrType pWLServiceContext = &pRepContext->ConnContext.WLContext.WLServiceContext;

  pWLServiceContext->NumServiceWLElements = 0u;                                                                                                      /* SBSW_DCM_GLOBAL_PTR_WRITE */

  /* Loop over all service white list elements until there are no more left */
  do
  {
    uint32 lElementLength = DCM_AUTHMGR_ELEMENT_SERVICE_SIZE;

    lStdResult = Dcm_AuthMgrGetCertWLElement(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].ConnectionCertificateId
                                            ,Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].CertWLServicesId
                                            ,&(pWLServiceContext->WLServiceElement[pWLServiceContext->NumServiceWLElements].WLData[0u])
                                            ,&lElementLength
                                            ,lOpStatus
                                            ,pRepContext
                                            ,ErrorCode);                                                                                             /* SBSW_DCM_POINTER_WRITE_SERVICE_WL_ELEMENT */ /* SBSW_DCM_COMB_PTR_FORWARD */

    /* If element successfully read: */
    if(lStdResult == DCM_E_LOOP)
    {
      /* If retrieved element length fits within allocated buffer: */
      if((lElementLength > 0u) && (lElementLength <= DCM_AUTHMGR_ELEMENT_SERVICE_SIZE))
      {
        /* Store length of service white list element */
        pWLServiceContext->WLServiceElement[pWLServiceContext->NumServiceWLElements].WLEntryLength = (uint8)lElementLength;                          /* SBSW_DCM_POINTER_WRITE_SERVICE_WL_ELEMENT */

        /* Increment number of service white list entries for next iteration */
        pWLServiceContext->NumServiceWLElements++;                                                                                                   /* SBSW_DCM_GLOBAL_PTR_WRITE */
        lOpStatus = DCM_PENDING;

        /* If buffer too small for the number of entries: Send NRC 0x55 (DCM_E_CVF_INVALIDCONTENT) */
        if(pWLServiceContext->NumServiceWLElements >= DCM_AUTHMGR_NUM_SERVICE_WL_ELEMENTS)
        {
          *ErrorCode = DCM_E_CVF_INVALIDCONTENT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
      else
      {
        /* Otherwise, if read element is bigger than expected: */
        if(Dcm_DebugDetectError(lElementLength > DCM_AUTHMGR_ELEMENT_SERVICE_SIZE))
        {
          /* Send panic NRC */
          *ErrorCode = DCM_E_PANIC_NRC;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
          Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_BUFFER_OVERFLOW);
        }
        else
        {
          /* Otherwise, send NRC 0x55 (DCM_E_CVF_INVALIDCONTENT) */
          *ErrorCode = DCM_E_CVF_INVALIDCONTENT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
    } /* Otherwise, all elements read or send prepared NRC */
  } while((pWLServiceContext->NumServiceWLElements < DCM_AUTHMGR_NUM_SERVICE_WL_ELEMENTS) && (lStdResult == DCM_E_LOOP));

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_AUTHMGR_WHITELIST_DID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrDidWLReadList()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrDidWLReadList(
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                 lStdResult;
  Dcm_OpStatusType               lOpStatus = DCM_INITIAL;
  Dcm_AuthMgrWLDidContextPtrType pWLDidContext = &pRepContext->ConnContext.WLContext.WLDidContext;
  uint32                         lElementLength = DCM_AUTHMGR_ELEMENT_DID_SIZE;
  uint8                          lDidReadElement[DCM_AUTHMGR_ELEMENT_DID_SIZE];

  pWLDidContext->NumDidWLElements = 0u;                                                                                                              /* SBSW_DCM_GLOBAL_PTR_WRITE */

  /* Loop over all service white list elements until there are no more left */
  do
  {
    lStdResult = Dcm_AuthMgrGetCertWLElement(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].ConnectionCertificateId
                                            ,Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].CertWLDidId
                                            ,&lDidReadElement[0u]
                                            ,&lElementLength
                                            ,lOpStatus
                                            ,pRepContext
                                            ,ErrorCode);                                                                                             /* SBSW_DCM_POINTER_WRITE_WL_ELEMENT */ /* SBSW_DCM_COMB_PTR_FORWARD */

    /* If element successfully read: */
    if(lStdResult == DCM_E_LOOP)
    {
      /* If retrieved element length is as expected: */
      if(lElementLength == DCM_AUTHMGR_ELEMENT_DID_SIZE)
      {
        /* Store DID element data into context (big endian format) */
        pWLDidContext->WLDidElement[pWLDidContext->NumDidWLElements].DidNumber = (Dcm_UtiMake16Bit(lDidReadElement[0u], lDidReadElement[1u]));       /* SBSW_DCM_POINTER_WRITE_DID_WL_ELEMENT */
        pWLDidContext->WLDidElement[pWLDidContext->NumDidWLElements].DidAccessMask = lDidReadElement[2u];                                            /* SBSW_DCM_POINTER_WRITE_DID_WL_ELEMENT */

        /* Increment number of DID white list entries for next iteration */
        pWLDidContext->NumDidWLElements++;                                                                                                           /* SBSW_DCM_GLOBAL_PTR_WRITE */
        lOpStatus = DCM_PENDING;

        /* If buffer too small for the number of entries: Send NRC 0x55 (DCM_E_CVF_INVALIDCONTENT) */
        if(pWLDidContext->NumDidWLElements >= DCM_AUTHMGR_NUM_DID_WL_ELEMENTS)
        {
          *ErrorCode = DCM_E_CVF_INVALIDCONTENT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
      else
      {
        /* Otherwise, if read element is bigger than expected: */
        if(Dcm_DebugDetectError(lElementLength > DCM_AUTHMGR_ELEMENT_DID_SIZE))
        {
          /* Send panic NRC */
          *ErrorCode = DCM_E_PANIC_NRC;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
          Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_BUFFER_OVERFLOW);
        }
        else
        {
          /* Otherwise, send NRC 0x55 (DCM_E_CVF_INVALIDCONTENT) */
          *ErrorCode = DCM_E_CVF_INVALIDCONTENT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
    }/* Otherwise, all elements read or send prepared NRC */
  } while((pWLDidContext->NumDidWLElements < DCM_AUTHMGR_NUM_DID_WL_ELEMENTS) && (lStdResult == DCM_E_LOOP));

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_AUTHMGR_WHITELIST_RID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrRidWLReadList()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrRidWLReadList(
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                 lStdResult;
  Dcm_OpStatusType               lOpStatus = DCM_INITIAL;
  Dcm_AuthMgrWLRidContextPtrType pWLRidContext = &pRepContext->ConnContext.WLContext.WLRidContext;
  uint32                         lElementLength = DCM_AUTHMGR_ELEMENT_RID_SIZE;
  uint8                          lRidReadElement[DCM_AUTHMGR_ELEMENT_RID_SIZE];

  pWLRidContext->NumRidWLElements = 0u;                                                                                                              /* SBSW_DCM_GLOBAL_PTR_WRITE */

  /* Loop over all service white list elements until there are no more left */
  do
  {
    lStdResult = Dcm_AuthMgrGetCertWLElement(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].ConnectionCertificateId
                                            ,Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].CertWLRidId
                                            ,&lRidReadElement[0u]
                                            ,&lElementLength
                                            ,lOpStatus
                                            ,pRepContext
                                            ,ErrorCode);                                                                                             /* SBSW_DCM_POINTER_WRITE_WL_ELEMENT */ /* SBSW_DCM_COMB_PTR_FORWARD */

    /* If element successfully read: */
    if(lStdResult == DCM_E_LOOP)
    {
      /* If retrieved element length is as expected: */
      if(lElementLength == DCM_AUTHMGR_ELEMENT_RID_SIZE)
      {
        /* Store RID element data into context (big endian format) */
        pWLRidContext->WLRidElement[pWLRidContext->NumRidWLElements].RidNumber = (Dcm_UtiMake16Bit(lRidReadElement[0u], lRidReadElement[1u]));       /* SBSW_DCM_POINTER_WRITE_RID_WL_ELEMENT */
        pWLRidContext->WLRidElement[pWLRidContext->NumRidWLElements].RidAccessMask = lRidReadElement[2u];                                            /* SBSW_DCM_POINTER_WRITE_RID_WL_ELEMENT */

        /* Increment number of RID white list entries for next iteration */
        pWLRidContext->NumRidWLElements++;                                                                                                           /* SBSW_DCM_GLOBAL_PTR_WRITE */
        lOpStatus = DCM_PENDING;

        /* If buffer too small for the number of entries: Send NRC 0x55 (DCM_E_CVF_INVALIDCONTENT) */
        if(pWLRidContext->NumRidWLElements >= DCM_AUTHMGR_NUM_RID_WL_ELEMENTS)
        {
          *ErrorCode = DCM_E_CVF_INVALIDCONTENT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
      else
      {
        /* Otherwise, if read element is bigger than expected: */
        if(Dcm_DebugDetectError(lElementLength > DCM_AUTHMGR_ELEMENT_RID_SIZE))
        {
          /* Send panic NRC */
          *ErrorCode = DCM_E_PANIC_NRC;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
          Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_BUFFER_OVERFLOW);
        }
        else
        {
          /* Otherwise, send NRC 0x55 (DCM_E_CVF_INVALIDCONTENT) */
          *ErrorCode = DCM_E_CVF_INVALIDCONTENT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
    }/* Otherwise, all elements read or send prepared NRC */
  } while((pWLRidContext->NumRidWLElements < DCM_AUTHMGR_NUM_RID_WL_ELEMENTS) && (lStdResult == DCM_E_LOOP));

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_AUTHMGR_WHITELIST_MEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrMemWLReadList()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrMemWLReadList(
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                 lStdResult;
  Dcm_OpStatusType               lOpStatus = DCM_INITIAL;
  Dcm_AuthMgrWLMemContextPtrType pWLMemContext = &pRepContext->ConnContext.WLContext.WLMemContext;
  uint32                         lElementLength = DCM_AUTHMGR_ELEMENT_MEM_SIZE;
  uint8                          lMemReadElement[DCM_AUTHMGR_ELEMENT_MEM_SIZE];

  pWLMemContext->NumMemWLElements = 0u;                                                                                                              /* SBSW_DCM_GLOBAL_PTR_WRITE */

  /* Loop over all service white list elements until there are no more left */
  do
  {

    lStdResult = Dcm_AuthMgrGetCertWLElement(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].ConnectionCertificateId
                                            ,Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].CertWLMemId
                                            ,&lMemReadElement[0u]
                                            ,&lElementLength
                                            ,lOpStatus
                                            ,pRepContext
                                            ,ErrorCode);                                                                                             /* SBSW_DCM_POINTER_WRITE_WL_ELEMENT */ /* SBSW_DCM_COMB_PTR_FORWARD */

    /* If element successfully read: */
    if(lStdResult == DCM_E_LOOP)
    {
      /* If retrieved element length is as expected: */
      if(lElementLength == DCM_AUTHMGR_ELEMENT_MEM_SIZE)
      {
        /* Store MEM element data into context */
        pWLMemContext->WLMemElement[pWLMemContext->NumMemWLElements].MemNumber = lMemReadElement[0u];                                                /* SBSW_DCM_POINTER_WRITE_MEM_WL_ELEMENT */

        /* Increment number of MEM white list entries for next iteration */
        pWLMemContext->NumMemWLElements++;                                                                                                           /* SBSW_DCM_GLOBAL_PTR_WRITE */
        lOpStatus = DCM_PENDING;

        /* If buffer too small for the number of entries: Send NRC 0x55 (DCM_E_CVF_INVALIDCONTENT) */
        if(pWLMemContext->NumMemWLElements >= DCM_AUTHMGR_NUM_MEM_WL_ELEMENTS)
        {
          *ErrorCode = DCM_E_CVF_INVALIDCONTENT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
      else
      {
        /* Otherwise, if read element is bigger than expected: */
        if(Dcm_DebugDetectError(lElementLength > DCM_AUTHMGR_ELEMENT_MEM_SIZE))
        {
          /* Send panic NRC */
          *ErrorCode = DCM_E_PANIC_NRC;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
          Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_BUFFER_OVERFLOW);
        }
        else
        {
          /* Otherwise, send NRC 0x55 (DCM_E_CVF_INVALIDCONTENT) */
          *ErrorCode = DCM_E_CVF_INVALIDCONTENT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
    }/* Otherwise, all elements read or send prepared NRC */
  } while((pWLMemContext->NumMemWLElements < DCM_AUTHMGR_NUM_MEM_WL_ELEMENTS) && (lStdResult == DCM_E_LOOP));

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_TMR_NUM_AUTHENTICATION > 0u)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutAuthentication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutAuthentication(
  Dcm_ThreadIdMemType threadId
  )
{
  Dcm_TmrTimerCntrMemType       lReloadTick = 0u;
  Dcm_CfgNetAuthInfoRefOptType  lTmrIter;

  DCM_IGNORE_UNREF_PARAM(threadId);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Enter critical section (Reason: A timer can be modified from an ISR) */
  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* For each software timer: */
  for(lTmrIter = 0; lTmrIter < DCM_AUTHMGR_NUM_DELAY_TIMERS; ++lTmrIter)
  {
    /* If the software timer is active: */
    if(Dcm_AuthMgrTimerActive(lTmrIter) == TRUE)                                                                                                     /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
    {
      /* Decrement the timer value */
      Dcm_AuthMgrTimerSet((Dcm_CfgNetAuthInfoRefMemType)lTmrIter, (Dcm_AuthMgrTimerType)(Dcm_AuthMgrTimerGet(lTmrIter) - 1u));

      /* If the software timer is still active */
      if(Dcm_AuthMgrTimerActive(lTmrIter) == TRUE)                                                                                                   /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
      {
        /* Reload the hardware timer */
        lReloadTick = 1u;
      }
      else
      {
        /* Otherwise, update the global expired timer mask flag with position of expired timer */
        Dcm_AuthMgrTimerExpireMaskSetBit(lTmrIter);
      }
    }
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  /* Leave critical section */
  Dcm_UtiLeaveCriticalSection();

  /* If at least one timer has expired */
  if(Dcm_AuthMgrAnyTimerExpired())                                                                                                                   /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
  {
    /* Set the event to deauthenticate idle connections in default session */
    Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_IDLE_CONN, threadId);
  }

  return lReloadTick;
}
# endif
#endif /* (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetTaskTaMonitor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskTaMonitor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_CfgNetTObjHandleOptType lTObjCntr;
  Dcm_TskTaskEvOptType        lEv = pEventContext->Ev;

  /* Check whether any request which has to be canceled is in progress */
  if(((DCM_DIAG_QUEUE_FLAG_IS_ACTIVE | DCM_DIAG_QUEUE_FLAG_IS_WAITING) & pContext->Thread->Diag.QueuedSet.Flags) != 0u)
  {

    /* Enter critical section (Reason: the transport object may not be modified from outside) */
    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/

    /* If a request is in progress */
    if((DCM_DIAG_QUEUE_FLAG_IS_ACTIVE & pContext->Thread->Diag.QueuedSet.Flags) != 0u)
    {
      Dcm_TskTaskEvMemType tObjEv = Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, Dcm_DiagGetTranspObj(pContext->Thread)->Handle);

      /* If the ongoing request is from the same tester as the new request with the foreign N_TA */
      if (Dcm_TskIsLocalEventSet(lEv, tObjEv))
      {
        /* Cancel the request processing */
        Dcm_DiagCancelProcessing(Dcm_DiagGetTranspObj(pContext->Thread));                                                                            /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      }/* else - post processing or idle are to be handled in a normal way */
    }

    /* If a waiting new request is in the queue */
    if((DCM_DIAG_QUEUE_FLAG_IS_WAITING & pContext->Thread->Diag.QueuedSet.Flags) != 0u)
    {
       Dcm_TskTaskEvMemType tObjEv = Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, Dcm_DiagGetQueuedTranspObj(pContext->Thread)->Handle);

       /* If the queued request is from the same tester as the new request with the foreign N_TA */
       if (Dcm_TskIsLocalEventSet(lEv, tObjEv))
       {
         /* Cancel the queued request in the next task cycle */
         pEventContext->PostEv = tObjEv;/* retry later */                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
       }
    }
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    /* Leave critical section */
    Dcm_UtiLeaveCriticalSection();
  }

  /* Scan all affected transport objects */
  lTObjCntr = 0u;
  DCM_TSK_EVENT_SCAN_LOOP(lEv)
  {
    if (Dcm_TskIsLocalEventSet(lEv, 0x01u))
    {
      Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTransportObject(lTObjCntr);

      /* If a received but not yet processed request was interrupted by another request with a foreign N_TA */
      if( ( pTranspObj->State == DCM_NET_TOBJ_STATE_RX_END)
        &&((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_OBSOLETE) != 0u ) ) /* This is still the original transport object marked to be canceled in the Dcm_OnRequestIndication */
      {
        Dcm_NetBufferContextPtrType pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);

        /* Prevent the processing of the received but not yet processed request */
        Dcm_TskClrEvent(DCM_TSK_ID_NET_RX, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle));

        /* Deallocate the transport object and free the connection */
        Dcm_NetUnRegisterComMActivity(pTranspObj->ConnHdl); /* Deallocate transport object */
        Dcm_NetBufferRelease(pBufferContext); /* The buffer is free now */                                                                           /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
        Dcm_NetUnRegisterActiveConnection(pTranspObj); /* No further processing needed */                                                            /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      } /* Otherwise, connection is not obsolete or will be canceled during service processing (already in state
         * DCM_NET_TOBJ_STATE_READY) */
    }
    ++lTObjCntr;
  }
}                                                                                                                                                    /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */
#endif

/**********************************************************************************************************************
 *  Dcm_NetTaskRx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskRx(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_TskTaskEvMemType          lBusyEvents;
  Dcm_CfgNetTObjHandleOptType   lTranspObjWinnerId;
  Dcm_NetTransportObjectPtrType pTranspObj;

  lTranspObjWinnerId = Dcm_NetRxPrioritisationFindWinner(pEventContext->Ev, &lBusyEvents);                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */

  pTranspObj = Dcm_NetGetTransportObject(lTranspObjWinnerId);

#if (DCM_NET_PROTOCOL_PARALLELISATION_ENABLED == STD_ON)
  /* If this is a request which can be handled in parallel */
  if(pContext->Thread->ThreadId != DCM_THREAD_ID_BASIC)
  {
    Dcm_NetProcessStartProtocol(pTranspObj);                                                                                                         /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
  }
  else
#endif
  {
    Dcm_NetRxPrioritisationProcessWinner(pContext, pTranspObj, &lBusyEvents);                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */
    Dcm_NetRxPrioritisationProcessLoosers(lBusyEvents);
  }
}

/**********************************************************************************************************************
 *  Dcm_NetTaskTx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskTx(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_NET_TX_SEND_USDT))
  {
    {
      Dcm_CfgNetTObjHandleOptType lTObjIter;

      /* find candidate for NRC 0x21 or final response */
      for (lTObjIter = 0; lTObjIter < Dcm_PbCfgNetNumTransportObjects; ++lTObjIter)
      {
        Dcm_NetTransportObjectPtrType pTranspObj;
        pTranspObj = Dcm_NetGetTransportObject(lTObjIter);

#if (DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
        if ((pTranspObj->State == DCM_NET_TOBJ_STATE_RX_END) /* Completely received ... */
          && ((DCM_NET_TOBJ_FLAG_BUSY & pTranspObj->Flags) != 0u))/* ... a parallel request */
        {
          /* Send NRC 0x21 response */
          Dcm_NetComposeAddNegResponse(pTranspObj, DCM_NET_TOBJ_RESTYPE_SIMPLE, DCM_E_BUSYREPEATREQUEST);                                            /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        }
#endif

        if (pTranspObj->State == DCM_NET_TOBJ_STATE_PREPTX)
        {
          Dcm_NetTransmitUsdtResponse(pTranspObj);                                                                                                   /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        }
      }
    }
  }

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_NET_TX_SEND_UUDT))
  {
    Dcm_CfgNetPTxObjHandleOptType lPerTxObjIter;

    for (lPerTxObjIter = 0; lPerTxObjIter < Dcm_NetPeriodicMsgGetNextMsgHdl(); lPerTxObjIter++)
    {
      if (Dcm_NetGetPeriodicTxObject(lPerTxObjIter)->State == DCM_NET_PERIODIC_TX_STATE_QUEUED)
      {
        Dcm_NetPeriodicMsgTransmitTxObj(lPerTxObjIter);
      }
    }
  }
#endif
}

/**********************************************************************************************************************
 *  Dcm_NetRegisterComMActivity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetRegisterComMActivity(
  Dcm_NetTransportObjectPtrType pTranspObj                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) == 0u)/* internal requests do not manage the ComM activity */
#endif
  {
    Dcm_CfgNetNetIdRefMemType lNetHandle;
    Dcm_NetComMContextPtrType pComMContext;

    lNetHandle   = Dcm_PbCfgNetConnectionInfo[pTranspObj->ConnHdl].NetworkIdRef;
    pComMContext = Dcm_NetGetComMContext(lNetHandle);

    Dcm_DebugAssert((pComMContext->RegisteredNetworks != Dcm_UtiMaxValueOfUintType(Dcm_NetConnRefMemType)), DCM_SID_INTERNAL, DCM_E_PARAM);          /* COV_DCM_RTM_DEV_DEBUG XF */

    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    if(pComMContext->RegisteredNetworks == 0u)
    {
      /* activate only if default session is active, otherwise already active */
      if(   Dcm_StateIsDefaultSessionActive()
        && (Dcm_SingletonContext.Network.ActiveDiagnostic == DCM_NET_COMM_ACTIVE)
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
        && (Dcm_SingletonContext.Network.KeepAlive == FALSE)
#endif
        )
      {
        /* Register one connection */
        ComM_DCM_ActiveDiagnostic(Dcm_PbCfgNetAllComMChannelMap[Dcm_PbCfgNetConnComMChannelMap[lNetHandle]]);
      }
    }

    /* Register one connection */
    ++pComMContext->RegisteredNetworks;                                                                                                              /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiLeaveCriticalSection();
  }
}

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterComMActivity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterComMActivity(
  Dcm_NetConnRefMemType connHdl
  )
{
  Dcm_CfgNetNetIdRefMemType lNetHandle;
  Dcm_NetComMContextPtrType pComMContext;

  lNetHandle   = Dcm_PbCfgNetConnectionInfo[connHdl].NetworkIdRef;
  pComMContext = Dcm_NetGetComMContext(lNetHandle);

  Dcm_DebugAssert((pComMContext->RegisteredNetworks != 0u), DCM_SID_INTERNAL, DCM_E_PARAM);                                                          /* COV_DCM_RTM_DEV_DEBUG XF */

  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Unregister one connection */
  --pComMContext->RegisteredNetworks;                                                                                                                /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */

  if(pComMContext->RegisteredNetworks == 0u)
  {
    /* return only if default session is active */
    if (Dcm_StateIsDefaultSessionActive()
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
       &&(Dcm_SingletonContext.Network.KeepAlive == FALSE)
#endif
       )
    {
      ComM_DCM_InactiveDiagnostic(Dcm_PbCfgNetAllComMChannelMap[Dcm_PbCfgNetConnComMChannelMap[lNetHandle]]);
    }
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiLeaveCriticalSection();
}

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterAllComMActivity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterAllComMActivity(
  void
  )
{
  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  {
    Dcm_CfgNetNetIdRefOptType lNetHandleIter;
    for(lNetHandleIter = 0; lNetHandleIter < Dcm_PbCfgNetNumComMChannels; ++lNetHandleIter)
    {
      /* unregister only if no connection is ongoing */
      if(Dcm_PbRamNetComMContext[lNetHandleIter].RegisteredNetworks == 0u)
      {
        ComM_DCM_InactiveDiagnostic(Dcm_PbCfgNetAllComMChannelMap[Dcm_PbCfgNetConnComMChannelMap[lNetHandleIter]]);
      }
    }
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiLeaveCriticalSection();
}

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterActiveConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterActiveConnection(
  Dcm_NetTransportObjectPtrType pTranspObj
  )
{
#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if ((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) != 0u)
  {
# if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
    Dcm_ExtSvc86TxEnd();
# endif
  }
  else
#endif
  {
    Dcm_DebugAssert((Dcm_SingletonContext.Network.NumActiveConnections != 0u), DCM_SID_INTERNAL, DCM_E_PARAM);                                       /* COV_DCM_RTM_DEV_DEBUG XF */

    Dcm_UtiEnterCriticalSection();
    /*=================================*
     BEGIN CRITICAL SECTION
     *=================================*/
    /* Start the idle connection timer for the authenticated session connection */
#if (DCM_AUTHMGR_DEFAULT_SESSION_TIMEOUT_ENABLED == STD_ON)
    /* Check if authentication restriction is supported for this connection */
    if (Dcm_NetGetAuthInfoRef(pTranspObj->ConnHdl) != DCM_AUTHMGR_INVALID_AUTH_INFO_REF)
    {
      Dcm_AuthMgrTimerStart(Dcm_NetGetAuthInfoRef(pTranspObj->ConnHdl), DCM_AUTHMGR_DEFAULT_SESSION_TIMEOUT);
    }
#endif

    /* If this was not a functional request from different tester with 0x3E 0x80 or a denied parallel tester request */
    if ((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_IGNORE) == 0u)
    {
      /* The timers shall be restarted later with the original timer values (when the last connection goes inactive) */
      Dcm_TmrSetTimer(DCM_TMR_ID_S3, DCM_DIAG_TIME_S3);
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
      Dcm_TmrSetTimer(DCM_TMR_ID_KEEP_ALIVE, DCM_NET_KEEP_ALIVE_TIME);
#endif
    }

    /* Un-register an active connection */
    --Dcm_SingletonContext.Network.NumActiveConnections;

    if(Dcm_SingletonContext.Network.NumActiveConnections == 0u)
    {
      /* Start or resume the S3 timer and keep-alive timer with the last set values */
      Dcm_TmrResumeTimer(DCM_TMR_ID_S3);
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
      Dcm_TmrResumeTimer(DCM_TMR_ID_KEEP_ALIVE);
#endif
    }

    /*=================================*
     END CRITICAL SECTION
     *=================================*/
    Dcm_UtiLeaveCriticalSection();
  }
  Dcm_NetTranspObjRelease(pTranspObj);                                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_NetAllocateOrGetTranspObject()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetAllocateOrGetTranspObject(
  Dcm_NetConnRefOptType connHdl,
  CONSTP2VAR(Dcm_NetTransportObjectPtrType, AUTOMATIC, AUTOMATIC) pTranspObj
  )
{
  BufReq_ReturnType lResult = BUFREQ_E_NOT_OK; /* No free transport object found */

  if(Dcm_DebugDetectRuntimeError(connHdl >= Dcm_PbCfgNetNumConnections))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    if(Dcm_PbRamNetConnHdl2TObjMap[connHdl] >= DCM_NET_INVALID_TOBJID)/* check if already assigned */
    {
      Dcm_CfgNetTObjHandleOptType lTObjIter;

      for(lTObjIter = 0; lTObjIter < Dcm_PbCfgNetNumTransportObjects; ++lTObjIter)
      {
        if(Dcm_PbRamNetTransportObject[lTObjIter].State == DCM_NET_TOBJ_STATE_FREE)
        {
          Dcm_NetPutToConn2TObjMap(connHdl, (Dcm_CfgNetTObjHandleMemType)lTObjIter); /* Assign ownership information */
          *pTranspObj = Dcm_NetGetTransportObject(lTObjIter);                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
          lResult = BUFREQ_OK;
          break;
        }/* Transport Object is in use - check next one */
      }
    }
    else
    {
      *pTranspObj = Dcm_NetGetTransportObject(Dcm_PbRamNetConnHdl2TObjMap[connHdl]);                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
      lResult = BUFREQ_OK;
    }
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetGetTranspObjOfConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetGetTranspObjOfConnection(
  Dcm_NetConnRefOptType connHdl,
  CONSTP2VAR(Dcm_NetTransportObjectPtrType, AUTOMATIC, AUTOMATIC) pTranspObj
  )
{
  BufReq_ReturnType lResult = BUFREQ_E_NOT_OK;

  if(Dcm_DebugDetectRuntimeError(connHdl >= Dcm_PbCfgNetNumConnections))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    if(Dcm_PbRamNetConnHdl2TObjMap[connHdl] < DCM_NET_INVALID_TOBJID)
    {
      *pTranspObj = Dcm_NetGetTransportObject(Dcm_PbRamNetConnHdl2TObjMap[connHdl]);                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
      lResult = BUFREQ_OK;
    }
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetTranspObjRelease()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTranspObjRelease(
  Dcm_NetTransportObjectPtrType pTranspObj
  )
{
  /* If the transport object is still in use: */
  if(pTranspObj->State != DCM_NET_TOBJ_STATE_FREE) /* assure the object has validly initialized fields */
  {
    /* Its states are valid and can be used if needed */
    /* Reset only the relevant states of the transport object */
    Dcm_NetPutToConn2TObjMap(pTranspObj->ConnHdl, DCM_NET_INVALID_TOBJID); /* Clear the ownership information */
    pTranspObj->ResType  = DCM_NET_TOBJ_RESTYPE_NONE;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    pTranspObj->Flags    = DCM_NET_TOBJ_FLAG_NONE;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    /* Reset the guard state (object in use) at last to avoid critical section usage */
    pTranspObj->State    = DCM_NET_TOBJ_STATE_FREE;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */

  }
  /* Otherwise nothing to do */
}

/**********************************************************************************************************************
 *  Dcm_NetGetConnHdlByTesterAddress()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_NetConnRefMemType, DCM_CODE) Dcm_NetGetConnHdlByTesterAddress(
  uint16 testerAddress
  )
{
  Dcm_NetConnRefOptType lConnIter;
  Dcm_NetConnRefMemType lResult = DCM_NET_INVALID_CONNHDL;

  for(lConnIter = 0; lConnIter < Dcm_PbCfgNetNumConnections; ++lConnIter)
  {
    if (testerAddress == Dcm_PbCfgNetConnectionInfo[lConnIter].ClientSrcAddr)
    {
      lResult = (Dcm_NetConnRefMemType)lConnIter;
      break;
    }
  }
  return lResult;
}

#if ((DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON) && (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)) || \
    (DCM_AUTHMGR_SET_DEAUTH_ROLE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetGetConnHdlByConnectionId()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_NetConnRefMemType, DCM_CODE) Dcm_NetGetConnHdlByConnectionId(
  uint16 connectionId
  )
{
  Dcm_NetConnRefOptType lConnIter;
  Dcm_NetConnRefMemType lResult = DCM_NET_INVALID_CONNHDL;

  for(lConnIter = 0; lConnIter < Dcm_PbCfgNetNumConnections; ++lConnIter)
  {
    if(connectionId == Dcm_PbCfgNetConnectionInfo[lConnIter].ConnectionId)
    {
      lResult = (Dcm_NetConnRefMemType)lConnIter;
      break;
    }
  }
  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetUsdtTxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUsdtTxConfirmation(
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_NetTransmissionResultType result
  )
{
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) != 0u)
  {
    Dcm_NetBufferContextPtrType pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
    Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                               /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    /* ComM is already released in the DiagPostProcessing task */
    Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    if(pTranspObj->ResType == DCM_NET_TOBJ_RESTYPE_SIMPLE)
    {
#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
      if ((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) == 0u)
#endif
      {
        Dcm_NetUnRegisterComMActivity(pTranspObj->ConnHdl);
      }
      Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      Dcm_DiagOnTxFinished(pTranspObj, result);                                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }
}

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutPeriodicTx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutPeriodicTx(
  Dcm_ThreadIdMemType threadId
  )
{
  Dcm_TmrTimerCntrMemType lReloadTick;
  boolean                 lDoReload;

  DCM_IGNORE_UNREF_PARAM(threadId);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lDoReload = Dcm_OnTimeoutTxObjectHandler();
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  if (!lDoReload)
  {
    lDoReload = Dcm_OnTimeoutDelayTimerHandler();
  }
# endif

  lReloadTick = (Dcm_TmrTimerCntrMemType)((lDoReload == TRUE)?1u:0u);

  return lReloadTick;
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgAllocate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_CfgNetPTxObjHandleMemType, DCM_CODE) Dcm_NetPeriodicMsgAllocate(
  uint16 Did
  )
{
  Dcm_CfgNetPTxObjHandleMemType perTxObjHandle = DCM_NET_INVALID_PTXOBJ_HANDLE;

  /* If all queued messages were sent, reset counters (continue with highest prio UUDT) */
  if(Dcm_NetPeriodicMsgGetNextMsgHdl() == Dcm_NetPeriodicMsgGetTxObjectSentCntr())
  {
    /* Note: No critical section needed to avoid interrupt by Dcm_NetPeriodicMsgRelease because at this point, all
     *       messages are already sent and so no more notification interrupt can occur */
    Dcm_NetPeriodicMsgResetNextMsgHdl();
    Dcm_NetPeriodicMsgResetTxObjectSentCntr();
  }

  /* If there is a message ID left that has a lower priority: */
  if(Dcm_NetPeriodicMsgGetNextMsgHdl() < Dcm_NetPeriodicMsgNumMsgsCurrConnection())
  {
    Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj;

    perTxObjHandle = (Dcm_CfgNetPTxObjHandleMemType)Dcm_NetPeriodicMsgGetNextMsgHdl();
    pPeriodicTxObj = Dcm_NetGetPeriodicTxObject(perTxObjHandle);
    pPeriodicTxObj->State = DCM_NET_PERIODIC_TX_STATE_RESERVED; /* Mark tx object as reserved */                                                     /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
    pPeriodicTxObj->Did = Did; /* Store the DID */                                                                                                   /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
    Dcm_NetPeriodicMsgIncNextMsgHdl(); /* Increment message handle for next message */
  }

  return perTxObjHandle;
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgRelease()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgRelease(
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj
  )
{
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  if (pPeriodicTxObj->State == DCM_NET_PERIODIC_TX_STATE_ONTX)
  {
    Dcm_NetPTxDelayTimerStart(); /* start delay timer */
  }
# endif

  Dcm_NetPTxObjTimerStop(pPeriodicTxObj);                                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
  pPeriodicTxObj->State = DCM_NET_PERIODIC_TX_STATE_FREE;                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */

  Dcm_NetPeriodicMsgIncTxObjectSentCntr(); /* Update sent message statistics */
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgTransmit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgTransmit(
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj,
  PduLengthType length
  )
{
  PduLengthType lLength = length;

  Dcm_DebugAssert((Dcm_NetPeriodicMsgGetConnection() < DCM_NET_INVALID_CONNHDL), DCM_SID_INTERNAL, DCM_E_PARAM);                                     /* COV_DCM_RTM_DEV_DEBUG XF */

# if (DCM_NET_PERIODIC_MSG_PADDING_ENABLED == STD_ON)
  if(Dcm_DebugDetectRuntimeError(Dcm_PbCfgNetConnectionInfo[Dcm_NetPeriodicMsgGetConnection()].UudtFrameSize > DCM_NET_PERIODIC_BUFFER_SIZE))        /* COV_DCM_RTM_RUNTIME_CHECK XF */
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    for(; lLength < Dcm_PbCfgNetConnectionInfo[Dcm_NetPeriodicMsgGetConnection()].UudtFrameSize; lLength++)
    {
      pPeriodicTxObj->TxBuffer[lLength] = DCM_NET_PERIODIC_MSG_PADDING_PATTERN;                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
# endif

# if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
  /* In case of generic connection, append the meta data at the end of the paylaod. */
  if(Dcm_NetIsGenericConnection(Dcm_NetPeriodicMsgGetConnection()))
  {
    if(Dcm_DebugDetectRuntimeError(lLength > (PduLengthType)(DCM_NET_PERIODIC_BUFFER_SIZE - DCM_NET_METADATA_LENGTH)))                               /* COV_DCM_RTM_RUNTIME_CHECK XF */
    {
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    }
    else
    {
      pPeriodicTxObj->TxBuffer[lLength] = Dcm_NetGetNodeAddress(Dcm_SingletonContext.Network.PeriodicTxContext.ConnHdlInUse);                        /* SBSW_DCM_PARAM_PTR_WRITE */
      lLength++;
      pPeriodicTxObj->TxBuffer[lLength] = (Dcm_MsgItemType)Dcm_NetPeriodicMsgGetClientSrcAddr();                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
      lLength++;
    }
  }
# endif

  pPeriodicTxObj->TxPduInfo.SduLength = lLength;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
  pPeriodicTxObj->State = DCM_NET_PERIODIC_TX_STATE_QUEUED;                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_UUDT);
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetSetComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetSetComModeEntered(
  NetworkHandleType networkId,
  Dcm_NetComMStateType newComState
  )
{
  /* used to always verify for valid parameter */
  sint16_least lDcmComMHandle = Dcm_UtiLookUpUint8(Dcm_PbCfgNetNetworkHdlLookUp, networkId);                                                         /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  if(lDcmComMHandle >= 0) /* consider only DCM relevant channels */
  {
    Dcm_NetComMContextPtrType pComMContext;

    pComMContext = Dcm_NetGetComMContext((Dcm_CfgNetNetIdRefOptType)lDcmComMHandle);

    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    pComMContext->ComState = newComState;                                                                                                            /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiLeaveCriticalSection();
  }/* else - not a DCM channel -> ignore */
}

/**********************************************************************************************************************
 *  Dcm_NetStartOfReception()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetStartOfReception(
  PduIdType rxPduId,
  P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info,
  PduLengthType tpSduLength,
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr,
  Dcm_NetTransportObjectFlagType addTObjFlags
  )
{
  BufReq_ReturnType lResult = BUFREQ_E_NOT_OK;
  Dcm_NetConnRefMemType lConnHdl = Dcm_NetGetConnHdlOfRxPduId(rxPduId);                                                                              /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
  DCM_IGNORE_UNREF_PARAM(info);                                                                                                                      /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* If the communication state allows any diagnostic request reception (at least SilentCommunicationMode): */
  if( ((DCM_NET_COMM_STATE_FLAG_RX_EN & Dcm_NetGetComStateByConnection(lConnHdl)) != 0u)
#if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
    &&(Dcm_SingletonContext.Network.RxAllowed == TRUE)
#endif
#if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
    &&( (!Dcm_NetIsGenericConnection(lConnHdl))
      ||(Dcm_PbCfgNetRxPduInfo[rxPduId].IsFuncReq == TRUE)
      ||(info->SduDataPtr[DCM_NET_METADATA_TA_OFFSET] == Dcm_PbCfgNetConnectionInfo[lConnHdl].EcuAddress) )
#endif
    )
  {
    Dcm_NetTransportObjectPtrType pTranspObj;

    /* Enter critical section (Reason: Needed only on multi-channel DCM configurations to guarantee the correct
     * transport object allocation and initialization) */
    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    /* Allocate new or get existing, already associated with this DcmRxPduId transport object */
    /* If allocation or getter succeeded: */
    if(Dcm_NetAllocateOrGetTranspObject(lConnHdl, &pTranspObj) == BUFREQ_OK)                                                                         /* SBSW_DCM_POINTER_FORWARD_STACK */
    {
      /* If the transport object is allocated as a new one: */
      if(pTranspObj->State == DCM_NET_TOBJ_STATE_FREE)
      {
        Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;

        pTranspObj->BufferHdl = Dcm_NetGetProtObjOfConnection(lConnHdl)->RxTxBufferRef;                                                              /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        lBufferInfo = Dcm_NetGetBufferInfo(pTranspObj->BufferHdl);

        /* If the request message length fits the Rx-buffer associated with the DcmRxPduId: */
        if(tpSduLength <= lBufferInfo->Size)
        {
          Dcm_NetBufferContextPtrType pBufferContext;

          /* Prepare for positive result or NRC 0x21 response: */
          pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
          /* Prepare result to be reported for the available Rx-buffer size */
          *bufferSizePtr = lBufferInfo->Size;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */

          /* Initialize the transport object */
          pTranspObj->RxPduId  = rxPduId;                                                                                                            /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->ConnHdl   = (Dcm_NetConnRefMemType)lConnHdl;                                                                                   /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */

          /* Set up Rx message context */
          pTranspObj->RxLength = (Dcm_CfgNetBufferSizeMemType)tpSduLength;/* safe cast, since tpSduLength <= bufferSize = value fits Dcm_CfgNetBufferSizeMemType */ /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->BuffPos  = 0u; /* start writing from the buffer begin */                                                                       /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->State    = DCM_NET_TOBJ_STATE_ONRX;                                                                                            /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->Flags    = addTObjFlags;                                                                                                       /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */

#if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
          /* #20 If the transport object uses generic connection, set meta data. */
          if (Dcm_NetIsGenericConnection(lConnHdl))
          {
            /* Source address of the request shall be the target address of the response. */
            pTranspObj->ClientSrcAddr = info->SduDataPtr[DCM_NET_METADATA_SA_OFFSET];                                                                /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          }
          else
#endif
          {
            pTranspObj->ClientSrcAddr = Dcm_PbCfgNetConnectionInfo[lConnHdl].ClientSrcAddr;                                                          /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          }

          /* #30 If the new request can be received - that is: */
          if( Dcm_NetBufferIsFree(pBufferContext) /* Is the buffer free? */
#if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
            &&( ((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) != 0u) /* a default session is/will be active */
              ||( (Dcm_NetGetSessionConnection() == lConnHdl)
                &&(Dcm_NetGetSessionClientSrcAddr() == pTranspObj->ClientSrcAddr) ) /* the owner of the (non-default) session */
              ||(Dcm_NetGetProtObjOfConnection(lConnHdl)->Priority
                < Dcm_NetGetProtObjOfConnection(Dcm_NetGetSessionConnection())->Priority) /* higher priority -> let it through */
              )
#endif
            )
          {
            /* Lock the buffer and allow further request reception */
            pTranspObj->RxData = lBufferInfo->BufferPtr;                                                                                             /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            Dcm_NetBufferLock(pBufferContext); /* the buffer is in use now */                                                                        /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
            lResult = BUFREQ_OK;
          }
#if (DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
          else
          {
            /* Otherwise, prepare for pseudo request reception (only SID and sub-function will be copied) (if multiple client environment enabled) */
            pTranspObj->RxData = &pTranspObj->AddBuffer[1];                                                                                          /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            /* no free "real buffer" object - ignore or simulate reception for NRC 0x21 */
            pTranspObj->Flags |= (Dcm_NetTransportObjectFlagType)(DCM_NET_TOBJ_FLAG_BUSY | DCM_NET_TOBJ_FLAG_COPYHEAD | DCM_NET_TOBJ_FLAG_IGNORE);   /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            lResult = BUFREQ_OK;
          }
#endif
        }
        else
        {
          /* Otherwise, reject the message reception with the result "message too long" */
          lResult = BUFREQ_E_OVFL;
        }

        /* #40 If the message reception is to be continued, register the client connection as active  */
        if(lResult == BUFREQ_OK)
        {
          Dcm_NetRegisterActiveConnection(pTranspObj);                                                                                               /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        }
        else
        {
          /* Otherwise, release the allocated transport object */
          Dcm_NetTranspObjRelease(pTranspObj);/* no further processing needed */                                                                     /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        }
      }/* Otherwise, the transport object is already in use (i.e. parallel request from the same tester):
        *   - reject the message reception */
    }/* Otherwise, no free transport object found (more clients than transport objects configured, legal use case
      * to save resources) - reject the message reception */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    /* Leave critical section */
    Dcm_UtiLeaveCriticalSection();
  } /* Otherwise, reject the message reception */
  return lResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6050, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferExecute()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferExecute(
  Dcm_ContextPtrType pContext,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;                                                                                                          /* PRQA S 2981 */ /* MD_Dcm_RetVal */

  Dcm_UtiResetRuntimeLimiter();

  DCM_UTI_LOOP_FOR_EVER                                                                                                                              /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  {
    Dcm_DiagSvcUpdateFuncType pUpdateFunc;

    pUpdateFunc = Dcm_DiagGetUpdateFunc(pContext->Thread->PagedBuffer.UpdateFuncRef);

    /* Delegate to the page writer */
    lStdResult = pUpdateFunc(pContext
                            ,pContext->Thread->PagedBuffer.OpStatus
                            ,pDataContext
                            ,ErrorCode);                                                                                                             /* SBSW_DCM_CALL_FUNCPTR_SVCUPDATERS */

    if(lStdResult != DCM_E_LOOP)
    {
      break;
    }/* else - just loop again */

    pContext->Thread->PagedBuffer.OpStatus = DCM_INITIAL;                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */

    if (Dcm_UtiRuntimeLimitReached() == TRUE)
    {
      lStdResult = DCM_E_PENDING_LIMITER;
      break;
    }
  }

  return lStdResult;
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCancel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferCancel(
  Dcm_ContextPtrType pContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                lResult = DCM_E_OK;
  Dcm_DiagDataContextType       lDataContext;
  Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;

  /* If page buffer is currently activated: */
  if(pContext->Thread->PagedBuffer.State != DCM_PAGEDBUFFER_STATE_INACTIVE)
  {
    /* If not all data was written by the application: */
    if(pContext->Thread->PagedBuffer.UpdateFinished == FALSE)
    {
      /* Notify the application about the cancellation */
      Dcm_DiagSvcCancelFuncType lCancelFunc = Dcm_DiagGetCancelFunc(pContext->Thread->PagedBuffer.CancelFuncRef);

      /* Initialize the data context */
      lBufferInfo = Dcm_NetGetBufferInfo(pContext->Thread->PagedBuffer.BufferHdl);
      Dcm_UtiInitDataContext(&lDataContext, lBufferInfo->BufferPtr, lBufferInfo->Size);                                                              /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

      lCancelFunc(pContext, &lDataContext);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_CALL_FUNCPTR_SVCCANCELLERS */ /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */
    }

    /* If no transmission was started yet: */
    if(pContext->Thread->PagedBuffer.State == DCM_PAGEDBUFFER_STATE_ACTIVATED)                                                                       /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
    {
      /* Send the appropriate NRC by using the linear buffer if needed */
      *ErrorCode = DCM_DIAG_CANCEL_OP_NRC;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      lResult = DCM_E_NOT_OK;
    }

    /* Reset page buffer state */
    Dcm_PagedBufferInitByThread(pContext->Thread->ThreadId);
    /* Clear any pending events in the Dcm_PagedBufferTask() to avoid any further processing */
    Dcm_TskClrEventByThread(DCM_TSK_ID_PGDBUF, DCM_TSK_EV_ALL_EVENTS, pContext->Thread->ThreadId);
  }

  return lResult;
}
#endif /* (DCM_PAGED_BUFFER_ENABLED == STD_ON) */

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferTask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_PagedBufferTask(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  )
{
  Std_ReturnType               lStdResult;
  Dcm_NetBufferContextPtrType  pBufferContext;
  Dcm_NegativeResponseCodeType lNrc = DCM_E_PANIC_NRC; /* to avoid compiler warnings */

  /* currently no other events are possible to be set for this task -> no need to check any flags */
# if (DCM_TSK_EV_PGDBUF_MSB != 0x01u)
#  error "New events have been added Dcm_PagedBufferTask! Make set event check here!"
# endif

  pBufferContext = Dcm_NetGetBufferContext(pContext->Thread->PagedBuffer.BufferHdl);

  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
    *=================================*/
  /* If any diagnostic job is open: */
  if( ((pContext->Thread->Diag.State & (DCM_DIAG_STATE_PROCESS | DCM_DIAG_STATE_ON_TX)) != 0u)
    && (!Dcm_NetBufferIsFree(pBufferContext)) )                                                                                                      /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX tx tx */
  {
    /* Avoid buffer releasing on asynchronous TxConfirmation with failed status */
    Dcm_NetBufferUsageEnter(pBufferContext);                                                                                                         /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    /*=================================*
      END CRITICAL SECTION
      *=================================*/
    Dcm_UtiLeaveCriticalSection();

    /* Update paged data */
    lStdResult = Dcm_PagedBufferUpdatePage(pContext, &lNrc);                                                                                         /* SBSW_DCM_POINTER_FORWARD_STACK */

    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
      *=================================*/
    Dcm_NetBufferUsageLeave(pBufferContext);                                                                                                         /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */

    /* If the application needs more time: */
    if(lStdResult == DCM_E_PENDING)
    {
      /* If the paged-buffer was not the last user, try getting data again */
      if(!Dcm_NetBufferIsFree(pBufferContext))                                                                                                       /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
      {
        Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_PGDBUF_UPDATE_PAGE);                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      }/* else - buffer is free - no more data is to be expected */
    }/* else - that is all */
    /*=================================*
      END CRITICAL SECTION
      *=================================*/
    Dcm_UtiLeaveCriticalSection();

    if (lStdResult == DCM_E_NOT_OK)
    {
      Dcm_SetNegResponse(lNrc, pContext->Thread->ThreadId);
      Dcm_ProcessingDone(pContext->Thread->ThreadId);
    }
  }
  else
  {
    /*=================================*
    END CRITICAL SECTION
    *=================================*/
    Dcm_UtiLeaveCriticalSection();
  }
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_PagedBufferStart(
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_MsgLenType resDataLen
  )
{
  Dcm_ThreadContextPtrType pThreadContext = Dcm_GetThreadContext(pMsgContext->threadId);

  /* Once multiple multi frame response started, can not be started again */
  Dcm_DebugAssert((pThreadContext->PagedBuffer.State == DCM_PAGEDBUFFER_STATE_INACTIVE), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                     /* COV_DCM_RTM_DEV_DEBUG XF */
  /* No multiple multi frame response if a NRC has been already registered */
  Dcm_DebugAssert((pThreadContext->Diag.ErrorRegister == DCM_E_OK), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                          /* COV_DCM_RTM_DEV_DEBUG XF */

  /*  Initialize paged-buffer response transmission */
  pThreadContext->PagedBuffer.UpdateFuncRef  = Dcm_CfgDiagServiceInfo[pThreadContext->Diag.SidIndex].UpdateFuncRef;                                  /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  pThreadContext->PagedBuffer.CancelFuncRef  = Dcm_CfgDiagServiceInfo[pThreadContext->Diag.SidIndex].CancelFuncRef;                                  /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  pThreadContext->PagedBuffer.BufferHdl      = Dcm_DiagGetTranspObj(pThreadContext)->BufferHdl;                                                      /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  pThreadContext->PagedBuffer.WriteIndex     = (Dcm_CfgNetBufferSizeMemType)(pThreadContext->Diag.MsgContext.resDataLen                              /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
                                                                                + pThreadContext->Diag.MsgContext.resProtHeadLen); /* Write behind SID and the prepared data */
  pThreadContext->PagedBuffer.ReadIndex      = 0u;                                                                                                   /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  pThreadContext->PagedBuffer.RemainingLen   = resDataLen; /* Keep track of response data to be copied */                                            /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  pThreadContext->PagedBuffer.State          = DCM_PAGEDBUFFER_STATE_ACTIVATED;                                                                      /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  pThreadContext->PagedBuffer.UpdateFinished = FALSE;                                                                                                /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  pThreadContext->PagedBuffer.UpdaterDataProvisionState = DCM_PAGEDBUFFER_WAIT_FOR_DATA;                                                             /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  pThreadContext->PagedBuffer.OpStatus       = DCM_INITIAL;                                                                                          /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */

  /*  Calculate total response length, considering any already linearly written data */
  pThreadContext->Diag.MsgContext.resDataLen += (Dcm_MsgLenType)resDataLen;                                                                          /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */

  /*  Initiate paged-data reader */
  Dcm_TskSetEventByThread(DCM_TSK_ID_PGDBUF, DCM_TSK_EV_PGDBUF_UPDATE_PAGE, pMsgContext->threadId);
}
#endif
/**********************************************************************************************************************
 *  Dcm_RepeaterExecute()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_RepeaterExecute(
  Dcm_ContextPtrType pContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;                                                                                                          /* PRQA S 2981 */ /* MD_Dcm_RetVal */

  /* make a backup in case the processor uses the Dcm_RepeaterSetCallee API */
  Dcm_OpStatusType opStatusBckp = pContext->Thread->Repeater.Contexts.OpStatus;

  Dcm_UtiResetRuntimeLimiter();

  DCM_UTI_LOOP_FOR_EVER                                                                                                                              /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  {
    Dcm_CfgDiagServiceInfoPtrType pServiceInfo;

    lStdResult = Dcm_CfgDiagServiceInfoGetEntry(pContext->Thread->Repeater.CalleeIdx, &pServiceInfo, ErrorCode);                                     /* SBSW_DCM_COMB_PTR_FORWARD */

    if (lStdResult == DCM_E_OK)                                                                                                                      /* COV_DCM_RTM_RUNTIME_CHECK TX */
    {
#if (DCM_DIAG_SERVICE_DISPATCHER_ENABLED == STD_ON)
      if(pContext->Thread->Diag.ProcessServiceExtern == TRUE)
      {
        lStdResult = pServiceInfo->AltProcFunc(pContext
                                              ,pContext->Thread->Repeater.Contexts.OpStatus
                                              ,&(pContext->Thread->Diag.MsgContext)
                                              ,ErrorCode);                                                                                           /* SBSW_DCM_CALL_FUNCPTR_SERVICEINFO */
      }
      else
#endif
      {
        lStdResult = pServiceInfo->ProcFunc(pContext
                                           ,pContext->Thread->Repeater.Contexts.OpStatus
                                           ,&(pContext->Thread->Diag.MsgContext)
                                           ,ErrorCode);                                                                                              /* SBSW_DCM_CALL_FUNCPTR_SERVICEINFO */
      }
    }

    if(opStatusBckp == DCM_CANCEL)
    {
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
      if(pContext->Thread->Repeater.Contexts.User == DCM_REPEATER_USER_DEM)
      {
        Dcm_DemAPI_CancelOperation();/* signal to DEM not to expect any further calls */
      }
#endif
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
      Dcm_DidMgrCancelOperation();
#endif
#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
      if(pContext->Thread->Repeater.Contexts.User == DCM_REPEATER_USER_AUTHENTICATION)
      {
        Dcm_AuthMgrCancelOperation();                                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
#endif
      *ErrorCode = DCM_DIAG_CANCEL_OP_NRC;/* always return the cancellation NRC! */                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;/* enforce finalization */
    }

    if(lStdResult != DCM_E_LOOP)
    {
      break;
    }/* else - just loop again */

    Dcm_RepeaterResetOpStatus(pContext);                                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

    if (Dcm_UtiRuntimeLimitReached() == TRUE)
    {
      lStdResult = DCM_E_PENDING_LIMITER;
      break;
    }
  }

  return lStdResult;
}
#if (DCM_MODEMGR_MONITORING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeTaskMonitor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeTaskMonitor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
   DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_MODE_CTRLDTCSETTING_MONITOR_ENABLED == STD_ON)
  /* If activated, monitor DTCsetting related mode-rule fulfillment */
  if( Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_MODE_MON_SVC85) )
  {
    Dcm_ModeMonitorControlDtcSetting(pEventContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
# endif

# if (DCM_MODE_COMMCTRL_MONITOR_ENABLED == STD_ON)
  /* If activated, monitor CommunicationControl related mode-rule fulfillment */
  if( Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_MODE_MON_SVC28) )
  {
    Dcm_ModeMonitorCommunicationControl(pEventContext);                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
# endif
}
#endif

#if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchDtcSetting()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeSwitchDtcSetting(
  Rte_ModeType_DcmControlDtcSetting newMode,
  uint32 DTCGroup,
  uint8 DemClientId
  )
{
  /* execute transition */
  (void)Rte_Switch_DcmControlDtcSetting_DcmControlDtcSetting(newMode);

  DCM_IGNORE_UNREF_PARAM(DTCGroup);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(DemClientId);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Update local states */
  Dcm_ModeSetControlDtcSettingGroup(DTCGroup);
  Dcm_ModeSetControlDtcSettingMode(newMode);

# if (DCM_MODE_CTRLDTCSETTING_MONITOR_ENABLED == STD_ON)
  if(newMode == RTE_MODE_DcmControlDtcSetting_DISABLEDTCSETTING)
  {
    Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.LastDisableDTCClientID = DemClientId;
    Dcm_TskSetEvent(DCM_TSK_ID_MODE_MONITOR, DCM_TSK_EV_MODE_MON_SVC85);
  }
  else
  {
    Dcm_TskClrEvent(DCM_TSK_ID_MODE_MONITOR, DCM_TSK_EV_MODE_MON_SVC85);
  }
# endif
}
#endif

#if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchCommControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeSwitchCommControl(
  Dcm_CfgNetNetIdRefOptType networkRef,
  Dcm_CommunicationModeType newMode
  )
{
  NetworkHandleType lNetwork = Dcm_PbCfgNetAllComMChannelMap[networkRef];

  BswM_Dcm_CommunicationMode_CurrentState(lNetwork, newMode);/* notify BswM */
  Dcm_ModeOnComControlModeChange(lNetwork, Dcm_ModeComCtrlModeMap[newMode]); /* notify the application */

  Dcm_ModeSetCommControlState(networkRef, newMode);

# if (DCM_MODE_COMMCTRL_MONITOR_ENABLED == STD_ON)
  if((newMode & DCM_SVC_28_CTRL_OP_MASK) != 0u)/* operation is with any disabling */
  {
    Dcm_TskSetEvent(DCM_TSK_ID_MODE_MONITOR, DCM_TSK_EV_MODE_MON_SVC28);
  }
  else
  {
    Dcm_TskClrEvent(DCM_TSK_ID_MODE_MONITOR, DCM_TSK_EV_MODE_MON_SVC28);
  }
# endif
}
#endif
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateCheckRID()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_StateCheckRID(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  uint16 rid,
  uint8 ridSubfunc,
  Dcm_CfgStateRefOptType stateRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdReturn;

  /* Get the precondition package for the related diagnostic entity */
  CONSTP2CONST(Dcm_CfgStateDiagStateInfoType, AUTOMATIC, DCM_CONST) pStatePreconditions = &Dcm_StateGetPreconditionStates(stateRef);

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* First verify the diagnostic session pre-condition (UDS verification order) */
  if(!Dcm_StateIsSupportedInSession(*pStatePreconditions))                                                                                           /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
  {
    /* If not met, return appropriate to UDS NRC for the evaluated diagnostic entity (i.e. NRC 0x7F for services, 0x7E for sub-functions etc.) */
    *ErrorCode = Dcm_StateSessionNrcs[DCM_DIAG_CHK_LVL_PARAMETER];                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  /* Otherwise, if supported, verify the authentication requirement (UDS verification order) */
# if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
  if(Dcm_AuthMgrCheckRid(pContext, rid, ridSubfunc, stateRef) == DCM_E_NOT_OK)                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    /* If not met, do return NRC 0x34 */
    *ErrorCode = DCM_E_AUTHENTICATIONREQUIRED;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
  /* Otherwise, if supported, verify the security access level pre-condition (UDS verification order) */
# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  if(!Dcm_StateIsSupportedInSecurityLevel(*pStatePreconditions))
  {
    /* If not met, do return NRC 0x33 (UDS) */
    *ErrorCode = DCM_E_SECURITYACCESSDENIED;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
  {
# if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
    /* Otherwise, if supported, get the the mode-related pre-condition expression(s) result */
    lStdReturn = Dcm_ModeCheck(Dcm_CfgStatePreconditions[stateRef].ModeRuleRef, ErrorCode);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
# else
    /* Otherwise, everything fine - return positive response code */
    lStdReturn = DCM_E_OK;
# endif
  }

  DCM_IGNORE_UNREF_PARAM(rid);                                                                                                                       /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ridSubfunc);                                                                                                                /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return lStdReturn;
}
#endif

/**********************************************************************************************************************
 *  Dcm_StateCheck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_StateCheck(
  Dcm_CfgStateRefOptType stateRef,
  Dcm_DiagCheckLvlType chkLevel,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdReturn;

  /* Get the precondition package for the related diagnostic entity */
  CONSTP2CONST(Dcm_CfgStateDiagStateInfoType, AUTOMATIC, DCM_CONST) pStatePreconditions = &Dcm_StateGetPreconditionStates(stateRef);

  /* First verify the diagnostic session pre-condition (UDS verification order) */
  if(!Dcm_StateIsSupportedInSession(*pStatePreconditions))                                                                                           /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
  {
    /* If not met, return appropriate to UDS NRC for the evaluated diagnostic entity (i.e. NRC 0x7F for services, 0x7E for sub-functions etc.) */
    *ErrorCode = Dcm_StateSessionNrcs[chkLevel];                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  /* Otherwise, if supported, verify the security access level pre-condition (UDS verification order) */
#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  if(!Dcm_StateIsSupportedInSecurityLevel(*pStatePreconditions))
  {
    /* If not met, do return NRC 0x33 (UDS) */
    *ErrorCode = DCM_E_SECURITYACCESSDENIED;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
#endif
  {
#if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
    /* Otherwise, if supported, get the the mode-related pre-condition expression(s) result */
    lStdReturn = Dcm_ModeCheck(Dcm_CfgStatePreconditions[stateRef].ModeRuleRef, ErrorCode);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
#else
    /* Otherwise, everything fine - return positive response code */
    lStdReturn = DCM_E_OK;
#endif
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_StateSetSession()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_StateSetSession(
  Dcm_StateIndexOptType stateRef
  )
{
  Dcm_CfgStateGroupMemType oldSession;

  oldSession = Dcm_SingletonContext.StateMgr.Preconditions.Session;

  /* Commit the new diagnostic session */
  Dcm_SplitTaskEnterCS();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  Dcm_SingletonContext.StateMgr.Preconditions.Session = Dcm_UtiGetBitFromIndex(Dcm_CfgStateGroupMemType, stateRef);
  Dcm_StateSyncPendingSession();
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_SplitTaskLeaveCS();

  /* Notify application for a diagnostic session transition (also for self-transitions e.g. Default->Default): */
  (void)Rte_Switch_DcmDiagnosticSessionControl_DcmDiagnosticSessionControl(Dcm_CfgStateSessionInfo[stateRef].Mode);

  Dcm_StateExecOnStateChangeFunc(Dcm_CfgStateSessionNotificationInfo, Dcm_StateGetSessionValue(Dcm_UtiGetBitPosition(oldSession)), Dcm_StateGetSessionValue(stateRef)); /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  /* If the new session is the default one, reset all related internally handled diagnostic jobs (order irrelevant): */
  if(Dcm_StateIsDefaultSessionActive())
  {
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
    if(Dcm_SingletonContext.Network.KeepAlive == FALSE)
#endif
    {
      Dcm_NetUnRegisterAllComMActivity();
    }

#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
    Dcm_Svc2ASchdStopAll();
#endif
#if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
    Dcm_Svc2FReturnControlToEcu();
#endif
#if(DCM_AUTHMGR_DEFAULT_SESSION_TIMEOUT_ENABLED == STD_ON)
    Dcm_AuthMgrDetectIdleConnection(oldSession);
#endif
  }

  /* On any diagnostic session transition (order irrelevant): */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
  /* Enable DTCsetting in DEM (if ControlDTCsetting service is not supported in current session) */
  Dcm_Svc85OnChangeSession();
#endif
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
  /* Enable communication abilities of application and NM messages (if CommunicationControl service is not supported in current session) */
  Dcm_Svc28OnChangeSession();
#endif
#if (DCM_SVC_86_RST_ON_DSC_ENABLED == STD_ON)
  /* Notify the diagnostic service 0x86 processor (if diagnostic service 0x86 is handled by DCM) */
  Dcm_ExtSvc86OnChangeSession(oldSession, Dcm_SingletonContext.StateMgr.Preconditions.Session);
#endif

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
# if (DCM_STATE_SECURITY_BYPASS_ENABLED == STD_ON)
  if(Dcm_SingletonContext.Diag.IsSecurityBypass == FALSE)
# endif
  {
    /* Reset the security access level back to "locked" (if diagnostic service 0x27 is supported by the ECU configuration) */
    Dcm_StateSetSecurity(0);
  }
#else
# if (DCM_STATE_NOTIFY_SVC_PRO_ENABLED == STD_ON)
  /* Notify all service processors that are interested in a state change */
  Dcm_StateNotifyServiceProcessors();
# endif
#endif
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateSetSecurity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_StateSetSecurity(
  Dcm_StateIndexOptType stateRef
  )
{
  Dcm_CfgStateGroupMemType oldLevel;

  oldLevel = Dcm_SingletonContext.StateMgr.Preconditions.Security;

  /* #10 Commit the new security access level */
  Dcm_SingletonContext.StateMgr.Preconditions.Security = Dcm_UtiGetBitFromIndex(Dcm_CfgStateGroupMemType, stateRef);

  /* #20 Notify application for a security access level transition (only for non-self-transitions e.g. Locked->Level1): */
  if((oldLevel & Dcm_SingletonContext.StateMgr.Preconditions.Security) == 0u) /* consider only non-self transitions (i.e. Locked->Locked) */
  {
    Dcm_SecLevelType               secLev;
# if (DCM_MODE_SECURITY_ACCESS_ENABLED == STD_ON)
    Rte_ModeType_DcmSecurityAccess newMode;

    newMode = (Rte_ModeType_DcmSecurityAccess)((stateRef == 0u)?RTE_MODE_DcmSecurityAccess_LockedLevel
                                                               :Dcm_CfgStateSecurityInfo[stateRef - 1u].Mode);

    /* Notify application */
    (void)Rte_Switch_DcmSecurityAccess_DcmSecurityAccess(newMode);
# endif

    if (oldLevel == (Dcm_UtiMaxValueOfUintType(Dcm_CfgStateGroupMemType) - 1u))  /* Check for transition back from bypass mode */
    {
      secLev = 0;
    }
    else
    {
      secLev = Dcm_UtiGetBitPosition(oldLevel); /* Local variable needed to avoid warnings for side-effects on macro Dcm_StateGetSecurityValue() */
    }
    Dcm_StateExecOnStateChangeFunc(Dcm_CfgStateSecurityNotificationInfo, Dcm_StateGetSecurityValue(secLev), Dcm_StateGetSecurityValue(stateRef));    /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  }
# if (DCM_STATE_NOTIFY_SVC_PRO_ENABLED == STD_ON)
  /* Notify all service processors that are interested in a state change */
  Dcm_StateNotifyServiceProcessors();
# endif
}
#endif
/**********************************************************************************************************************
 *  Dcm_TmrTaskTimer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_TmrTaskTimer(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
  Dcm_TmrMaskOptType    expiredTimers = 0u;
  Dcm_TmrTimerIdOptType timerIter;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#if (DCM_TSK_EV_TIMER_MSB != 0x01u)
# error "New events have been added for Dcm_TmrTaskTimer! Make set event check here!"
#endif
  /* the only event here is the DCM_TSK_EV_TIMER_ACTIVE. If not set, this task will not be called -> no additional event check is necessary */

  /* Enter critical section (Reason: A timer can be modified from an ISR or higher priority task) */
  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Iterate over all system timers: */
  for(timerIter = 0; timerIter < DCM_TMR_NUM_TIMER_CONTEXTS_CASTED; ++timerIter)
  {
    Dcm_TmrTimerContextPtrType pTimerContext = Dcm_TmrGetTimerContext(timerIter);

    expiredTimers <<=1; /* next timer */
    /* If a timer is active (not yet expired or stopped), update its counter (decrement by one) */
    if(Dcm_TmrIsTimerRunning(timerIter))
    {
      pTimerContext->Timer--;                                                                                                                        /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_TIMERCONTEXT */

      if(pTimerContext->Timer == 0u)
      {
        /* If the concrete timer did expire with the above step, register the timerId for later processing */
        expiredTimers |= 0x01u;
        Dcm_TmrSetTimerStopped(timerIter);
      }
      else
      {
        /* Otherwise, signal reactivation of this task again at next main-function cycle, since at least one timer still active */
        pEventContext->PostEv |= DCM_TSK_EV_TIMER_ACTIVE;                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
      }
    }
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  /* Leave critical section */
  Dcm_UtiLeaveCriticalSection();

  /* Iterate over all expired timers only: */
  DCM_UTI_LOOP_BIT_SCAN(expiredTimers)
  {
    --timerIter; /* pre-decrement since the iterator equals at first DCM_TMR_NUM_TIMERS_CASTED */
    if(Dcm_UtiBitOpTest(Dcm_TmrMaskOptType, expiredTimers, 0x01u))
    {
      Dcm_TmrTimerIdOptType   lTimerInfoId;
      Dcm_TmrTimerInfoPtrType lTimerInfo;

      lTimerInfoId = Dcm_TmrGetTimerContext(timerIter)->TimerInfoRef;
      lTimerInfo   = Dcm_TmrGetTimerInfo(lTimerInfoId);

      {
        /* Invoke the associated with the timer "Dcm_OnTimeout*" handler function */
        Dcm_TmrTimerCntrMemType reloadTicks = lTimerInfo->OnTimeoutFunc((Dcm_ThreadIdMemType)(timerIter - lTimerInfo->TimerContextRef));             /* SBSW_DCM_CALL_FUNCPTR_TIMERINFO */
        if(reloadTicks != 0u)                                                                                                                        /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
        {
          /* If the handler requires an immediate reload of the timer, activate the timer immediately */
          Dcm_TmrStartTimerByThread(lTimerInfoId, reloadTicks, (Dcm_ThreadIdMemType)(timerIter - lTimerInfo->TimerContextRef));
        }
      }
    }
  }
}
#if (DCM_DEM_API_421_ENABLED == STD_ON) || (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON)
# if (DCM_DEMAPI_RETVAL_TO_NRC_MAP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DemApiGetNrcForDemRetValue()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_DemApiGetNrcForDemRetValue(
  uint8 demResult,
  Dcm_Uint8ConstDataPtrType demResult2NrcMap
  )
{
  Dcm_NegativeResponseCodeType lNrcResult = DCM_E_PANIC_NRC;
  Dcm_Uint8ConstDataPtrType lDemResult2NrcMap = demResult2NrcMap;

  /* Iterate over the "DEM result to NRC" using increment by two to visit each <key,value> pair */
  while (lDemResult2NrcMap[0] != E_OK)
  {
    /* If a match is found, return the associated NRC */
    if (lDemResult2NrcMap[0] == demResult)
    {
      lNrcResult = lDemResult2NrcMap[1];                                                                                                             /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
      break;
    }
    /* Otherwise return the panic NRC */

    /* Increment by two for next map entry */
    lDemResult2NrcMap = &lDemResult2NrcMap[2];                                                                                                       /* PRQA S 2931 */ /* MD_Dcm_ComputingInvalidPointer */
  }

  /* Check if the DEM has returned an unexpected value (i.e. default case in a switch-case dispatcher) */
  if (Dcm_DebugDetectError(lDemResult2NrcMap[0] == E_OK))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
  }

  /* Return final result (concrete or panic NRC) */
  return lNrcResult;
}
# endif

# if (DCM_DEMAPI_GETNEXTFILTEREDITEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DemApiConvDemRsltGetNextFilteredItem()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DemApiConvDemRsltGetNextFilteredItem(
  Dcm_DemReturnGetNextFilteredItemType demResult,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lDcmResult;
  switch(demResult)
  {
  case DCM_DEM_RET_FILTERED_NO_ITEMS:
    /* If no more items to be reported, signal data ready with eventual data padding */
    lDcmResult = DCM_E_DATA_READY_PADDING; /* signal end of list */
    break;
  case DCM_DEM_RET_FILTERED_PENDING:
    /* If Dem cannot provide next filtered item immediately, signal a retry */
    lDcmResult = DCM_E_PENDING;/* signal end of list */
    break;
  case DCM_DEM_RET_FILTERED_BUFFER_TOO_SMALL:
    /* If Dem cannot provide the data due to a too low buffer allocation, signal buffer overrun */
    lDcmResult = DCM_E_BUFFERTOOLOW;
    break;
  default:
    /* Any other Dem result is treated as an error, thus signal job closing with panic NRC */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);

    lDcmResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  }
  return lDcmResult;
}
# endif

# if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DemApiGetDTCOfOBDFreezeFrame()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DemApiGetDTCOfOBDFreezeFrame(
  uint8 frameNumber,
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) dtc,
  Dem_DTCFormatType dtcFormat
  )
{
  Std_ReturnType lDemResult;
  DCM_IGNORE_UNREF_PARAM(dtcFormat);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lDemResult = Dem_DcmGetDTCOfOBDFreezeFrame(frameNumber
                                            ,dtc
#  if (DCM_DEM_API_421_ENABLED == STD_OFF)
                                            ,dtcFormat
#  endif
                                            );                                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */

  return lDemResult;
}
# endif

# if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DemApiReadDataOfOBDFreezeFrame()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DemApiReadDataOfOBDFreezeFrame(
  uint8 pid,
  uint8 dataElementIndexOfPid,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) destBuffer,
  P2VAR(Dcm_MsgLenType, AUTOMATIC, AUTOMATIC) bufSize
  )
{
  Std_ReturnType lDemResult;

  /* Calculate maximum possible buffer size (reduce by two to compensate the place for PID and FF!) */
#  if (DCM_DEM_API_421_ENABLED == STD_ON)
  uint8 lBufSize;
  lBufSize = (uint8)Dcm_UtiMathMin(*bufSize, 0xFFu);
#  else
  uint16 lBufSize;
  lBufSize = (uint16)Dcm_UtiMathMin(*bufSize, 0xFFFFu);
#  endif

  lDemResult = Dem_DcmReadDataOfOBDFreezeFrame(pid
                                              ,dataElementIndexOfPid
                                              ,destBuffer
                                              ,&lBufSize);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

  *bufSize = lBufSize;                                                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */

  return lDemResult;
}
# endif
#endif /* (DCM_DEM_API_421_ENABLED == STD_ON) || (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON) */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_DIDMGR_DYNDID_DEEP_CHECK_ON_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrDynDidStateCheck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrDynDidStateCheck(
  Dcm_NetConnRefMemType connHdl,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_DidMgrStaticDidStateCheck(connHdl                                                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
                                            ,pDidInfoContext->Did
                                            ,DCM_DIDMGR_OP_READ
                                            ,Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext)->ExecCondRef
                                            ,ErrorCode);

  if (lStdResult == DCM_E_OK)
  {
    if(Dcm_DidMgrIsOpSupported(Dcm_CfgDidMgrGetDidInfo(pDidInfoContext)
                              ,DCM_DIDMGR_OP_DEFINE)) /* for DynDID check source states */
    {
      lStdResult = Dcm_Svc2CStateCheckSrcItems(connHdl
                                              ,(Dcm_CfgDidMgrDynDidHandleMemType)(Dcm_CfgDidMgrGetDidInfo(pDidInfoContext)->OpRef)
                                              ,ErrorCode);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }/* else - ErrorCode already set */

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrCancelOperation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrCancelOperation(
  void
  )
{
  Dcm_RsrcMgrReleaseDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID22);
  Dcm_RsrcMgrReleaseDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID2E);
  Dcm_RsrcMgrReleaseDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID2F);
  /* readPeriodic, readDynamic and RoE scheduler have own cancellation mechanisms */
}

/**********************************************************************************************************************
 *  Dcm_DidMgrInitOpInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrInitOpInfo(
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrOpOptType didOp
  )
{
  Dcm_DidMgrOpOptType lDidOp = didOp;

  pDidInfoContext->Descriptor.DidOpInfoIdx = Dcm_CfgDidMgrGetDidInfo(pDidInfoContext)->OpBaseIdx;                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  /* 0x01 ->0x00 -> already found
   * 0x02 ->0x01 -> iterate once
   * .Etc */
  --lDidOp; /* there is always at least one operation configured */

  /* clear all flags above this operation index (not relevant) */
  lDidOp &= Dcm_CfgDidMgrGetDidInfo(pDidInfoContext)->Operations;

  while(lDidOp != 0u)
  {
    pDidInfoContext->Descriptor.DidOpInfoIdx++;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    lDidOp &= (Dcm_DidMgrOpOptType)(lDidOp - 1u); /* clear the least significant bit set */
  }
}

/**********************************************************************************************************************
 *  Dcm_DidMgrInitOpTypeHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrInitOpTypeHandler(
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
  )
{
  /* Number of operations to be iterated (number signals) */
  pDidOpTypeContext->Base.NumSignals = (Dcm_CfgDidMgrSignalIterMemType)
                                       ( Dcm_CfgDidMgrDidOpClassInfoGetEntry((Dcm_CfgDidMgrDidOpClassHandleOptType)(pDidInfoContext->Descriptor.DidOpClassInfoIdx) + 1u)->OpClassRef
                                       - Dcm_CfgDidMgrDidOpClassInfoGetEntry((Dcm_CfgDidMgrDidOpClassHandleOptType)(pDidInfoContext->Descriptor.DidOpClassInfoIdx) + 0u)->OpClassRef); /* SBSW_DCM_PARAM_PTR_WRITE */ /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */

  /* Start position of the operations to be called */
  pDidOpTypeContext->Base.SignalOpClassInfoRef = Dcm_CfgDidMgrGetDidOpClassInfo(pDidInfoContext)->OpClassRef;                                        /* SBSW_DCM_PARAM_PTR_WRITE */
}
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc(
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_ObdDtcManagerContextPtrType pRepContext                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  uint32                                lDtc;
  uint8                                 dtcStatus;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if (pDataContext->AvailLen >= 2u)
  {
    demResult = Dcm_DemAPI(GetNextFilteredDTC)(
# if (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON)
                                               pRepContext->DemClientId,
# endif
                                               &lDtc, &dtcStatus);                                                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */

    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      Dcm_UtiProvideDataAsU8(pDataContext, Dcm_UtiGetHiLoByte(lDtc));                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_UtiProvideDataAsU8(pDataContext, Dcm_UtiGetLoHiByte(lDtc));                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_LOOP;
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult, ErrorCode);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }
  else
  {
    lStdResult = DCM_E_BUFFERTOOLOW;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrDemSetDTCFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrDemSetDTCFilter(
  uint8 StatusMask,
  Dem_DTCOriginType Origin,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_ObdDtcManagerContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn;
  Dcm_DemReturnSetFilterType resultSetDtcFilter;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  resultSetDtcFilter = Dcm_DemAPI(SetDTCFilter)(
# if (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON)
                                                pRepContext->DemClientId,
# endif
                                                StatusMask
# if (DCM_DEM_API_421_ENABLED == STD_ON)
                                               ,DEM_DTC_KIND_EMISSION_REL_DTCS
# endif
                                               ,DEM_DTC_FORMAT_OBD
                                               ,Origin
                                               ,DCM_DEM_FILTER_WITH_SEVERITY_NO
                                               ,DEM_SEVERITY_NO_SEVERITY
                                               ,DCM_DEM_FILTER_FOR_FDC_NO);

  if(resultSetDtcFilter == DCM_DEM_RET_FILTER_ACCEPTED)
  {
    Dcm_ObdDtcMgrSetNextStep(DCM_OBDDTCMGR_PROGRESS_GETNUMFLTRDDTC, pRepContext);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdReturn = DCM_E_LOOP;
  }
  else
  {/* else - set NRC */
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(resultSetDtcFilter, Dcm_DemApiNrcMapSetDTCFilter);                                                   /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrReadDtcByStatusMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE)Dcm_ObdDtcMgrReadDtcByStatusMask(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_ObdDtcManagerContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;

  switch (Dcm_ObdDtcMgrGetNextStep(pRepContext))                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
  case DCM_OBDDTCMGR_PROGRESS_GETNUMFLTRDDTC:
    lStdResult = Dcm_ObdDtcMgrDemGetNumFltrdDtc(opStatus, pMsgContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_OFF)
  case DCM_OBDDTCMGR_PROGRESS_COPYLINEARDATA:
    lStdResult = Dcm_ObdDtcMgrCopyLinearData(opStatus, pMsgContext, ErrorCode, pRepContext);                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
# endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_TskScheduler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_TskScheduler(
  Dcm_TskTaskPrioMemType tskPrio
  )
{
  Dcm_TskSchedulerContextPtrType pSchedulerContext;
  Std_ReturnType                 lResult;

  lResult = Dcm_TskGetSchedulerContext(tskPrio, &pSchedulerContext);                                                                                 /* SBSW_DCM_POINTER_FORWARD_STACK */

  if (lResult == DCM_E_OK)                                                                                                                           /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    if(pSchedulerContext->SchdIsActive == TRUE)                                                                                                      /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
    {
      Dcm_TskTaskIdOptType  lTaskIter;
      Dcm_TskTaskEvOptType  lEv;

      /*
       * No interrupt protection needed since:
       * If a SetEvent is called and interrupts this assignment, then it sets this flag to true. Two scenarios are possible:
       * - The TRUE signal may be gone - it does not matter since the scheduler is already activated.
       * - The TRUE signal remains - in the worst case the scheduler will be executed once more later but will not have any active tasks.
       */
      pSchedulerContext->SchdIsActive = FALSE; /* per default - no active tasks any more. If any SetEvent executed during the task execution -> the flag will be set again */ /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_WRITE_SCHEDULERCONTEXT */

      for(lTaskIter = 0; lTaskIter < DCM_TSK_NUM_TASKS; ++lTaskIter)
      {
#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
        if(tskPrio == Dcm_TskTaskInfo[lTaskIter].TskPrio)
#endif
        {
          Dcm_ThreadIdOptType lThreadIter;

          for(lThreadIter = 0; lThreadIter < DCM_NUM_THREADS; ++lThreadIter)
          {
            lEv = Dcm_TskGetEventByThread(lTaskIter, lThreadIter);                                                                                   /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */
            if(lEv != DCM_TSK_EV_NONE)
            {
              Dcm_TskExecuteActiveTask(lTaskIter, lEv, lThreadIter);
            }
#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
            if ((Dcm_TskTaskInfo[lTaskIter].TskAtr & DCM_TSK_ATR_THREAD_MULTI) == 0u) /* Single Thread Task */
            {
              break;
            }
#endif
          }
        }
      }
    }
  }
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#if (DCM_TSK_NUM_DIAG_GARB_COL > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagTaskGarbageCollector()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskGarbageCollector(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_TskTaskEvOptType        lEv = pEventContext->Ev;
  Dcm_CfgNetTObjHandleOptType lTObjCntr;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Cleanup or reject all transport objects that never succeeded and are now canceled */
  lTObjCntr = 0;
  DCM_TSK_EVENT_SCAN_LOOP(lEv)
  {
    /* Check who shall be removed */
    if (Dcm_TskIsLocalEventSet(lEv, 0x01u))
    {
      Dcm_NetTransportObjectPtrType pTranspObj;

      pTranspObj = Dcm_NetGetTransportObject(lTObjCntr);
      /* Always unregister ComM activity here, since CANCELED flag will not clean it up!
       * If no RCR-RP on transmission: everything has to be cleaned up here!
       */
      Dcm_NetUnRegisterComMActivity(pTranspObj->ConnHdl);

      /* If just requested, then only this TObject could be the trigger for P2 timer - avoid any RCR-RP transmission */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ) != 0u)
      {
        Dcm_TskClrEventByThread(DCM_TSK_ID_DIAG_TX, DCM_TSK_EV_DIAG_TX_SEND_RCRRP, Dcm_NetGetThreadIdOfTranspObj(pTranspObj));
      }

      Dcm_UtiEnterCriticalSection();
      /*=================================*
       BEGIN CRITICAL SECTION
       *=================================*/
      /* Check if any RCR-RP for this object is on Tx (DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ is excluded since the high-prio
       * Dcm_DiagTaskTx() shall already have switched to ON_TX!) */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_RCRRP_ON_TX) != 0u)
      {
        pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_CANCELED; /* isolate this connection */                                                               /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */

        /* Try cancel any ongoing response. The return value does not matter:
         * OK -> there will be a confirmation for this cancellation
         * N_OK -> request rejected, but there will be a confirmation due to the ongoing transmission
         */
        (void)PduR_DcmCancelTransmit(Dcm_PbCfgNetConnectionInfo[pTranspObj->ConnHdl].TxPduIdMain);
        /* Any RCR-RP will just end with releasing the connection assigned to the tObject!
         * No confirmation post-processing will be performed! */
      }
      else
      {
        Dcm_NetBufferContextPtrType pBufferContext;

        pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
        Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                           /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
        Dcm_NetUnRegisterActiveConnection(pTranspObj); /* no further processing needed */                                                            /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      }
      /*=================================*
       END CRITICAL SECTION
       *=================================*/
      Dcm_UtiLeaveCriticalSection();
    }
    ++lTObjCntr;
  }
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

/**********************************************************************************************************************
 *  Dcm_DiagRcrRpTxFinished()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagRcrRpTxFinished(
  Dcm_NetTransportObjectPtrType pTranspObj,                                                                                                          /* COV_DCM_RTM_NO_RCR_RP_TX */ /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NetTransmissionResultType txStatus
  )
{
  Dcm_ThreadContextPtrType pThreadContext = Dcm_GetThreadContext(Dcm_NetGetThreadIdOfTranspObj(pTranspObj));                                         /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */

  pThreadContext->Diag.TxStatus = txStatus;/* store current Tx state */                                                                              /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */

  pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_NONE;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_ON_TX);                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_UtiBitOpSet(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_SENT);/* mark RCR-RP at least once sent state */        /* SBSW_DCM_PARAM_PTR_WRITE */
  pTranspObj->State   = DCM_NET_TOBJ_STATE_READY;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */

  Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_TX_END_RCRRP, Dcm_NetGetThreadIdOfTranspObj(pTranspObj));  /* Notify for sent RCR_RP */ /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */
}

/**********************************************************************************************************************
 *  Dcm_DiagSetP2Timings()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagSetP2Timings(
  Dcm_StateIndexMemType sesStateIdx,
  Dcm_NetProtRefMemType protocolIdx,
  Dcm_ThreadIdMemType threadId
  )
{
  Dcm_ThreadContextPtrType pThreadContext = Dcm_GetThreadContext(threadId);

  Dcm_UtiEnterCriticalSection();

  /*=================================*
    BEGIN CRITICAL SECTION
    *=================================*/

  /* Calculate the current P2 timings considering the protocol related adjust timings */
  pThreadContext->Diag.P2Timings.P2 = Dcm_DiagGetP2Time(sesStateIdx)
                                    - Dcm_NetGetP2AdjTime(protocolIdx);                                                                              /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */

  pThreadContext->Diag.P2Timings.P2Star = Dcm_DiagGetP2StarTime(sesStateIdx)
                                        - Dcm_NetGetP2StarAdjTime(protocolIdx);                                                                      /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */

  /*=================================*
    END CRITICAL SECTION
    *=================================*/
  Dcm_UtiLeaveCriticalSection();
}

/**********************************************************************************************************************
 *  Dcm_DiagCancelProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagCancelProcessing(
  Dcm_NetTransportObjectPtrType pTranspObj                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
  Dcm_ThreadContextPtrType pThreadContext = Dcm_GetThreadContext(DCM_THREAD_ID_BASIC);
#endif

  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
  if( (Dcm_NetGetThreadIdOfTranspObj(pTranspObj) == DCM_THREAD_ID_BASIC)
    ||((DCM_DIAG_QUEUE_FLAG_IS_WAITING & pThreadContext->Diag.QueuedSet.Flags) == 0u) )
#endif
  {
    Dcm_TmrStopTimerByThread(DCM_TMR_ID_P2, DCM_THREAD_ID_BASIC);
  }

#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
  /* Update diagnostic kernel queue flags: */
  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  Dcm_UtiBitOpSet(Dcm_DiagProcessorFlagType, pThreadContext->Diag.QueuedSet.Flags, DCM_DIAG_QUEUE_FLAG_IS_CANCELING);                                /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiLeaveCriticalSection();
#endif

  Dcm_TskKillAllTasks();
  Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_KILL_JOBS, DCM_THREAD_ID_BASIC);
}

/**********************************************************************************************************************
 *  Dcm_DiagRxIndication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagRxIndication(
  Dcm_NetTransportObjectPtrType pTranspObj                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_ThreadContextPtrType pThreadContext = Dcm_GetThreadContext(Dcm_NetGetThreadIdOfTranspObj(pTranspObj));                                         /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */

  /* #10 Handle OBD requests (SID [0x00-0x0F]) when only one diagnostic client is used */
  if ( (pTranspObj->RxData[0] < 0x10u)
#if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
     &&(Dcm_PbCfgNetNumProtocols == 1u)
#endif
     &&((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) == 0u)
     &&(Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE)                                                                                /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
     )
  {
    /* The number of threads is limited to one, so use basic thread here */
    Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF, DCM_THREAD_ID_BASIC);
    Dcm_DiagSetP2Timings(0, 0, DCM_THREAD_ID_BASIC);
  }

  /* #20 Update diagnostic kernel queue flags: */
  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
    *=================================*/
  pThreadContext->Diag.QueuedSet.Flags |= DCM_DIAG_QUEUE_FLAG_IS_WAITING;                                                                            /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  /*=================================*
    END CRITICAL SECTION
    *=================================*/
  Dcm_UtiLeaveCriticalSection();

  /* #30 Prepare for new diagnostic request processing by setting all relevant for the real-time task properties: */
  Dcm_DiagSetQueuedTranspObj(pThreadContext, pTranspObj);                                                                                            /* SBSW_DCM_COMB_PTR_FORWARD */
  Dcm_TmrStartTimerByThread(DCM_TMR_ID_P2, pThreadContext->Diag.P2Timings.P2, Dcm_NetGetThreadIdOfTranspObj(pTranspObj));                            /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.KeepAlive = TRUE;
#endif

  /* #40 Signal the Dcm_DiagTaskWorker that the request is now ready for processing */
  Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_RX, DCM_TSK_EV_DIAG_RX_NEW_REQ, Dcm_NetGetThreadIdOfTranspObj(pTranspObj));                                /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */
}

/**********************************************************************************************************************
 *  Dcm_DiagTxFinalization()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTxFinalization(
  Dcm_NetTransportObjectPtrType pTranspObj,                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NetTransmissionResultType txStatus
  )
{
  Dcm_ContextType lContext;

  Dcm_InitContext(&lContext, Dcm_NetGetThreadIdOfTranspObj(pTranspObj));                                                                             /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_INIT_CONTEXT */

  lContext.Thread->Diag.TxStatus = txStatus;                                                                                                         /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_WRITE_CONTEXT */
  lContext.Thread->Diag.State    = DCM_DIAG_STATE_POST_PROCESS;                                                                                      /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_WRITE_CONTEXT */

  Dcm_SplitTaskEnterCS();
  /*=================================*
    BEGIN CRITICAL SECTION
    *=================================*/
  Dcm_UtiBitOpClr(Dcm_DiagProcessorFlagType, lContext.Thread->Diag.QueuedSet.Flags, DCM_DIAG_QUEUE_FLAG_IS_ACTIVE);                                  /* SBSW_DCM_POINTER_WRITE_CONTEXT */
  /*=================================*
    END CRITICAL SECTION
    *=================================*/
  Dcm_SplitTaskLeaveCS();

  if(((DCM_DIAG_APPL_NOTIFICATION_FASTPOSTPROCESSOR)& lContext.Thread->Diag.ApplNotification) != 0u)                                                 /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
  {
    Dcm_DiagSvcConfirmationFuncType lFastConfFunc;
    Dcm_ConfirmationStatusType      lConfStatus;

    lFastConfFunc = Dcm_DiagGetPostProcessorFunc(Dcm_CfgDiagServiceInfo[lContext.Thread->Diag.SidIndex].FastConfFuncRef);                            /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
    lConfStatus   = Dcm_DiagGetPostProcessResult(&lContext);                                                                                         /* SBSW_DCM_POINTER_WRITE_CONTEXT */

    /* Execute any internal service processors fast-post-handlers */
    lFastConfFunc(&lContext, lConfStatus);                                                                                                           /* SBSW_DCM_CALL_FUNCPTR_SVCPOSTPROCESSORS */ /* SBSW_DCM_POINTER_WRITE_CONTEXT */
  }

  /* Release the connection */
  if((DCM_NET_TOBJ_FLAG_CANCELED & pTranspObj->Flags) == 0u) /* let the connection expire with the Tx confirmation (after CancelTransmit) */
  {
    Dcm_NetBufferContextPtrType pBufferContext;

    pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
    Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                               /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    Dcm_NetUnRegisterActiveConnection(pTranspObj);/* Start the S3 timer if needed here to have maximum real-time accuracy (from communication bus point of view) */ /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL, Dcm_NetGetThreadIdOfTranspObj(pTranspObj));                       /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagOnFblResTxFinished()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagOnFblResTxFinished(
  Dcm_NetTransportObjectPtrType pTranspObj,                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NetTransmissionResultType txStatus
  )
{
  Dcm_NetBufferContextPtrType pBufferContext;

  pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);

  Dcm_NetBufferRelease(pBufferContext);                                                                                                              /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
  Dcm_NetUnRegisterActiveConnection(pTranspObj);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

  Dcm_SingletonContext.Diag.StartUpFbl.TxStatus = txStatus;
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_FBLRES, DCM_TSK_EV_DIAG_FBLRES_TXCONF);
}
#endif

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutFblRes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutFblRes(
  Dcm_ThreadIdMemType threadId
  )
{
  DCM_IGNORE_UNREF_PARAM(threadId);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_FBLRES, DCM_TSK_EV_DIAG_FBLRES_CANCEL);
  return 0u;
}
#endif

/**********************************************************************************************************************
 *  Dcm_OnTimeoutP2()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutP2(
  Dcm_ThreadIdMemType threadId                                                                                                                       /* COV_DCM_RTM_NO_RCR_RP_TX */
  )
{
  Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_RX, DCM_TSK_EV_DIAG_RX_TMR_P2_TO, threadId);
  return 0u;
}

/**********************************************************************************************************************
 *  Dcm_OnTimeoutS3()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutS3(
  Dcm_ThreadIdMemType threadId
  )
{
  if(!Dcm_StateIsDefaultSessionActive())
  {
    Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF, threadId);
    Dcm_DiagSetP2Timings(0, Dcm_NetGetProtIdOfActiveProtocol(), threadId);

#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
    {
      Dcm_CfgNetAuthInfoRefMemType lAuthInfoRef = Dcm_NetGetAuthInfoRef(Dcm_NetGetSessionConnection());

      if (lAuthInfoRef != DCM_AUTHMGR_INVALID_AUTH_INFO_REF)
      {
        if (Dcm_AuthMgrAuthenticationState(lAuthInfoRef) == DCM_AUTHENTICATED)
        {
          Dcm_AuthMgrTimerExpireMaskSetBit(lAuthInfoRef);
          Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_IDLE_CONN, threadId);
        }
      }
    }
#endif
  }
  return 0u;
}

#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutKeepAlive()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutKeepAlive(
  Dcm_ThreadIdMemType threadId
  )
{
  DCM_IGNORE_UNREF_PARAM(threadId);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(Dcm_StateIsDefaultSessionActive())                                                                                                              /* COV_DCM_RTM_DEPENDS_ON_CFG */
  {
    Dcm_NetUnRegisterAllComMActivity();
  } /* else - ComM activity will be unregistered by S3 timeout */

  Dcm_SingletonContext.Network.KeepAlive = FALSE;

  return 0u; /* No reload */
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagExecIndicationFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagExecIndicationFunc(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_MsgItemType sid,
  Dcm_DiagApplNotificationType notificationType,
  Dcm_CfgDiagNotificationInfoPtrType notifList,
  Dcm_NegativeResponseCodePtrType ErrorCode                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lResult = DCM_E_OK; /* positive case */
  uint16_least   lIter;

  pContext->Thread->Diag.ApplNotification |= notificationType; /* mark application has been notified */                                              /* SBSW_DCM_PARAM_PTR_WRITE */

  /* Prepare for post processing later */
  pContext->Thread->Diag.PostProcessorContext.Sid     = sid;                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  pContext->Thread->Diag.PostProcessorContext.SrcAddr = Dcm_DiagGetTranspObj(pContext->Thread)->ClientSrcAddr;                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  pContext->Thread->Diag.PostProcessorContext.ReqType = (uint8)pContext->Thread->Diag.MsgContext.msgAddInfo.reqType;                                 /* SBSW_DCM_PARAM_PTR_WRITE */

  *ErrorCode = DCM_E_POSITIVERESPONSE;                                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */

  for(lIter = 0u; notifList[lIter].IndFunc != NULL_PTR; ++lIter)                                                                                     /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
  {
    Std_ReturnType               lStdResult;
    Dcm_NegativeResponseCodeType lNrc = DCM_E_POSITIVERESPONSE; /* Initialize out parameter */

    lStdResult = notifList[lIter].IndFunc(sid
                                         ,pContext->Thread->Diag.MsgContext.reqData
                                         ,(uint16)pContext->Thread->Diag.MsgContext.reqDataLen
                                         ,(uint8)pContext->Thread->Diag.MsgContext.msgAddInfo.reqType
                                         ,pContext->Thread->Diag.PostProcessorContext.SrcAddr
                                         ,&lNrc);                                                                                                    /* SBSW_DCM_CALL_FUNCPTR_TERMINATED_LIST */

    if(lStdResult != DCM_E_OK)
    {
      lResult = DCM_E_NOT_OK; /* Mark error, but let other checks to be performed - check for higher priority NOT_ACCEPTED result */

      switch(lStdResult)
      {
      case DCM_E_NOT_OK:
        Dcm_UtiHandleApplNrc(lStdResult, &lNrc, DCM_E_CONDITIONSNOTCORRECT);                                                                         /* SBSW_DCM_POINTER_FORWARD_STACK */
        break;
      case DCM_E_REQUEST_NOT_ACCEPTED:
        lNrc = DCM_E_CONDITIONSNOTCORRECT; /* In DCM_E_REQUEST_NOT_ACCEPTED case no positive response shall be sent! */
        pContext->Thread->Diag.DoSuppressResponse = TRUE; /* Try to suppress, but if an RCR-RP has been already sent - send the registered NRC */    /* SBSW_DCM_PARAM_PTR_WRITE */
        break;
      default:
        /* Unexpected return value */
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
        lNrc = DCM_E_PANIC_NRC;
        break;
      }

      /* Try to register NRC if no other has been set! */
      if (*ErrorCode == DCM_E_POSITIVERESPONSE)
      {
        *ErrorCode = lNrc;                                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      }
    }
  }

  return lResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_ProcessingDone()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ProcessingDone(
  Dcm_ThreadIdOptType threadId
  )
{
  Dcm_ThreadContextPtrType pThreadContext = Dcm_GetThreadContext(threadId);

  /* If positive response to be sent: */
  if(pThreadContext->Diag.ErrorRegister == DCM_E_POSITIVERESPONSE)
  {
    /* If SPRMIB == TRUE (suppression of positive response): */
    if(pThreadContext->Diag.MsgContext.msgAddInfo.suppressPosResponse != 0u)
    {
      /* Mark no response to be sent */
      pThreadContext->Diag.DoSuppressResponse = TRUE;                                                                                                /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
    }/* Otherwise - proceed with positive response transmission */
  }
  else /* Otherwise (negative response): */
  {
    /* If functionally requested diagnostic job: */
    if(pThreadContext->Diag.MsgContext.msgAddInfo.reqType != 0u)
    {
      switch(pThreadContext->Diag.ErrorRegister)
      {
        case DCM_E_SERVICENOTSUPPORTED:
        case DCM_E_SUBFUNCTIONNOTSUPPORTED:
        case DCM_E_REQUESTOUTOFRANGE:
#if (DCM_DIAG_SUPPRESS_NRC_7F_7E_ENABLED == STD_ON)
        case DCM_E_SERVICENOTSUPPORTEDINACTIVESESSION:
        case DCM_E_SUBFUNCTIONNOTSUPPORTEDINACTIVESESSION:
#endif
          /* Suppress negative response for certain NRCs only */
          pThreadContext->Diag.DoSuppressResponse = TRUE;                                                                                            /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
          break;
        default:
          /* Otherwise - proceed with negative response transmission */
          break;
      }
    }/* Otherwise - proceed with negative response transmission */
  }
  /* Update diagnostic sub-component activity state */
  pThreadContext->Diag.State = DCM_DIAG_STATE_ON_TX;                                                                                                 /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */

  /* Notify the transmission task for linear data response transmission/suppression */
  Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_TX, DCM_TSK_EV_DIAG_TX_SEND_LINEAR, threadId);
}

/**********************************************************************************************************************
 *  Dcm_SetNegResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_SetNegResponse(
  Dcm_NegativeResponseCodeType nrc,
  Dcm_ThreadIdOptType threadId
  )
{
  Dcm_ThreadContextPtrType pThreadContext = Dcm_GetThreadContext(threadId);

  if(pThreadContext->Diag.ErrorRegister == DCM_E_POSITIVERESPONSE)
  {
    pThreadContext->Diag.ErrorRegister = nrc;                                                                                                        /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  }
}
/**********************************************************************************************************************
 *  Dcm_DiagTaskRx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskRx(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_NetTransportObjectPtrType pQueuedTObj;

  pQueuedTObj = Dcm_DiagGetQueuedTranspObj(pContext->Thread);

  /* If new request received: */
  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_RX_NEW_REQ))
  {
    /* Initialize related objects */
    pQueuedTObj->State = DCM_NET_TOBJ_STATE_READY;                                                                                                   /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */
    Dcm_DiagResetRcrRpLimiter(pContext);                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    /* Synchronize with diagnostic job processing task */
    Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_NEW_REQ, pContext->Thread->ThreadId);
  }

  /* If P2 timeout detected: */
  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_RX_TMR_P2_TO))
  {
    /* Pre-processing a P2 timeout in oder to cancel the working thread in time (on non-split task configuration) */
#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
    /* If RCR-RP limit reached: */
    if(Dcm_DiagGetRcrRpLimiter(pContext) == 0u)
    {
      /* Reset any RCR-RP related states and notify worker task to initiate job cancellation */
      Dcm_DiagRcrRpTxFinished(pQueuedTObj, DCM_E_NOT_OK);                                                                                            /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */

      /*
       * Signal cancellation to the worker. If worker gets interrupted by this high priority task,
       * while already called "processing done", the cancellation signal will be lost and
       * the final response will be sent at next worker task call.
       */
      Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_CANCEL_OP, pContext->Thread->ThreadId);

      /*
       * Do not send RCR-RP and restart the P2 timer again since the limit has been reached and the worker will
       * finalize the job, once the cancel signal is received.
       */
    }
    else
#endif
    {
#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
      /* Otherwise - update RCR-RP limiter */
      Dcm_DiagDecrementRcrRpLimiter(pContext);                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
#endif
      /* Notify diagnostic transmission task to initiate RCR-RP transmission */
      pQueuedTObj->Flags |= DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ;                                                                                          /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */
      Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_TX, DCM_TSK_EV_DIAG_TX_SEND_RCRRP, pContext->Thread->ThreadId);
    }
  }
}

#if (DCM_TSK_NUM_DIAG_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagTaskFblRes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskFblRes(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  )
{
  /* Check for eventual FBL final response request */
  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_FBLRES_SEND))
  {
    Dcm_DiagFblResDoGetProgCond(pContext, pEventContext);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* If final response required, wait for ComM before sending the response */
  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_FBLRES_WAITTXCOMM))
  {
    Dcm_DiagFblResDoWaitTxComm(pContext, pEventContext);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* Once final FBL response request processed, reset all flags to prevent from a new response at next power-on/reset */
  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_FBLRES_RSTFLAGS))
  {
    Dcm_DiagFblResDoResetFlags(pContext, pEventContext);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* If any FBL final response confirmation received, do the designated job (e.g. session transition) */
  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_FBLRES_TXCONF))
  {
    Dcm_DiagFblResDoProcessTxConfirmation(pContext, pEventContext);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagTaskWorker()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskWorker(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  )
{
  /* Important: this event is a synchronization event between high- and low-priority tasks.
   * Never move this event processing into another task than the one that initiates the new request processing (DCM_TSK_EV_DIAG_WORK_NEW_REQ).
   * Otherwise the clean-up jobs from DCM_TSK_EV_DIAG_WORK_KILL_JOBS event may be performed AFTER the new request processing has been started.
   * This will lead to out of sync of services post- and main-processing!
  */
  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_KILL_JOBS))
  {
    Dcm_DiagWorkerDoCancelProcessing(pContext, pEventContext);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL))
  {
    Dcm_DiagWorkerDoPostProcessing(pContext);                                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_EXT_SET2DEF))
  {
    Dcm_DiagWorkerSetDefSessionExtern(pContext, pEventContext);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF))
  {
    Dcm_StateSetSession(0);
  }

#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_IDLE_CONN))
  {
    Dcm_AuthMgrDeauthenticateIdleConn();
  }
#endif

#if (DCM_AUTHMGR_SET_DEAUTH_ROLE_ENABLED == STD_ON)
  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_EXT_SETROLE))
  {
    Dcm_AuthMgrSetDeauthenticatedRole(pContext, pEventContext);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
#endif

#if (DCM_STATE_SECURITY_BYPASS_ENABLED == STD_ON)
  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_EXT_SETSECBYPASS))
  {
    Dcm_DiagWorkerSetSecurityBypass(pContext, pEventContext);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
#endif

  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_NEW_REQ))
  {
    Dcm_DiagWorkerProcessNewRequest(pContext, pEventContext);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_TX_END_RCRRP))
  {
    Dcm_DiagWorkerProcessRcrRpTxEnd(pContext, pEventContext);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON) && \
    (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_CANCEL_OP))
  {
    Dcm_DiagWorkerCancelOperation(pContext, pEventContext);                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
#endif

  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_REPEAT))
  {
    Dcm_DiagWorkerDoRepeat(pContext, pEventContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}                                                                                                                                                    /* PRQA S 6010, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_DiagTaskTx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskTx(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  )
{
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_TX_SEND_PAGED))
  {
    Dcm_DiagTxPostponeFinalPagedResponse(pContext, pEventContext);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
#endif

  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, (DCM_TSK_EV_DIAG_TX_SEND_PAGED | DCM_TSK_EV_DIAG_TX_SEND_LINEAR)))
  {
    Dcm_DiagTxStartFinalResponse(pContext, pEventContext);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_TX_SEND_RCRRP))
  {
    Dcm_DiagTxStartRcrRpResponse(pContext);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}

#if (DCM_TSK_NUM_DIAG_RECOVERY > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagTaskRecovery()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskRecovery(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_RECOVERY_GETSTATE))
  {
    Std_ReturnType lResult;

    /* Retrieve the recovery information from the application */
    lResult = Dcm_GetRecoveryStates(&Dcm_SingletonContext.Recovery.RecoveryInfo);                                                                    /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

    switch(lResult)
    {
    case DCM_E_OK:
      Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_RECOVERY_PROCESS);                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
      Dcm_SingletonContext.Recovery.OpStatus = DCM_INITIAL;
      break;
    case DCM_E_PENDING:
      /* Retry next time */
      Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_DIAG_RECOVERY_GETSTATE);                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
      break;
    default:
      Dcm_DebugAssert((lResult == DCM_E_NOT_OK), DCM_SID_GETRECOVERYSTATES, DCM_E_INTERFACE_RETURN_VALUE);                                           /* COV_DCM_RTM_DEV_DEBUG XF */
      /* Abort recovering */
      Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_RECOVERY_FINISH);                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      break;
    }
  }

  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_RECOVERY_PROCESS))
  {
    Std_ReturnType   lResult;
    lResult = Dcm_DiagSafeProcessRecoveryInfo(&Dcm_SingletonContext.Recovery.RecoveryInfo
                                             ,Dcm_SingletonContext.Recovery.OpStatus);                                                               /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

    switch(lResult)
    {
    case DCM_E_OK:
      Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_RECOVERY_FINISH);                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      break;
    case DCM_E_PENDING:
      /* Retry next time */
      Dcm_SingletonContext.Recovery.OpStatus = DCM_PENDING;
      Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_DIAG_RECOVERY_PROCESS);                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
      break;
    default: /* DCM_E_NOT_OK */
      /* Abort recovering */
      Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_RECOVERY_FINISH);                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      break;
    }
  }

  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_RECOVERY_FINISH))
  {
# if (DCM_DIDMGR_DYNDID_CLR_ON_STATE_CHG_ENABLED == STD_ON) && \
     (DCM_SVC_2C_NVRAM_SUPPORT_ENABLED == STD_ON)
    Dcm_Svc2COnStateChanged();
# endif
    Dcm_SingletonContext.Network.RxAllowed = TRUE;
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagLookUpFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_DiagLookUpFilter(
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  sint16_least lookUpResult,
  Dcm_VarRefMemPtrType lookUpFilterTable,
  Dcm_DiagCheckLvlType chkLevel,
  Dcm_NegativeResponseCodePtrType errorCode
  )
{
  sint16_least lLookUpResult;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Check if diagnostic object exists in current variant */
  lLookUpResult = Dcm_VarMgrLookUpFilter(lookUpResult, lookUpFilterTable);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* If diagnostic object not supported in current variant at all: */
  if(lLookUpResult < 0)
  {
    /* Set appropriate NRC depending on the diagnostic object type */
    *errorCode = Dcm_DiagObjNotFoundNrcs[chkLevel];                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  /* Otherwise if requested SID is not accessible by the client sent it, exit service validation by sending NRC 0x11 */
  else if( (chkLevel == DCM_DIAG_CHK_LVL_SERVICE_ID)
         &&((Dcm_PbCfgDiagSvcId2ProtMap[lLookUpResult] & Dcm_UtiGetBitFromIndex(Dcm_CfgDiagSvc2ProtMapMemType, Dcm_NetGetProtIdOfMsgContext(pMsgContext))) == 0u) )
  {
    lLookUpResult = -1; /* override result */
    *errorCode = DCM_E_SERVICENOTSUPPORTED;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    /* Otherwise return positive result  */
  }

  return lLookUpResult;
}

#if (DCM_DIAG_SF_ONLY_SERVICE_ENABLED == STD_ON)                                                                                                     /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DiagSvcWithOnlySubFuncReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_DiagSvcWithOnlySubFuncReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  )
{
  DCM_IGNORE_UNREF_PARAM(sfRef);                                                                                                                     /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  return 1u;
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagNoSequenceChecker()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagNoSequenceChecker(
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DiagSubServiceRefOptType subSvcRef,
  Dcm_NegativeResponseCodePtrType ErrorCode                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(subSvcRef);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = DCM_E_OK;

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_DiagSvcWithSubFuncStateCheck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSvcWithSubFuncStateCheck(
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_CfgStateRefOptType stateRef,
  Dcm_DiagSubFuncSequenceCheckerFuncType subFuncSequenceChecker,
  Dcm_DiagSubServiceRefOptType subSvcRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdReturn;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(subFuncSequenceChecker);                                                                                                    /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(subSvcRef);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */


  if(!Dcm_StateIsSupportedInSession(Dcm_StateGetPreconditionStates(stateRef)))
  {
    /* If session is not correct, send NRC 0x7E */
    *ErrorCode = DCM_E_SUBFUNCTIONNOTSUPPORTEDINACTIVESESSION;                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
#if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
  if(Dcm_AuthMgrCheckRole(stateRef, Dcm_AuthMgrGetAuthInfoRef(pMsgContext)) == DCM_E_NOT_OK)
  {
    /* If authentication role is not correct, send NRC 0x34 */
    lStdReturn = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_AUTHENTICATIONREQUIRED;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
#endif
  /* If supported, verify the security access level pre-condition (UDS verification order) */
#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  if(!Dcm_StateIsSupportedInSecurityLevel(Dcm_StateGetPreconditionStates(stateRef)))
  {
    /* If not met, do return NRC 0x33 (UDS) */
    *ErrorCode = DCM_E_SECURITYACCESSDENIED;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
#endif
#if (DCM_DIAG_SF_SEQUENCE_CHECK_SUPPORT_ENABLED == STD_ON)
  if(subFuncSequenceChecker(pMsgContext, subSvcRef, ErrorCode) != DCM_E_OK)                                                                          /* SBSW_DCM_PARAM_FUNCPTR_CALL */
  {
    /* If SF sequence is not correct, ErrorCode already set */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
#endif
  {
#if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
    /* Otherwise, if supported, get the the mode-related pre-condition expression(s) result */
    lStdReturn = Dcm_ModeCheck(Dcm_CfgStatePreconditions[stateRef].ModeRuleRef, ErrorCode);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
#else
    /* Otherwise, everything fine - return positive response code */
    lStdReturn = DCM_E_OK;
#endif
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_DiagVerifyServiceWithSubFunction()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagVerifyServiceWithSubFunction(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_Uint8ConstDataPtrType lookUpTable,
  Dcm_VarRefMemPtrType lookUpFilterTable,
  Dcm_DiagServiceLengthGetterFuncType svcLengthGetter,
  Dcm_DiagSubFuncSequenceCheckerFuncType subFuncSequenceChecker,
  Dcm_DiagSubServiceRefOptPtrType pSubSvcRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  sint16_least   lLookUpResult;
  uint8          sfID = Dcm_UtiGetReqDataAsU8(pMsgContext);                                                                                          /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */

  *pSubSvcRef = 0;                                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */

  /* Min Length already checked in DiagDispatcher and expected to be 1 !!! */
  Dcm_DebugAssert((pMsgContext->reqDataLen > 0u), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                            /* COV_DCM_RTM_DEV_DEBUG XF */

  lLookUpResult = Dcm_DiagLookUpFilter(pMsgContext
                                      ,Dcm_UtiLookUpUint8(lookUpTable, sfID)
                                      ,lookUpFilterTable
                                      ,DCM_DIAG_CHK_LVL_SUBFUNC
                                      ,ErrorCode);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lLookUpResult >= 0)
  {
    /* Mark found position in any case if found */
    *pSubSvcRef = (Dcm_DiagSubServiceRefOptType)lLookUpResult;                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

    /* Check security, sequence, and mode */
    lStdResult = Dcm_DiagSvcWithSubFuncStateCheck(pMsgContext
                                                 ,lookUpFilterTable[lLookUpResult]
                                                 ,subFuncSequenceChecker
                                                 ,*pSubSvcRef
                                                 ,ErrorCode);                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */


    if(lStdResult == DCM_E_OK)                                                                                                                       /* PRQA S 2991, 2995 */ /* MD_Dcm_ConstExpr, MD_Dcm_ConstExpr */
    {
      Dcm_DiagSubServiceLengthType expectedLength;
      expectedLength = svcLengthGetter(*pSubSvcRef);                                                                                                 /* SBSW_DCM_PARAM_FUNCPTR_CALL */

      if( (expectedLength != 0u) /* dynamic length */
        &&(expectedLength != pMsgContext->reqDataLen) ) /* SF + data */
      {
        *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
    /* Extract SF in any case if supported */
    Dcm_UtiConsumeReqData(pMsgContext, 1u);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_UtiProvideResDataAsU8(pMsgContext, sfID);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

    Dcm_DiagSetNewReqBaseToCurProgress(pMsgContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagSetNewResBaseToCurProgress(pMsgContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    /* else - ErrorCode is already set */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050, 6060 */ /* MD_MSR_STCAL, MD_MSR_STPAR */
#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrIsEnabledInActiveVariants()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_VarMgrIsEnabledInActiveVariants(
  Dcm_CfgStateRefOptType cfgVariantRef
  )
{
  boolean lIsEnabled = FALSE;
  Dcm_CfgVarMgrDiagVariantIdOptType varRowIter = Dcm_VarMgrBitSetCalcSize(DCM_VARMGR_NUM_CFG_VARIANTS);

  /* scan all variants (at least 8 way scan) for at least one match */
  while(varRowIter > 0u)
  {
    --varRowIter;
    if((Dcm_PbCfgVarMgrDiagVariantFilter[cfgVariantRef][varRowIter] & Dcm_SingletonContext.VarMgr.ActiveCfgVariants[varRowIter]) != 0u)
    {
      lIsEnabled = TRUE;/* at least one matched variant */
      break;
    }/* else - continue searching */
  }

  return lIsEnabled;
}
#endif

/**********************************************************************************************************************
 *  Dcm_VarMgrLookUpFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_VarMgrLookUpFilter(
  sint16_least lookUpResult,
  Dcm_VarRefMemPtrType lookUpFilterTable
  )
{
  sint16_least lLookUpResult = lookUpResult;
  DCM_IGNORE_UNREF_PARAM(lookUpFilterTable);                                                                                                         /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
  if (lLookUpResult >= 0)
  {
    if (Dcm_VarMgrIsEnabledInActiveVariants(lookUpFilterTable[lLookUpResult]) == FALSE)                                                              /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
    {
      lLookUpResult = -1; /* override result */
    }
  }
#endif

  return lLookUpResult;
}
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_ProcessEcuReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_ProcessEcuReset(
  Dcm_ContextPtrType pContext,
  Rte_ModeType_DcmEcuReset mode,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  /* Try performing mode switch on ECU reset */
  if(Dcm_ModeSwitchEcuReset(mode) == DCM_E_OK)                                                                                                       /* PRQA S 2991, 2995 */ /* MD_Dcm_ConstExpr, MD_Dcm_ConstExpr */
  {
    /* If succeeded, go on with waiting for acknowledge */
    Dcm_RepeaterNextStep(pContext, DCM_SVC11_PROGRESS_ECURST_WAITFORACK);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
    lResult = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    /* If this attempt fails, send back NRC 0x22 to notify diagnostic client */
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */ /* PRQA S 2880 */ /* MD_MSR_Unreachable */
    lResult = DCM_E_NOT_OK;
  }
  return lResult;
}
# endif

# if (DCM_SVC_11_RAPID_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_ProcessRapPwrDwn()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_ProcessRapPwrDwn(
  Dcm_ContextPtrType pContext,
  Rte_ModeType_DcmModeRapidPowerShutDown mode,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  /* Try performing mode switch on ECU reset */
  if(Dcm_ModeSwitchRapidShutDown(mode) == DCM_E_OK)                                                                                                  /* PRQA S 2991, 2995 */ /* MD_Dcm_ConstExpr, MD_Dcm_ConstExpr */
  {
    /* If succeeded, go on with waiting for acknowledge */
    Dcm_RepeaterNextStep(pContext, DCM_SVC11_RAPPWRDWN_WAITFORACK);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    lResult = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    /* If this attempt fails, send back NRC 0x22 to notify diagnostic client */
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */ /* PRQA S 2880 */ /* MD_MSR_Unreachable */
    lResult = DCM_E_NOT_OK;
  }

  return lResult;
}
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc19ReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  )
{
  /* Return sub-function specific length */
  return Dcm_CfgSvc19SubFuncInfo[sfRef].ReqLength;
}
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_19_CHAINING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiChainStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiChainStart(
  Dcm_ContextPtrType pContext,
  P2CONST(Dcm_RepeaterProgressType, AUTOMATIC, DCM_CONST) funcChain,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  pRepContext->FuncChain = funcChain;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_RepeaterNextStep(pContext, *pRepContext->FuncChain);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
  return DCM_E_LOOP;/* execute it immediately */
}
# endif

# if (DCM_SVC_19_CHAINING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiChainNext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiChainNext(
  Dcm_ContextPtrType pContext,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  Dcm_UtiNextItemByPtr(pRepContext->FuncChain, 1u);                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_RepeaterNextStep(pContext, *pRepContext->FuncChain);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
  return DCM_E_LOOP;/* take next item from list */
}
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportDtcByStatusMaskData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportDtcByStatusMaskData(
  Dcm_ContextPtrType pContext,
  Dcm_Svc19DemSetFilterClassType dsfClass,
  Dcm_Svc19DemSetFilterMaskUsageType maskUsage,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;
  uint8 dtcStatusMask;
  uint8 dtcSAM;

  /* Gather the configured DEM Status Availability Mask */
  lStdResult = Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask(&dtcSAM, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == E_OK)
  {
    lStdResult = DCM_E_NOT_OK;

    /* If a requested DTC status mask shall be considered: */
    if(maskUsage == DCM_SVC_19_USE_MASK_REQ)
    {
      Dcm_UtiConsumeReqDataAsU8(pMsgContext, &dtcStatusMask);                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */
      dtcStatusMask &= dtcSAM;

      if(dtcStatusMask == 0u)
      {
        /* If no supported (relevant) status bit remains, omit DEM SetFilter API invokation
         * (i.e. send final positive response only with SAM)
         */
        lStdResult = DCM_E_OK;
      }
      /* Otherwise, prepare a DEM filter to consider relevant DTC status bits */
    }
    else
    {
      /* Otherwise, prepare a DEM filter to report all supported DTCs */
      dtcStatusMask = 0u;
    }

    Dcm_UtiProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* If DEM filtering still required: */
    if(lStdResult != DCM_E_OK)
    {
      lStdResult = Dcm_Svc19UtiDemSetDTCFilter(ErrorCode
                                              ,dsfClass
                                              ,dtcStatusMask
                                              ,0 /* parameter not used */
                                              ,DCM_DEM_FILTER_FOR_FDC_NO
                                              ,pRepContext);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
      if(lStdResult == DCM_E_OK)
      {
        lStdResult = Dcm_Svc19UtiChainStart(pContext, Dcm_Svc19DemChainReadDtcByStatus, pRepContext);                                                /* SBSW_DCM_COMB_PTR_FORWARD */
      }/* Otherwise, Already set by Dcm_Svc19UtiDemSetDTCFilter */
    }/* Otherwise, send the final response with no additional data */
  }/* Otherwise, Already set by Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask */
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6060 */ /* MD_MSR_STPAR */
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportNumDtcByStatusMaskData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportNumDtcByStatusMaskData(
  Dcm_ContextPtrType pContext,
  Dcm_Svc19DemSetFilterClassType dsfClass,
  uint8 dtcStatusMask,
  Dem_DTCSeverityType dtcSeverity,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType           lStdResult;
  uint8                    dtcSAM;
  uint8 lDtcStatusMask = dtcStatusMask;

  /* Gather the configured DEM Status Availability Mask */
  lStdResult = Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask(&dtcSAM, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lStdResult == E_OK)
  {
    Dcm_UtiProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

#  if (DCM_DEM_API_421_ENABLED == STD_ON)
    Dcm_UtiProvideResDataAsU8(pMsgContext, Dcm_DemAPI(GetTranslationType)());                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
#  else
    Dcm_UtiProvideResDataAsU8(pMsgContext, Dcm_DemAPI(GetTranslationType)(pRepContext->DemClientId));                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
#  endif

    lDtcStatusMask &= dtcSAM;
    if (lDtcStatusMask != 0u)
    {
      lStdResult = Dcm_Svc19UtiDemSetDTCFilter(ErrorCode
                                              ,dsfClass
                                              ,lDtcStatusMask
                                              ,dtcSeverity
                                              ,DCM_DEM_FILTER_FOR_FDC_NO
                                              ,pRepContext);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
      if(lStdResult == DCM_E_OK)
      {
        lStdResult = Dcm_Svc19UtiChainStart(pContext, Dcm_Svc19DemChainDtcCount, pRepContext);                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
      }/* Otherwise, Already set by Dcm_Svc19UtiDemSetDTCFilter */
    }
    else
    {
      Dcm_UtiProvideResDataAsU16(pMsgContext, 0);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_OK;
    }
  }/* Otherwise, Already set by Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask */

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6060 */ /* MD_MSR_STPAR */
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportExtDataRecordByDtcNum()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportExtDataRecordByDtcNum(                                                                    /* PRQA S 2889 */ /* MD_Dcm_Optimize_2889 */
  Dcm_ContextPtrType pContext,
  Dem_DTCOriginType dtcOrigin,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  pRepContext->Origin = dtcOrigin;                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */

  Dcm_UtiConsumeReqDataAsU24(pMsgContext, &(pRepContext->Dtc));                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &(pRepContext->RecordNum));                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(pRepContext->RecordNum == DCM_SVC_19_RECNUM_ALL)
  {
    pRepContext->RecordNumList = Dcm_Svc19ExtDataRecords;                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else if(pRepContext->RecordNum == DCM_SVC_19_RECNUM_OBD_ALL)
  {
#  if (DCM_SVC_19_OBD_EXT_RECORD_ENABLED == STD_ON)
    pRepContext->RecordNumList = Dcm_Svc19ExtDataRecordsObd;                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
#  else
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE; /* the ECU does not support any OBD extended data records - reject request */                              /* SBSW_DCM_PARAM_PTR_WRITE */
    return DCM_E_NOT_OK;
#  endif
  }
  else
  {
    /* Single record */
    pRepContext->RecordNumList = NULL_PTR;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  return Dcm_Svc19UtiChainStart(pContext, Dcm_Svc19DemChainReadExtRecords, pRepContext);                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_OCCUR_TIME_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportNumDtcByOccurenceTime()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportNumDtcByOccurenceTime(
  Dcm_ContextPtrType pContext,
  Dem_DTCRequestType dtcReqType,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;
  uint8 dtcSAM;

  /* Gather the configured DEM Status Availability Mask */
  lStdResult = Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask(&dtcSAM, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lStdResult == E_OK)
  {
    Dcm_DemReturnGetDTCByOccurrenceTimeType demResult;

    Dcm_UtiProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

    demResult = Dcm_DemAPI(GetDTCByOccurrenceTime)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON)
                                                   pRepContext->DemClientId,
#  endif
                                                   dtcReqType
                                                  ,&pRepContext->Dtc);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    switch(demResult)
    {
      case DCM_DEM_RET_OCCURR_OK:
        pRepContext->Origin = DEM_DTC_ORIGIN_PRIMARY_MEMORY;                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = Dcm_Svc19UtiChainStart(pContext, Dcm_Svc19DemChainGetDtcStatusEnd, pRepContext);                                                /* SBSW_DCM_COMB_PTR_FORWARD */
        break;
      default:
        *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetDTCByOccurrenceTime);                                               /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
        break;
    }
  }/* Otherwise, Already set by Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask */
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportDtcFFRByDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportDtcFFRByDtc(
  Dcm_ContextPtrType pContext,
  Dem_DTCOriginType dtcOrigin,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext
  )
{
  pRepContext->Origin = dtcOrigin;                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_UtiConsumeReqDataAsU24(pMsgContext, &(pRepContext->Dtc));                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &(pRepContext->RecordNum));                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(pRepContext->RecordNum == DCM_SVC_19_RECNUM_ALL)
  {
    pRepContext->RecordNumList = Dcm_Svc19FFDataRecords;                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    /* Single record */
    pRepContext->RecordNumList = NULL_PTR;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  return Dcm_Svc19UtiChainStart(pContext, Dcm_Svc19DemChainReadFFRByDtc, pRepContext);                                                               /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
# if (DCM_TSK_NUM_SVC27 > 0u)
/**********************************************************************************************************************
 *  Dcm_Svc27Task()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc27Task(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* If the attempt counters should be restored: */
  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_READ))
  {
    /* Process attempt counter reading */
    Dcm_Svc27ReadAttemptCounter(pEventContext);                                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* If the attempt counters should be stored: */
  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_WRITE))
  {
    /* Process attempt counter writing */
    Dcm_Svc27WriteAttemptCounter(pEventContext);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_OnTimeoutSecurityAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSecurityAccess(
  Dcm_ThreadIdMemType threadId
  )
{
  Dcm_TmrTimerCntrMemType lReloadTick = 0u;
  uint8_least             lTmrIter;
# if (DCM_STATE_SEC_RESET_ATT_CNTR_ON_TIMEOUT_ENABLED == STD_ON)
  uint32_least            lJustExpiredMask = 0u;
# endif

  DCM_IGNORE_UNREF_PARAM(threadId);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* For each software timer: */
  for(lTmrIter = 0; lTmrIter < DCM_SVC_27_NUM_DELAY_TIMERS; ++lTmrIter)
  {
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
    /* If delay time is set to infinity: */
    if((boolean)(Dcm_Svc27ReloadReadFailedGet(lTmrIter)) == TRUE)                                                                                    /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
    {
      /* Reload forever */
      lReloadTick = 1u;
    }
    else
# endif
    {
      /* Otherwise, if the software timer is active: */
      if(Dcm_Svc27TimerActive(lTmrIter) == TRUE)                                                                                                     /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
      {
        /* Decrement the timer value */
        Dcm_Svc27TimerSet(lTmrIter, (Dcm_TmrTimerCntrMemType)(Dcm_Svc27TimerGet(lTmrIter) - 1u));

        /* If the software timer is still active */
        if(Dcm_Svc27TimerActive(lTmrIter) == TRUE)                                                                                                   /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
        {
          /* Reload the hardware timer */
          lReloadTick = 1u;
        }
# if (DCM_STATE_SEC_RESET_ATT_CNTR_ON_TIMEOUT_ENABLED == STD_ON)
        else
        {
          /* Otherwise, remember the index of the just expired timer */
          lJustExpiredMask |= Dcm_UtiGetBitFromIndex(uint32_least, lTmrIter);
        }
# endif
      }
    }
  }

# if (DCM_STATE_SEC_RESET_ATT_CNTR_ON_TIMEOUT_ENABLED == STD_ON)
  {
    uint8_least lSecLvlIter;

    /* For each security level */
    for(lSecLvlIter = 0; lSecLvlIter < DCM_STATE_SECURITY_NUM_LEVELS; ++lSecLvlIter)
    {
      /* If the corresponding timer of the given security level is just expired */
      if(Dcm_Svc27TimerJustExpired(lJustExpiredMask, lSecLvlIter) == TRUE)                                                                           /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
      {
        /*
         * Reset the corresponding attempt counter of the given security level (if only single counter used, it will
         * be overwritten multiple times)
         */
        Dcm_Svc27CounterReset(lSecLvlIter);
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
        Dcm_SingletonContext.Diag.Services.Svc27.SetAttCntrEventMask |= Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter);
#  endif
      }
    }
  }

#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  /* If at least one attempt counter was reset */
  if(Dcm_SingletonContext.Diag.Services.Svc27.SetAttCntrEventMask != 0u)
  {
    /* Notify the application about changed attempt counter values */
    Dcm_TskSetEvent(DCM_TSK_ID_SVC27, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_WRITE);
  }
#  endif

# endif

  return lReloadTick;
}

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27UtiSetAttemptCntr()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc27UtiSetAttemptCntr(
  Dcm_OpStatusType opStatus,
  P2VAR(uint32, AUTOMATIC, DCM_VAR_NOINIT) levelMask
  )
{
  uint8_least lSecLvlIter;

  /* For each security level: */
  for (lSecLvlIter = 0u; lSecLvlIter < DCM_CFGSVC27SECLEVELINFO_SIZE; ++lSecLvlIter)
  {
    /* If the attempt counter for that specific security level is not already written: */
    if(Dcm_UtiBitOpTest(uint32, *levelMask, Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter)))
    {
      Dcm_CfgSvc27SecLevelInfoPtrType pSecLevelInfo;
      Std_ReturnType                  lResult;
      Dcm_NegativeResponseCodeType    lNrc;

      lResult = Dcm_CfgSvc27SecLevelInfoGetEntry(lSecLvlIter, &pSecLevelInfo, &lNrc);                                                                /* SBSW_DCM_COMB_PTR_FORWARD */

      if (lResult == DCM_E_OK)                                                                                                                       /* COV_DCM_RTM_RUNTIME_CHECK TX */
      {
        /* Notify the application about the new attempt counter value */
        lResult = pSecLevelInfo->SetAttemptCntrFunc(opStatus, Dcm_Svc27CounterGet(lSecLvlIter));                                                     /* SBSW_DCM_CALL_FUNCPTR_SVC27SECLEVEL */

        if (lResult == DCM_E_PENDING)
        {
          /* Otherwise try it later */
        }
        else
        {
          Dcm_DebugAssert(((lResult == DCM_E_OK) || (lResult == DCM_E_NOT_OK)), DCM_SID_SETSECURITYATTEMPTCOUNTER, DCM_E_INTERFACE_RETURN_VALUE);
          /*
           * If the attempt counter was written successfully or an error occurred, don't try to write the attempt
           * counter again.
           */
          Dcm_SplitTaskEnterCS(); /* Avoid interrupt from Dcm_OnTimeoutSecurityAccess */
          /*=================================*
            BEGIN CRITICAL SECTION
           *=================================*/
          Dcm_UtiBitOpClr(uint32                                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
                         ,*levelMask
                         ,Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter));
          /*=================================*
            END CRITICAL SECTION
           *=================================*/
          Dcm_SplitTaskLeaveCS();
        }
      }
    }
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc27ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc27ReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  )
{
  /* Return sub-function specific length */
  return Dcm_CfgSvc27SubFuncInfo[sfRef].ReqLength;
}

/**********************************************************************************************************************
 *  Dcm_Svc27SubFuncSequenceChecker()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc27SubFuncSequenceChecker(
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DiagSubServiceRefOptType subSvcRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if((Dcm_Svc27IsKeyRequest(subSvcRef) == TRUE)                                                                                                      /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
    &&(Dcm_Svc27IsThisKeyRequestExpected(Dcm_Svc27GetSecLvlRef(subSvcRef)) == FALSE))                                                                /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_REQUESTSEQUENCEERROR;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  return lStdResult;
}
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc28EnableCommunication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc28EnableCommunication(
  void
  )
{
  uint8_least channelIter = Dcm_PbCfgNetNumAllComMChannels;

  while(channelIter != 0u) /* Use top-down counting to be consistent with the Dcm_Svc28ApplyCommControl all-channel calls */
  {
    --channelIter;
    if(Dcm_ModeGetCommControlState(channelIter) != DCM_ENABLE_RX_TX_NORM_NM)
    {
      Dcm_ModeSwitchCommControl(channelIter, DCM_ENABLE_RX_TX_NORM_NM);
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc28OnChangeSession()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc28OnChangeSession(
  void
  )
{
  sint16_least lSidRef = Dcm_UtiLookUpUint8(Dcm_CfgDiagSvcIdLookUpTable, 0x28u);                                                                     /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  if ((Dcm_StateIsDefaultSessionActive())
     ||(!Dcm_StateIsSupportedInSession(Dcm_StateGetPreconditionStates(Dcm_CfgDiagSvcIdExecPrecondTable[lSidRef]))))
  {
    Dcm_Svc28EnableCommunication();
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc28ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc28ReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  )
{
  /* Return sub-function specific length */
  return Dcm_CfgSvc28SubFuncInfo[sfRef].ReqLength;
}
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29CancelOperation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc29CancelOperation(
  void
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  if(Dcm_Svc29IsAsyncCsmJobActive())
  {
    lStdResult = Csm_CancelJob(Dcm_Svc29GetPendingCsmJobId(), CRYPTO_OPERATIONMODE_SINGLECALL);
  }

  Dcm_UtiEnterCriticalSection();
  /*=================================*
  BEGIN CRITICAL SECTION
  *=================================*/
  if(lStdResult == DCM_E_OK)
  {
    if(Dcm_Svc29IsAsyncKeyMJobActive())
    {
      /* No user to the buffer needs to be added, since buffer is not locked by KeyM */
      Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_KEYM_CANCELLED);
    }
    else
    {
      /* Csm job is cancelled, reset the callback processing state to idle */
      Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_IDLE);
    }
  }
  else
  {
    /* Recheck if any Csm job is still active to assure that the callback is not triggered in the meantime */
    if(Dcm_Svc29IsAsyncCsmJobActive())
    {
      /* Cancellation of Csm job not possible, wait for callback */
      Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_CSM_CANCELLED);
      /* Add service 0x29 as user of the buffer to prevent releasing of the buffer since asynchronous Csm job has still locked the buffer */
      Dcm_NetBufferUsageEnter(Dcm_NetGetBufferContext(Dcm_Svc29GetBufferHdl()));                                                                     /* PRQA S 2840, 3387 */ /* MD_Dcm_DerefInvalidPointer, MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    }
    else
    {
      /* Callback is triggered in the meantime, reset the callback processing state to idle */
      Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_IDLE);
    }
  }
  /*=================================*
  END CRITICAL SECTION
  *=================================*/
  Dcm_UtiLeaveCriticalSection();

  /* Reset request sequence */
  Dcm_Svc29ResetSequence();
}

/**********************************************************************************************************************
 *  Dcm_Svc29CertificateStoreVerify()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29CertificateStoreVerify(
  uint8 cocoField,
  uint16 clientCertLength,
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  KeyM_CertDataType lClientCertificate;
  Dcm_Svc29RepeaterProxyContextConstPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc29;

  /* If COCO field equals 0x00 start request processing */
  if(cocoField == 0u)
  {
    /* Create certificate structure from request to be passed on Key Manager */
    lClientCertificate.certDataLength = (uint32)clientCertLength;
    lClientCertificate.certData = Dcm_UtiGetReqData(pMsgContext);

    /* Get Job ID from generated array */
    Dcm_Svc29SetPendingKeyMCertId(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].ConnectionCertificateId);

    /* Store certificate on Key Manager and get operation result */
    lStdResult = Dcm_Svc29KeyMSetCertificate(Dcm_Svc29GetPendingKeyMCertId(), &lClientCertificate, ErrorCode);                                       /* SBSW_DCM_COMB_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)
    {
      /* If certificate storage was sucessfull attemp to verify */
      lStdResult = Dcm_Svc29KeyMVerifyCertificate(pContext, Dcm_Svc29GetPendingKeyMCertId(), ErrorCode);                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
    }/* Otherwise, send the already set NRC */
  }
  /* If COCO field doesnt equal 0x00 send NRC 0x31 and stop looping */
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc29CertificateVerificationDoneHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29CertificateVerificationDoneHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Check for callback result of KeyM */
  lStdResult = Dcm_Svc29ValidateKeyMCbkResult(ErrorCode);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
    /* Provide authenticationReturnParameter with value Ownership Verification Necessary to response buffer */
    Dcm_UtiProvideResDataAsU8(pMsgContext, DCM_SVC29_OWNERSHIP_VERIFICATION_NECESSARY);                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
    /* Generate the server challenge */
    lStdResult = Dcm_Svc29GenerateServerChallenge(pContext, pMsgContext, ErrorCode, pRepContext);                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  } /* else ErrorCode already set */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc29GenerateServerChallenge()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29GenerateServerChallenge(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;
  Std_ReturnType lCsmResult;

  Dcm_Svc29SetPendingCsmJobId(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].RandomJobId);
  Dcm_Svc29SetLengthAsyncCbk(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].EcuChallengeLength);

  /* Provide size of server challenge in response */
  Dcm_UtiProvideResDataAsU16(pMsgContext, (uint16)Dcm_Svc29GetLengthAsyncCbk());                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

  lStdResult = Dcm_UtiMsgContextVerifySize(pMsgContext, Dcm_Svc29GetLengthAsyncCbk(), ErrorCode);                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Check if buffer can hold the server challenge */
  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    /* Set callback processing state to generate challenge */
    Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_GENERATE_CHALLENGE);

    /* Start asynchronous challenge generation */
    lCsmResult = Csm_RandomGenerate(Dcm_Svc29GetPendingCsmJobId()
                                   ,Dcm_UtiGetResData(pMsgContext)
                                   ,&Dcm_Svc29GetLengthAsyncCbk());                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_WRITE_MESSAGE_CONTEXT_RESBUFFER */

    if(lCsmResult == DCM_E_OK)
    {
      /* If async job was accepted change progress state */
      Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_WAITCHALLENGEGEN);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_PENDING;
    }
    /* If async job was rejected send NRC and dont loop */
    else if(lCsmResult == CRYPTO_E_BUSY)
    {
      *ErrorCode = DCM_E_BUSYREPEATREQUEST;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    else
    {
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    }
  }
  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc29ChallengeGenerationDoneHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29ChallengeGenerationDoneHandler(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Validate the callback result */
  lStdResult = Dcm_Svc29ValidateCsmCbkResult(ErrorCode);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Check if ecu challenge length copied succesfully */
  if(lStdResult == DCM_E_OK)
  {
    /* Check if expected challenge length is generated */
    if(Dcm_DebugDetectRuntimeError(Dcm_Svc29GetLengthAsyncCbk() != Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].EcuChallengeLength))          /* COV_DCM_RTM_RUNTIME_CHECK XF */
    {
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    else
    {
      /* Notify message context about server challenge data written from previous async operation */
      Dcm_UtiProvideResData(pMsgContext, Dcm_Svc29GetLengthAsyncCbk());                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */

      switch(pRepContext->SubFuncId)
      {
# if (DCM_SVC_29_01_SUPPORT_ENABLED == STD_ON)
        case DCM_SVC29_SUBFUNC_VERIFY_CERT_UNIDIR:
          lStdResult = Dcm_Svc29FinalizeSequenceStartReq(pMsgContext, ErrorCode);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
          break;
# endif
# if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
        case DCM_SVC29_SUBFUNC_VERIFY_CERT_BIDIR:
          lStdResult = Dcm_Svc29GetServerCertificate(pMsgContext, ErrorCode, pRepContext);                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

          if(lStdResult == DCM_E_OK)
          {
            lStdResult = Dcm_Svc29GenerateSignature(pContext, pMsgContext, ErrorCode, pRepContext);                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
          } /* else ErrorCode already set */
          break;
# endif
        default:
          *ErrorCode = DCM_E_PANIC_NRC;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
          Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
          break;
      }
    }
  } /* else ErrorCode already set */

  return lStdResult;
}

# if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29GenerateSignature()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29GenerateSignature(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;
  Std_ReturnType lCsmResult;

  /* Check if response buffer can hold the proof of ownership length field */
  if (pMsgContext->resMaxDataLen > DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN)
  {
    Dcm_Svc29SetPendingCsmJobId(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].SignClientChallengeJobId);
    /* Provide Csm_SignatureGenerate with all available buffer length (without 2Bytes for the lengthField) */
    Dcm_Svc29SetLengthAsyncCbk((pMsgContext->resMaxDataLen - DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN));

    Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_SIGN_CHALLENGE);

    /* Sign client challenge */
    lCsmResult = Csm_SignatureGenerate(Dcm_Svc29GetPendingCsmJobId()
                                      ,CRYPTO_OPERATIONMODE_SINGLECALL
                                      ,Dcm_SingletonContext.Diag.Services.Svc29.ChallengeSwapBuffer
                                      ,(uint32)Dcm_Svc29GetLengthChallengeSwapBuffer()
                                      ,Dcm_UtiGetResDataRel(pMsgContext, DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN)                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
                                      ,&Dcm_Svc29GetLengthAsyncCbk());                                                                               /* SBSW_DCM_COMB_PTR_FORWARD */ /* SBSW_DCM_POINTER_WRITE_MESSAGE_CONTEXT_RESBUFFER */
    if(lCsmResult == E_OK)
    {
      /* If async job was accepted change progress state and keep looping */
      Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_SUBFUNC02_WAITCHALLENGESIGNED);                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_PENDING;
    }
    /* If async job was rejected send response and dont loop */
    else if(lCsmResult == CRYPTO_E_BUSY)
    {
      *ErrorCode = DCM_E_BUSYREPEATREQUEST;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    else if(lCsmResult == CRYPTO_E_SMALL_BUFFER)
    {
      *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    else
    {
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    }
  }
  /* If res buffer is out of space send NRC and stop looping */
  else
  {
    *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29_02ChallengeSigningDoneHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_02ChallengeSigningDoneHandler(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_Svc29ValidateCsmCbkResult(ErrorCode);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* If callback was successful continue processing: */
  if(lStdResult == DCM_E_OK)
  {
    /* Provide server generated signature data length */
    Dcm_UtiProvideResDataAsU16(pMsgContext, (uint16)Dcm_Svc29GetLengthAsyncCbk());                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    /* Notify message context about server generated signature data written from previous async operation */
    Dcm_UtiProvideResData(pMsgContext, Dcm_Svc29GetLengthAsyncCbk());                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdResult = Dcm_Svc29FinalizeSequenceStartReq(pMsgContext, ErrorCode);                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  } /* else ErrorCode already set */

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc29ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc29ReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  )
{
  return Dcm_CfgSvc29SubFuncInfo[sfRef].ReqLength;
}

/**********************************************************************************************************************
 *  Dcm_Svc29_03RoleRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03RoleRead(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{

  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Verify the verify pointer from the CSM signature verify job */
  if(Dcm_Svc29GetSignatureVerifyResult() == CRYPTO_E_VER_OK)
  {
    /* Read the role from the certificate via KeyM */
    lStdResult = Dcm_AuthMgrGetCertRole(opStatus, ErrorCode, pRepContext);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* If role read from certificate was successful */
    if(lStdResult == DCM_E_OK)
    {
      /* Move on to further processing of service 0x29 */
      Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_SUBFUNC03_SERVICEWHITELISTREAD);                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_LOOP;
    }
  }
  else
  {
    /* CSM signature verify job failed, send NRC 0x58 */
    *ErrorCode = DCM_E_OWNERSHIPVERIFICATIONFAILED;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
/**********************************************************************************************************************
 *  Dcm_Svc29_03ServiceWL()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03ServiceWL(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
  lStdResult = DCM_E_OK;

  /* If white list supported by tester */
  if(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].CertWLServicesId != DCM_AUTHMGR_INVALID_WL_KEYM_ELEMENT_ID)
  {
    /* Read elements from Service white list */
    lStdResult = Dcm_AuthMgrServiceWLReadList(pRepContext, ErrorCode);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(lStdResult == DCM_E_OK)
# else
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
# endif
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_SUBFUNC03_DIDWHITELISTREAD);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc29_03DidWL()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03DidWL(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_AUTHMGR_WHITELIST_DID_ENABLED == STD_ON)
  lStdResult = DCM_E_OK;

  /* If white list supported by tester */
  if(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].CertWLDidId != DCM_AUTHMGR_INVALID_WL_KEYM_ELEMENT_ID)
  {
    lStdResult = Dcm_AuthMgrDidWLReadList(pRepContext, ErrorCode);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  if(lStdResult == DCM_E_OK)
# else
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
# endif
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_SUBFUNC03_RIDWHITELISTREAD);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc29_03RidWL()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03RidWL(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_AUTHMGR_WHITELIST_RID_ENABLED == STD_ON)
  lStdResult = DCM_E_OK;

  /* If white list supported by tester */
  if(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].CertWLRidId != DCM_AUTHMGR_INVALID_WL_KEYM_ELEMENT_ID)
  {
    lStdResult = Dcm_AuthMgrRidWLReadList(pRepContext, ErrorCode);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  if(lStdResult == DCM_E_OK)
# else
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
# endif
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_SUBFUNC03_MEMWHITELISTREAD);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc29_03MemWL()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03MemWL(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_AUTHMGR_WHITELIST_MEM_ENABLED == STD_ON)
  lStdResult = DCM_E_OK;

  /* If white list supported by tester */
  if (Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].CertWLMemId != DCM_AUTHMGR_INVALID_WL_KEYM_ELEMENT_ID)
  {
    lStdResult = Dcm_AuthMgrMemWLReadList(pRepContext, ErrorCode);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if (lStdResult == DCM_E_OK)
# else
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
# endif
  {
    /* Set connection state to authenticated */
    pRepContext->ConnContext.AuthState = DCM_AUTHENTICATED;                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */

    /* Provide authenticationReturnParameter with authentication complete */
    Dcm_UtiProvideResDataAsU8(pMsgContext, DCM_SVC29_OWNERSHIP_VERIFIED_AUTHENTICATION_COMPLETE);                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Provide session key info length field */
    Dcm_UtiProvideResDataAsU16(pMsgContext, (uint16)0x00);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Change to next processing state and loop over */
    Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_PERSIST_AUTHENTICATION);                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc29_03PersistAuthentication()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03PersistAuthentication(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdReturn = DCM_E_OK;                                                                                                              /* PRQA S 2981 */ /* MD_Dcm_RetVal */
# if (DCM_AUTHMGR_PERSIST_STATE_ENABLED == STD_ON)
  Std_ReturnType lModeCheck = DCM_E_OK;
# endif

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_AUTHMGR_PERSIST_STATE_ENABLED == STD_ON)
  if (opStatus == DCM_INITIAL)
  {
    /* Write authentication state to NvM if mode rule is activated. */
    lModeCheck = Dcm_ModeCheck(DCM_MODE_AUTH_PERSIST_STATE_MODERULE_REF, ErrorCode);                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if (lModeCheck == DCM_E_OK)
  {
    /* Trigger NvM to write the corresponding block */
    lStdReturn = Dcm_UtiNvMWrite(opStatus
                                ,&pRepContext->ConnContext                                                                                           /* PRQA S 0315 */ /* MD_MSR_Dir1.1 */ /* SBSW_DCM_SVC29_NV_ACCESS */
                                ,Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].NvMBlockId);

    if (lStdReturn == DCM_E_NOT_OK)
    {
      /* NvM storage failed */
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  if (lStdReturn == DCM_E_OK)
# endif
  {
# if(DCM_AUTHMGR_WHITELISTS_ENABLED == STD_ON)
    Dcm_AuthMgrWLContextPtrType pConnWLContext;

    lStdReturn = Dcm_AuthMgrGetWLContext(pRepContext->AuthInfoHdl, &pConnWLContext, ErrorCode);                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

    if (lStdReturn == DCM_E_OK)                                                                                                                      /* COV_DCM_RTM_RUNTIME_CHECK TX */
# endif
    {
# if(DCM_AUTHMGR_WHITELISTS_ENABLED == STD_ON)
      *pConnWLContext = pRepContext->ConnContext.WLContext;                                                                                          /* SBSW_DCM_POINTER_WRITE_AUTHNVMDATA */
# endif
      Dcm_AuthMgrUpdateActiveRole(pRepContext->AuthInfoHdl, pRepContext->ConnContext.ActiveRole);
      Dcm_AuthMgrSetAuthentication(pRepContext->AuthInfoHdl, pRepContext->ConnContext.AuthState);

      Dcm_Svc29ResetSequence();
    }
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc29VerifySignature()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29VerifySignature(
  uint16 proofOfOwnershipLength,
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  Std_ReturnType lCsmResult;

  Dcm_Svc29RepeaterProxyContextConstPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc29;

  Dcm_Svc29SetPendingCsmJobId(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].ProofOfOwnershipJobId);
  /* Set callback processing state to verify signature */
  Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_VERIFY_POOW);
  /* Trigger the Csm signature verify job */
  lCsmResult = Csm_SignatureVerify(Dcm_Svc29GetPendingCsmJobId()
                                  ,CRYPTO_OPERATIONMODE_SINGLECALL
                                  ,Dcm_SingletonContext.Diag.Services.Svc29.ChallengeSwapBuffer
                                  ,Dcm_Svc29GetLengthChallengeSwapBuffer()
                                  ,Dcm_UtiGetReqData(pMsgContext)
                                  ,(uint32)proofOfOwnershipLength
                                  ,&Dcm_Svc29GetSignatureVerifyResult());                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_COMB_PTR_FORWARD */

  switch(lCsmResult)
  {
  case E_OK:
    Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_SUBFUNC03_WAITSIGVERIFY);                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_PENDING;
    break;
  case CRYPTO_E_BUSY:
    *ErrorCode = DCM_E_BUSYREPEATREQUEST;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  case CRYPTO_E_SMALL_BUFFER:
    *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  case CRYPTO_E_KEY_NOT_VALID:
    *ErrorCode = DCM_E_OWNERSHIPVERIFICATIONFAILED;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  default:
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }
  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc29SubFuncSequenceChecker()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29SubFuncSequenceChecker(
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DiagSubServiceRefOptType subSvcRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(subSvcRef);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(Dcm_UtiGetReqDataAsU8(pMsgContext) == DCM_SVC29_SUBFUNC_PROOF_OF_OWNERSHIP)                                                                     /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */
  {
    if(Dcm_Svc29IsOwnershipRequestExpected())
    {
      if(Dcm_NetGetConnHdlOfRxPduId(Dcm_Svc29GetRxPduId()) != Dcm_NetGetConnHdlOfRxPduId(pMsgContext->rxPduId))
      {
        /* This causes NRC 0x22 to be sent back */
        lStdResult = DCM_E_NOT_OK;
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
      }/* else return DCM_E_OK */
    }
    else
    {
      /* This causes NRC 24 to be sent back. Wrong sequence */
      lStdResult = DCM_E_NOT_OK;
      *ErrorCode = DCM_E_REQUESTSEQUENCEERROR;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }/* else return DCM_E_OK */

  return lStdResult;
}
#endif /* (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
# if (DCM_TMR_NUM_SVC2A_SCHEDULER > 0u)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSvc2AScheduler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSvc2AScheduler(
  Dcm_ThreadIdMemType threadId
  )
{
  Dcm_TmrTimerCntrMemType lReturn = 0;

  DCM_IGNORE_UNREF_PARAM(threadId);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
    boolean doActivateProcessorTask;

    doActivateProcessorTask = Dcm_Svc2ASchdUpdateTimers();

    if(doActivateProcessorTask == TRUE)
    {
      Dcm_TskSetEvent(DCM_TSK_ID_SVC2A_SCHEDULER, DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS);/* at least one job to do */
    }
    lReturn = 1u;/* immediate timeout in next slot */
  }/* else - a NOP activate - will be the last one */
  return lReturn;/* no reload */
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2ATaskSchdProcess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ATaskSchdProcess(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
  /* scheduler timer update is done in a dedicated task to achieve maximum timing accuracy */
# else
  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_SVC2A_SCHEDULER_TMR_UPD))
  {
    boolean doActivateProcessorTask;

    if(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
    {
      doActivateProcessorTask = Dcm_Svc2ASchdUpdateTimers();
      if(doActivateProcessorTask == TRUE)
      {
        Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS);/* let's check which did is in a timeout */                      /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      /* still something to do - keep timer updater alive */
      Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_SVC2A_SCHEDULER_TMR_UPD);                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS))
# endif
  {
    Dcm_Svc2ASchdItemHandleOptType lSchdIter;

    /* loop over all scheduled items (maximum once per task activation) */
    for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
    {
      Dcm_Svc2ASchdEntryPtrType pSchedTableEntry =
        Dcm_Svc2ASchdGetEntry(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex);

      if( (pSchedTableEntry->Timer == 0u)
        &&( (pSchedTableEntry->Rate & DCM_SVC2A_RATE_TYPE_STOPPED) == 0u) )
      {
        Std_ReturnType lStdReturn;

        lStdReturn = Dcm_Svc2ASchdProcessEntry(pSchedTableEntry);                                                                                    /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
        if(lStdReturn == DCM_E_PENDING)
        {
          Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS);                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
          break; /* leave the loop and the task */
        }
      }
      /* next entry to be processed */
      Dcm_Svc2ASchdNextEntryIdxInc();
    }
  }
}
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopAll()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopAll(
  void
  )
{
  if(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
    Dcm_Svc2ASchdItemHandleOptType lSchdIter;

    for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
    {
      Dcm_Svc2ASchdStopItemByHandle(lSchdIter);
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCancelReadByHandle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdCancelReadByHandle(
  Dcm_Svc2ASchdItemHandleOptType schdHandle
  )
{
  if( (Dcm_RsrcMgrHasDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID2A) == TRUE)
    &&(schdHandle == Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex) )
  {
    Dcm_NegativeResponseCodeType lNrc;/* not evaluated after the API call */
    Dcm_DiagDataContextType      lDataContext;

    Dcm_UtiInitDataContext(&lDataContext
                       ,&Dcm_NetPeriodicMsgGetTxBuffer(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle)[1]
                       ,(Dcm_MsgLenType)(DCM_NET_PERIODIC_BUFFER_SIZE - 1u));                                                                        /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

    /* cancel ongoing operation immediately  */
    (void)Dcm_DidMgrReadDid(DCM_CANCEL
                           ,&lDataContext
                           ,&(Dcm_Svc2ASchdGetEntry(schdHandle)->DidContext)
                           ,&(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.DidOpTypeContext)
                           ,&lNrc);                                                                                                                  /* SBSW_DCM_COMB_PTR_FORWARD */

    /* Finish scheduled job */
    Dcm_Svc2ASchdFinishEntryProcessing(FALSE);
  }/* else - nothing to do */
}

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCancelReadByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdCancelReadByDid(
  uint16 did
  )
{
  Dcm_Svc2ASchdItemHandleOptType lSchdHandle = 0u;

  if(Dcm_Svc2ASchdGetItemByDid(did, &lSchdHandle) == TRUE)                                                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    Dcm_Svc2ASchdCancelReadByHandle(lSchdHandle);
  }
}
# endif

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2AGetConnectionOfDID()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_NetConnRefMemType, DCM_CODE) Dcm_Svc2AGetConnectionOfDID(
  uint16 did
  )
{
  Dcm_NetConnRefMemType lConnHdl = DCM_NET_INVALID_CONNHDL;
  Dcm_Svc2ASchdItemHandleOptType lSchdHandle = 0u;

  if(Dcm_Svc2ASchdGetItemByDid(did, &lSchdHandle) == TRUE)                                                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    Dcm_Svc2ASchdEntryConstPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdHandle);
    if(pSchdEntry->Rate < DCM_SVC2A_RATE_TYPE_STOPPED)
    {
      lConnHdl = Dcm_NetPeriodicMsgGetConnection();
    }
  }
  return lConnHdl;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopItemByHandle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopItemByHandle(
  Dcm_Svc2ASchdItemHandleOptType schdHandle
  )
{
  Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(schdHandle);
  if(pSchdEntry->Rate < DCM_SVC2A_RATE_TYPE_STOPPED)
  {
    pSchdEntry->Rate = DCM_SVC2A_RATE_TYPE_STOPPED;                                                                                                  /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
    /* must have at least one element (this one) */
    Dcm_DebugAssert((Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries > 0u)
                   ,DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                          /* COV_DCM_RTM_DEV_DEBUG XF */

    --Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries; /* update statistic */

    Dcm_Svc2ASchdCancelReadByHandle(schdHandle);

    Dcm_NetPeriodicMsgStopDid(pSchdEntry->DidContext.Did);
    if(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries == 0u)/* scheduler is empty */
    {
      Dcm_NetPeriodicMsgResetConnection(); /* allow other tester to use service 0x2A */
      Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex = 0u;
# if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
      /* stop timer updater */
      Dcm_TmrStopTimer(DCM_TMR_ID_SVC2A_SCHEDULER);
# else
      /* no need to deactivate the task - if the event was set, the task will deactivate itself after a single short
       * execution time activation */
# endif
    }
  }/* else - this item is not scheduled at all */
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopItemByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopItemByDid(
  uint16 did
  )
{
  Dcm_Svc2ASchdItemHandleOptType lSchdHandle = 0u;

  if(Dcm_Svc2ASchdGetItemByDid(did, &lSchdHandle) == TRUE)                                                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    Dcm_Svc2ASchdStopItemByHandle(lSchdHandle);
  }
}
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdGetItemByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdGetItemByDid(
  uint16 did,
  P2VAR(Dcm_Svc2ASchdItemHandleOptType, AUTOMATIC, AUTOMATIC) schdHandle
  )
{
  boolean lItemFound = FALSE;
  Dcm_Svc2ASchdItemHandleOptType lSchdIter;

  if(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
    for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
    {
      Dcm_Svc2ASchdEntryConstPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);
      if( (pSchdEntry->Rate < DCM_SVC2A_RATE_TYPE_STOPPED)
        &&(pSchdEntry->DidContext.Did == did) )
      {
        *schdHandle = lSchdIter;                                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
        lItemFound = TRUE;
        break;
      }
    }
  }
  return lItemFound;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdFinishEntryProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdFinishEntryProcessing(
  boolean doSendResponse
  )
{
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj;

  pPeriodicTxObj = Dcm_NetGetPeriodicTxObject(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle);

  if(doSendResponse == TRUE)
  {
    Dcm_Svc2ASchdEntryConstPtrType pSchdEntry =
      Dcm_Svc2ASchdGetEntry(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex);
    Dcm_NetPeriodicMsgTransmit(pPeriodicTxObj, ((PduLengthType)pSchdEntry->DidContext.DidLength + 1u));                                              /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
  }
  else
  {
    /* release resource if not used */
    Dcm_NetPeriodicMsgRelease(pPeriodicTxObj);                                                                                                       /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
  }

  /* free for next DID */
  Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle = DCM_NET_INVALID_PTXOBJ_HANDLE;

  Dcm_RsrcMgrReleaseDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID2A);
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ADidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidLookUp(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn;
  boolean doProcessDid = TRUE;

  if(opStatus == DCM_INITIAL)
  {
    if(pMsgContext->reqDataLen != 0u)
    {
      uint8 perDidLoByte;
      Dcm_UtiConsumeReqDataAsU8(pMsgContext, &perDidLoByte);                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */

      pRepContext->DidInfoContext.Did = Dcm_Svc2AMakePeriodicDid(perDidLoByte);                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      doProcessDid = FALSE;
    }
  }

  if(doProcessDid == TRUE)
  {
    lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                     ,&(pRepContext->DidInfoContext)
                                     ,&(pRepContext->DidOpTypeContext)
                                     ,DCM_DIDMGR_OP_READ);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    if(lStdReturn == DCM_E_OK)
    {
      pRepContext->HasAnySupportedDids = TRUE; /* register a supported DID */                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
      /* go on with the DID condition check - DCM_E_OK */
    }
    else if(lStdReturn == DCM_E_PENDING)
    {
      /* already set */
    }
    else
    {
      /* Just skip this DID - DCM_E_NOT_OK - request a new client loop */
      lStdReturn = DCM_E_LOOP;
    }
  }
  else
  {
    /* empty run loop ended without any DID to be processed (for this activation of the repeater proxy) */
    /* all DIDs processed */
    if (pRepContext->HasAnySupportedDids == FALSE)
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
    else
    {
      lStdReturn = DCM_E_PROCESSINGDONE;
    }
  }

  return lStdReturn;
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrClear()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2CDefMgrClear(
  Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle
  )
{
  Dcm_Svc2CDynDidItemPtrType pItem;

#  if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
  {
    uint16 lDid = Dcm_DidMgrGetDynDidIdFromHandle(dynDidHandle);
    /* Try stopping any active periodic DID (can be still read at that time)! */
    Dcm_Svc2ASchdStopItemByDid(lDid);
  }
#  endif

  pItem = Dcm_Svc2CGetItem(dynDidHandle);
  pItem->Length = 0u;                                                                                                                                /* SBSW_DCM_POINTER_WRITE_2CITEM */
  pItem->Count  = 0u;                                                                                                                                /* SBSW_DCM_POINTER_WRITE_2CITEM */
}
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CCheckAndSetNumOfItems()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CCheckAndSetNumOfItems(
  uint8 numRequestedItems,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn;
  if ((uint8)(Dcm_DidMgrGetDynDidSize(pRepContext->DynDidHandle) - pRepContext->DynDidItemCount) < numRequestedItems)
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  {
    pRepContext->ReqNumOfItems = numRequestedItems;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_OK;
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CParseAndCheckDynDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CParseAndCheckDynDid(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn;

  if(opStatus == DCM_INITIAL)
  {
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &pRepContext->DynDidInfoContext.Did);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&pRepContext->DynDidInfoContext                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
                                   ,&pRepContext->DynDidOpTypeContext                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
                                   ,DCM_DIDMGR_OP_DEFINE);

  switch(lStdReturn)
  {
  case DCM_E_OK:
    lStdReturn = Dcm_StateCheckDID(Dcm_NetGetConnHdlOfRxPduId(pMsgContext->rxPduId)                                                                  /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
                                  ,pRepContext->DynDidInfoContext.Did
                                  ,DCM_DIDMGR_OP_READ
                                  ,Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DynDidInfoContext))->ExecCondRef
                                  ,ErrorCode);                                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
    if (lStdReturn == DCM_E_OK)
    {
      Dcm_Svc2CDynDidItemConstPtrType pItem;

      Dcm_Svc2CSetMaxAllowedDynDIDLength(pContext, pRepContext);                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
      pRepContext->DynDidHandle = (Dcm_CfgDidMgrDynDidHandleMemType)Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DynDidInfoContext))->OpRef;               /* SBSW_DCM_PARAM_PTR_WRITE */

      pItem = Dcm_Svc2CGetItem(pRepContext->DynDidHandle);
      pRepContext->DynDidLength = pItem->Length; /* set current length for updates during service processing */                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      pRepContext->SrcItemIndex = Dcm_Svc2CGetSrcItemIndex(pRepContext->DynDidHandle, pItem->Count);                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
      pRepContext->DynDidItemCount = pItem->Count;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */

      Dcm_UtiProvideResData(pMsgContext, 2u); /* positive response contains the DynDID (2Byte) */                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
      /* lStdReturn = DCM_E_OK - already set */
    } /* else DCM_E_NOT_OK (ErrorCode already set) */
    break;
  case DCM_E_PENDING:
    break;
  default: /* DCM_E_NOT_OK */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
    break;
  }
  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_Svc2CReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc2CReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  )
{
  DCM_IGNORE_UNREF_PARAM(sfRef);                                                                                                                     /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  /* Return sub-function specific length (always zero -> dynamic since it depends on the complete request content) */
  return 0u;
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc85EnableDtcSetting()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85EnableDtcSetting(
  uint8 DemClientId
  )
{
  Std_ReturnType                     lStdResult;
  Dcm_DemReturnControlDTCSettingType lDemResult;

  if(Dcm_ModeGetControlDtcSettingMode() != RTE_MODE_DcmControlDtcSetting_ENABLEDTCSETTING)
  {
    /* Enable the DTC setting for all DTCs */
# if (DCM_DEM_API_421_ENABLED == STD_ON)
    lDemResult = Dcm_DemAPI(EnableDTCSetting)(DEM_DTC_GROUP_ALL_DTCS, DEM_DTC_KIND_ALL_DTCS);
# else
    lDemResult = Dcm_DemAPI(EnableDTCSetting)(DemClientId);
# endif

    switch (lDemResult)
    {
      case DCM_DEM_RET_CONTROL_DTC_SETTING_OK:
        lStdResult = DCM_E_OK;
        Dcm_ModeSwitchDtcSetting(RTE_MODE_DcmControlDtcSetting_ENABLEDTCSETTING, DEM_DTC_GROUP_ALL_DTCS, DemClientId);
        break;
# if defined (DCM_DEM_RET_CONTROL_DTC_SETTING_PENDING)
      case DCM_DEM_RET_CONTROL_DTC_SETTING_PENDING:
        lStdResult = DCM_E_PENDING;
        break;
# endif
      default:
        lStdResult = DCM_E_NOT_OK;
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
        break;
    }
  }
  else
  {
    lStdResult = DCM_E_OK;
  }
  return lStdResult;
}

# if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc85DisableDtcSetting()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85DisableDtcSetting(
  Dem_DTCGroupType DTCGroup,
  uint8 DemClientId
  )
{
  Std_ReturnType                     lStdResult;
  Dcm_DemReturnControlDTCSettingType lDemResult;

  /* Disable the DTC setting for all DTCs */
#  if (DCM_DEM_API_421_ENABLED == STD_ON)
  lDemResult = Dcm_DemAPI(DisableDTCSetting)(DTCGroup, DEM_DTC_KIND_ALL_DTCS);
#  else
  lDemResult = Dcm_DemAPI(DisableDTCSetting)(DemClientId);
#  endif

  switch (lDemResult)
  {
    case DCM_DEM_RET_CONTROL_DTC_SETTING_OK:
      lStdResult = DCM_E_OK;
      Dcm_ModeSwitchDtcSetting(RTE_MODE_DcmControlDtcSetting_DISABLEDTCSETTING, DTCGroup, DemClientId);
      break;
#  if defined (DCM_DEM_RET_CONTROL_DTC_SETTING_PENDING)
    case DCM_DEM_RET_CONTROL_DTC_SETTING_PENDING:
      lStdResult = DCM_E_PENDING;
      break;
#  endif
    default:
      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
      break;
  }
  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc85OnChangeSession()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc85OnChangeSession(
  void
  )
{
    sint16_least lSidRef = Dcm_UtiLookUpUint8(Dcm_CfgDiagSvcIdLookUpTable, 0x85u);                                                                   /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

    if ((Dcm_StateIsDefaultSessionActive())
       ||(!Dcm_StateIsSupportedInSession(Dcm_StateGetPreconditionStates(Dcm_CfgDiagSvcIdExecPrecondTable[lSidRef]))))
    {
      /* Enable DTC setting */
      (void)Dcm_Svc85EnableDtcSetting(Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.LastDisableDTCClientID);
    }
}

/**********************************************************************************************************************
 *  Dcm_Svc85ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc85ReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  )
{
  DCM_IGNORE_UNREF_PARAM(sfRef);                                                                                                                     /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  /* Return sub-function specific length (always the same constant) */
  return DCM_SVC_85_REQ_LENGTH;
}

/**********************************************************************************************************************
 *  Dcm_Svc85_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85_XX_RepeaterProxy(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc85RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType                     lStdResult;
  Dcm_DemReturnControlDTCSettingType lDemResult;
  Dcm_CfgSvc85SubFuncInfoPtrType     pSubFuncInfo;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_CfgSvc85SubFuncInfoGetEntry(pRepContext->SubSvcRef, &pSubFuncInfo, ErrorCode);                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lStdResult == DCM_E_OK)                                                                                                                        /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
# if (DCM_DEM_API_421_ENABLED == STD_ON)
    lDemResult = pSubFuncInfo->DemFunc(pRepContext->DTCGroup, DEM_DTC_KIND_ALL_DTCS);                                                                /* SBSW_DCM_CALL_FUNCPTR_SVC85SUBFUNC */
# else
    lDemResult = pSubFuncInfo->DemFunc(pRepContext->DemClientId);                                                                                    /* SBSW_DCM_CALL_FUNCPTR_SVC85SUBFUNC */
# endif
    switch(lDemResult)
    {
    case DCM_DEM_RET_CONTROL_DTC_SETTING_OK:
      /* success */
      lStdResult = DCM_E_OK;
      break;
# if defined (DCM_DEM_RET_CONTROL_DTC_SETTING_N_OK)
    case DCM_DEM_RET_CONTROL_DTC_SETTING_N_OK:
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      break;
# endif
# if defined (DCM_DEM_RET_CONTROL_DTC_WRONG_DTCGROUP)
    case DCM_DEM_RET_CONTROL_DTC_WRONG_DTCGROUP:
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      break;
# endif
# if defined (DCM_DEM_RET_CONTROL_DTC_SETTING_PENDING)
    case DCM_DEM_RET_CONTROL_DTC_SETTING_PENDING:
      lStdResult = DCM_E_PENDING;
      break;
# endif
    default:
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
      lStdResult = DCM_E_NOT_OK;
      break;
    }
  }

  return lStdResult;
}
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc86ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc86ReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  )
{
  /* Return sub-function specific length */
  return Dcm_CfgSvc86SubFuncInfo[sfRef].ReqLength;
}
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */

/**********************************************************************************************************************
 *  GLOBAL FUNCTIONS
 *********************************************************************************************************************/
#define DCM_START_SEC_CODE
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */
#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_AUTHMGR_SET_DEAUTH_ROLE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_SetDeauthenticatedRole()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_SetDeauthenticatedRole(
  uint16 connectionId,                                                                                                                               /* PRQA S 1330 */ /* MD_Dcm_RteSpecific_1330 */
  P2CONST(uint8, AUTOMATIC, RTE_DCM_APPL_DATA) deauthenticatedRole                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if (Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    Dcm_NetConnRefMemType lConnHdl;

    lConnHdl = Dcm_NetGetConnHdlByConnectionId(connectionId);

    if (Dcm_DebugDetectError(lConnHdl == DCM_NET_INVALID_CONNHDL))
    {
      lErrorId = DCM_E_PARAM;
    }
    else if (Dcm_DebugDetectError(Dcm_NetGetAuthInfoRef(lConnHdl) == DCM_AUTHMGR_INVALID_AUTH_INFO_REF))
    {
      lErrorId = DCM_E_PARAM;
    }
    else
    {
      /* ----- Implementation ---------------------------------------------- */
      uint8_least               lRoleIndex;
      Dcm_CfgStateGroupMemType  lRoleInLittleEndian = 0x00u;

      for (lRoleIndex = 0; lRoleIndex < DCM_AUTHMGR_CERT_ROLE_SIZE; lRoleIndex++)
      {
        lRoleInLittleEndian |= (Dcm_CfgStateGroupMemType)deauthenticatedRole[lRoleIndex]<<(lRoleIndex * 8u);
      }

      /* Enter critical section (Reason: API is reentrant) */
      Dcm_UtiEnterCriticalSection();
      /*=================================*
      BEGIN CRITICAL SECTION
      *=================================*/
      Dcm_AuthMgrSetPendingRole(Dcm_NetGetAuthInfoRef(lConnHdl), lRoleInLittleEndian);
      Dcm_SingletonContext.AuthMgr.PendingData.ConnectionMask |= Dcm_UtiGetBitFromIndex(uint32, lConnHdl);
      /*=================================*
      END CRITICAL SECTION
      *=================================*/
      Dcm_UtiLeaveCriticalSection();

      Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_EXT_SETROLE);
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_DCMSETDEAUTHENTICATEDROLE, lErrorId);

  return DCM_E_OK;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif
#endif /* (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_VERSION_INFO_API == STD_ON)
/**********************************************************************************************************************
 *  Dcm_GetVersionInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_GetVersionInfo(
  P2VAR(Std_VersionInfoType, AUTOMATIC, DCM_APPL_DATA) versioninfo
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(versioninfo == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    versioninfo->vendorID = (uint16)DCM_VENDOR_ID;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    versioninfo->moduleID = (uint16)DCM_MODULE_ID;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    versioninfo->sw_major_version = (uint8)DCM_SW_MAJOR_VERSION;                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    versioninfo->sw_minor_version = (uint8)DCM_SW_MINOR_VERSION;                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    versioninfo->sw_patch_version = (uint8)DCM_SW_PATCH_VERSION;                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_GETVERSIONINFO, lErrorId);
}
#endif
#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TriggerTransmit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_TriggerTransmit(
  PduIdType txPduId,
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) pTxPduInfo
  )
{
  Std_ReturnType lResult  = E_NOT_OK;                                                                                                                /* PRQA S 2981 */ /* MD_Dcm_RetVal */
  uint8          lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsTxPduIdValid(txPduId) == FALSE))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError(pTxPduInfo == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(Dcm_DebugDetectError(pTxPduInfo->SduDataPtr == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(Dcm_DebugDetectError(Dcm_NetPeriodicMsgGetConnection() != Dcm_NetGetConnHdlOfTxPduId(txPduId)))
  {
    lErrorId = DCM_E_ILLEGAL_STATE;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_CfgNetPTxObjHandleMemType lPerTxObjHandle;

    lPerTxObjHandle = (Dcm_CfgNetPTxObjHandleMemType)Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId);

    if(Dcm_DebugDetectError(Dcm_NetPeriodicMsgNumMsgsCurrConnection() <= lPerTxObjHandle))
    {
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
    {
      P2CONST(PduInfoType, AUTOMATIC, DCM_VAR_NOINIT) txPduInfoPtr = &(Dcm_NetGetPeriodicTxObject(lPerTxObjHandle)->TxPduInfo);

      Dcm_UtiMemCopySafe(txPduInfoPtr->SduDataPtr
                        ,pTxPduInfo->SduDataPtr
                        ,0u
                        ,pTxPduInfo->SduLength
                        ,txPduInfoPtr->SduLength);                                                                                                   /* SBSW_DCM_COMB_PTR_FORWARD */

      pTxPduInfo->SduLength = txPduInfoPtr->SduLength;                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
      lResult = E_OK;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_TRIGGERTRANSMIT, lErrorId);

  return lResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */
#endif /* (DCM_NET_PERIODIC_TX_ENABLED == STD_ON) */

/**********************************************************************************************************************
 *  Dcm_GetActiveProtocol()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetActiveProtocol(
  P2VAR(Dcm_ProtocolType, AUTOMATIC, DCM_APPL_DATA) ActiveProtocol
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(ActiveProtocol == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    if(Dcm_NetGetProtIdOfActiveProtocol() >= DCM_NET_INVALID_PROTID)
    {
      *ActiveProtocol = DCM_NO_ACTIVE_PROTOCOL;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      *ActiveProtocol = Dcm_PbCfgNetProtocolInfo[Dcm_NetGetProtIdOfActiveProtocol()].Id;                                                             /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_GETACTIVEPROTOCOL, lErrorId);

  return DCM_E_OK;
}

/**********************************************************************************************************************
 *  Dcm_GetTesterSourceAddress()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetTesterSourceAddress(
  PduIdType DcmRxPduId,
  P2VAR(uint16, AUTOMATIC, DCM_APPL_DATA) TesterSourceAddress
  )
{
  Std_ReturnType lResult  = DCM_E_NOT_OK;                                                                                                            /* PRQA S 2981 */ /* MD_Dcm_RetVal */
  uint8          lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsRxPduIdValid(DcmRxPduId) == FALSE))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError(TesterSourceAddress == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
#if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
  else if(Dcm_DebugDetectError(Dcm_NetIsGenericConnection(Dcm_NetGetConnHdlOfRxPduId(DcmRxPduId))))
  {
    lErrorId = DCM_E_PARAM;
  }
#endif
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    lResult = DCM_E_OK;
    *TesterSourceAddress = Dcm_PbCfgNetConnectionInfo[Dcm_NetGetConnHdlOfRxPduId(DcmRxPduId)].ClientSrcAddr;                                         /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_GETTESTERSOURCEADDRESS, lErrorId);

  return lResult;
}

#if (DCM_DIAG_VIRTUAL_REQUEST_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ProcessVirtualRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_ProcessVirtualRequest(
  PduIdType RxPduId,
  Dcm_MsgType Data,
  PduLengthType Length
  )
{
  Std_ReturnType lResult  = DCM_E_NOT_OK;
  uint8          lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsRxPduIdValid(RxPduId) == FALSE))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError(Data == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  /* if (length > <BufferSize>)
  {
    This check is done through the Dcm_NetRxIndInternal API!
  }
  else */
  {
    /* ----- Implementation ------------------------------------------------ */
    uint16 lClientSrcAddr;

# if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
    if(Dcm_NetIsGenericConnection(Dcm_NetGetConnHdlOfRxPduId(RxPduId)))
    {
      /* The client source address is stored behind payload data */
      lClientSrcAddr = Data[Length];
    }
    else
# endif
    {
      lClientSrcAddr = Dcm_NetGetTesterAddress(Dcm_NetGetConnHdlOfRxPduId(RxPduId));
    }

    lResult = Dcm_NetRxIndInternal(RxPduId, lClientSrcAddr, Data, Length);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_PROCESSVIRTUALREQUEST, lErrorId);

  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_SetActiveDiagnostic()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_SetActiveDiagnostic(
  boolean active
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (Dcm_DebugDetectError( (active != DCM_NET_COMM_ACTIVE) && (active != DCM_NET_COMM_NOT_ACTIVE) ))
  {
    lErrorId = DCM_E_PARAM;                                                                                                                          /* PRQA S 2880 */ /* MD_MSR_Unreachable */
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    /* Enter critical section (Reason: API is reentrant) */
    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    /* Apply new ComM management state */
    Dcm_SingletonContext.Network.ActiveDiagnostic = active;
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    /* Leave critical section */
    Dcm_UtiLeaveCriticalSection();
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_SETACTIVEDIAGNOSTIC, lErrorId);

  return DCM_E_OK;
}

/**********************************************************************************************************************
 *  Dcm_GetRequestKind()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetRequestKind(
  uint16 TesterSourceAddress,
  P2VAR(Dcm_RequestKindType, AUTOMATIC, DCM_APPL_DATA) RequestKind
  )
{
  Std_ReturnType lResult  = DCM_E_NOT_OK;
  uint8          lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if (Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (Dcm_DebugDetectError(RequestKind == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_NetConnRefMemType lConnHdl;

    lConnHdl = Dcm_NetGetConnHdlByTesterAddress(TesterSourceAddress);

    /* Check if the tester source address is a valid one */
    if (lConnHdl < DCM_NET_INVALID_CONNHDL)
    {
#if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
      if (Dcm_DebugDetectError(Dcm_NetIsGenericConnection(lConnHdl)))
      {
        lErrorId = DCM_E_PARAM;
      }
      else
#endif
      {
        Dcm_NetTransportObjectPtrType pTranspObj;
        BufReq_ReturnType             lBufReqResult;

        /* Assure that no interrupt will change the state of the conn2tobj map and the tobj state/flags */
        Dcm_UtiEnterCriticalSection();
        /*=================================*
          BEGIN CRITICAL SECTION
          *=================================*/
        lBufReqResult = Dcm_NetGetTranspObjOfConnection(lConnHdl, &pTranspObj);                                                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

        if (lBufReqResult == BUFREQ_OK)
        {
          /* If for this tester any request is ongoing: */
          if (pTranspObj->State != DCM_NET_TOBJ_STATE_FREE)
          {
#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
            /* Determine the kind of the request */
            if ((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) != 0u)
            {
              *RequestKind = DCM_REQ_KIND_ROE;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
            }
            else
#endif
            {
              *RequestKind = DCM_REQ_KIND_EXTERNAL;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
            }
          }
          else
          {
            /* Otherwise consider this tester idling */
            *RequestKind = DCM_REQ_KIND_NONE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
          }
        }
        else
        {
          *RequestKind = DCM_REQ_KIND_NONE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
        }
        /*=================================*
          END CRITICAL SECTION
          *=================================*/
        Dcm_UtiLeaveCriticalSection();

        lResult = DCM_E_OK;
      }
    } /* else - result already set to NOT_OK */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_GETREQUESTKIND, lErrorId);

  return lResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_ComM_NoComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_ComM_NoComModeEntered(
  NetworkHandleType networkId
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_NetSetComModeEntered(networkId, DCM_NET_COMM_STATE_RX_DIS_TX_DIS);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_COMMENTERNOCOMMODE, lErrorId);
}

/**********************************************************************************************************************
 *  Dcm_ComM_SilentComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_ComM_SilentComModeEntered(
  NetworkHandleType networkId
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_NetSetComModeEntered(networkId, DCM_NET_COMM_STATE_RX_EN_TX_DIS);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_COMMENTERSILENTCOMMODE, lErrorId);
}

/**********************************************************************************************************************
 *  Dcm_ComM_FullComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_ComM_FullComModeEntered(
  NetworkHandleType networkId
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_NetSetComModeEntered(networkId, DCM_NET_COMM_STATE_RX_EN_TX_EN);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_COMMENTERFULLCOMMODE, lErrorId);
}

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnRequestDetection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_OnRequestDetection(
  PduIdType canTpRxPduId,
  uint8 tpAddrExtension
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  /* Check initialization state */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    /* Check whether the CanTpPduId is between the upper and lower bound of DCM CanTpPduIds */
    if(
# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
        (Dcm_PbCfgNetNumCanRxPduIds > 0u) &&  /* Check for a non-empty map */
# endif
        ( (canTpRxPduId >= Dcm_PbCfgNetCanTpRxPduIdMin)
        &&(canTpRxPduId <= Dcm_PbCfgNetCanTpRxPduIdMax) )
      )
    {
      PduIdType lDcmRxPduId;

      /* Retrieve the DCM RxPduId from the CanTp PduId */
      lDcmRxPduId = Dcm_NetGetDcmRxPduIdOfCanTpPduId(canTpRxPduId);

      /* Check for DCM connection on this SDU */
      if(lDcmRxPduId < Dcm_PbCfgNetNumRxPduIds)
      {
        Dcm_NetConnRefMemType lConnHdl = Dcm_NetGetConnHdlOfRxPduId(lDcmRxPduId);

        /* Compare the N_TA with the own ECU address. React only on external ECU requests */
        if(Dcm_NetGetNodeAddress(lConnHdl) != tpAddrExtension)
        {
          Dcm_NetOnRequestDetection(lConnHdl);
        }/* else - a DcmPduId and the same N_TA -> request will be ignored on task level */
      }/* else - not a DcmPduId or a functional DcmPduId -> ignore */
    }/* else - not a DcmPduId -> ignore */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_ONREQUESTDETECTION, lErrorId);
}
#endif

/**********************************************************************************************************************
 *  Dcm_StartOfReception()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_StartOfReception(
  PduIdType rxPduId,
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info ,                                                                                                /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  PduLengthType tpSduLength,
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr
  )
{
  BufReq_ReturnType lResult  = BUFREQ_E_NOT_OK;                                                                                                      /* PRQA S 2981 */ /* MD_Dcm_RetVal */
  uint8             lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsRxPduIdValid(rxPduId) == FALSE))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError(bufferSizePtr == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
  /* info is not NULL_PTR only when the connection is generic. */
  if(Dcm_DebugDetectError( ((info != NULL_PTR) && !Dcm_NetIsGenericConnection(Dcm_NetGetConnHdlOfRxPduId(rxPduId)))
                         ||((info == NULL_PTR) &&  Dcm_NetIsGenericConnection(Dcm_NetGetConnHdlOfRxPduId(rxPduId))) ))
#else
  if(Dcm_DebugDetectError(info != NULL_PTR))
#endif
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
#if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
  else if(Dcm_DebugDetectError( (info != NULL_PTR) && (info->SduLength != DCM_NET_METADATA_LENGTH) ))
  {
    lErrorId = DCM_E_PARAM;
  }
#endif
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    lResult = Dcm_NetStartOfReception(rxPduId, info, tpSduLength, bufferSizePtr, DCM_NET_TOBJ_FLAG_NONE);                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_STARTOFRECEPTION, lErrorId);

  return lResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_CopyRxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_CopyRxData(
  PduIdType rxPduId,
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info ,                                                                                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr
  )
{
  BufReq_ReturnType  lResult  = BUFREQ_E_NOT_OK;                                                                                                     /* PRQA S 2981 */ /* MD_Dcm_RetVal */
  uint8              lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsRxPduIdValid(rxPduId) == FALSE))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsPduInfoValid(info) == FALSE))                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(Dcm_DebugDetectError(bufferSizePtr == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_NetTransportObjectPtrType pTranspObj;

    lResult = Dcm_NetGetTranspObjOfConnection(Dcm_NetGetConnHdlOfRxPduId(rxPduId), &pTranspObj);                                                     /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_FORWARD_STACK */

    DCM_IGNORE_UNREF_PARAM(rxPduId);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

    /* Check always for valid call state - if free or ready -> ignore call
    * This check is necessary in case Dcm_Init is called some time during ongoing transmission
    */
    if(lResult == BUFREQ_OK)
    {
      Dcm_DebugAssert((rxPduId == pTranspObj->RxPduId), DCM_SID_COPYRXDATA, DCM_E_ILLEGAL_STATE);                                                    /* COV_DCM_RTM_DEV_DEBUG XF */

      if(Dcm_DebugDetectError(pTranspObj->State != DCM_NET_TOBJ_STATE_ONRX))/* expected state for copy Rx? */                                        /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY XF */
      {
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
      else
      {
        lResult = Dcm_NetCopyRxData(pTranspObj, info, bufferSizePtr);                                                                                /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
      }
    }
    else
    {
      /* Check for valid call state */
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_COPYRXDATA, lErrorId);

  return lResult;
}                                                                                                                                                    /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_TpRxIndication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_TpRxIndication(
  PduIdType rxPduId,
  Std_ReturnType result
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsRxPduIdValid(rxPduId) == FALSE))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_NetTpRxIndication(rxPduId, result);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_TPRXINDICATION, lErrorId);
}

/**********************************************************************************************************************
 *  Dcm_CopyTxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_CopyTxData(
  PduIdType txPduId,
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info ,                                                                                                /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  P2VAR(RetryInfoType, AUTOMATIC, DCM_APPL_DATA) retry ,                                                                                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr
  )
{
  BufReq_ReturnType lResult  = BUFREQ_E_NOT_OK;                                                                                                      /* PRQA S 2981 */ /* MD_Dcm_RetVal */
  uint8             lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsTxPduIdValid(txPduId) == FALSE))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsPduInfoValid(info) == FALSE))                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(Dcm_DebugDetectError(availableDataPtr == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(Dcm_DebugDetectError( (retry != NULL_PTR) /* else - if(retry == NULL_PTR) -> not used => OK */
                              &&(retry->TpDataState != TP_DATACONF) ))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_NetTransportObjectPtrType pTranspObj;

    lResult = Dcm_NetGetTranspObjOfConnection(Dcm_NetGetConnHdlOfTxPduId(txPduId), &pTranspObj);                                                     /* SBSW_DCM_POINTER_FORWARD_STACK */

    DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
    DCM_IGNORE_UNREF_PARAM(retry);                                                                                                                   /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

    if(lResult == BUFREQ_OK)
    {
      if(Dcm_DebugDetectError(pTranspObj->State != DCM_NET_TOBJ_STATE_ONTX))                                                                         /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY XF */
      {
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
      else
      {
        lResult = Dcm_NetCopyTxData(pTranspObj, info, availableDataPtr);                                                                             /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
      }
    }
    else
    {
      /* Check for valid call state */
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_COPYTXDATA, lErrorId);

  return lResult;
}                                                                                                                                                    /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_TpTxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_TpTxConfirmation(
  PduIdType txPduId,
  Std_ReturnType result
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsTxPduIdValid(txPduId) == FALSE))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_NetTransportObjectPtrType pTranspObj;
    BufReq_ReturnType             lResult;

    lResult = Dcm_NetGetTranspObjOfConnection(Dcm_NetGetConnHdlOfTxPduId(txPduId), &pTranspObj);                                                     /* SBSW_DCM_POINTER_FORWARD_STACK */

    if(lResult == BUFREQ_OK)
    {
      if(Dcm_DebugDetectError(pTranspObj->State != DCM_NET_TOBJ_STATE_ONTX))
      {
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
      else
      {
        Dcm_NetUsdtTxConfirmation(pTranspObj, result);                                                                                               /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
      }
    }
    else
    {
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_TPTXCONFIRMATION, lErrorId);
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_TxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_TxConfirmation(
  PduIdType txPduId
  )
{
#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
  uint8 lErrorId = DCM_E_NO_ERROR;

  DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsTxPduIdValid(txPduId) == FALSE))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError(Dcm_NetPeriodicMsgGetConnection() != Dcm_NetGetConnHdlOfTxPduId(txPduId)))
  {
    lErrorId = DCM_E_ILLEGAL_STATE;
  }
  else if(Dcm_DebugDetectError(Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId) >= Dcm_NetPeriodicMsgNumMsgsCurrConnection()))
  {
    lErrorId = DCM_E_ILLEGAL_STATE;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_NetPeriodicMsgRelease(Dcm_NetGetPeriodicTxObject(Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId)));                                          /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_TXCONFIRMATION, lErrorId);
#else
  /* Function is not used since 0x2A or periodic messages are not available.
   * Note: PduR may still need this API to be able to link in case periodic messages are available, but SID 0x2A shall
   * not be supported.
   */
  DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
#endif /* (DCM_NET_PERIODIC_TX_ENABLED == STD_ON) */
}
/**********************************************************************************************************************
 *  Dcm_ResetToDefaultSession()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_ResetToDefaultSession(
  void
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    /* Just register an externally triggered request for changing back to default diagnostic session */
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_EXT_SET2DEF);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_RESET2DEFAULTSESSION, lErrorId);

  return DCM_E_OK;
}

/**********************************************************************************************************************
 *  Dcm_GetSesCtrlType()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetSesCtrlType(
  P2VAR(Dcm_SesCtrlType, AUTOMATIC, DCM_APPL_DATA) SesCtrlType
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(SesCtrlType == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    /* Return the diagnostic session ID of the currently (still) active (committed not pending) diagnostic session state */
    *SesCtrlType = Dcm_CfgStateSessionInfo[Dcm_UtiGetBitPosition(Dcm_SingletonContext.StateMgr.Preconditions.Session)].Value;                        /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_GETSESCTRLTYPE, lErrorId);

  return DCM_E_OK;
}

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_GetSecurityLevel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetSecurityLevel(
  P2VAR(Dcm_SecLevelType, AUTOMATIC, DCM_APPL_DATA) SecLevel
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(SecLevel == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# if (DCM_STATE_SECURITY_BYPASS_ENABLED == STD_ON)
  if(Dcm_DebugDetectError(Dcm_SingletonContext.Diag.IsSecurityBypass == TRUE))
  {
    lErrorId = DCM_E_ILLEGAL_STATE;
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    uint8 stateIdx = Dcm_UtiGetBitPosition(Dcm_SingletonContext.StateMgr.Preconditions.Security);
    /* Return the security access level ID of the currently active security access level state */
    *SecLevel = Dcm_StateGetSecurityValue(stateIdx);                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_GETSECLEVEL, lErrorId);

  return DCM_E_OK;
}
#endif

#if (DCM_STATE_SECURITY_EXT_SETTER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_SetSecurityLevel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_SetSecurityLevel(
  Dcm_SecLevelType SecLevel
  )
{
  Std_ReturnType lResult  = DCM_E_NOT_OK;
  uint8          lErrorId = DCM_E_NO_ERROR;
  sint8_least    lStateIdx;

  /* Convert security access level to internal zero based security access state handle */
  lStateIdx = Dcm_StateFindStateIndexFromSecLevel(SecLevel);/* Calling this API is safe since it does not depend on any internal DCM state (no initialization is needed!) */

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (Dcm_DebugDetectError(lStateIdx < 0))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    /* Check for valid API call context */

    /* Protect against any ISR or higher priority tasks */
    Dcm_UtiEnterCriticalSection();

    if(Dcm_DebugDetectError(Dcm_TskTraceIsEmpty()))
    {
      /* No task active: this API is called outside of any DCM main-function context! */
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else if(Dcm_DebugDetectError(Dcm_TskTraceGetCurrTskId() != DCM_TSK_ID_DIAG_WORK))                                                                /* PRQA S 0404 */ /* MD_Dcm_OptimizedInlineCode_0404 */
    {
      /* A task is active, but not the correct one: worker task with low priority! */
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
    {
      /* Needed by MISRA */
    }
    Dcm_UtiLeaveCriticalSection();

    if(lErrorId == DCM_E_NO_ERROR)
    {
      Dcm_StateSetSecurity((Dcm_StateIndexOptType)lStateIdx);
      lResult = DCM_E_OK;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_SETSECLEVEL, lErrorId);

  return lResult;
}
#endif

#if (DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_GetSecurityLevelFixedBytes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetSecurityLevelFixedBytes(
  Dcm_SecLevelType SecLevel,
  P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) FixedBytes,
  P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) BufferSize
  )
{
  Std_ReturnType  lResult  = DCM_E_NOT_OK;
  uint8           lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if (Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (Dcm_DebugDetectError( (FixedBytes == NULL_PTR) || (BufferSize == NULL_PTR) ))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    lResult = Dcm_StateGetSecurityLevelFixedBytes(SecLevel, FixedBytes, BufferSize);                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_GETSECLEVELFIXEDBYTES, lErrorId);

  return lResult;
}
#endif

#if (DCM_STATE_SECURITY_BYPASS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_SetSecurityBypass()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_SetSecurityBypass(
  boolean SecBypass
  )
{
  Std_ReturnType lResult  = DCM_E_NOT_OK;
  uint8          lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  /*  Check that the module is initialized. */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  /* Check for valid parameter. */
  else if(Dcm_DebugDetectError((SecBypass != FALSE) && (SecBypass != TRUE)))
  {
    lErrorId = DCM_E_PARAM;                                                                                                                          /* PRQA S 2880 */ /* MD_MSR_Unreachable */
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_SingletonContext.Diag.IsSecurityBypass = SecBypass;

    /* Just register security bypass mode */
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_EXT_SETSECBYPASS);
    lResult = DCM_E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_SETSECURITYBYPASS, lErrorId);

  return lResult;
}
#endif
/**********************************************************************************************************************
 *  Dcm_InitMemory()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_InitMemory(
  void
  )
{
  Dcm_DebugDeInit();
}

/**********************************************************************************************************************
 *  Dcm_Init()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_Init(
  Dcm_ConfigPtrType configPtr
  )
{
  DCM_IGNORE_UNREF_PARAM(configPtr);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#if (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
  if(Dcm_VarMgrInit(configPtr) == TRUE)                                                                                                              /* PRQA S 2991, 2995 */ /* MD_Dcm_ConstExpr, MD_Dcm_ConstExpr */ /* SBSW_DCM_PARAM_PTR_FORWARD */
#endif
  {
    Dcm_ThreadIdOptType lThreadIter;
    for(lThreadIter = 0; lThreadIter < DCM_NUM_THREADS; ++lThreadIter)
    {
      Dcm_ThreadContextPtrType pThreadContext = Dcm_GetThreadContext(lThreadIter);

      pThreadContext->ThreadId = (Dcm_ThreadIdMemType)lThreadIter;                                                                                   /* SBSW_DCM_POINTER_INIT_MESSAGE_CONTEXT */

      /*
      * Initialize pMsgContext so that it points always to a valid buffer.
      * From now on the buffer information can only be changed via Dcm_DiagInitiateServiceProcessing().
      * So in case that Dcm_DiagInitiateServiceProcessing() was called, but for a different (wrong) thread,
      * DCM still never writes to an invalid memory locations due to this initialization.
      */
      Dcm_DiagInitMsgContextBufferInfo(&(pThreadContext->Diag.MsgContext), 0u);                                                                      /* SBSW_DCM_POINTER_INIT_MESSAGE_CONTEXT */
    }

    /* Initialize run-time kernel sub-system */
    Dcm_TmrInit();
    Dcm_TskInit();

    /* Initialize communication sub-systems */
    Dcm_NetInit();
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
    Dcm_PagedBufferInit();
#endif

    /* Initialize diagnostic service helpers sub-systems */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
    Dcm_DidMgrInit();                                                                                                                                /* PRQA S 2987 */ /* MD_Dcm_2987 */
#endif
    Dcm_RsrcMgrInit();

    /* Initialize diagnostic state management sub-systems */
#if (DCM_MODE_COMMCTRL_ENABLED == STD_ON) || \
    (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
    Dcm_ModeInit();
#endif
    Dcm_StateInit();
#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
    Dcm_AuthMgrInit();
#endif

    /* Initialize diagnostic service processing kernel sub-system */
    Dcm_DiagInit();

    /* Initialize debug sub-component as last to mark DCM as completely initialized */
    Dcm_DebugInit();/* from now on the DCM is ready to work */
#if (DCM_FBLMGR_SUPPORT_ENABLED == STD_ON)
    Dcm_FblMgrReset();
#endif /* (DCM_FBLMGR_SUPPORT_ENABLED == STD_ON) */
  }
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MainFunctionTimer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_MainFunctionTimer(
  void
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  if(!Dcm_DebugIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    Dcm_TskScheduler(DCM_TSK_PRIO_HIGH);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_MAINFUNCTION, lErrorId);
}
#endif

#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MainFunctionWorker()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_MainFunctionWorker(
  void
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  if(!Dcm_DebugIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    Dcm_TskScheduler(DCM_TSK_PRIO_LOW);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_MAINFUNCTION, lErrorId);
}
#endif

#if (DCM_SPLIT_TASKS_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_MainFunction()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_MainFunction(
  void
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  if(!Dcm_DebugIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    Dcm_TskScheduler(DCM_TSK_PRIO_NONE);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_MAINFUNCTION, lErrorId);
}
#endif
/**********************************************************************************************************************
 *  Dcm_ExternalProcessingDone()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_ExternalProcessingDone(
  Dcm_MsgContextPtrType pMsgContext                                                                                                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_ProcessingDone(pMsgContext->threadId);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_EXT_PROCESSINGDONE, lErrorId);
}

/**********************************************************************************************************************
 *  Dcm_ExternalSetNegResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_ExternalSetNegResponse(
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodeType errorCode
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_SetNegResponse(errorCode, pMsgContext->threadId);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_EXT_SETNEGRESPONSE, lErrorId);
}

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ProvideRecoveryStates()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_ProvideRecoveryStates(
  P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo
  )
{
  Std_ReturnType  lResult  = DCM_E_NOT_OK;
  uint8           lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(RecoveryInfo == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_DiagProvideRecoveryStates(RecoveryInfo);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
    lResult = DCM_E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_PROVIDERECOVERYSTATES, lErrorId);

  return lResult;
}
#endif

#if (DCM_DIAG_SPECIFIC_CAUSE_CODE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_SetSpecificCauseCode()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_SetSpecificCauseCode(
  Dcm_SpecificCauseCodeType specificCauseCode
  )
{
  Std_ReturnType lResult  = DCM_E_NOT_OK;
  uint8          lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_DiagSetSpecificCauseCode(specificCauseCode);
    lResult = DCM_E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_SETSPECIFICCAUSECODE, lErrorId);

  return lResult;
}
#endif
#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VsgSetSingle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_VsgSetSingle(
  Dcm_VsgIdentifierType VsgId,
  Dcm_VsgStateType State
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  uint8          lErrorId   = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */

  if (Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (Dcm_DebugDetectError( (VsgId >= DCM_VARMGR_NUM_CFG_VARIANTS)
                               ||(VsgId == 0u) ))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    lStdResult = DCM_E_OK;

    Dcm_VarMgrVsgSetSingle(VsgId, State);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_VSGSETSINGLE, lErrorId);

  return lStdResult;
}
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VsgIsActive()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_VsgIsActive(
  Dcm_VsgIdentifierType VsgId,
  P2VAR(Dcm_VsgStateType, AUTOMATIC, DCM_APPL_DATA) State
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  uint8          lErrorId   = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ------------------------------------- */

  if (Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (Dcm_DebugDetectError( (VsgId >= DCM_VARMGR_NUM_CFG_VARIANTS)
                               ||(VsgId == 0u) ))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if (Dcm_DebugDetectError(State == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    lStdResult = DCM_E_OK;

    Dcm_VarMgrVsgIsActive(VsgId, State);                                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_VSGISACTIVE, lErrorId);

  return lStdResult;
}
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VsgSetMultiple()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_VsgSetMultiple(
  P2CONST(Dcm_VsgIdentifierType, AUTOMATIC, DCM_APPL_DATA) VsgIdList,
  uint16 VsgListSize,
  Dcm_VsgStateType State
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  uint8          lErrorId   = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if (Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (Dcm_DebugDetectError( (VsgListSize > DCM_VARMGR_NUM_CFG_VARIANTS)
                               ||(VsgListSize == 0u) ))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if (Dcm_DebugDetectError(VsgIdList == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_VsgIdentifierType lVsgIter;

    /* Iterate over all passed VSGs */
    for (lVsgIter = 0; lVsgIter < VsgListSize; ++lVsgIter)
    {
      lStdResult = Dcm_VsgSetSingle(VsgIdList[lVsgIter], State);

      if(lStdResult == DCM_E_NOT_OK)
      {
        break;
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_VSGSETMULTIPLE, lErrorId);

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VsgIsActiveAnyOf()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_VsgIsActiveAnyOf(
  P2CONST(Dcm_VsgIdentifierType, AUTOMATIC, DCM_APPL_DATA) VsgIdList,
  uint16 VsgListSize,
  P2VAR(Dcm_VsgStateType, AUTOMATIC, DCM_APPL_DATA) State
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  uint8          lErrorId   = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if (Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (Dcm_DebugDetectError( (VsgListSize > DCM_VARMGR_NUM_CFG_VARIANTS)
                               ||(VsgListSize == 0u) ))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if (Dcm_DebugDetectError(State == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if (Dcm_DebugDetectError(VsgIdList == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_VsgIdentifierType lVsgIter;

    /* Iterate over all passed VSGs */
    for (lVsgIter = 0; lVsgIter < VsgListSize; ++lVsgIter)
    {
      lStdResult = Dcm_VsgIsActive(VsgIdList[lVsgIter], State);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */

      if( (lStdResult == DCM_E_NOT_OK)
        ||(*State == DCM_VSG_ENABLED) )
      {
        break;
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_VSGISACTIVEANY, lErrorId);

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif
#if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_KeyMAsyncCertificateVerifyFinished()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_KeyMAsyncCertificateVerifyFinished(
  KeyM_CertificateIdType CertId,
  KeyM_CertificateStatusType Result
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_Svc29GetPendingKeyMCertId() != CertId))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_UtiEnterCriticalSection();
    /*=================================*
    BEGIN CRITICAL SECTION
    *=================================*/
    if(Dcm_Svc29IsAsyncKeyMJobActive())
    {
      Dcm_SingletonContext.Diag.Services.Svc29.KeyMCbkResult = Result;
      Dcm_Svc29SetNextCbkProcessingState();
    }
    else if(Dcm_Svc29IsCbkStateActive(DCM_SVC29_CBK_PROC_STATE_KEYM_CANCELLED))
    {
      /* Reset callback processing state */
      Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_IDLE);
    }
    else
    {
      /* Callback is not expected */
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
    }
    /*=================================*
    END CRITICAL SECTION
    *=================================*/
    Dcm_UtiLeaveCriticalSection();
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_KEYMASYNCCERTIFICATEVERIFYFINISHED, lErrorId);
  return DCM_E_OK;
}

/**********************************************************************************************************************
 *  Dcm_CsmAsyncJobFinished()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_CsmAsyncJobFinished(
  P2CONST(Crypto_JobType, AUTOMATIC, DCM_APPL_DATA) job,
  Crypto_ResultType result
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_Svc29GetPendingCsmJobId() != job->jobId))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    switch(Dcm_Svc29GetCbkProcessingState())
    {
    case DCM_SVC29_CBK_PROC_STATE_GENERATE_CHALLENGE:
    case DCM_SVC29_CBK_PROC_STATE_SIGN_CHALLENGE:
    case DCM_SVC29_CBK_PROC_STATE_VERIFY_POOW:
      Dcm_SingletonContext.Diag.Services.Svc29.CsmCbkResult = result;
      Dcm_Svc29SetNextCbkProcessingState();
      break;
    case DCM_SVC29_CBK_PROC_STATE_CSM_CANCELLED:
      /* Remove service 0x29 as user of the buffer since the Csm callback is triggered and released the buffer */
      Dcm_NetBufferUsageLeave(Dcm_NetGetBufferContext(Dcm_Svc29GetBufferHdl()));                                                                     /* PRQA S 2840, 3387 */ /* MD_Dcm_DerefInvalidPointer, MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
      /* Reset callback processing state */
      Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_IDLE);
      break;
    default:                                                                                                                                         /* PRQA S 2016 */ /* MD_MSR_EmptyClause */
      /* Callback is not expected */
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
      break;
    }
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiLeaveCriticalSection();
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_CSMASYNCJOBFINISHED, lErrorId);
}
#endif /* (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */

#define DCM_START_SEC_CODE
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DCM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrReadUdsMid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgrReadUdsMid(
  Dcm_ObdIdMgrHandleMemType handle,
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext
  )
{
  Std_ReturnType                 lStdResult = DCM_E_OK; /* if no data to be returned -> positive response */
  uint16                         lTestValue;
  uint16                         lMinLimit;
  uint16                         lMaxLimit;
  Dcm_DTRStatusType              lStatus;
  Dcm_CfgSvc06Mid2TidRefOptType  lHandle    = Dcm_CfgSvc06Mid2TidRefMap[handle];
  Dcm_CfgSvc06Mid2TidRefOptType  lMaxHandle = Dcm_CfgSvc06Mid2TidRefMap[handle + 1u];
  Dcm_CfgSvc06MidTidInfoPtrType  pMidTidInfo;
  Dcm_NegativeResponseCodeType   lNrc;

  for(;lHandle<lMaxHandle; lHandle++)
  {
    lStdResult = Dcm_CfgSvc06MidTidInfoGetEntry(lHandle, &pMidTidInfo, &lNrc);                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)                                                                                                                       /* COV_DCM_RTM_RUNTIME_CHECK TX */
    {
      lStdResult = pMidTidInfo->OpFunc(opStatus, &lTestValue, &lMinLimit, &lMaxLimit, &lStatus);                                                     /* SBSW_DCM_POINTER_FORWARD_STACK */ /* SBSW_DCM_CALL_FUNCPTR_SVC06MIDTIDINFO */

      if (lStdResult == DCM_E_OK)
      {
        if(lStatus == DCM_DTRSTATUS_INVISIBLE)
        {
          lTestValue = 0;
          lMinLimit  = 0;
          lMaxLimit  = 0;
        }

        /* Copy data */
        Dcm_UtiProvideDataAsU8(pDataContext, pMidTidInfo->Tid);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_UtiProvideDataAsU8(pDataContext, pMidTidInfo->Uasid);                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_UtiProvideDataAsU16(pDataContext, lTestValue);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_UtiProvideDataAsU16(pDataContext, lMinLimit);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_UtiProvideDataAsU16(pDataContext, lMaxLimit);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
    }

    if(lStdResult != DCM_E_OK)
    {
      break;
    }
  }

  return lStdResult;
}
# endif

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_IsDidAvailable()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_IsDidAvailable(
  uint16 DID,
  Dcm_OpStatusType OpStatus,
  P2VAR(Dcm_DidSupportedType, AUTOMATIC, DCM_VAR_NOINIT) supported
  )
{
  uint8 lOBDMid = Dcm_UtiGetLoByte(DID);

  DCM_IGNORE_UNREF_PARAM(OpStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  *supported = DCM_DID_NOT_SUPPORTED;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */

  /* Check kind of DID (Availability ID or Data ID) */
  if (Dcm_ObdIdMgrIsAvailabilityId(DID))
  {
    /* If DID is a availability ID  */
    uint32 lObdMidAvailMask;

    /* Request value of availabity ID from Dem */
    if (Dem_DcmGetAvailableOBDMIDs(lOBDMid, &lObdMidAvailMask) == E_OK)                                                                              /* SBSW_DCM_POINTER_FORWARD_STACK */
    {
      /* If request ist successful */
      /* Report to caller that DID is available */
      *supported = DCM_DID_SUPPORTED;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
  else
  {
    /* If DID is Data ID */
    uint8 lNumOfTIDs;

    /* Request number of TIDs for Data ID */
    if (Dem_DcmGetNumTIDsOfOBDMID(lOBDMid, &lNumOfTIDs) == E_OK)                                                                                     /* SBSW_DCM_POINTER_FORWARD_STACK */
    {
      /* If request is successful */
      /* Report to caller that DID is available */
      *supported = DCM_DID_SUPPORTED;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  return DCM_E_OK;
}
# endif

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidRangeDataLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidRangeDataLength(
  uint16 DID,
  Dcm_OpStatusType OpStatus,
  P2VAR(uint16, AUTOMATIC, DCM_VAR_NOINIT) DataLength
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(OpStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Check kind of DID (Availability ID or Data ID) */
  if (Dcm_ObdIdMgrIsAvailabilityId(DID))
  {
    /* If DID is an availability ID  */
    /* Set data length to 4 */
    *DataLength = 4u;                                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    /* Otherwise DID is a Data ID */
    uint8 lObdMid = Dcm_UtiGetLoByte(DID);
    uint8 lNumOfTIDs;

    /* Request number of TIDs for Data ID */
    if (Dem_DcmGetNumTIDsOfOBDMID(lObdMid, &lNumOfTIDs) == E_OK)                                                                                     /* SBSW_DCM_POINTER_FORWARD_STACK */
    {
      /* If request is successful calculate total response data length */
      *DataLength = (uint16)lNumOfTIDs * 8u;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      /* Otherwise something went wrong - report back */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}
# endif

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidData(
  uint16 DID,
  Dcm_OpStatusType OpStatus,
  Dcm_DiagDataContextPtrType pDataContext
  )
{
  Std_ReturnType lStdResult;
  uint8 lObdMid = Dcm_UtiGetLoByte(DID);

  DCM_IGNORE_UNREF_PARAM(OpStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Check kind of DID (Availability ID or Data ID) */
  if (Dcm_ObdIdMgrIsAvailabilityId(DID))
  {
    /* If DID is a availability ID */
    /* Read value of availabiltity Id */
    lStdResult = Dcm_ObdIdMgr_F6XX_ReadDidData_SupportedId(lObdMid, pDataContext);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  /* Otherwise */
  else
  {
    /* Read Value of Data Id */
    lStdResult = Dcm_ObdIdMgr_F6XX_ReadDidData_DataId(lObdMid, pDataContext);                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  return lStdResult;
}
# endif

# if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON) && \
     (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrGetDidAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(uint32, DCM_CODE) Dcm_ObdIdMgrGetDidAvailabilityMask(
  uint16 DidLookUpRefStart,
  uint16 DidLookUpRefEnd,
  Dcm_ObdIdMgrMaskValueTableType maskValue
  )
{
  uint32 lResultMask;
  uint16_least lLookUpIter;

  DCM_IGNORE_UNREF_PARAM(maskValue);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lResultMask = 0;

  /* Iterate over all (WWH-)OBD DIDs related to the AID */
  for(lLookUpIter  = DidLookUpRefStart;
      lLookUpIter <= DidLookUpRefEnd;
      ++lLookUpIter)
  {
    Dcm_DidMgrDidInfoContextType lDidInfoContext;
    uint8 lDidLowByte;

    /* Consider only the DID low-byte since the AID reports the availability mask only for a certain
     * DID range (e.g 0xF4XX).
     */
    lDidLowByte = Dcm_UtiGetLoByte(Dcm_CfgDidMgrDidLookUpTable[lLookUpIter]);

    lDidInfoContext.Descriptor.DidInfoIdx = (Dcm_CfgDidMgrDidInfoRefType)(lLookUpIter - 1u);
    Dcm_DidMgrInitOpInfo(&lDidInfoContext, DCM_DIDMGR_OP_READ);                                                                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

    /* If the DID is (still) supported: */
    if(Dcm_VarMgrIsEnabledInActiveVariants(Dcm_CfgDidMgrGetDidOpInfo(&lDidInfoContext)->ExecCondRef) == TRUE)                                        /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
    {
      /* Set the corresponding bit in the availability bitmap */
      Dcm_UtiBitOpSet(uint32, lResultMask, Dcm_ObdIdMgrGetObdIdMaskBit(lDidLowByte));
    }
  }

#  if (DCM_OBDUDSIDMGR_CALIBRATION_ENABLED == STD_ON)
  /* Consider any DIDs additionally suppressed by calibration procedure */
  lResultMask &= maskValue;
#  endif

  return lResultMask;
}
# endif

# if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON) && \
     (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrGetRidAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(uint32, DCM_CODE) Dcm_ObdIdMgrGetRidAvailabilityMask(
  uint16 RidLookUpRefStart,
  uint16 RidLookUpRefEnd,
  Dcm_ObdIdMgrMaskValueTableType maskValue
  )
{
  uint32 lResultMask;
  uint16_least lLookUpIter;

  DCM_IGNORE_UNREF_PARAM(maskValue);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lResultMask = 0;
  /* Iterate over all (WWH-)OBD RIDs related to the AID */
  for(lLookUpIter  = RidLookUpRefStart;
      lLookUpIter <= RidLookUpRefEnd;
      ++lLookUpIter)
  {
    uint8 lRidLowByte;
    /* Consider only the RID low-byte since the AID reports the availability mask only for a certain
     * RID range (e.g 0xE0XX).
     */
    lRidLowByte = Dcm_UtiGetLoByte(Dcm_CfgRidMgrRidLookUpTable[lLookUpIter]);

    /* If the RID is (still) supported: */
    if(Dcm_VarMgrIsEnabledInActiveVariants(Dcm_CfgRidMgrRidInfo[lLookUpIter-1u].ExecCondRef) == TRUE)                                                /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
    {
      /* Set the corresponding bit in the availability bitmap */
      Dcm_UtiBitOpSet(uint32, lResultMask, Dcm_ObdIdMgrGetObdIdMaskBit(lRidLowByte));
    }
  }

#  if (DCM_OBDUDSIDMGR_CALIBRATION_ENABLED == STD_ON)
  /* Consider any RIDs additionally suppressed by calibration procedure */
  lResultMask &= maskValue;
#  endif

  return lResultMask;
}
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_NetGetTransportObject()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Dcm_NetTransportObjectPtrType, DCM_CODE) Dcm_NetGetTransportObject(
  Dcm_CfgNetTObjHandleOptType index
  )
{
  Dcm_NetTransportObjectPtrType lResult;

  if (Dcm_DebugDetectRuntimeError(index >= Dcm_PbCfgNetNumTransportObjects))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = &Dcm_PbRamNetTransportObject[0];
  }
  else
  {
    lResult = &Dcm_PbRamNetTransportObject[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetGetComState()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Dcm_NetComMStateType, DCM_CODE) Dcm_NetGetComState(
  PduIdType rxPduId
  )
{
  Dcm_NetComMStateType lResult  = DCM_NET_COMM_STATE_RX_DIS_TX_DIS;                                                                                  /* PRQA S 2981 */ /* MD_Dcm_RetVal */
  uint8                lErrorId = DCM_E_NO_ERROR;

  DCM_IGNORE_UNREF_PARAM(rxPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(Dcm_NetIsRxPduIdValid(rxPduId) == FALSE))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    lResult = Dcm_NetGetComStateByRxPduId(rxPduId);                                                                                                  /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_INTERNAL, lErrorId);

  return lResult;
}

#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxIndInternal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_NetRxIndInternal(
  PduIdType rxPduId,
  uint16 sourceAddress,
  Dcm_MsgType data,                                                                                                                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  PduLengthType length
  )
{
  Std_ReturnType                              notifResult = DCM_NET_ARENV_NTFRSLT_NOT_OK;
  BufReq_ReturnType                           bufReq;
  PduLengthType                               bufferSize;
  P2CONST(PduInfoType, AUTOMATIC, AUTOMATIC)  pInfo;
# if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
  uint8                                     lMetaData[DCM_NET_METADATA_LENGTH];
  PduInfoType                               lInfo;
# endif

  DCM_IGNORE_UNREF_PARAM(sourceAddress);                                                                                                             /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
  if(Dcm_NetIsGenericConnection(Dcm_NetGetConnHdlOfRxPduId(rxPduId)))
  {
    lMetaData[DCM_NET_METADATA_SA_OFFSET] = (uint8)sourceAddress;                                                                                    /* SBSW_DCM_LOCAL_ARRAY_WRITE */
    lMetaData[DCM_NET_METADATA_TA_OFFSET] = Dcm_NetGetNodeAddress(Dcm_NetGetConnHdlOfRxPduId(rxPduId));                                              /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_LOCAL_ARRAY_WRITE */
    lInfo.SduDataPtr = lMetaData;
    lInfo.SduLength = DCM_NET_METADATA_LENGTH;
    pInfo = &lInfo;
  }
  else
# endif
  {
    pInfo = NULL_PTR;
  }

# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
  Dcm_DebugAssert((Dcm_NetGetConnHdlOfRxPduId(rxPduId) < Dcm_PbCfgNetNumConnections), DCM_SID_INTERNAL, DCM_E_PARAM);                                /* COV_DCM_RTM_DEV_DEBUG XF */
# endif

  /* start virtual request; */
  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Initiate reception for the required RxPduID. Mark this reception as an internal one in order to get correct
   * ComM management.
   */
  bufReq = Dcm_NetStartOfReception(rxPduId, pInfo, length, &bufferSize, DCM_NET_TOBJ_FLAG_INTERNAL);                                                 /* SBSW_DCM_POINTER_FORWARD_STACK */
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiLeaveCriticalSection();

  /* If reception accepted: */
  if(bufReq == BUFREQ_OK)
  {
    Dcm_NetTransportObjectPtrType pTranspObj;
    bufReq = Dcm_NetGetTranspObjOfConnection(Dcm_NetGetConnHdlOfRxPduId(rxPduId), &pTranspObj);                                                      /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_FORWARD_STACK */

    if(bufReq == BUFREQ_OK)                                                                                                                          /* COV_DCM_RTM_UNREACHABLE XF */
    {
# if (DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      /* If not a pseudo parallel request */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) == 0u)
# endif
      {
        PduInfoType pduInfo;

        pduInfo.SduDataPtr = data;
        pduInfo.SduLength = length;

        /* Copy received data */
        bufReq = Dcm_CopyRxData(rxPduId, &pduInfo, &bufferSize);                                                                                     /* SBSW_DCM_POINTER_FORWARD_STACK */
        /* If data copy succeeded: */
        if(bufReq == BUFREQ_OK)                                                                                                                      /* COV_DCM_RTM_UNREACHABLE TX */
        {
          /* Notify DCM about successful reception */
          notifResult = DCM_NET_ARENV_NTFRSLT_OK;
        }/* else - Dcm_CopyRxData failed -> exit with Dcm_TpRxIndication(failed) */
      }/* else - a pseudo parallel request will not be processed over an internal request */
    }
    else
    {
      /* Check for valid call state */
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                   /* COV_DCM_RTM_DEV_DEBUG XF */
    }
    /* Notify DCM about reception accomplishment only in case the reception was accepted */
    Dcm_TpRxIndication(rxPduId, notifResult);
  }/* else - no reception possible exit with fail */
  /* Return the operation result to the caller */
  return notifResult;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif
/**********************************************************************************************************************
 *  Dcm_RepeaterSetCallee()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_RepeaterSetCallee(
  Dcm_ContextPtrType pContext,
  uint8 serviceProcessorIdx
  )
{
  pContext->Thread->Repeater.CalleeIdx = serviceProcessorIdx;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_RepeaterNextStep(pContext, DCM_REPEATER_PROGRESS_INITIAL);                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
}
#if (DCM_MODE_ROE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchRoE()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_ModeSwitchRoE(
  uint8 eventId,
  Rte_ModeType_DcmResponseOnEvent mode
  )
{
  if (Dcm_DebugDetectRuntimeError(eventId >= DCM_CFGMODEROEEVENTMODESWITCHINFOTABLE_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    (void)Dcm_CfgModeRoEEventModeSwitchInfoTable[eventId].OpFunc(mode);                                                                              /* SBSW_DCM_CALL_FUNCPTR_ROEMODESWITCH */
  }
}
#endif
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateCheckDID()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_StateCheckDID(
  Dcm_NetConnRefMemType connHdl,
  uint16 did,
  Dcm_DidOpType didOpMask,
  Dcm_CfgStateRefOptType stateRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdReturn;

  /* Get the precondition package for the related diagnostic entity */
  CONSTP2CONST(Dcm_CfgStateDiagStateInfoType, AUTOMATIC, DCM_CONST) pStatePreconditions = &Dcm_StateGetPreconditionStates(stateRef);

  /* First verify the diagnostic session pre-condition (UDS verification order) */
  if(!Dcm_StateIsSupportedInSession(*pStatePreconditions))                                                                                           /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
  {
    /* If not met, return appropriate to UDS NRC for the evaluated diagnostic entity (i.e. NRC 0x7F for services, 0x7E for sub-functions etc.) */
    *ErrorCode = Dcm_StateSessionNrcs[DCM_DIAG_CHK_LVL_PARAMETER];                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  /* Otherwise, if supported, verify the authentication requirement (UDS verification order) */
# if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
  if(Dcm_AuthMgrCheckDid(connHdl, did, didOpMask, stateRef) == DCM_E_NOT_OK)
  {
    /* If not met, do return NRC 0x34 */
    *ErrorCode = DCM_E_AUTHENTICATIONREQUIRED;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
  /* Otherwise, if supported, verify the security access level pre-condition (UDS verification order) */
# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  if(!Dcm_StateIsSupportedInSecurityLevel(*pStatePreconditions))
  {
    /* If not met, do return NRC 0x33 (UDS) */
    *ErrorCode = DCM_E_SECURITYACCESSDENIED;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
  {
# if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
    /* Otherwise, if supported, get the the mode-related pre-condition expression(s) result */
    lStdReturn = Dcm_ModeCheck(Dcm_CfgStatePreconditions[stateRef].ModeRuleRef, ErrorCode);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
# else
    /* Otherwise, everything fine - return positive response code */
    lStdReturn = DCM_E_OK;
# endif
  }

  DCM_IGNORE_UNREF_PARAM(did);                                                                                                                       /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(didOpMask);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(connHdl);                                                                                                                   /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return lStdReturn;
}
#endif
/**********************************************************************************************************************
 *  Dcm_TmrSetTimerByThread()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_TmrSetTimerByThread(
  Dcm_TmrTimerIdOptType timerId,
  Dcm_TmrTimerCntrMemType timeTicks,
  Dcm_ThreadIdOptType threadId
  )
{
  Dcm_TmrTimerIdOptType      lTimerContextId;
  Dcm_TmrTimerContextPtrType pTimerContext;

  lTimerContextId = (Dcm_TmrTimerIdOptType)(Dcm_TmrGetTimerInfo(timerId)->TimerContextRef + threadId);
  pTimerContext   = Dcm_TmrGetTimerContext(lTimerContextId);

  /* Update the corresponding timer counter */
  pTimerContext->Timer = timeTicks;                                                                                                                  /* SBSW_DCM_POINTER_WRITE_TIMERCONTEXT */
}

/**********************************************************************************************************************
 *  Dcm_TmrStartTimerByThread()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_TmrStartTimerByThread(
  Dcm_TmrTimerIdOptType timerId,
  Dcm_TmrTimerCntrMemType timeTicks,
  Dcm_ThreadIdOptType threadId
  )
{
  if (timeTicks != 0u)
  {
    Dcm_TmrTimerIdOptType      lTimerContextId;
    Dcm_TmrTimerContextPtrType pTimerContext;

    lTimerContextId = (Dcm_TmrTimerIdOptType)(Dcm_TmrGetTimerInfo(timerId)->TimerContextRef + threadId);
    pTimerContext = Dcm_TmrGetTimerContext(lTimerContextId);

    /* Enter critical section (Reason: A timer can be modified from an ISR or higher priority task) */
    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
      *=================================*/
    /* Update the corresponding timer counter */
    pTimerContext->Timer = timeTicks;                                                                                                                /* SBSW_DCM_POINTER_WRITE_TIMERCONTEXT */

    /* Mark timer as running */
    Dcm_TmrSetTimerRunning(lTimerContextId);
    /*=================================*
      END CRITICAL SECTION
      *=================================*/
    Dcm_UtiLeaveCriticalSection();
    /* Signal the Dcm_TmrTaskTimer() that at least one timer is active */
    Dcm_TskSetEvent(DCM_TSK_ID_TIMER, DCM_TSK_EV_TIMER_ACTIVE);
  }
}

/**********************************************************************************************************************
 *  Dcm_TmrStopTimerByThread()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_TmrStopTimerByThread(
  Dcm_TmrTimerIdOptType timerId,
  Dcm_ThreadIdOptType threadId
  )
{
  Dcm_TmrTimerIdOptType lTimerContextId;

  lTimerContextId = (Dcm_TmrTimerIdOptType)(Dcm_TmrGetTimerInfo(timerId)->TimerContextRef + threadId);

  /* Enter critical section (Reason: A timer can be modified from an ISR or higher priority task) */
  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Mark timer as not running */
  Dcm_TmrSetTimerStopped(lTimerContextId);
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiLeaveCriticalSection();
}

/**********************************************************************************************************************
 *  Dcm_TmrResumeTimerByThread()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_TmrResumeTimerByThread(
  Dcm_TmrTimerIdOptType timerId,
  Dcm_ThreadIdOptType threadId
  )
{
  Dcm_TmrTimerIdOptType           lTimerContextId;
  Dcm_TmrTimerContextConstPtrType pTimerContext;

  lTimerContextId = (Dcm_TmrTimerIdOptType)(Dcm_TmrGetTimerInfo(timerId)->TimerContextRef + threadId);
  pTimerContext   = Dcm_TmrGetTimerContext(lTimerContextId);

  /* Enter critical section (Reason: A timer can be modified from an ISR or higher priority task) */
  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  if(pTimerContext->Timer != 0u)
  {
    /* Mark timer as running */
    Dcm_TmrSetTimerRunning(lTimerContextId);
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiLeaveCriticalSection();
  /* Signal the Dcm_TmrTaskTimer() that at least one timer is active */
  Dcm_TskSetEvent(DCM_TSK_ID_TIMER, DCM_TSK_EV_TIMER_ACTIVE);
}
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrDidNoOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrDidNoOp(
  Dcm_MsgType data                                                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(data);                                                                                                                      /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  return DCM_E_OK;
}

# if (DCM_DIDMGR_NVM_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadNvMSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrNvMReadSignal(
  Dcm_OpStatusType opStatus,
  Dcm_MsgType data,
  uint16 blockId
  )
{
  return Dcm_UtiNvMRead(opStatus, data, blockId);                                                                                                    /* PRQA S 0315 */ /* MD_MSR_Dir1.1 */ /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_DIDMGR_NVM_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWriteNvMSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrNvMWriteSignal(
  Dcm_ReadOnlyMsgType data,
  Dcm_OpStatusType opStatus,
  Dcm_NegativeResponseCodePtrType errorCode,
  uint16 blockId
  )
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_UtiNvMSwcDataWrite(opStatus, data, blockId);                                                                                      /* PRQA S 0315 */ /* MD_MSR_Dir1.1 */ /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdResult == DCM_E_NOT_OK)
  {
    *errorCode = DCM_E_GENERALPROGRAMMINGFAILURE;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  return lStdResult;
}
# endif

# if (DCM_DIDMGR_SR_IO_CONTROL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoCtrlSRHandler_Control()
*********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoCtrlSRHandler_Control(
  Dcm_CfgDidMgrIoCtrlSRHandlersRefOptType srEntryIndex,
  uint8 ioOperation,
  Dcm_ReadOnlyMsgType reqData,
  Dcm_OpStatusType opStatus,
  uint32 cemr,
  Dcm_NegativeResponseCodePtrType errorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;
  Dcm_IOOperationResponseType ioResponse;
  Dcm_DidMgrIoCtrlSRHandlersConstPtrType pIoControlSrHandlers = Dcm_CfgDidMgrIoControlSenderReceiverHandlersGetEntry(srEntryIndex);

  *errorCode = DCM_E_POSITIVERESPONSE;                                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */

  /* ignore parameter reqData if no IO Did supports ShortTermAdjustment */
  DCM_IGNORE_UNREF_PARAM(reqData);                                                                                                                   /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if (opStatus == DCM_INITIAL)
  {
    /* Clear IsUpdated flag */
    lStdResult = pIoControlSrHandlers->IoCtrlResRead(&ioResponse);                                                                                   /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */ /* SBSW_DCM_POINTER_FORWARD_STACK */

    if ( (ioOperation == 0x03u)
       &&(lStdResult == DCM_E_OK))
    {
      /* Transfer requested data */
      lStdResult = pIoControlSrHandlers->IoCtrlReqCtrlStateWrite(reqData);                                                                           /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */
    }

    if (lStdResult == DCM_E_OK)
    {
      /* Transfer new IO operation and new CEMR  */
      lStdResult = pIoControlSrHandlers->IoCtrlReqIoOpReqWrite(ioOperation, cemr);                                                                   /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */
    }
  }

  /* OpStatus == DCM_CANCEL has no negative effect -> leave it unhandled */

  /* Get acknowledge */
  if (lStdResult == DCM_E_OK)
  {
    if (pIoControlSrHandlers->IoCtrlResIsUpdated() == TRUE)                                                                                          /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */
    {
      lStdResult = pIoControlSrHandlers->IoCtrlResRead(&ioResponse);                                                                                 /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */ /* SBSW_DCM_POINTER_FORWARD_STACK */
      if (lStdResult == DCM_E_OK)
      {
        switch (ioResponse)
        {
        case DCM_POSITIVE_RESPONSE:
        {
          uint32 underControl;
          lStdResult = pIoControlSrHandlers->IoCtrlReqUnderControlRead(&underControl);                                                               /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */ /* SBSW_DCM_POINTER_FORWARD_STACK */
          if (lStdResult == DCM_E_OK)
          {
            lStdResult = pIoControlSrHandlers->IoCtrlReqUnderControlWrite(underControl | cemr);                                                      /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */
          }
          /* Set IO Operation to Idle (0xFF); return value is not evaulated due to final response of application */
          (void)pIoControlSrHandlers->IoCtrlReqIoOpReqWrite(0xFFu, cemr);                                                                            /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */
          break;
        }
        case DCM_RESPONSE_PENDING:
          lStdResult = DCM_E_PENDING;
          break;
        default: /* any NRC */
          /* Set IO Operation to Idle (0xFF); return value is not evaulated due to final response of application */
          (void)pIoControlSrHandlers->IoCtrlReqIoOpReqWrite(0xFFu, cemr);                                                                            /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */
          *errorCode = ioResponse;                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
          break;
        }
      }
    }
    else
    {
      lStdResult = DCM_E_PENDING;
    }
  }

  if ( (lStdResult == DCM_E_NOT_OK)
     &&(*errorCode == DCM_E_POSITIVERESPONSE))
  {
    *errorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }/* else:RTE error codes are handled in DCM core */

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6060, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STPAR, MD_MSR_STMIF */
# endif

# if (DCM_DIDMGR_SR_IO_CONTROL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoCtrlSRHandler_Reset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoCtrlSRHandler_Reset(
  Dcm_CfgDidMgrIoCtrlSRHandlersRefOptType srEntryIndex,
  uint32 cemr,
  Dcm_NegativeResponseCodePtrType errorCode
  )
{
  Std_ReturnType lStdResult;
  uint32         underControl;

  Dcm_DidMgrIoCtrlSRHandlersConstPtrType pIoControlSrHandlers = Dcm_CfgDidMgrIoControlSenderReceiverHandlersGetEntry(srEntryIndex);

  /* Update under control elements */
  lStdResult = pIoControlSrHandlers->IoCtrlReqUnderControlRead(&underControl);                                                                       /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */ /* SBSW_DCM_POINTER_FORWARD_STACK */

  if (lStdResult == DCM_E_OK)
  {
    lStdResult = pIoControlSrHandlers->IoCtrlReqUnderControlWrite(underControl & ~cemr);                                                             /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */
  }

  if (lStdResult == DCM_E_OK)
  {
    /* Transfer new IO operation and new CEMR  */
    lStdResult = pIoControlSrHandlers->IoCtrlReqIoOpReqWrite(0x00u, cemr);                                                                           /* SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER */
  }

  if (lStdResult == DCM_E_NOT_OK)
  {
    *errorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }/* else:RTE error codes are handled in DCM core */

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrGetDidInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetDidInfo(
  Dcm_OpStatusType opStatus,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,                                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrOpOptType didOp
  )
{
  Std_ReturnType lStdReturn;
  Dcm_OpStatusType lOpStatus = opStatus;

  DCM_IGNORE_UNREF_PARAM(lOpStatus);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                         /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdReturn = DCM_E_NOT_OK;

  /* On the very first call: */
  if (lOpStatus == DCM_INITIAL)
  {
    /* Determine the lookup engine to run first (DID range or concrete DID) */
    pDidOpTypeContext->OpType.LookUp.State = DCM_DIDMGR_LOOKUP_STATE_DIDRANGE;                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  /* Otherwise: proceed with next steps */

  /* If current progress is to (still) lookup for a DID range: */
  if(pDidOpTypeContext->OpType.LookUp.State == DCM_DIDMGR_LOOKUP_STATE_DIDRANGE)
  {
    /* Delegate search to the DID range lookup engine */
    lStdReturn = Dcm_DidMgrDidRangeLookUp(lOpStatus, pDidInfoContext, pDidOpTypeContext, didOp);                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Evaluate result: */
    if(lOpStatus == DCM_CANCEL)
    {
      /* If the current call is a cancellation event: Terminate immediately any further processing */
      lStdReturn = DCM_E_NOT_OK;
    }
    else if(lStdReturn == DCM_E_NOT_OK)
    {
      /* Otherwise: If no match found: Continue with concrete DID look up */
      pDidOpTypeContext->OpType.LookUp.State = DCM_DIDMGR_LOOKUP_STATE_CONCRETEDID;                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
# if (DCM_DIDMGR_EXTENDED_LOOKUP_ENABLED == STD_ON)
    if(lStdReturn == DCM_E_OK)
    {
      lOpStatus = DCM_INITIAL; /* Prepare for new asynchronous calling sequence */
      /* Otherwise: If match found: Go on with optional DID look up result filtering */
      pDidOpTypeContext->OpType.LookUp.State = DCM_DIDMGR_LOOKUP_STATE_DIDFILTER_EXTERN;                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
# endif
# if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
    if(lStdReturn == DCM_E_LOOKUP_MATCH_FOUND)
    {
      /* Otherwise: If range match found but it was a gap: Report DID as not supported */
      lStdReturn = DCM_E_NOT_OK;
    }
    else
# endif
    {
      /*
       * Otherwise: Just return the final result: (DCM_E_PENDING | DCM_E_OK (if no extended look up) |
       * DCM_E_NOT_OK (if no gaps) )
       */
    }
  }
  /* Otherwise - keep current result: DCM_E_NOT_OK */

  /* If current progress is to lookup for a concrete DID: */
  if(pDidOpTypeContext->OpType.LookUp.State == DCM_DIDMGR_LOOKUP_STATE_CONCRETEDID)
  {
    /* Start concrete DID lookup engine */
    lStdReturn = Dcm_DidMgrConcreteDidLookUp(pDidInfoContext, didOp);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Evaluate result: */
# if (DCM_DIDMGR_EXTENDED_LOOKUP_ENABLED == STD_ON)
    if(lStdReturn == DCM_E_OK)
    {
      /* If valid DID found: proceed with optional lookup result filtering */
      lOpStatus = DCM_INITIAL; /* Prepare for new asynchronous calling sequence */
      pDidOpTypeContext->OpType.LookUp.State = DCM_DIDMGR_LOOKUP_STATE_DIDFILTER_EXTERN;                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    }
# endif
  }
  /* Otherwise - keep current result: DCM_E_OK, DCM_E_NOT_OK, DCM_E_PENDING */

# if (DCM_DIDMGR_EXTENDED_LOOKUP_ENABLED == STD_ON)
  /* If any valid DID(range) found: */
  if(pDidOpTypeContext->OpType.LookUp.State == DCM_DIDMGR_LOOKUP_STATE_DIDFILTER_EXTERN)
  {
    /* Proceed with optional lookup result filtering */
    lStdReturn = Dcm_FilterDidLookUpResult(lOpStatus, pDidInfoContext->Did, (Dcm_DidOpType)didOp);

    /* Evaluate result: */
    if(lOpStatus == DCM_CANCEL)
    {
      /* If the current call is a cancellation event: Terminate immediately any further processing */
      lStdReturn = DCM_E_NOT_OK;
    }

    /* If an valid/unexpected return value: */
    if(Dcm_DebugDetectError( (lStdReturn != DCM_E_OK)
                           &&(lStdReturn != DCM_E_PENDING)
                           &&(lStdReturn != DCM_E_NOT_OK) ))
    {
      /* Unexpected return value is treated as "DID not supported" */
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
      lStdReturn = DCM_E_NOT_OK;
    }
  }
  /* Otherwise - keep current result: DCM_E_OK, DCM_E_NOT_OK, DCM_E_PENDING */
# endif

  if(lStdReturn == DCM_E_OK)
  {
    /* Always perform standard filtering (variant, session, etc.) */
    lStdReturn = Dcm_DidMgrFilterDidLookUp(pDidInfoContext, didOp);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

  }

  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_DidMgrInitOpClassInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_DidMgrInitOpClassInfo(
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrOpCallOptType opType
  )
{
  Dcm_DidMgrOpCallOptType lOpType = opType;
  pDidInfoContext->Descriptor.DidOpClassInfoIdx = Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext)->OpTypeBaseIdx;                                         /* SBSW_DCM_PARAM_PTR_WRITE */

  /* 0x01 ->0x00 -> already found
   * 0x02 ->0x01 -> iterate once
   * .Etc */
  --lOpType; /* there is always at least one operation configured */

  /* clear all flags above this operation index (not relevant) */
  lOpType &= Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext)->CallTypes;

  while (lOpType != 0u)
  {
    pDidInfoContext->Descriptor.DidOpClassInfoIdx++;                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
    lOpType &= (Dcm_DidMgrOpOptType)(lOpType - 1u); /* clear the least significant bit set */
  }
}

/**********************************************************************************************************************
 *  Dcm_DidMgrReadCheckCond()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadCheckCond(
  Dcm_OpStatusType opStatus,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,                                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType   lStdResult = DCM_E_NOT_OK;                                                                                                        /* PRQA S 2981 */ /* MD_Dcm_RetVal */
  Dcm_OpStatusType lOpStatus = opStatus;

  if (lOpStatus == DCM_INITIAL)
  {
    /* Initialize DID handler */
    Dcm_DidMgrInitOpTypeHandler(pDidInfoContext, pDidOpTypeContext);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  DCM_UTI_LOOP_FOR_EVER
  {
    lStdResult = Dcm_DidMgrReadCheckCondSignal(lOpStatus
                                              ,pDidInfoContext
                                              ,pDidOpTypeContext
                                              ,ErrorCode);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    if(lStdResult == DCM_E_OK)
    {
      pDidOpTypeContext->Base.NumSignals--;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
    }

    if ((lStdResult != DCM_E_OK) || (pDidOpTypeContext->Base.NumSignals == 0u))
    {
      break;                                                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
    }

    /* next signal */
    pDidOpTypeContext->Base.SignalOpClassInfoRef++;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    lOpStatus = DCM_INITIAL;/* reset op status */
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6060 */ /* MD_MSR_STPAR */

/**********************************************************************************************************************
 *  Dcm_DidMgrReadLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadLength(
  Dcm_OpStatusType opStatus,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType          lStdResult;
  Dcm_DidMgrDidLengthType lSignalLength;

  if(opStatus == DCM_INITIAL)
  {
    /* Initialize DID handler */
    Dcm_DidMgrInitOpTypeHandler(pDidInfoContext, pDidOpTypeContext);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  lStdResult = Dcm_DidMgrReadLengthSignal(opStatus
                                         ,pDidInfoContext
                                         ,pDidOpTypeContext
                                         ,&lSignalLength
                                         ,ErrorCode);                                                                                                /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
    /* Set DID length to concrete DID length */
    pDidInfoContext->DidLength = (Dcm_DidMgrDidLengthType)(Dcm_CfgDidMgrGetDidInfo(pDidInfoContext)->MinLength + lSignalLength);                     /* SBSW_DCM_PARAM_PTR_WRITE */

    /* If no additional buffer space has to be reserved for that DID: */
    if(Dcm_CfgDidMgrGetDidInfo(pDidInfoContext)->ReservedLength == 0u)
    {
      /* Set required buffer space to concrete DID length */
      pDidInfoContext->ReservedLength = pDidInfoContext->DidLength;                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_DidMgrReadDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadDid(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if(opStatus == DCM_CANCEL)
  {
    lResult = DCM_E_NOT_OK;
    /* If DID signal already in processing: */
    if(pDidOpTypeContext->OpType.Read.OpStatus != DCM_INITIAL)
    {
      /* Notify application about cancellation */
      (void)Dcm_DidMgrReadSignal(opStatus
                                ,pDataContext
                                ,pDidInfoContext
                                ,pDidOpTypeContext
                                ,ErrorCode);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
    } /* Otherwise no cancellation shall be notified */
  }
  else
  {
    if(opStatus == DCM_INITIAL)
    {
      /* Otherwise, initialize DID handler */
      Dcm_DidMgrInitOpTypeHandler(pDidInfoContext, pDidOpTypeContext);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

      pDidOpTypeContext->OpType.Read.OpStatus = DCM_INITIAL;                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
      pDidOpTypeContext->OpType.Read.Progress = 0u;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    }

    /* Read all signals */
    lResult = Dcm_DidMgrReadMultiSignal(pDataContext, pDidInfoContext, pDidOpTypeContext, ErrorCode);                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  return lResult;
}
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_TskSetEventByThread()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_TskSetEventByThread(
  Dcm_TskTaskIdOptType taskId,
  Dcm_TskTaskEvMemType ev,
  Dcm_ThreadIdOptType threadId
  )
{
  Dcm_TskSchedulerContextPtrType pSchedulerContext;
  Dcm_TskTaskContextPtrType      pTaskContext;
  Dcm_TskTaskEvMemType           lEv = ev;
  Dcm_TskTaskIdOptType           lTaskContextId;
  Dcm_TskTaskInfoPtrType         pTaskInfo;
  Std_ReturnType                 lResult;

  /* No zero events are allowed! Possibly the Dcm_TskTaskEvMemType is too small to hold the value? */
  Dcm_DebugAssert((lEv != DCM_TSK_EV_NONE), DCM_SID_INTERNAL, DCM_E_PARAM);                                                                          /* COV_DCM_RTM_DEV_DEBUG XF */

  lResult = Dcm_TskGetSchedulerContext(Dcm_TskTaskInfo[taskId].TskPrio, &pSchedulerContext);                                                         /* SBSW_DCM_POINTER_FORWARD_STACK */

  if(lResult == DCM_E_OK)                                                                                                                            /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lResult = Dcm_TskGetTaskInfo(taskId, &pTaskInfo);                                                                                                /* SBSW_DCM_POINTER_FORWARD_STACK */

    if(lResult == DCM_E_OK)                                                                                                                          /* COV_DCM_RTM_RUNTIME_CHECK TX */
    {
      lTaskContextId    = (Dcm_TskTaskIdOptType)(pTaskInfo->TaskContextRef + threadId);
      lResult           = Dcm_TskGetTaskContext(lTaskContextId, &pTaskContext);                                                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

      if(lResult == DCM_E_OK)                                                                                                                        /* COV_DCM_RTM_RUNTIME_CHECK TX */
      {
        /* Enter critical section (Reason: a task event can be set during any ISR or higher priority task processing.) */
        Dcm_UtiEnterCriticalSection();
        /*=================================*
          BEGIN CRITICAL SECTION
         *=================================*/
#if (DCM_TSK_TASK_COMPLEX_KILL_ENABLED == STD_ON)
        /* If the task is marked as suspended, do set only those new events that are non-killable */
        if(Dcm_TskIsFlagSet(pTaskContext, DCM_TSK_TASK_FLAG_KILLED))
        {
          /* mask all to be set events, except the non-killable ones! */
          lEv &= Dcm_TskTaskInfo[taskId].NonKillEvents;
        }
#endif
        /* Add any masked/unmasked new events */
        Dcm_UtiBitOpSet(Dcm_TskTaskEvMemType, pTaskContext->TaskEvents, lEv);                                                                        /* SBSW_DCM_POINTER_WRITE_TASKCONTEXT */
        /* Activate the scheduler associated with the task */
        pSchedulerContext->SchdIsActive = TRUE;                                                                                                      /* PRQA S 2841, 2842 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_WRITE_SCHEDULERCONTEXT */
        /*=================================*
          END CRITICAL SECTION
         *=================================*/
        Dcm_UtiLeaveCriticalSection();
      }
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_TskClrEvent()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_TskClrEventByThread(
  Dcm_TskTaskIdOptType taskId,
  Dcm_TskTaskEvMemType ev,
  Dcm_ThreadIdOptType threadId
  )
{
  Dcm_TskTaskContextPtrType pTaskContext;
  Dcm_TskTaskIdOptType      lTaskContextId;
  Dcm_TskTaskInfoPtrType    pTaskInfo;
  Std_ReturnType            lResult;

  /* No zero events are allowed! Possibly the Dcm_TskTaskEvMemType is too small to hold the value? */
  Dcm_DebugAssert((ev != DCM_TSK_EV_NONE), DCM_SID_INTERNAL, DCM_E_PARAM);                                                                           /* COV_DCM_RTM_DEV_DEBUG XF */

  lResult = Dcm_TskGetTaskInfo(taskId, &pTaskInfo);                                                                                                  /* SBSW_DCM_POINTER_FORWARD_STACK */

  if (lResult == DCM_E_OK)                                                                                                                           /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lTaskContextId = (Dcm_TskTaskIdOptType)(pTaskInfo->TaskContextRef + threadId);
    lResult        = Dcm_TskGetTaskContext(lTaskContextId, &pTaskContext);                                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */

    if (lResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
    {
      Dcm_UtiEnterCriticalSection();
      /*=================================*
        BEGIN CRITICAL SECTION
       *=================================*/
      Dcm_UtiBitOpClr(Dcm_TskTaskEvMemType, pTaskContext->TaskEvents, ev);                                                                           /* SBSW_DCM_POINTER_WRITE_TASKCONTEXT */
      /*=================================*
        END CRITICAL SECTION
       *=================================*/
      Dcm_UtiLeaveCriticalSection();
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_TskGetEventByThread()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Dcm_TskTaskEvMemType, DCM_CODE) Dcm_TskGetEventByThread(
  Dcm_TskTaskIdOptType taskId,
  Dcm_ThreadIdOptType threadId
  )
{
  return Dcm_SingletonContext.TaskMgr.TaskContext[Dcm_TskTaskInfo[taskId].TaskContextRef + threadId].TaskEvents;
}
#if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrGetActiveComVariant()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dcm_CfgVarMgrComVariantType, DCM_CODE) Dcm_VarMgrGetActiveComVariant(
  void
  )
{
  return Dcm_SingletonContext.VarMgr.ActiveComVariant;
}
#endif

/**********************************************************************************************************************
 *  Dcm_VarMgrGetActiveCfgVariantId()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dcm_CfgVarMgrDiagVariantIdMemType, DCM_CODE) Dcm_VarMgrGetActiveCfgVariantId(
  void
  )
{
#if ((DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON) && (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_OFF))
  return Dcm_SingletonContext.VarMgr.ActiveCfgVariantId;
#else
  return 0;
#endif
}
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27Init()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_Service27Init(
  void
  )
{
  uint8_least lSecLvlIter;
  Dcm_Svc27ResetSequence();

  /* For each security level: */
  for(lSecLvlIter = 0; lSecLvlIter < DCM_STATE_SECURITY_NUM_LEVELS; ++lSecLvlIter)
  {
    /* Initialize the security timer and counter */
    Dcm_Svc27TimerReset(lSecLvlIter);
    Dcm_Svc27CounterReset(lSecLvlIter);

# if (DCM_STATE_SEC_DELAY_ON_BOOT_ENABLED == STD_ON)
    /* If a delay time on boot is supported: */
    if(Dcm_CfgStateSecurityInfo[lSecLvlIter].DelayTimeOnBoot != 0u)                                                                                  /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
    {
      /* Start the appropriate security timer */
      Dcm_Svc27TimerStart(lSecLvlIter, Dcm_CfgStateSecurityInfo[lSecLvlIter].DelayTimeOnBoot);                                                       /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
    }
# endif
  }

  /* Initialize the bit masks related to Get- and Set-AttemptCounter APIs */
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  Dcm_SingletonContext.Diag.Services.Svc27.GetAttCntrEventMask = DCM_SVC_27_LEVEL_MASK;
  Dcm_SingletonContext.Diag.Services.Svc27.SetAttCntrEventMask = 0u;
  Dcm_SingletonContext.Diag.Services.Svc27.ReloadMask = 0u;
  Dcm_SingletonContext.Diag.Services.Svc27.GetAttOpStatus = DCM_INITIAL;
  Dcm_SingletonContext.Diag.Services.Svc27.SetAttOpStatus = DCM_INITIAL;

  /* Trigger the reading of the attempt counter values */
  Dcm_TskSetEvent(DCM_TSK_ID_SVC27, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_READ);
# endif
}
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service29Init()
*********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_Service29Init(
  void
  )
{
  Dcm_Svc29ResetSequence();
  Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_IDLE);
  }
#endif /* (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2AInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_Service2AInit(
  void
  )
{
  Dcm_Service2ASchedulerInit();
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrRead(
  Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle,
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext
  )
{
  Std_ReturnType lStdReturn;
  Dcm_OpStatusType lOpStatus = opStatus;

  /* The DDDID shall be a defined one! */
  Dcm_DebugAssert((Dcm_Svc2CIsDynDidDefined(dynDidHandle)), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                  /* COV_DCM_RTM_DEV_DEBUG XF */

  lStdReturn = Dcm_Svc2CDefMgrReadCheckAccessAndInit(dynDidHandle, &lOpStatus);                                                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

  if(lStdReturn == DCM_E_OK)
  {
    Dcm_Svc2CDynDidProcessContextPtrType pProcessContext;

    pProcessContext = Dcm_Svc2CGetDDDidProcessContext(DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED);

    if(lOpStatus == DCM_INITIAL)
    {
      Dcm_SingletonContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse = dynDidHandle;
      pProcessContext->ItemInProgress = Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle);                                                            /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
      pProcessContext->ItemToStop = (Dcm_CfgDidMgrDynDidSrcItemIdxMemType)(pProcessContext->ItemInProgress + Dcm_Svc2CGetItem(dynDidHandle)->Count); /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
    }

    /* Process source items */
    lStdReturn = Dcm_Svc2CDefMgrReadSrcItems(lOpStatus, pDataContext, pProcessContext);                                                              /* SBSW_DCM_POINTER_FORWARD_STACK */
  }

  if(lStdReturn != DCM_E_PENDING)
  {
    /* Release resource */
    Dcm_SingletonContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse = DCM_SVC2C_INVALID_DYNDID_HDL;
  }
  return lStdReturn;
}

# if (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_COND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrConditionCheckRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrConditionCheckRead(
  Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle,
  Dcm_OpStatusType opStatus,
  Dcm_NegativeResponseCodePtrType errorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_OK; /* if the DynDID does not contain any DID sources -> always OK */
  Dcm_Svc2CDynDidProcessContextPtrType pProcessContext;
  Dcm_OpStatusType lOpStatus = opStatus;

  /* The DDDID shall be a defined one! */
  Dcm_DebugAssert((Dcm_Svc2CIsDynDidDefined(dynDidHandle)), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                  /* COV_DCM_RTM_DEV_DEBUG XF */

  pProcessContext = Dcm_Svc2CGetDDDidProcessContext(DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY);

  if(lOpStatus == DCM_INITIAL)
  {
    pProcessContext->ItemInProgress = Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle);                                                              /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
    pProcessContext->ItemToStop = (Dcm_CfgDidMgrDynDidSrcItemIdxMemType)(pProcessContext->ItemInProgress
                                                                         + Dcm_Svc2CGetItem(dynDidHandle)->Count);                                   /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
  }

  for(; pProcessContext->ItemInProgress < pProcessContext->ItemToStop; ++pProcessContext->ItemInProgress)                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  {
    if(Dcm_Svc2CIsDidSrcItem(pProcessContext->ItemInProgress))
    {
      Dcm_Svc2CInitDidInfoFromDidInfoIdx(Dcm_Svc2CGetSrcItem(pProcessContext->ItemInProgress)->DidDescriptor.DidInfoIdx
                                         ,&(pProcessContext->SrcDidContext));                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */

      if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(pProcessContext->SrcDidContext))                                                    /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
                                    ,DCM_DIDMGR_OPTYPE_READCHKCOND))
      {
        Dcm_DidMgrInitOpClassInfo(&(pProcessContext->SrcDidContext)                                                                                  /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
                                 ,DCM_DIDMGR_OPTYPE_READCHKCOND);

        lStdResult = Dcm_DidMgrReadCheckCond(lOpStatus
                                            ,&(pProcessContext->SrcDidContext)
                                            ,&(pProcessContext->DidOpTypeContext)
                                            ,errorCode);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
        if(lStdResult == DCM_E_OK)
        {
          /* prepare for next item */
          lOpStatus = DCM_INITIAL;
        }
        else
        {
          break; /* just delegate the return value */                                                                                                /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
        }
      } /* else - no check condition supported by this signal */
    } /* else - memory ranges cannot be checked in advance! */
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadDataLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadDataLength(
  Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle,
  Dcm_DidMgrDidLengthPtrType dataLength
  )
{
  *dataLength = Dcm_Svc2CGetItem(dynDidHandle)->Length;                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
  return DCM_E_OK;
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2CInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_Service2CInit(
  void
  )
{
  Dcm_Svc2CDefMgrInit();
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2FInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_Service2FInit(
  void
  )
{
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
  Dcm_CfgDidMgrIoDidHandleOptType ioDidIter;

  Dcm_SingletonContext.Diag.Services.Svc2F.HasAnyActiveIoDid = FALSE;
  for(ioDidIter = 0; ioDidIter < Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS); ++ioDidIter)
  {
    Dcm_UtiBitSetBasePtrType pActiveIoDids = Dcm_Svc2FGetActiveIoDids(ioDidIter);
    *pActiveIoDids = 0u;                                                                                                                             /* SBSW_DCM_POINTER_WRITE_2FACTIVEIODIDS */
  }
# endif
}
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service86Init()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_Service86Init(
  void
  )
{
  Dcm_ExtService86Init();/* delegate to the extension */
}
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */

#define DCM_START_SEC_CALLOUT_CODE
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferDataPadding()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_PagedBufferDataPadding(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Check for remaining parts to be padded */
  Dcm_UtiMemSetUintX(Dcm_UtiGetDataContextBuffer(pDataContext), Dcm_MsgItemType, 0x00u, pDataContext->AvailLen);                                     /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */
  /* Signalize that all requested data are provided */
  Dcm_UtiCommitData(pDataContext, pDataContext->AvailLen);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
  /* Enforce transmission of the current part */
  return DCM_E_BUFFERTOOLOW;
}
#endif
/**********************************************************************************************************************
 *  Dcm_RepeaterDeadEnd()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_RepeaterDeadEnd(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  return DCM_E_STOP_REPEATER;
}
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_DIDMGR_DID_F186_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgr_F186_ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_DidMgr_F186_ReadData(
  P2VAR(uint8, AUTOMATIC, DCM_VAR_NOINIT) Data
  )
{
  return Dcm_GetSesCtrlType(Data);                                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service01Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service01Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{

  Std_ReturnType lStdResult;

  Dcm_Svc01RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc01;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc01Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC01_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc01_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service02Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service02Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType  lStdResult;

  Dcm_Svc02RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc02;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc02Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC02_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc02_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_02_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service03Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service03Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType  lStdResult;

  Dcm_ObdDtcManagerContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc03.ReadDtcContext;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc03Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC03_PROGRESS_SETDTCFILTER:
    lStdResult = Dcm_Svc03UtiDemSetDTCFilter(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                               /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC03_PROGRESS_READDTCBYSTATUSMASK:
    lStdResult = Dcm_ObdDtcMgrReadDtcByStatusMask(opStatus, pMsgContext, ErrorCode, pRepContext);                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service03Updater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service03Updater(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc(pDataContext, ErrorCode, &pContext->Thread->Repeater.Contexts.Context.Svc03.ReadDtcContext);              /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif
#endif /* (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service04Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service04Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                lStdResult;
  Dcm_Svc04RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc04;

  if(opStatus == DCM_INITIAL)
  {
    pRepContext->DemClientId = Dcm_DiagGetDemClientId(Dcm_NetGetProtIdOfMsgContext(pMsgContext));                                                    /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_GLOBAL_PTR_WRITE */
  }

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc04Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  case DCM_SVC04_PROGRESS_REPEATERPROXY_SELECT_DTC:
    lStdResult = Dcm_Svc04_XX_RepeaterProxy_SelectDTC(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                      /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
  case DCM_SVC04_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc04_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service06Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service06Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType  lStdResult;

  Dcm_Svc06RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc06;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc06Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC06_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc06_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service06Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service06Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc06RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc06;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc06Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC06_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc06_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_07_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service07Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service07Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType  lStdResult;

  Dcm_ObdDtcManagerContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc07.ReadDtcContext;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc07Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC07_PROGRESS_SETDTCFILTER:
    lStdResult = Dcm_Svc07UtiDemSetDTCFilter(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                               /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC07_PROGRESS_READDTCBYSTATUSMASK:
    lStdResult = Dcm_ObdDtcMgrReadDtcByStatusMask(opStatus, pMsgContext, ErrorCode, pRepContext);                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service07Updater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service07Updater(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc(pDataContext, ErrorCode, &pContext->Thread->Repeater.Contexts.Context.Svc07.ReadDtcContext);              /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif
#endif /* (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service08Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service08Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc08RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc08;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc08Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC08_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc08_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service09Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service09Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc09RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc09;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc09Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC09_PROGRESS_CHECKACCESS:
    lStdResult = Dcm_Svc09CheckAccess(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC09_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc09_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service0AProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service0AProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType  lStdResult;

  Dcm_ObdDtcManagerContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc0A.ReadDtcContext;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc0AHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC0A_PROGRESS_SETDTCFILTER:
    lStdResult = Dcm_Svc0AUtiDemSetDTCFilter(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                               /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC0A_PROGRESS_READDTCBYSTATUSMASK:
    lStdResult = Dcm_ObdDtcMgrReadDtcByStatusMask(opStatus, pMsgContext, ErrorCode, pRepContext);                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service0AUpdater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service0AUpdater(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc(pDataContext, ErrorCode, &pContext->Thread->Repeater.Contexts.Context.Svc0A.ReadDtcContext);              /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif
#endif /* (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_Service10Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service10Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc10RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc10;

  switch(Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc10Handler(pContext, opStatus, pMsgContext, ErrorCode , pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC10_PROGRESS_CHECK_ACCESS:
    lStdResult = Dcm_Svc10CheckAccess(pContext, opStatus, pMsgContext, ErrorCode , pRepContext);                                                     /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
  case DCM_SVC10_PROGRESS_TRIGGER_RESET:
    lStdResult = Dcm_Svc10_TriggerReset(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC10_PROGRESS_WAIT_RESET_ACK:
    lStdResult = Dcm_Svc10_WaitForResetAck(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC10_PROGRESS_WAIT_RCRRP_ACK:
    lStdResult = Dcm_Svc10_WaitForRcrRpAck(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC10_PROGRESS_SET_PRGCOND:
    lStdResult = Dcm_Svc10_SetProgConditions(opStatus, pMsgContext, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
#endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service10FastPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service10FastPostProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_ConfirmationStatusType status
  )
{
  if(status == DCM_RES_POS_OK)
  {
    Dcm_DiagSetP2Timings(pContext->Thread->Repeater.Contexts.Context.Svc10.SesStateIdx
                        ,Dcm_NetGetProtIdOfActiveProtocol()
                        ,pContext->Thread->ThreadId);

#if (DCM_SVC_10_RESET_AFTER_RESPONSE == STD_ON)
    if(pContext->Thread->Repeater.Contexts.Context.Svc10.ResetMode != RTE_MODE_DcmEcuReset_NONE)
    {
      Dcm_SingletonContext.Network.RxAllowed = FALSE; /* lock any further communication while the ECU is getting reset */
    }
#endif
  }
}

/**********************************************************************************************************************
 *  Dcm_Service10PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service10PostProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_ConfirmationStatusType status
  )
{
  if(status == DCM_RES_POS_OK)
  {
    /* execute transition */
    Dcm_StateSetSession(pContext->Thread->Repeater.Contexts.Context.Svc10.SesStateIdx);
#if (DCM_SVC_10_RESET_AFTER_RESPONSE == STD_ON)
    if(pContext->Thread->Repeater.Contexts.Context.Svc10.ResetMode != RTE_MODE_DcmEcuReset_NONE)
    {
      /* fire and forget - if failed - no chance to send any NRC from here */
      (void)Dcm_ModeSwitchEcuReset(RTE_MODE_DcmEcuReset_EXECUTE);
    }
#endif
  }
  else
  {
    /* on the way of changing a session */
    if(0u == ( Dcm_SingletonContext.StateMgr.Preconditions.Session
            & Dcm_SingletonContext.StateMgr.PendingSession) )
    {
      /* undo pending session expectation */
#if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
      Dcm_UtiEnterCriticalSection();/* avoid interrupt from the Dcm_NetTaskRx || Dcm_NetStartOfReception() */
#else
      Dcm_SplitTaskEnterCS();/* avoid interrupt from the Dcm_NetTaskRx */
#endif
      /*=================================*
        BEGIN CRITICAL SECTION
       *=================================*/
      Dcm_StateSyncPendingSession();/* synchronize with the currently active session */
      /*=================================*
        END CRITICAL SECTION
       *=================================*/
#if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
      Dcm_UtiLeaveCriticalSection();
#else
      Dcm_SplitTaskLeaveCS();
#endif
    }/* else - nothing to undo */
  }
}
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc11RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc11;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc11Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC11_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc11SubFuncHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
  case DCM_SVC11_PROGRESS_ECURST_WAITFORACK:
    lStdResult = Dcm_Svc11_EcuRst_WaitForAck(opStatus, pMsgContext, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_SVC_11_RAPID_SHTDWN_ENABLED == STD_ON)
  case DCM_SVC11_RAPPWRDWN_WAITFORACK:
    lStdResult = Dcm_Svc11_RapPwrDwn_WaitForAck(opStatus, pMsgContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service11PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service11PostProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_ConfirmationStatusType status
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(status);                                                                                                                    /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
  if(status == DCM_RES_POS_OK)
  {
    if(pContext->Thread->Repeater.Contexts.Context.Svc11.SubFuncId < 0x04u)
    {
      /* reset only on 0x01 (hard), 0x02 (soft), 0x03 (keyOnOff) */
      (void)Dcm_ModeSwitchEcuReset(RTE_MODE_DcmEcuReset_EXECUTE);
    }
  }
# endif
}

/**********************************************************************************************************************
 *  Dcm_Service11FastPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service11FastPostProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_ConfirmationStatusType status
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(status);                                                                                                                    /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
  if(status == DCM_RES_POS_OK)
  {
    if(pContext->Thread->Repeater.Contexts.Context.Svc11.SubFuncId < 0x04u)
    {
      Dcm_SingletonContext.Network.RxAllowed = FALSE;
    }
  }
# endif
}
# if (DCM_SVC_11_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11_01Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11_01Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  /* Delegate job to the concrete mode manager */
  return Dcm_Svc11_ProcessEcuReset(pContext, RTE_MODE_DcmEcuReset_HARD, ErrorCode);                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif
# if (DCM_SVC_11_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11_02Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11_02Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Delegate job to the concrete mode manager */
  return Dcm_Svc11_ProcessEcuReset(pContext, RTE_MODE_DcmEcuReset_KEYONOFF, ErrorCode);                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif
# if (DCM_SVC_11_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11_03Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11_03Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Delegate job to the concrete mode manager */
  return Dcm_Svc11_ProcessEcuReset(pContext, RTE_MODE_DcmEcuReset_SOFT, ErrorCode);                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif
# if (DCM_SVC_11_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11_04Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11_04Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Prepare for a positive response */
  Dcm_UtiProvideResDataAsU8(pMsgContext, DCM_SVC_11_POWERDOWNTIME);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Delegate job to the concrete mode manager */
  return Dcm_Svc11_ProcessRapPwrDwn(pContext, RTE_MODE_DcmModeRapidPowerShutDown_ENABLE_RAPIDPOWERSHUTDOWN, ErrorCode);                              /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif
# if (DCM_SVC_11_05_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11_05Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11_05Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Delegate job to the concrete mode manager */
  return Dcm_Svc11_ProcessRapPwrDwn(pContext, RTE_MODE_DcmModeRapidPowerShutDown_DISABLE_RAPIDPOWERSHUTDOWN, ErrorCode);                             /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service14Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service14Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc14RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc14;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc14Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  case DCM_SVC14_PROGRESS_REPEATERPROXY_SELECT_DTC:
    lStdResult = Dcm_Svc14_XX_RepeaterProxySelectDTC(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                       /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC14_PROGRESS_REPEATERPROXY_CHECK_SELECTION_RESULT:
    lStdResult = Dcm_Svc14_XX_RepeaterProxyCheckSelectionResult(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                            /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
  case DCM_SVC14_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc14_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc19Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC19_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc19SubFuncHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# if (DCM_SVC_19_COPY_LINEAR_DATA_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_UTI_COPYLINEARDATA:
    lStdResult = Dcm_Svc19UtiCopyLinearData(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_SELECT_DTC:
    lStdResult = Dcm_Svc19UtiDemSelectDTC(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                  /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_DISABLERECORDUPDATE:
    lStdResult = Dcm_Svc19UtiDemDisableRecordUpdate(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                        /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_GETSTATUSOFDTC_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETSTATUSOFDTC:
    lStdResult = Dcm_Svc19UtiDemGetStatusOfDtc(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                             /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEM_API_SELECT_FFR_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_SELECTFFREC:
    lStdResult = Dcm_Svc19UtiDemSelectFFData(pContext, ErrorCode, pRepContext);                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_GETSIZEOFFFRECORD_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETSIZEOFFFREC:
    lStdResult = Dcm_Svc19UtiDemGetSizeOfFFRecord(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEM_API_SELECT_EDR_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_SELECTEXTDATAREC:
    lStdResult = Dcm_Svc19UtiDemSelectExtRecord(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                            /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_GETSIZEOFEXTRECORD_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETSIZEOFEXTDATAREC:
    lStdResult = Dcm_Svc19UtiDemGetSizeOfExtRecord(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                         /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_GETNUMFILTEREDDTC_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC:
    lStdResult = Dcm_Svc19UtiDemGetNumFltrdDtc(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                             /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDSEVERITY:
    lStdResult = Dcm_Svc19UtiDemGetNxtFltrdSeverity(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                        /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETSEVERITYOFDTC:
    lStdResult = Dcm_Svc19UtiDemGetSeverityOfDtc(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                           /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETFUNCUNITOFDTC:
    lStdResult = Dcm_Svc19UtiDemGetFuncUnitOfDtc(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                           /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_GETNEXTFILTEREDDTC_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDDTC:
    lStdResult = Dcm_Svc19UtiDemGetNxtFltrdDtc(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                             /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_PUTNUMFLTRDDTC:
    lStdResult = Dcm_Svc19UtiPutNumFilteredDtc(opStatus, pMsgContext, ErrorCode, pRepContext);                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDFDC:
    lStdResult = Dcm_Svc19UtiDemGetNxtFltrdFDC(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                             /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_WWHOBD_GETNEXTFLTRDSEVERITY:
    lStdResult = Dcm_Svc19UtiWwhObdDemGetNxtFltrdSeverity(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                  /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_SVC_19_CHAIN_END_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_CHAIN_END:
    lStdResult = DCM_E_OK;
    break;
# endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_Service19PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service19PostProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  Dcm_ConfirmationStatusType status
  )
{
# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
#  if (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON)
  Dcm_Svc19RepeaterProxyContextConstPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;
#  endif
# endif

# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
#  if (DCM_DEM_API_421_ENABLED == STD_ON)
  (void)Dcm_DemAPI(EnableDTCRecordUpdate)();
#  else
  (void)Dcm_DemAPI(EnableDTCRecordUpdate)(pRepContext->DemClientId);
#  endif
# endif
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(status);                                                                                                                    /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
}

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19Updater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19Updater(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_Service19UtiCopyData(pContext, pDataContext, ErrorCode, pRepContext);                                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif
# if (DCM_SVC_19_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_01Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_01Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  uint8 reqDtcStatusMask;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &reqDtcStatusMask);                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */

  return Dcm_Svc19UtiReportNumDtcByStatusMaskData(pContext
                                                 ,DCM_SVC_19_DEM_SETFILTER_CLASS_01
                                                 ,reqDtcStatusMask
                                                 ,0
                                                 ,pMsgContext
                                                 ,ErrorCode
                                                 ,pRepContext);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_02Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_02Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_Svc19UtiReportDtcByStatusMaskData(pContext
                                              ,DCM_SVC_19_DEM_SETFILTER_CLASS_01
                                              ,DCM_SVC_19_USE_MASK_REQ
                                              ,pMsgContext
                                              ,ErrorCode
                                              ,pRepContext);                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_03Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_03Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType             lStdResult;
  Dcm_DemReturnSetFilterType demResult;
  uint16                     numOfRecords;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  demResult = Dcm_DemAPI(SetFreezeFrameRecordFilter)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON) || (DCM_DEM_API_431_ENABLED == STD_ON)
      pRepContext->DemClientId,
#  endif
      DEM_DTC_FORMAT_UDS,
      &numOfRecords);                                                                                                                                /* SBSW_DCM_POINTER_FORWARD_STACK */
  if (demResult == DCM_DEM_RET_FILTER_ACCEPTED)
  {
    lStdResult =  Dcm_Sv19UtiStartReporting(pContext
                                           ,pMsgContext
                                           ,DCM_SVC_19_UPDATE_GET_NXT_FLTRD_RECORD
                                           ,((Dcm_MsgLenType)numOfRecords * 4u)
                                           ,pRepContext);                                                                                            /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  }
  else
  { /* Any DEM error */
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_DemApiNrcMapSetDTCFilter);                                                            /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_04Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_04Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  )
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_Svc19UtiReportDtcFFRByDtc(pContext, DEM_DTC_ORIGIN_PRIMARY_MEMORY, pMsgContext, pRepContext);                                           /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_05_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_05Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_05Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdReturn;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &(pRepContext->RecordNum));                                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */

  if( (pRepContext->RecordNum == 0x00u)
    ||(pRepContext->RecordNum == DCM_SVC_19_RECNUM_ALL) )
  {
    uint16 recordLength;
    Dcm_MsgType freezeFrameDataBuffer;
    Dcm_DemReturnGetFreezeFrameDataByRecordType demResult;

    /* Report immediately the only possible SSRN (0x00) */
    Dcm_UtiProvideResDataAsU8(pMsgContext, 0x00u);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    /* Calculate remaining length for SSRN data provision by DEM
     * (i.e. subtract the DTC (3bytes) and status mask (1 Byte) from the current available response buffer, that will be written later)
     */
    recordLength = (uint16)Dcm_UtiGetRemainingResLenWithOffset(pMsgContext, 4u);                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
    freezeFrameDataBuffer = Dcm_UtiGetResDataRel(pMsgContext, 4u);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

    pRepContext->Origin = DEM_DTC_ORIGIN_PRIMARY_MEMORY;                                                                                             /* SBSW_DCM_GLOBAL_PTR_WRITE */
    /* Gather the SSRN data (with offset of 4 bytes to the current position) and DTC number */
    demResult = Dcm_DemAPI_GetOBDFreezeFrameData(0x00u                                                                                               /* SBSW_DCM_COMB_PTR_FORWARD */
                                                ,pRepContext->Origin
                                                ,&pRepContext->Dtc
                                                ,freezeFrameDataBuffer
                                                ,&recordLength);
    switch(demResult)
    {
    case DCM_DEM_RET_FFBYRECORD_OK:
      /* Commit the reported SSRN data */
      Dcm_UtiUpdateResLength(pMsgContext, recordLength);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
      /* Delegate the service processing to the "DTCAndStatusRecord" reporting utility (i.e. writes DTC and its status into the response) */
      lStdReturn = Dcm_Svc19UtiChainStart(pContext, Dcm_Svc19DemChainGetDtcStatusEnd, pRepContext);                                                  /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
      break;
    case DCM_DEM_RET_FFBYRECORD_NO_DTC:
      /* Otherwise, if the DEM has found no matching DTC, just return the SSRN with no further data */
      lStdReturn = DCM_E_OK;
      break;
    default:
      *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetOBDFreezeFrameData);                                                  /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
      break;
    }
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
# endif

# if (DCM_SVC_19_06_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_06Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_06Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_Svc19UtiReportExtDataRecordByDtcNum(pContext
                                                ,DEM_DTC_ORIGIN_PRIMARY_MEMORY
                                                ,pMsgContext
                                                ,ErrorCode
                                                ,pRepContext);                                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_07_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_07Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_07Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  uint8 reqDtcStatusMask;
  uint8 reqDtcSeverityMask;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &reqDtcSeverityMask);                                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &reqDtcStatusMask);                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */

  return Dcm_Svc19UtiReportNumDtcByStatusMaskData(pContext
                                                 ,DCM_SVC_19_DEM_SETFILTER_CLASS_02
                                                 ,reqDtcStatusMask
                                                 ,reqDtcSeverityMask
                                                 ,pMsgContext
                                                 ,ErrorCode
                                                 ,pRepContext);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_08Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_08Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                    lStdResult;
  uint8                             dtcStatusMask;
  uint8                             dtcSeverityMask;
  uint8                             dtcSAM;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* save the requested masks */
  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &dtcSeverityMask);                                                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &dtcStatusMask);                                                                                            /* SBSW_DCM_COMB_PTR_FORWARD */

  /* Gather the configured DEM Status Availability Mask */
  lStdResult = Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask(&dtcSAM, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == E_OK)
  {
    Dcm_UtiProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Form the relevant status bits */
    dtcStatusMask &= dtcSAM;

    if(dtcStatusMask == 0u)
    {
      lStdResult = DCM_E_OK;/* no DTCs to report */
    }
    else
    {
      /* filter the DTCs */
      lStdResult = Dcm_Svc19UtiDemSetDTCFilter(ErrorCode
                                              ,DCM_SVC_19_DEM_SETFILTER_CLASS_02
                                              ,dtcStatusMask
                                              ,dtcSeverityMask
                                              ,DCM_DEM_FILTER_FOR_FDC_NO
                                              ,pRepContext);                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
      if(lStdResult == DCM_E_OK)
      {
        lStdResult = Dcm_Svc19UtiChainStart(pContext, Dcm_Svc19_08DemChain, pRepContext);                                                            /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
      }/* Otherwise, Already set by Dcm_Svc19UtiDemSetDTCFilter */
    }
  }/* Otherwise, Already set by Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask */

  return lStdResult;
}
# endif

# if (DCM_SVC_19_09_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_09Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_09Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  uint8 dtcSAM;

  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  Dcm_UtiConsumeReqDataAsU24(pMsgContext, &(pRepContext->Dtc));                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

  /* Gather the configured DEM Status Availability Mask */
  lStdResult = Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask(&dtcSAM, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == E_OK)
  {
    Dcm_UtiProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

    pRepContext->Origin = DEM_DTC_ORIGIN_PRIMARY_MEMORY;                                                                                             /* SBSW_DCM_GLOBAL_PTR_WRITE */
    lStdResult = Dcm_Svc19UtiChainStart(pContext, Dcm_Svc19_09DemChain, pRepContext);                                                                /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  }/* Otherwise, Already set by Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask */
  return lStdResult;
}
# endif

# if (DCM_SVC_19_0A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0AProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0AProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_Svc19UtiReportDtcByStatusMaskData(pContext
                                              ,DCM_SVC_19_DEM_SETFILTER_CLASS_01
                                              ,DCM_SVC_19_USE_MASK_ALL
                                              ,pMsgContext
                                              ,ErrorCode
                                              ,pRepContext);                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_0B_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0BProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0BProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_Svc19UtiReportNumDtcByOccurenceTime(pContext
                                                ,DEM_FIRST_FAILED_DTC
                                                ,pMsgContext
                                                ,ErrorCode
                                                ,pRepContext);                                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_0C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0CProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0CProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_Svc19UtiReportNumDtcByOccurenceTime(pContext
                                                ,DEM_FIRST_DET_CONFIRMED_DTC
                                                ,pMsgContext
                                                ,ErrorCode
                                                ,pRepContext);                                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_0D_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0DProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0DProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_Svc19UtiReportNumDtcByOccurenceTime(pContext
                                                ,DEM_MOST_RECENT_FAILED_DTC
                                                ,pMsgContext
                                                ,ErrorCode
                                                ,pRepContext);                                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_0E_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0EProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0EProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_Svc19UtiReportNumDtcByOccurenceTime(pContext
                                                ,DEM_MOST_REC_DET_CONFIRMED_DTC
                                                ,pMsgContext
                                                ,ErrorCode
                                                ,pRepContext);                                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_0F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0FProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0FProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_Svc19UtiReportDtcByStatusMaskData(pContext
                                              ,DCM_SVC_19_DEM_SETFILTER_CLASS_03
                                              ,DCM_SVC_19_USE_MASK_REQ
                                              ,pMsgContext
                                              ,ErrorCode
                                              ,pRepContext);                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_10_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_10Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_10Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_Svc19UtiReportExtDataRecordByDtcNum(pContext
                                                ,DEM_DTC_ORIGIN_MIRROR_MEMORY
                                                ,pMsgContext
                                                ,ErrorCode
                                                ,pRepContext);                                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_11_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_11Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_11Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  uint8 reqDtcStatusMask;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &reqDtcStatusMask);                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */

  return Dcm_Svc19UtiReportNumDtcByStatusMaskData(pContext
                                                 ,DCM_SVC_19_DEM_SETFILTER_CLASS_03
                                                 ,reqDtcStatusMask
                                                 ,0
                                                 ,pMsgContext
                                                 ,ErrorCode
                                                 ,pRepContext);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif
# if (DCM_SVC_19_12_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_12Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_12Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  uint8 reqDtcStatusMask;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &reqDtcStatusMask);                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */

  return Dcm_Svc19UtiReportNumDtcByStatusMaskData(pContext
                                                 ,DCM_SVC_19_DEM_SETFILTER_CLASS_04
                                                 ,reqDtcStatusMask
                                                 ,0
                                                 ,pMsgContext
                                                 ,ErrorCode
                                                 ,pRepContext);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_13_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_13Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_13Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_Svc19UtiReportDtcByStatusMaskData(pContext
                                              ,DCM_SVC_19_DEM_SETFILTER_CLASS_04
                                              ,DCM_SVC_19_USE_MASK_REQ
                                              ,pMsgContext
                                              ,ErrorCode
                                              ,pRepContext);                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif
# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_14Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_14Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType           lStdResult;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_Svc19UtiDemSetDTCFilter(ErrorCode
                                          ,DCM_SVC_19_DEM_SETFILTER_CLASS_01
                                          ,0x00u
                                          ,0u /* not used */
                                          ,DCM_DEM_FILTER_FOR_FDC_YES
                                          ,pRepContext);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
  if(lStdResult == DCM_E_OK)
  {
    lStdResult = Dcm_Svc19UtiChainStart(pContext, Dcm_Svc19_14DemChain, pRepContext);                                                                /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  }
  else
  {
    /* Already set by Dcm_Svc19UtiDemSetDTCFilter */
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_15_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_15Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_15Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_Svc19UtiReportDtcByStatusMaskData(pContext
                                              ,DCM_SVC_19_DEM_SETFILTER_CLASS_05
                                              ,DCM_SVC_19_USE_MASK_ALL
                                              ,pMsgContext
                                              ,ErrorCode
                                              ,pRepContext);                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_16_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_16Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_16Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                       lStdResult;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &(pRepContext->RecordNum));                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

  if( (pRepContext->RecordNum == DCM_SVC_19_RECNUM_ALL)
    ||(pRepContext->RecordNum == DCM_SVC_19_RECNUM_OBD_ALL) )
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
  {
    Dcm_UtiProvideResDataAsU8(pMsgContext, pRepContext->RecordNum);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdResult = Dcm_Svc19UtiDemSetExtDataRecordFilter(ErrorCode, pRepContext);                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

    if (lStdResult == DCM_E_OK)
    {
      Std_ReturnType lDemResult;
      uint16         lNumRecords;
      uint16         lRecordSize;

      /* The record size for a specific record number is constant but varies for different record numbers */
      lDemResult = Dem_GetNumberOfFilteredExtendedDataRecords(pRepContext->DemClientId
                                                             ,&lNumRecords
                                                             ,&lRecordSize);                                                                         /* SBSW_DCM_POINTER_FORWARD_STACK */

      if (lDemResult == E_OK)
      {
        /* Response size = NumRecords * (DTCAndStatusRecord + DTCExtDataRecord) */
        lStdResult = Dcm_Sv19UtiStartReporting(pContext
                                              ,pMsgContext
                                              ,DCM_SVC_19_UPDATE_GET_NXT_FLTRD_EXT_RECORD
                                              ,(lNumRecords * ((Dcm_MsgLenType)4u + lRecordSize))
                                              ,pRepContext);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      else
      {
        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    } /* Otherwise, ErrorCode already set by Dcm_Svc19UtiDemSetExtDataRecordFilter */
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_19_17_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_17Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_17Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext;
  uint8 lUserMemId;

  lUserMemId = Dcm_UtiGetReqDataAsU8Rel(pMsgContext, 1u);
  pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#  if (DCM_SVC_19_USER_MEM_ID_CHECK_ENABLED == STD_ON)
  if(lUserMemId != DCM_SVC_19_USER_MEM_ID)
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
#   if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
  if(Dcm_AuthMgrCheckMem(pContext, lUserMemId) == DCM_E_NOT_OK)                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    *ErrorCode = DCM_E_AUTHENTICATIONREQUIRED;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
#   endif
#  endif
  {
    Dcm_DiagBufferIndexType resUserMemIdx = pMsgContext->resIndex;

    /* Set the UserMid in response now */
    Dcm_UtiProvideResData(pMsgContext, 1u);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

#  if (DCM_DEM_API_431_ENABLED == STD_ON)
    pRepContext->Origin = lUserMemId + 0x0100u;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
#  endif

    lStdResult = Dcm_Svc19UtiReportDtcByStatusMaskData(pContext
                                                      ,DCM_SVC_19_DEM_SETFILTER_CLASS_06
                                                      ,DCM_SVC_19_USE_MASK_REQ
                                                      ,pMsgContext
                                                      ,ErrorCode
                                                      ,pRepContext);                                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
    /* place the UserMid to the response */
    Dcm_UtiSetResDataAsU8At(pMsgContext, resUserMemIdx, lUserMemId);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_18_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_18Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_18Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  )
{
  Std_ReturnType lStdResult;
  uint8 lUserMemId;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext;

  pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;
  lUserMemId = Dcm_UtiGetReqDataAsU8Rel(pMsgContext, 4u);

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#  if (DCM_SVC_19_USER_MEM_ID_CHECK_ENABLED == STD_ON)
  if (lUserMemId != DCM_SVC_19_USER_MEM_ID)
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
#   if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
  if(Dcm_AuthMgrCheckMem(pContext, lUserMemId) == DCM_E_NOT_OK)                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    *ErrorCode = DCM_E_AUTHENTICATIONREQUIRED;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
#   endif
#  endif
  {
    /* save UserMid response location */
    Dcm_DiagBufferIndexType resUserMemIdx = pMsgContext->resIndex;
    /* Set the UserMid in response now */
    Dcm_UtiProvideResData(pMsgContext, 1u);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdResult = Dcm_Svc19UtiReportDtcFFRByDtc(pContext
#  if (DCM_DEM_API_431_ENABLED == STD_ON)
                                              ,lUserMemId + 0x0100u
#  else
                                              ,DEM_DTC_ORIGIN_SECONDARY_MEMORY
#  endif
                                              ,pMsgContext
                                              ,pRepContext);                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
    /* place the UserMid to the response */
    Dcm_UtiSetResDataAsU8At(pMsgContext, resUserMemIdx, lUserMemId);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_19Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_19Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  uint8 lUserMemId;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext;

  pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;
  lUserMemId = Dcm_UtiGetReqDataAsU8Rel(pMsgContext, 4u);

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#  if (DCM_SVC_19_USER_MEM_ID_CHECK_ENABLED == STD_ON)
  if (lUserMemId != DCM_SVC_19_USER_MEM_ID)
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
#   if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
  if(Dcm_AuthMgrCheckMem(pContext, lUserMemId) == DCM_E_NOT_OK)                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    *ErrorCode = DCM_E_AUTHENTICATIONREQUIRED;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
#   endif
#  endif
  {
    /* save UserMid response location */
    Dcm_DiagBufferIndexType resUserMemIdx = pMsgContext->resIndex;
    /* skip the UserMid in response now */
    Dcm_UtiProvideResData(pMsgContext, 1u);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdResult = Dcm_Svc19UtiReportExtDataRecordByDtcNum(pContext
#  if (DCM_DEM_API_431_ENABLED == STD_ON)
                                                        ,lUserMemId + 0x0100u
#  else
                                                        ,DEM_DTC_ORIGIN_SECONDARY_MEMORY
#  endif
                                                        ,pMsgContext
                                                        ,ErrorCode
                                                        ,pRepContext);                                                                               /* SBSW_DCM_COMB_PTR_FORWARD */
    /* place the UserMid to the response */
    Dcm_UtiSetResDataAsU8At(pMsgContext, resUserMemIdx, lUserMemId);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_1A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_1AProcessor()
 *********************************************************************************************************************/
 /*!
  * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
  */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_1AProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
)
{
  Std_ReturnType lStdResult;
  uint8          lExtDataRecNumber;

  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &lExtDataRecNumber);                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */

  if ((lExtDataRecNumber == DCM_SVC_19_RECNUM_ALL)
    || (lExtDataRecNumber == DCM_SVC_19_RECNUM_OBD_ALL))
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
  {
    uint8 dtcSAM;
    /* Gather the configured DEM Status Availability Mask */
    lStdResult = Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask(&dtcSAM, ErrorCode, pRepContext);                                                       /* SBSW_DCM_COMB_PTR_FORWARD */

    if (lStdResult == E_OK)
    {
      Dcm_UtiProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_UtiProvideResDataAsU8(pMsgContext, lExtDataRecNumber);                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

      /* Set DEM reporting filter */
      lStdResult = Dcm_Svc19UtiDemSetDTCFilterByExtendedDataRecordNumber(lExtDataRecNumber, ErrorCode, pRepContext);                                 /* SBSW_DCM_COMB_PTR_FORWARD */

      if (lStdResult == DCM_E_OK)
      {
        /* Delegate the service processing to the "DTCAndStatusRecord" reporting utility (i.e. writes DTC and its status into the response) */
        lStdResult = Dcm_Svc19UtiChainStart(pContext, Dcm_Svc19DemChainReadDtcByStatus, pRepContext);                                                /* SBSW_DCM_COMB_PTR_FORWARD */
      }/* Otherwise, Already set by Dcm_Svc19UtiDemSetDTCFilterByExtendedDataRecordNumber */
    } /* Otherwise, Already set by Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask */
  }
  return lStdResult;
}
# endif /* DCM_SVC_19_1A_SUPPORT_ENABLED == STD_ON */

# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_42Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_42Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                lStdResult;
  uint8                         dtcStatusMask;
  uint8                         dtcSeverityMask;
  uint8                         functionalId;
  uint8                         dtcSAM;
  uint8                         dtcSevAM;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &functionalId);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */

  if (functionalId == 0x33u)
  {
    Dcm_UtiConsumeReqDataAsU8(pMsgContext, &dtcStatusMask);                                                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    Dcm_UtiConsumeReqDataAsU8(pMsgContext, &dtcSeverityMask);                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */

    /* Echo the requested functional group (do it here, otherwise the above extracted data could be overwritten in case of shared Rx-Tx-Buffers) */
    Dcm_UtiProvideResDataAsU8(pMsgContext, functionalId);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Gather the configured DEM Status Availability Mask */
    lStdResult = Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask(&dtcSAM, ErrorCode, pRepContext);                                                       /* SBSW_DCM_COMB_PTR_FORWARD */

    if(lStdResult == E_OK)
    {
      /* Report configured DEM SAM */
      Dcm_UtiProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

#  if (DCM_DEM_API_421_ENABLED == STD_ON)
      lStdResult = Dcm_DemAPI(GetDTCSeverityAvailabilityMask)(&dtcSevAM);                                                                            /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
      lStdResult = Dcm_DemAPI(GetDTCSeverityAvailabilityMask)(pRepContext->DemClientId
                                                             ,&dtcSevAM);                                                                            /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

      if(lStdResult == E_OK)
      {
        Dcm_UtiProvideResDataAsU8(pMsgContext, dtcSevAM);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
        /* Report the configured in DEM DTC format identifier */
#  if (DCM_DEM_API_421_ENABLED == STD_ON)
        Dcm_UtiProvideResDataAsU8(pMsgContext, Dcm_DemAPI(GetTranslationType)());                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
#  else
        Dcm_UtiProvideResDataAsU8(pMsgContext, Dcm_DemAPI(GetTranslationType)(pRepContext->DemClientId));                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
#  endif

        /* Form the relevant status bits */
        dtcStatusMask &= dtcSAM;

        if(dtcStatusMask == 0u)
        {
          lStdResult = DCM_E_OK;/* no DTCs to report */
        }
        else
        {
          /* filter the DTCs */
          lStdResult = Dcm_Svc19UtiDemSetDTCFilter(ErrorCode
                                                  ,DCM_SVC_19_DEM_SETFILTER_CLASS_07
                                                  ,dtcStatusMask
                                                  ,dtcSeverityMask
                                                  ,DCM_DEM_FILTER_FOR_FDC_NO
                                                  ,pRepContext);                                                                                     /* SBSW_DCM_COMB_PTR_FORWARD */

          if(lStdResult == DCM_E_OK)
          {
            lStdResult = Dcm_Svc19UtiChainStart(pContext, Dcm_Svc19_42DemChain, pRepContext);                                                        /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
          }/* Otherwise, Already set by Dcm_Svc19UtiDemSetDTCFilter */
        }
      }
      else
      {
        *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_Svc19NrcMapStdReturnType);                                                       /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }/* Otherwise, Already set by Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask */
  }
  else
  {
    /* Invalid functional group */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */
# endif

# if (DCM_SVC_19_55_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_55Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_55Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  uint8          lFunctionalId;

  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &lFunctionalId);                                                                                            /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lFunctionalId == 0x33u)
  {
    uint8 dtcSAM;

    /* Echo the requested functional group (do it here, otherwise the above extracted data could be overwritten in case of shared Rx-Tx-Buffers) */
    Dcm_UtiProvideResDataAsU8(pMsgContext, lFunctionalId);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Gather the configured DEM Status Availability Mask */
    lStdResult = Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask(&dtcSAM, ErrorCode, pRepContext);                                                       /* SBSW_DCM_COMB_PTR_FORWARD */

    if(lStdResult == E_OK)
    {
      uint8 lDTCFormatId;

      /* Report configured DEM SAM */
      Dcm_UtiProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

      /* Report the configured in DEM DTC format identifier */
      lDTCFormatId = Dcm_DemAPI(GetTranslationType)(pRepContext->DemClientId);

      if((lDTCFormatId == 0x02u) || (lDTCFormatId == 0x04u))
      {
        Dcm_UtiProvideResDataAsU8(pMsgContext, lDTCFormatId);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */

        /* Set DEM reporting filter */
        lStdResult = Dcm_Svc19UtiDemSetDTCFilter(ErrorCode
                                                ,DCM_SVC_19_DEM_SETFILTER_CLASS_05
                                                ,0u /* DTC Status Mask must be equal to 0x00 according to AUTOSAR 4.3 */
                                                ,0u /* Severity mask is not relevant */
                                                ,DCM_DEM_FILTER_FOR_FDC_NO
                                                ,pRepContext);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */

        if(lStdResult == DCM_E_OK)
        {
          /* Delegate the service processing to the "DTCAndStatusRecord" reporting utility (i.e. writes DTC and its status into the response) */
          lStdResult = Dcm_Svc19UtiChainStart(pContext, Dcm_Svc19DemChainReadDtcByStatus, pRepContext);                                              /* SBSW_DCM_COMB_PTR_FORWARD */
        }/* Otherwise, Already set by Dcm_Svc19UtiDemSetDTCFilter */
      }
      else
      {
        /* Invalid DTC format identifier */
        *ErrorCode = DCM_E_GENERALREJECT;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }/* Otherwise, Already set by Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask */
  }
  else
  {
    /* Invalid functional group */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_56_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_56Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_56Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  uint8          lFunctionalId;
  uint8          lReadinessId;

  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &lFunctionalId);                                                                                            /* SBSW_DCM_COMB_PTR_FORWARD */
  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &lReadinessId);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lFunctionalId == 0x33u)
  {
    uint8 dtcSAM;

    /* Echo the requested functional group (do it here, otherwise the above extracted data could be overwritten in case of shared Rx-Tx-Buffers) */
    Dcm_UtiProvideResDataAsU8(pMsgContext, lFunctionalId);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Gather the configured DEM Status Availability Mask */
    lStdResult = Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask(&dtcSAM, ErrorCode, pRepContext);                                                       /* SBSW_DCM_COMB_PTR_FORWARD */

    if (lStdResult == E_OK)
    {
      uint8 lDTCFormatId;

      /* Report configured DEM SAM */
      Dcm_UtiProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

      /* Report the configured in DEM DTC format identifier */
      lDTCFormatId = Dcm_DemAPI(GetTranslationType)(pRepContext->DemClientId);

      Dcm_UtiProvideResDataAsU8(pMsgContext, lDTCFormatId);                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_UtiProvideResDataAsU8(pMsgContext, lReadinessId);                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

      /* Set DEM reporting filter */
      lStdResult = Dcm_Svc19UtiDemSetReadinessGroupIdentifierFilter(lReadinessId, ErrorCode, pRepContext);                                           /* SBSW_DCM_COMB_PTR_FORWARD */

      if (lStdResult == DCM_E_OK)
      {
        /* Delegate the service processing to the "DTCAndStatusRecord" reporting utility (i.e. writes DTC and its status into the response) */
        lStdResult = Dcm_Svc19UtiChainStart(pContext, Dcm_Svc19DemChainReadDtcByStatus, pRepContext);                                                /* SBSW_DCM_COMB_PTR_FORWARD */
      }/* Otherwise, Already set by Dcm_Svc19UtiDemSetReadinessGroupIdentifierFilter */
    }/* Otherwise, Already set by Dcm_Svc19UtiDemGetDTCStatusAvailabilityMask */
  }
  else
  {
    /* Invalid functional group */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service22Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service22Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc22RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc22;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc22Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC22_PROGRESS_DIDLOOKUP:
    lStdResult = Dcm_Svc22DidLookUp(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                        /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC22_PROGRESS_CHECKCONDITION:
    lStdResult = Dcm_Svc22CheckCondition(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC22_PROGRESS_GETLENGTH:
    lStdResult = Dcm_Svc22GetLength(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                        /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC22_PROGRESS_READDATA:
    lStdResult = Dcm_Svc22ReadData(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE XX */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service22Updater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service22Updater(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc22;

  return Dcm_Svc22UtiReadData(opStatus, pDataContext, ErrorCode, pRepContext);                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service22Cancel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service22Cancel(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DiagDataContextPtrType pDataContext
  )
{
  Dcm_DidMgrDidInfoContextPtrType  pDidInfoContext;
  Dcm_NegativeResponseCodeType     lNrc;

  pDidInfoContext = Dcm_Svc22GetDidInfoContext(&(pContext->Thread->Repeater.Contexts.Context.Svc22));                                                /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  /* Notify the application about the cancellation */
  (void)Dcm_DidMgrReadDid(DCM_CANCEL
                         ,pDataContext
                         ,pDidInfoContext
                         ,&(pContext->Thread->Repeater.Contexts.Context.Svc22.DidOpTypeContext)
                         ,&lNrc);                                                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  /* Cancel the ongoing DID operation */
  Dcm_DidMgrCancelOperation();
}
# endif
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service23Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service23Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc23RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc23;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc23Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC23_PROGRESS_CHECKACCESS:
    lStdResult = Dcm_Svc23CheckAccess(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC23_PROGRESS_READMEMORY:
    lStdResult = Dcm_Svc23ReadMemory(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_23_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service24Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service24Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc24RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc24;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc24Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC24_PROGRESS_DIDLOOKUP:
    lStdResult = Dcm_Svc24DidLookUp(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                        /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC24_PROGRESS_EXECUTEOP:
    lStdResult = Dcm_Svc24ExecuteOp(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                  /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service27Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc27RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc27;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Service27Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC27_PROGRESS_SEEDPROCESSOR:
    lStdResult = Dcm_Service27SeedProcessor(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC27_PROGRESS_KEYPROCESSOR:
    lStdResult = Dcm_Service27KeyProcessor(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  case DCM_SVC27_PROGRESS_SETATTEMPTCNTR:
    lStdResult = Dcm_Service27SetAttemptCntrRepeater(opStatus, pMsgContext, ErrorCode, pRepContext);                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
  case DCM_SVC27_PROGRESS_SEEDREPEATER:
    lStdResult = Dcm_Service27SeedRepeater(opStatus, pMsgContext, ErrorCode, pRepContext);                                                           /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC27_PROGRESS_KEYREPEATER:
    lStdResult = Dcm_Service27KeyRepeater(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                  /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC27_PROGRESS_CHECKATTEMPTSEXCEEDED:
    lStdResult = Dcm_Service27CheckAttemptsExceededRepeater(opStatus, pMsgContext, ErrorCode, pRepContext);                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_Service27PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service27PostProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_ConfirmationStatusType status
  )
{
  Dcm_Svc27RepeaterProxyContextConstPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc27;

  /* If a positive response was successfully sent */
  if(status == DCM_RES_POS_OK)
  {
    /* If it was a compare key request: */
    if(Dcm_Svc27IsKeyRequest(pRepContext->SubSvcRef) == TRUE)                                                                                        /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
    {
      /* Apply the new security state and reset sequence */
      Dcm_StateSetSecurity((Dcm_StateIndexOptType)(Dcm_Svc27GetSecLvlRef(pRepContext->SubSvcRef)) + 1u); /* locked = 0x00 -> level 1 = 0x01, etc */
    }
    else
    {
      /* If this was no zero seed response: */
      if(pRepContext->IsZeroSeed == FALSE)
      {
        /* Prepare for key acceptance */
        Dcm_SingletonContext.Diag.Services.Svc27.SeedLevel = Dcm_CfgStateSecurityInfo[(Dcm_Svc27GetSecLvlRef(pRepContext->SubSvcRef))].Value;
      }
      else
      {
        /* Otherwise, there is no key expected in that case after zero seed */
        Dcm_Svc27ResetSequence();
      }
    }
  }
  else if((DCM_DIAG_RES_NEG_ANY & status) != 0u) /* Otherwise, if any negative response was sent: */
  {
    /* Reset the key-seed-sequence */
    Dcm_Svc27ResetSequence();
  }
  else /* POS_NOK */
  {
    /*
     * Otherwise no change required:
     *   - on SeedReq: the client shall retry the seed request or send another one
     *                 -> do not move to expect key for a certain level
     *   - on KeyReq:  the client may retry the key request to get a response
     *                 -> do not invalidate expect key for this level
     */
  }
}
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service28_XXProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service28_XXProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint8   msgType;
  boolean validParam = TRUE;
  Dcm_Svc28RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc28;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Extract and validate the requested network type (i.e. request data byte[0], high nibble) */
  {
    sint16_least lookUpResult;
    lookUpResult = Dcm_UtiLookUpUint8(Dcm_CfgSvc28SubNetIdLookUp, (uint8)(Dcm_UtiGetReqDataAsU8(pMsgContext) >> 4u));                                /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */

    if(lookUpResult >= 0)
    {
      pRepContext->NetworkRef = Dcm_CfgSvc28SubNetIdMap[lookUpResult];                                                                               /* SBSW_DCM_GLOBAL_PTR_WRITE */
# if (DCM_SVC_28_CURNET_SUPPORT_ENABLED == STD_ON)
      if(pRepContext->NetworkRef == DCM_SVC_28_NETWORK_CURRENT)
      {
        pRepContext->NetworkRef = Dcm_PbCfgNetConnComMChannelMap[Dcm_PbCfgNetConnectionInfo[Dcm_DiagGetTranspObj(pContext->Thread)->ConnHdl].NetworkIdRef]; /* SBSW_DCM_GLOBAL_PTR_WRITE */
      }
# endif
    }
    else
    {
      validParam = FALSE;
    }
  }

  /* Extract and validate the requested message type (i.e. request data byte[0], low nibble) */
  {
    msgType = (uint8)(Dcm_UtiGetReqDataAsU8(pMsgContext) & 0x0Fu);                                                                                   /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */

    if(Dcm_UtiLookUpUint8(Dcm_CfgSvc28MessageTypeLookUpTable, msgType) < 0)                                                                          /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
    {
      validParam = FALSE;
    }
  }

  if(validParam == TRUE)
  {
    /*--------------------------------------------------------------
    Message types      |   Operations                |ComParamValue
    (Affected = 1,     |                             |
     Not affected = 0) | (Enable = 0, Disable = 1)   |
    ------+------------+-----------------+-----------+
    NM    |    Appl    |    RxPath       |  TxPath   |
    ------+------------+-----------------+-----------+--------------
      0   |     0      |        x        |    x      |    -
      0   |     1      |        0        |    0      |    4
      0   |     1      |        0        |    1      |    5
      0   |     1      |        1        |    0      |    6
      0   |     1      |        1        |    1      |    7
      1   |     0      |        0        |    0      |    8
      1   |     0      |        0        |    1      |    9
      1   |     0      |        1        |    0      |    10
      1   |     0      |        1        |    1      |    11
      1   |     1      |        0        |    0      |    12
      1   |     1      |        0        |    1      |    13
      1   |     1      |        1        |    0      |    14
      1   |     1      |        1        |    1      |    15
    ------+------------+-----------------+-----------+--------------
    => ModeValue := ((msgType) & 0x03) << 2) | ((RxPath) & 0x01) << 1) | ((TxPath) & 0x01) ) ) - 4
    SubFunc == ((RxPath) & 0x01) << 1) | ((TxPath) & 0x01);
    => ModeValue := ((msgType) & 0x03) << 2) | (SubFunc) ) - 4
    */
    pRepContext->ComMode = (Dcm_CommunicationModeType)( ( ((msgType & 0x03u) << 2u) | (pRepContext->SubServiceId & DCM_SVC_28_CTRL_OP_MASK) ) - 4u); /* SBSW_DCM_GLOBAL_PTR_WRITE */

    /* Mark current service execution as internally handled to perform the post-processing step later on */
    pRepContext->IsInternallyProcessed = TRUE;                                                                                                       /* SBSW_DCM_GLOBAL_PTR_WRITE */
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service28Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service28Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                lStdResult;
  Dcm_Svc28RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc28;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc28Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC28_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc28SubFuncHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service28PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service28PostProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  Dcm_ConfirmationStatusType status
  )
{
  if(status == DCM_RES_POS_OK)
  {
    if(pContext->Thread->Repeater.Contexts.Context.Svc28.IsInternallyProcessed == TRUE)
    {
      Dcm_Svc28ApplyCommControl(pContext->Thread->Repeater.Contexts.Context.Svc28.NetworkRef,
                                pContext->Thread->Repeater.Contexts.Context.Svc28.ComMode);
    }
  }
}
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service29_00Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service29_00Processor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc29;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Set connection state to deauthenticated */
  pRepContext->ConnContext.AuthState = DCM_DEAUTHENTICATED;                                                                                          /* SBSW_DCM_GLOBAL_PTR_WRITE */
  pRepContext->ConnContext.ActiveRole = DCM_AUTHMGR_DEAUTHENTICATED_ROLE;                                                                            /* SBSW_DCM_GLOBAL_PTR_WRITE */

  /* Set the authenticationReturnParameter of the response to DeAuthentication successful */
  Dcm_UtiProvideResDataAsU8(pMsgContext, DCM_SVC29_DEAUTH_SUCCESSFUL);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_PERSIST_AUTHENTICATION);                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

  return DCM_E_LOOP;
}

# if (DCM_SVC_29_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service29_01Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service29_01Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  boolean        lIsReqLenValid = FALSE;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Check that request contains COCO(1Byte) and length field for client certificate */
  if(pMsgContext->reqDataLen > (1u + DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN))
  {
    uint8 lCocoField;
    uint16 lClientCertLength;

    Dcm_UtiConsumeReqDataAsU8(pMsgContext, &lCocoField);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &lClientCertLength);                                                                                     /* SBSW_DCM_COMB_PTR_FORWARD */

    /* Check that request contains length field for client challenge */
    if( (lClientCertLength > 0u)
      &&(pMsgContext->reqDataLen == (lClientCertLength + DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN)) )
    {
      uint16 lChallengeClientLength = Dcm_UtiGetReqDataAsU16Rel(pMsgContext, lClientCertLength);                                                     /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */

      /* Check if length of challenge client is 0 */
      if(lChallengeClientLength == 0u)
      {
        lIsReqLenValid = TRUE;
        lStdResult = Dcm_Svc29CertificateStoreVerify(lCocoField, lClientCertLength, pContext, pMsgContext, ErrorCode);                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
    }
  }

  if(lIsReqLenValid == FALSE)
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service29_02Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service29_02Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  boolean        lIsReqLenValid = FALSE;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Check that request contains COCO(1Byte) and length field for client certificate */
  if(pMsgContext->reqDataLen > (1u + DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN))
  {
    uint8  lCocoField;
    uint16 lClientCertLength;

    Dcm_UtiConsumeReqDataAsU8(pMsgContext, &lCocoField);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &lClientCertLength);                                                                                     /* SBSW_DCM_COMB_PTR_FORWARD */

    /* Check that request contains length field for client challenge */
    if( (lClientCertLength > 0u)
      &&(pMsgContext->reqDataLen > (lClientCertLength + DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN)) )
    {
      uint16 lChallengeClientLength = Dcm_UtiGetReqDataAsU16Rel(pMsgContext, lClientCertLength);                                                     /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */

      /* Check if challenge client is valid and the request length is as expected */
      if( (lChallengeClientLength > 0u)
        &&(lChallengeClientLength <= DCM_AUTHMGR_CHALLENGE_MAX_SIZE)
        &&(pMsgContext->reqDataLen == (lClientCertLength + DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN + lChallengeClientLength)) )
      {
        lIsReqLenValid = TRUE;

        /* Copy client challenge in the special buffer */
        Dcm_UtiMemCopySafe(Dcm_UtiGetReqDataRel(pMsgContext, lClientCertLength + DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN)
                          ,Dcm_SingletonContext.Diag.Services.Svc29.ChallengeSwapBuffer
                          ,0
                          ,DCM_AUTHMGR_CHALLENGE_MAX_SIZE
                          ,lChallengeClientLength);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_WRITE_CHALLENGE_SWAP_BUFFER */

        Dcm_Svc29SetLengthChallengeSwapBuffer(lChallengeClientLength);

        lStdResult = Dcm_Svc29CertificateStoreVerify(lCocoField, lClientCertLength, pContext, pMsgContext, ErrorCode);                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
    }
  }

  if(lIsReqLenValid == FALSE)
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Service29_03Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service29_03Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  boolean lIsReqLenValid = FALSE;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Check that request contains length field for proof of ownership */
  if(pMsgContext->reqDataLen > DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN)
  {
    uint16 lProofOfOwnershipLength;
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &lProofOfOwnershipLength);                                                                               /* SBSW_DCM_COMB_PTR_FORWARD */

    /* Check that request contains length field for the ephemeral public key */
    if( (lProofOfOwnershipLength > 0u)
      &&(pMsgContext->reqDataLen == (lProofOfOwnershipLength + DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN)) )
    {
      uint16 lLengthEPK = Dcm_UtiGetReqDataAsU16Rel(pMsgContext, lProofOfOwnershipLength);                                                           /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */

      /* Only an ephemeral public key length of 0 is supported */
      if(lLengthEPK == 0u)
      {
        lIsReqLenValid = TRUE;
        lStdResult = Dcm_Svc29VerifySignature(lProofOfOwnershipLength, pContext, pMsgContext, ErrorCode);                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
    }
  }

  if(lIsReqLenValid == FALSE)
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  return lStdResult;
}
/**********************************************************************************************************************
 *  Dcm_Service29_08Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service29_08Processor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Set the authenticationReturnParameter of the response to Authentication Configuration APCE */
  Dcm_UtiProvideResDataAsU8(pMsgContext, DCM_SVC29_AUTH_CONFIG_APCE);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

  return DCM_E_OK;
}

/**********************************************************************************************************************
 *  Dcm_Service29Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service29Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc29;

  /* Proccess according to stage */
  switch (Dcm_RepeaterGetProgress(pContext))
  {
    /* Verifies subfunction validity e.g length and sequence */
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc29Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
    /* Calls initial subfunction processor function */
  case DCM_SVC29_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc29SubFuncHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
    /* Evaluates certificate verification result if positive starts challenge generation common to 0x01 and 0x02 */
  case DCM_SVC29_PROGRESS_CERTVERIFIED:
    lStdResult = Dcm_Svc29CertificateVerificationDoneHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                               /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
    /* Evaluate challenge generation result if positive starts signing of client challenge for subfunction 0x02 */
  case DCM_SVC29_PROGRESS_CHALLENGEGEN:
    lStdResult = Dcm_Svc29ChallengeGenerationDoneHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
    /* Evaluates challenge signing result if positive sends response for subfunction 0x02 */
  case DCM_SVC29_PROGRESS_SUBFUNC02_CHALLENGESIGNED:
    lStdResult = Dcm_Svc29_02ChallengeSigningDoneHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
  case DCM_SVC29_PROGRESS_SUBFUNC03_ROLEREAD:
    lStdResult = Dcm_Svc29_03RoleRead(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC29_PROGRESS_SUBFUNC03_SERVICEWHITELISTREAD:
    lStdResult = Dcm_Svc29_03ServiceWL(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                     /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC29_PROGRESS_SUBFUNC03_DIDWHITELISTREAD:
    lStdResult = Dcm_Svc29_03DidWL(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC29_PROGRESS_SUBFUNC03_RIDWHITELISTREAD:
    lStdResult = Dcm_Svc29_03RidWL(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC29_PROGRESS_SUBFUNC03_MEMWHITELISTREAD:
    lStdResult = Dcm_Svc29_03MemWL(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC29_PROGRESS_PERSIST_AUTHENTICATION:
    lStdResult = Dcm_Svc29_03PersistAuthentication(opStatus, pMsgContext, ErrorCode, pRepContext);                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
    /* On pending stages just loop */
  case DCM_SVC29_PROGRESS_SUBFUNC03_WAITSIGVERIFY:
  case DCM_SVC29_PROGRESS_WAITCERTVERIFY:
  case DCM_SVC29_PROGRESS_WAITCHALLENGEGEN:
# if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC29_PROGRESS_SUBFUNC02_WAITCHALLENGESIGNED:
# endif
    lStdResult = Dcm_Svc29CbkResultDispatcher(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                              /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

# if (DCM_MODE_AUTH_GENERAL_NRC_ENABLED == STD_ON)
  /* If processing result is a fail */
  if(lStdResult == DCM_E_NOT_OK)
  {
    /* Check if NRC is a Certificate Verification Failed NRC and change to General NRC if mode rule allows it */
    Dcm_Svc29GeneralNrcCheck(ErrorCode);                                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
# endif
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_Service29PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service29PostProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_ConfirmationStatusType status
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* If any negative response was sent: */
  if((DCM_DIAG_RES_NEG_ANY & status) != 0u)
  {
    Dcm_Svc29ResetSequence();
  }

  /* Only set state back to idle if request processing is not cancelled */
  if( (!Dcm_Svc29IsCbkStateActive(DCM_SVC29_CBK_PROC_STATE_CSM_CANCELLED))
    &&(!Dcm_Svc29IsCbkStateActive(DCM_SVC29_CBK_PROC_STATE_KEYM_CANCELLED)) )
  {
    /* Set callback processing state to idle */
    Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_IDLE);
  }
}
#endif /* (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2AProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2AProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc2A;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc2AHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC2A_PROGRESS_SCHEDULEDDID_LOOKUP:
    lStdResult = Dcm_Svc2AScheduledDidLookUp(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                               /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC2A_PROGRESS_DID_CHECKCONDITION:
    lStdResult = Dcm_Svc2ADidCheckCondition(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC2A_PROGRESS_DID_GETLENGTH:
    lStdResult = Dcm_Svc2ADidGetLength(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                     /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC2A_PROGRESS_STOPPED_DID_LOOKUP:
    lStdResult = Dcm_Svc2AStoppedDidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);                                                           /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service2APostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service2APostProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  Dcm_ConfirmationStatusType status
  )
{
  if(pContext->Thread->Repeater.Contexts.Context.Svc2A.UdsRate != DCM_SVC_2A_STOP_SENDING)
  {
    if(status == DCM_RES_POS_OK)
    {
      Dcm_Svc2ASchdCommit(Dcm_Svc2AMakeSchdRateFromUdsRate(pContext->Thread->Repeater.Contexts.Context.Svc2A.UdsRate));
      Dcm_NetPeriodicMsgSetConnection(pContext->Thread->Repeater.Contexts.Context.Svc2A.ConnHdl);
      Dcm_NetPeriodicMsgSetClientSrcAddr(Dcm_DiagGetTranspObj(pContext->Thread)->ClientSrcAddr);
    }
    else
    {
      Dcm_Svc2ASchdDiscard();
    }
  }/* else - nothing */
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2C_01Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2C_01Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdReturn;

  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc2C;

  lStdReturn = Dcm_Svc2CParseAndCheckDynDid(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdReturn == DCM_E_OK)
  {
    /* there shall be an iteration (+[4Byte]) */
    if( (pMsgContext->reqDataLen > 0u)
      &&( (pMsgContext->reqDataLen % 4u) == 0u) )
    {
      uint8 numReqItems = (uint8)(pMsgContext->reqDataLen / 4u); /* calculate number of source items to be processed */

      /* check DynDID capacity */
      lStdReturn = Dcm_Svc2CCheckAndSetNumOfItems(numReqItems, ErrorCode, pRepContext);                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      if(lStdReturn == DCM_E_OK)
      {
        Dcm_RepeaterNextStep(pContext, DCM_SVC2C_PROGRESS_01SRC_DIDLOOKUP);                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
        lStdReturn = DCM_E_LOOP; /* speed up processing */
      } /* else - Nrc and return value already set */
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
  } /* else - just return the value: DCM_E_PENDING, DCM_E_NOT_OK (ErrorCode already set) */

  return lStdReturn;
}
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2C_02Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2C_02Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdReturn;
  uint8          lAlfid;
  uint8          lBlockLength;

  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc2C;

  lStdReturn = Dcm_Svc2CParseAndCheckDynDid(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdReturn == DCM_E_OK)
  {
    /* Check, whether the ALFID is available */
    if (pMsgContext->reqDataLen != 0u)
    {
      /* the ALFID availability is checked within next call */
      lStdReturn = Dcm_MemMgrValidateAndGetAlfid(pMsgContext, &lAlfid, &lBlockLength, ErrorCode);                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
      if (lStdReturn == DCM_E_OK)
      {
        /* pMsgContext->reqDataLen cannot be zero! */
        if((pMsgContext->reqDataLen % lBlockLength) == 0u) /* the remained request length shall be a multiple of the memory address and size request block */
        {
          uint8 numReqItems = (uint8)(pMsgContext->reqDataLen / lBlockLength); /* calculate number of source items to be processed */

          /* check DynDID capacity */
          lStdReturn = Dcm_Svc2CCheckAndSetNumOfItems(numReqItems, ErrorCode, pRepContext);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
          if (lStdReturn == DCM_E_OK)
          {
            lStdReturn = Dcm_Svc2C02SrcItemsGetLength(lAlfid, pMsgContext, ErrorCode, pRepContext);                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
          } /* else - ErrorCode and return value already set */
        }
        else
        {
          /* else - ErrorCode set to 0x13 */
          *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdReturn = DCM_E_NOT_OK;
        }
      } /* else - DCM_E_NOT_OK (ErrorCode already set) */
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
  } /* else - DCM_E_NOT_OK (ErrorCode already set) */

  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_Service2C_03Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2C_03Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdReturn;

  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc2C;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  pRepContext->DynDidItemCount = 0u; /* prepare for a successful clear */                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */

  if(pMsgContext->reqDataLen == 0u)
  {
    /* clear all DynDID definitions */
    Dcm_CfgDidMgrDynDidHandleOptType dynDidIter;
    for(dynDidIter = 0; dynDidIter < DCM_NUM_DYNDIDS; ++dynDidIter)
    {
      Dcm_Svc2CDefMgrClear((Dcm_CfgDidMgrDynDidHandleMemType)dynDidIter);
    }
    lStdReturn = DCM_E_OK;
  }
  else if (pMsgContext->reqDataLen == 2u)
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC2C_PROGRESS_03_DIDLOOKUP); /* next job */                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdReturn = DCM_E_LOOP; /* speed up processing */
  }
  else
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  return lStdReturn;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Service2CProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2CProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc2C;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc2CHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC2C_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc2CSubFuncHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC2C_PROGRESS_01SRC_DIDLOOKUP:
    lStdResult = Dcm_Svc2C01SrcDidLookUp(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC2C_PROGRESS_01SRC_DIDCHECKCONDITIONS:
    lStdResult = Dcm_Svc2C01SrcDidCheckCondition(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC2C_PROGRESS_01SRC_DIDGETLENGTH:
    lStdResult = Dcm_Svc2C01SrcDidGetLength(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_ALWAYS TX */
  case DCM_SVC2C_PROGRESS_03_DIDLOOKUP:
    lStdResult = Dcm_Svc2C03DidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
# endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service2CPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service2CPostProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_ConfirmationStatusType status
  )
{
  if(status == DCM_RES_POS_OK)
  {
    Dcm_Svc2CRepeaterProxyContextConstPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc2C;

    if(pRepContext->DynDidItemCount != 0u) /* this is a definition service , not the clear one */
    {
      Dcm_Svc2CDynDidItemPtrType pItem;

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
      uint16 lDid = Dcm_DidMgrGetDynDidIdFromHandle(pRepContext->DynDidHandle);
      /* Kill any still not finished read periodic DID jobs to avoid inconsistent response data/length ! */
      Dcm_Svc2ASchdCancelReadByDid(lDid);
# endif
      /* Commit DynDID definition immediately */
      pItem = Dcm_Svc2CGetItem(pRepContext->DynDidHandle);
      pItem->Length = pRepContext->DynDidLength;                                                                                                     /* SBSW_DCM_POINTER_WRITE_2CITEM */
      pItem->Count  = pRepContext->DynDidItemCount;                                                                                                  /* SBSW_DCM_POINTER_WRITE_2CITEM */
    } /* else - the dynDid has been already cleared */

# if (DCM_SVC_2C_NVRAM_SUPPORT_ENABLED == STD_ON)
    Dcm_UtiNvMSetRamBlockStatus((uint16)DCM_SVC_2C_NVRAM_BLOCKID);
# endif
  } /* else - the dynDid list properties will not be changed - all prepared data will be discarded */
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2EProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2EProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc2ERepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc2E;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc2EHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC2E_PROGRESS_CHECKACCESS:
    lStdResult = Dcm_Svc2ECheckAccess(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC2E_PROGRESS_WRITEDATA:
    lStdResult = Dcm_Svc2EWriteData(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                  /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2FProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2FProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc2F;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc2FHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC2F_PROGRESS_CHECKACCESS:
    lStdResult = Dcm_Svc2FCheckAccess(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC2F_PROGRESS_EXECUTEOP:
    lStdResult = Dcm_Svc2FExecuteOp(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC2F_PROGRESS_GETLENGTH:
    lStdResult = Dcm_Svc2FGetLength(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC2F_PROGRESS_READDATA:
    lStdResult = Dcm_Svc2FReadData(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service2FPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service2FPostProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  Dcm_ConfirmationStatusType status
  )
{
  DCM_IGNORE_UNREF_PARAM(status);                                                                                                                    /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  Dcm_RsrcMgrReleaseDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID2F);
}
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service31Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service31Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc31RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc31;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc31Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC31_PROGRESS_EXECUTEOP:
    lStdResult = Dcm_Svc31ExecuteRoutine(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_34_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service34Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
*********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service34Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc34RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc34;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc34Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC34_PROGRESS_EXECUTEOP:
    lStdResult = Dcm_Svc34ProcessRequestDownload(opStatus, pMsgContext, ErrorCode, pRepContext);                                                     /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_34_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_36_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service36Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service36Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc36RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc36;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc36Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC36_PROGRESS_EXECUTEOP:
    lStdResult = Dcm_Svc36ProcessTransferDataWrite(opStatus, pMsgContext, ErrorCode, pRepContext);                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_36_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_37_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *Dcm_Service37Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service37Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc37RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc37;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc37Handler(pContext, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC37_PROGRESS_EXECUTEOP:
    lStdResult = Dcm_Svc37ProcessRequestTransferExit(opStatus, pMsgContext, ErrorCode, pRepContext);                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_37_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service3DProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service3DProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc3DRepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc3D;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc3DHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC3D_PROGRESS_CHECKACCESS:
    lStdResult = Dcm_Svc3DCheckAccess(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC3D_PROGRESS_WRITEMEMORY:
    lStdResult = Dcm_Svc3DWriteMemory(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3E_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service3EProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service3EProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Dcm_DiagSubServiceRefOptType  subSvcRef;

  /* Check initialization state */
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                             ,Dcm_CfgSvc3ESubFuncLookUpTable
                                             ,Dcm_CfgSvc3ESubFuncExecPrecondTable
                                             ,Dcm_DiagSvcWithOnlySubFuncReqLengthGetter
                                             ,Dcm_DiagNoSequenceChecker
                                             ,&subSvcRef
                                             ,ErrorCode);                                                                                            /* SBSW_DCM_COMB_PTR_FORWARD */

}
#endif /* (DCM_SVC_3E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service85Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service85Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc85RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc85;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc85Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC85_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc85_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service85PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service85PostProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_ConfirmationStatusType status
  )
{
  /* If a positive response was (successfully) sent: */
  if((status & DCM_DIAG_RES_NEG_ANY) == 0u)
  {
    /* Trigger the requested mode switch */
    Dcm_ModeSwitchDtcSetting(pContext->Thread->Repeater.Contexts.Context.Svc85.ReqMode
                            ,pContext->Thread->Repeater.Contexts.Context.Svc85.DTCGroup
                            ,pContext->Thread->Repeater.Contexts.Context.Svc85.DemClientId);
  }
}
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service86Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service86Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc86RepeaterProxyContextPtrType pRepContext = &pContext->Thread->Repeater.Contexts.Context.Svc86;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc86Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC86_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc86SubFuncHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CALLOUT_CODE
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_MemMap */

/**********************************************************************************************************************
 *  COMPONENT DETAILED DESIGN OF GENERATED FUNCTIONS
 *********************************************************************************************************************/
/**********************************************************************************************************************
 *  Dcm_Cfg<Unit>Get<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 *  Dcm_ModeRule<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_ModeCondGet_<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_ModeOnComControlModeChange()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 *  Dcm_DidMgr<XXX>ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr<DynDID>Read<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr<XXX>WriteData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr<OBD_AID>ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr<MID>ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr_<Data>_Write_IOControlRequest_ControlState()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr_DeadEnd_Write_IOControlRequest_ControlState()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr_<Data>_Write_IOControlRequest_IOOperationRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr_<Data>_Read_IOControlRequest_UnderControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr_<Data>_Write_IOControlRequest_UnderControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr_<DID>_IoControlOperation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr_<DID>_ReturnControlToECU()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr_<SupportedID>_ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr_<SupportedID>_ReadDataLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr<NvMDID>Read()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr<NvMDID>Write()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 *  Dcm_RidMgr<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_RidMgr_<XXX>_OBD_AID()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_RidMgr_<XXX>_OBD_TID()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 *  Dcm_SvcWrapper_<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_SubSvcWrapper_<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_ServiceNoPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_ServiceNoUpdater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_ServiceNoCancel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
/**********************************************************************************************************************
 *  Dcm_Svc27_Dummy_GetSecurityAttemptCounter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_Svc27_Dummy_SetSecurityAttemptCounter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 *  MISRA JUSTIFICATIONS
 *********************************************************************************************************************/
/* Following markers are only used in generated or extension files, thus "unused marker" warnings can be ignored.*/
                                                                                                                                                     /* PRQA S 0310 */ /* MD_Dcm_DifferentPointerType_0310 */
                                                                                                                                                     /* PRQA S 2982 */ /* MD_Dcm_Redundant_2982 */
                                                                                                                                                     /* PRQA S 1330 */ /* MD_Dcm_RteSpecific_1330 */
                                                                                                                                                     /* PRQA S 1514 */ /* MD_Dcm_ObjectOnlyAccessedOnce */
                                                                                                                                                     /* PRQA S 0612 */ /* MD_Dcm_0612 */

                                                                                                                                                     /* module specific MISRA deviations:

   MD_Dcm_DifferentPointerType_0310:
     Description: Rule 11.3
                  A cast shall not be performed between a pointer to object type and a pointer to a different object type.
     Reason:      To optimize access without the need of local variable, pointers to data types of the same size (uint8, sint8)
                  will be casted to the corresponding target pointer type.
     Risk:        Compile error/warnings.
     Prevention:  Compiler compatibility is tested during integration.

   MD_Dcm_0313:
     Description: Rule 11.1
                  Conversions shall not be performed between a pointer to a function and any other type.
     Reason:      No efficient dynamic-cast operation available in ANSI-C.
     Risk:        Data corruption due to miscast.
     Prevention:  Covered by descriptive pointer types and code review for correct usage.

   MD_Dcm_OptimizedInlineCode_0404:
     Description: Rule 1.3, Rule 13.2
                  More than one read access to volatile objects between sequence points.
     Reason:      This kind of read access is used only in case of function-like macros
                  where also a return value is expected. Needed for maximum inlining
                  efficiency and less other MISRA deviations.
     Risk:        Data inconsistency.
     Prevention:  These code sections are thoroughly tested by dedicated unit tests. the affected locations are simple expressions.

   MD_Dcm_Rule19.2:
     Description: Rule 19.2
                  The union keyword should not be used.
     Reason:      Data without shared lifetime is stored in union for efficiency.
     Risk:        None due to no shared lifetime.
     Prevention:  None.

   MD_Dcm_Optimize_0771:
     Description: Rule 15.4
                  There should be no more than one break or goto statement used to terminate any iteration statement.
     Reason:      The loop needs multiple exit points since error conditions cannot be verified prior to the loop.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_Rule1.2_1039:
    Description: Rule 1.2
                 Treating array of length one as potentially flexible member.
    Reason:      In a special configurations, a struct type has only one memeber of an array type with a size of one.
    Risk:        Some compilers would consider the array as a flexible memeber.
    Prevention:  Testing the code under several compilers.

   MD_Dcm_RteSpecific_1330:
     Description: Rule 8.3
                  All declarations of an object or function shall use the same names and type qualifiers.
     Reason:      The function declaration generated by the RTE are RTE-implementation specific and unknown at
                  the DCM development time.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_ObjectOnlyAccessedOnce:
    Description: Rule 8.9
                 An object should be defined at block scope if its identifier only appears in a single function.
    Reason:      Autosar rules or OEM requirements mandate this implementation.
    Risk:        None.
    Prevention : None.

   MD_Dcm_Optimize_2003:
     Description: Rule 16.3
                  An unconditional break statement shall terminate every switch-clause Enforcement.
     Reason:      To use optimal design small switch-case dispatchers use fall-through cases.
     Risk:        None, since documented as an explicit fall-through case.
     Prevention:  None.

   MD_Dcm_Redundant_2982:
    Description: Rule 2.2
                 This assignment is redundant. The value of this object is never used before being modified.
    Reason:      Initializing global variables.
    Risk:        None.
    Prevention:  None.

   MD_Dcm_Redundant_2983:
    Description: Rule 2.2
                 This assignment is redundant. The value of this object is never subsequently used.
    Reason:      In the last iteration of an iterative structure, a statement might be executed but not used.
    Risk:        None.
    Prevention:  None.

   MD_Dcm_Redundant_2985:
    Description: Rule 2.2
                 This operation is redundant. The value of the result is always that of the left-hand operand.
    Reason:      Apparent redundant-like operations are needed for better code readability.
    Risk:        None.
    Prevention:  None.

   MD_Dcm_Redundant_2986:
    Description: Rule 2.2
                 This operation is redundant. The value of the result is always that of the right-hand operand.
    Reason:      Apparent redundant-like operations are needed for better code readability.
    Risk:        None.
    Prevention:  None.

   MD_Dcm_Optimize_2889:
     Description: Rule 15.5
                  A function should have a single point of exit at the end.
     Reason:      For code run-time/ROM usage reason this function terminates immediately.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_ConstExpr:
    Description: Rule 2.2
                 Controlling expressions shall not be invariant.
    Reason:      A configuration dependent situation could lead to a constant logical expression.
    Risk:        None.
    Prevention:  None.

   MD_Dcm_CodingRule_3218:
     Description: Rule 8.9
                  An object should be defined at block scope if its identifier only appears in a single function.
     Reason:      Vector style guide prevents usage of static variables/constant objects in function scope.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_Rule13.5:
     Description: Rule 13.5
                  The right hand operand of a logical && or || operator shall not contain persistent side effects.
     Reason:      The function called on the right hand side has no side effects.
     Risk:        The function may introduce side effects at a later time.
     Prevention:  None.

   MD_Dcm_OptimizedInlineCode_3440:
     Description: Rule 13.3
                  A full expression containing an increment (++) or decrement (-) operator should have no other
                  potential side effects other than that caused by the increment or decrement operator
     Reason:      This kind of operator is used only in case of function-like macros where also a return value is expected.
                  Needed for maximum inlining efficiency and less other MISRA deviations.
     Risk:        The risks are at minimum since the affected locations are simple expressions.
     Prevention:  These code sections are thoroughly tested by dedicated unit tests.

   MD_Dcm_APIStd_3673:
     Description: Rule 8.13
                  A pointer should point to a const-qualified type whenever possible.
     Reason:      The API is defined by the AUTOSAR standardization.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_Design_3673:
     Description: Rule 8.13
                  A pointer should point to a const-qualified type whenever possible.
     Reason:      The API has to be compatible to a common prototype, defined by module's design to serve generic purposes.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_BitNegation_4399:
     Description: Rule 10.8
                  An expression which is the result of a ~ or << operation has been cast to a wider type.
     Reason:      Using the ~ operator avoids errors in manually typed bit masks.
     Risk:        May generate compiler warnings although explicit casts are used.
     Prevention:  None.

   MD_Dcm_2987:
     Description: Rule 2.2
                  This function call produces no side effects and is redundant.
     Reason:      The functions produces side effects, but only in specific configurations.
     Risk:        None.
     Prevention:  None.

  MD_Dcm_RetVal:
     Description: Rule 2.2
                  This initialization is redundant. The value of this object is never used before being modified.
     Reason:      Without this initialization some not so smart compilers will erroneously complain about use of uninitialized variable.
     Risk:        The redundant initialization code might be confusing.
     Prevention:  None.

  MD_Dcm_0612:
     Description: Rule 1.1
                  Size of object exceeds 32767 bytes - program does not conform strictly to ISO:C90.
     Reason:      A DCM buffer was configured with a size greater than 32767 bytes.
     Risk:        Decreased code portability.
     Prevention:  None.

  MD_Dcm_DerefInvalidPointer:
     Description: Rule 18.1
                  Dereference of an invalid pointer value.
     Reason:      This is a false positive and a known PRQA issue.
     Risk:        None.
     Prevention:  None.

  MD_Dcm_ComputingInvalidPointer:
     Description: Rule 18.1
                  Computing an invalid pointer value.
     Reason:      This is a false positive and a known PRQA issue.
     Risk:        None.
     Prevention:  None.

  MD_Dcm_8.5_Rte:
     Description: Rule 8.5
                  Multiple declarations of external object or function.
     Reason:      MICROSAR Rte generates prototypes for callbacks. Some callbacks are also contained in a replacement
                  header in case no Rte is used. This leads to duplicate definitions.
     Risk:        None.
     Prevention:  None.

  MD_Dcm_OptimizedInlineCode_3387:
     Description: Rule 13.3
                  A full expression containing an increment (++) or decrement (--) operator should have no other
                  potential side effects other than that caused by the increment or decrement operator
     Reason:      This kind of operator is used only in case of function-like macros where also a return value is expected.
                  Needed for maximum inlining efficiency and less other MISRA deviations.
     Risk:        The risks are at minimum since the affected locations are simple expressions.
     Prevention:  These code sections are thoroughly tested by dedicated unit tests.

  MD_Dcm_Design_3679:
     Description: Rule 8.13
                  The object referenced is not modified through it, so the object could be declared with type const*.
     Reason:      The API has to be compatible to a common prototype, defined by module's design to serve generic purposes.
     Risk:        None.
     Prevention:  None.
     
  MD_Dcm_2962:
     Description: Rule 9.1
                  The value of an object with automatic storage duration shall not be read before it has been set.
     Reason:      The variable is initialized in a function call before the variable is used. It is ensured that the variable
                  is initialized in the function call, because a check whether the DID exists is already done earlier. 
     Risk:        None.
     Prevention:  None.

  MD_Dcm_2822:
     Description: Rule 21.1
                  Arithmetic operation on NULL pointer.
     Reason:      This is a false positive.
     Risk:        None.
     Prevention:  None.
     
*/
/**********************************************************************************************************************
 *  COVERAGE JUSTIFICATIONS
 *********************************************************************************************************************/
/* COV_JUSTIFICATION_BEGIN

\ID COV_DCM_MACRO_OVERRIDE
  \ACCEPT TX
  \ACCEPT XF
  \REASON The value of a macro may be overridden by user config for test purposes. Since this is not officially
          supported, it is not covered by the test suite.

\ID COV_DCM_UNSUPPORTED
  \REASON [COV_MSR_UNSUPPORTED]

\ID COV_DCM_SUPPORT_PARTIALLY
  \REASON [COV_MSR_UNSUPPORTED]

\ID COV_DCM_SUPPORT_ALWAYS
  \REASON This configuration switch is always on, but the code is enclosed in a pre-processor precondition for consistency reasons and safe future changes.

\ID COV_DCM_SUPPORT_RESTRICTED
  \REASON This configuration switch is always on/off, due to feature range limitation.

\ID COV_DCM_SUPPORT_XOR
  \REASON Disjunction of configuration switches that are mutually exclusive and one of them is always true.

\ID COV_DCM_SUPPORT_WITH_MSR_DEM
  \REASON This configuration switch is always on as long as MSR4 DEM is used (required for SafeBSW context).

\ID COV_DCM_REQUIRED_BY_SAFEBSW
  \REASON This configuration switch is always on as required by SafeBSW context.

\ID COV_DCM_DEPENDS_ON_UNSUPPORTED
  \REASON This configuration switch is always on/off due to a justified expression it is involved in.

\ID COV_DCM_DEV_DEBUG
  \REASON The justified object is uncovered, since it is only used during component development to ease the detection of errors!

\ID COV_DCM_UNSUPPORTED_ERROR_DETECTION
  \REASON The justified object is uncovered, since it is only used to ease the detection of configuration errors!

\ID COV_DCM_NOUNIT
  \REASON The justified object is always undefined, since it is only used during component unit testing.

\ID COV_DCM_RTM_NO_RCR_RP_TX
  \ACCEPT XX
  \REASON The justified object is unreachable, since the configuration does not support any feature that could use it.
          A complete encapsulation of all use-cases where no RCR-RP will be sent would be too complex and risky.

\ID COV_DCM_RTM_DEV_DEBUG
  \REASON [COV_DCM_DEV_DEBUG]

\ID COV_DCM_RTM_UNREACHABLE
  \REASON The justified object is uncovered, since it is not intended to be reached! It just exists because of other reasons like MISRA (default case in a switch)
          or because of added debug assert monitoring for development purposes (see COV_DCM_RTM_DEV_DEBUG).

\ID COV_DCM_RTM_UNREACHABLE_COMPLEXITY
  \REASON The justified object is uncovered, since it can be reached only in very rare situations (i.e. interrupt, multiple events in a specific sequence, etc.)!
          But at the same time it is part of the (sub-)component design and cannot be removed.

\ID COV_DCM_RTM_DESIGN_LOWER_LAYER
  \REASON The justified object is uncovered, since it is a basic (lower layer) functionality and is designed to behave in different situations.
          These situations are not necessarily supported by all configurations. Due to the high complexity of dependent functionalities
          the concrete usage of the uncovered functionality is left to the upper layers in DCM!

\ID COV_DCM_RTM_RUNTIME_CHECK
  \REASON This condition depends on a runtime check for an uninitialized pointer or remaining buffer size check.

\ID COV_DCM_RTM_DEPENDS_ON_UNSUPPORTED
  \REASON The justified object is uncovered, since it can vary only if a specific (non supported in SafeBSW context) configuration is activated.

\ID COV_DCM_RTM_DEPENDS_ON_CFG
  \ACCEPT TX
  \ACCEPT XF
  \REASON The justified expression evaluates always depending on the configuration either to true or false.

COV_JUSTIFICATION_END */
/**********************************************************************************************************************
 *  SILENTBSW JUSTIFICATIONS
 *********************************************************************************************************************/
/* SBSW_JUSTIFICATION_BEGIN

\ID SBSW_DCM_PARAM_PTR_WRITE
  \DESCRIPTION    In a function, data is written through a pointer passed as function argument.
  \COUNTERMEASURE \N [CM_DCM_N_PASS_PARAM_PTR]

\ID SBSW_DCM_LOCAL_ARRAY_WRITE
  \DESCRIPTION    In a function, data written to an array.
  \COUNTERMEASURE \N [CM_DCM_N_ARRAY_INDEX_WRITE]

\ID SBSW_DCM_GEN_PARAM_PTR_WRITE
  \DESCRIPTION    In a generated function, called only by DCM static code, data is written through a
                  pointer passed as function argument.
  \COUNTERMEASURE \S [CM_DCM_S_GEN_PARAM_PTR_WRITE]

\ID SBSW_DCM_PARAM_PTR_FORWARD
  \DESCRIPTION    A pointer received in a function is passed to a function expecting a valid pointer.
  \COUNTERMEASURE \N [CM_DCM_N_PASS_PARAM_PTR]

\ID SBSW_DCM_GEN_PARAM_PTR_FORWARD
  \DESCRIPTION    A pointer received in a generated function, called only by DCM static code, is passed to
                  a function expecting a valid pointer.
  \COUNTERMEASURE \S [CM_DCM_S_GEN_PARAM_PTR_FORWARD]

\ID SBSW_DCM_PARAM_FUNCPTR_CALL
  \DESCRIPTION    In a function, a function pointer passed as function argument is called.
  \COUNTERMEASURE \N [CM_DCM_N_CALL_PARAM_FUNCPTR]

\ID SBSW_DCM_GLOBAL_PTR_WRITE
  \DESCRIPTION    In a function, data is written through a pointer taken from a global variable.
  \COUNTERMEASURE \N The pointer is taken from a global variable, as such it is always valid.

\ID SBSW_DCM_POINTER_FORWARD_STACK
  \DESCRIPTION    A pointer is passed to a function expecting a valid pointer. The called function does not store its
                  pointer parameter(s).
  \COUNTERMEASURE \N The pointer is taken from a local variable, as such it is always valid.

\ID SBSW_DCM_GEN_POINTER_FORWARD_STACK
  \DESCRIPTION    A pointer is passed to a function expecting a valid pointer (i.e. to return data through it).
                  The called function does not store its pointer parameter(s) for deferred writing.
  \COUNTERMEASURE \S [CM_DCM_S_GEN_POINTER_FORWARD_STACK]

\ID SBSW_DCM_POINTER_FORWARD_GLOBAL
  \DESCRIPTION    A pointer is passed to a function expecting a valid pointer. The called function does not store its
                  pointer parameters.
  \COUNTERMEASURE \N The pointer is taken from a global variable, as such it is always valid.

\ID SBSW_DCM_COMB_PTR_FORWARD
  \DESCRIPTION    A combination of pointers is passed to a function expecting valid pointers. The called function does
                  not store its pointer parameters.The pointer is taken from one of the following locations:
                     - global variable;
                     - local (stack) variable;
                     - is an argument of the caller function (refer also to CM_DCM_N_PASS_PARAM_PTR);
                     - is a pointer initialized with one of the following associated initialization function that
                       returns always a valid Pointer: Dcm_UtiGetDataContextBuffer(),
                                                       Dcm_UtiGetResData(),
                                                       Dcm_UtiGetResDataAt(),
                                                       Dcm_UtiInitDataContext(),
                                                       Dcm_DiagInitMsgContextBufferInfo(),
                                                       Dcm_DiagInitiateServiceProcessing(),
                                                       Dcm_NetGetBufferInfos(),
                                                       Dcm_NetGetTransportObject(),
                                                       Dcm_NetGetPeriodicTxObject(),
                                                       Dcm_Svc22GetDidInfoContext(),
                                                       Dcm_Svc2ASchdGetEntry(),
                                                       Dcm_Svc2CGetSrcItem(),
                                                       Dcm_InitContext(),
                                                       Dcm_GetThreadContext(),
                                                       Dcm_Svc31RedirectMsgContext(),
                                                       Dcm_Svc86GetDidRecord
                     as such it is always valid.
\COUNTERMEASURE \M [CM_DCM_M_SIZEOF_BUFFERINFO]
                \R [CM_DCM_R_GET_BUFFERINFO]
                \R [CM_DCM_R_SET_DATA_CONTEXT_USAGE]

\ID SBSW_DCM_GEN_COMB_PARAM_PTR_FORWARD
  \DESCRIPTION    A combination of pointers is passed to a function expecting valid pointers. The called function does
                  not store its pointer parameters.The pointer is taken from one of the following locations:
                     - local (stack) variable;
                     - is an argument of the caller function (refer also to CM_DCM_S_GEN_PARAM_PTR_FORWARD);
                     - is a pointer initialized with one of the following associated initialization function that
                       returns always a valid Pointer: Dcm_UtiGetResDataAt()
                     as such it is always valid.
\COUNTERMEASURE \R [CM_DCM_R_SET_MESSAGE_CONTEXT_REQBUFFER]
                \R [CM_DCM_R_SET_MESSAGE_CONTEXT_RESBUFFER]
                \S [CM_DCM_S_ROUTINE_OP_FUNC_SIGNATURE]
                \S [CM_DCM_S_ROUTINE_OP_FUNC_WRITE_DATA_LENGTH]
                \S [CM_DCM_S_ROUTINE_WRAPPER_WRITE_DATA_LENGTH]

\ID SBSW_DCM_GEN_RID_WRAPPER
  \DESCRIPTION    In a generated function, a pointer to a uint8/sint8 array routine signal is passed to a function
                  expecting a valid pointer.
  \COUNTERMEASURE \S [CM_DCM_S_ROUTINE_OP_FUNC_SIGNATURE]
                  \S [CM_DCM_S_ROUTINE_OP_FUNC_WRITE_DATA_LENGTH]
                  \S [CM_DCM_S_ROUTINE_WRAPPER_WRITE_DATA_LENGTH]

\ID SBSW_DCM_GEN_DID_WRAPPER
  \DESCRIPTION    In a generated function, a pointer to a uint8 array DID signal is passed to a function
                  expecting a valid pointer.
  \COUNTERMEASURE \S [CM_DCM_S_DID_WRAPPER_WRITE_DATA_LENGTH]
                  \S [CM_DCM_S_DID_WRAPPER_NV_BLOCK_ID_READ]
                  \S [CM_DCM_S_DID_WRAPPER_NV_BLOCK_ID_WRITE]

\ID SBSW_DCM_ROE_NV_ACCESS
  \DESCRIPTION    In a function, a pointer to a NvM data structure is passed to a function expecting valid pointers.
  \COUNTERMEASURE \S [CM_DCM_S_ROE_NV_BLOCK_ID_ACCESS]

\ID SBSW_DCM_SVC29_NV_ACCESS
  \DESCRIPTION    In a function, a pointer to a NvM data structure is passed to a function expecting valid pointers.
  \COUNTERMEASURE \S [CM_DCM_S_SVC29_NV_BLOCK_ID_ACCESS]


\ID SBSW_DCM_POINTER_WRITE_BUFFERINFO
  \DESCRIPTION    In an internal function, data is written through a pointer to a buffer info element, or the
                  pointer is passed to a function expecting a valid reference to a buffer info element.
                  The memory entry pointer is initialized by Dcm_NetGetBufferInfos() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_CONSISTENCY_BUFFERINFO]
                  \M [CM_DCM_M_SIZEOF_BUFFERINFO]
                  \R [CM_DCM_R_GET_BUFFERINFO]

\ID SBSW_DCM_POINTER_WRITE_COMMCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a ComM context element, or the
                  pointer is passed to a function expecting a valid reference to a ComM context element.
                  The memory entry pointer is initialized by Dcm_NetGetComMContext() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_COMMCONTEXT]
                  \R [CM_DCM_R_GET_COMMCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a buffer context element, or the
                  pointer is passed to a function expecting a valid reference to a buffer context element.
                  The memory entry pointer is initialized by Dcm_NetGetBufferContext() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_BUFFERCONTEXT]
                  \R [CM_DCM_R_GET_BUFFERCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT
  \DESCRIPTION    In an internal function, data is written through a pointer to a transport object, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_NetGetTransportObject() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TRANSPORTOBJECT]

\ID SBSW_DCM_POINTER_WRITE_TIMERCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a timer context , or the
                  pointer is passed to a function expecting a valid reference to a timer context.
                  The memory entry pointer is initialized by Dcm_TmrGetTimerContext() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_TIMERCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_THREADCONTEXT
  \DESCRIPTION    In an internal function, a pointer is called. The pointer is initialized by
                  Dcm_GetThreadContext() which will always return a valid thread context pointer.
  \COUNTERMEASURE \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_POINTER_INIT_CONTEXT
  \DESCRIPTION    The context pointer is locally allocated and passed to Dcm_InitContext() for
                  initialization.
  \COUNTERMEASURE \N The pointer is taken from a local variable, as such it is always valid.

\ID SBSW_DCM_POINTER_WRITE_CONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a context, or the
                  pointer is passed to a function expecting a valid reference to a context.
                  The memory entry pointer is initialized by Dcm_InitContext() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_INIT_CONTEXT]

\ID SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ
  \DESCRIPTION    In an internal function, data is written through a pointer to a transport object, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_DiagGetQueuedTranspObj() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TRANSPORTOBJECT]

\ID SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION
  \DESCRIPTION    In an internal function, data is written through a pointer to a transport object, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_NetGetTranspObjOfConnection().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ
  \DESCRIPTION    In an internal function, data is written through a pointer to a transport object, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_NetAllocateOrGetTranspObject().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_POINTER_WRITE_RESERVEDTOBJ
  \DESCRIPTION    In an internal function, data is written through a pointer to a transport object, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_NetLockConnection().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_POINTER_WRITE_PERTXOBJ
  \DESCRIPTION    In an internal function, data is written through a pointer to a periodic transport ojbect, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_NetGetPeriodicTxObject() which will always
                  return a pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_PERTXOBJ]
                  \R [CM_DCM_R_SET_PERTXOBJ]

\ID SBSW_DCM_POINTER_WRITE_TASKCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a task context object.
                  The memory entry pointer is initialized by Dcm_TskGetTaskContext().
  \COUNTERMEASURE \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_POINTER_WRITE_SCHEDULERCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a scheduler context object.
                  The memory entry pointer is initialized by Dcm_TskGetSchedulerContext().
  \COUNTERMEASURE \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_POINTER_WRITE_BITSET
  \DESCRIPTION    In an internal function, data is written to an array representing a bitset. The index within the
                  array is calculated by Dcm_UtiBitSetGetRowIdxSafe() which will always return a valid index within
                  the given bitset.
  \COUNTERMEASURE \R [CM_DCM_R_GET_BITSETROWINDEX]
                  \R [CM_DCM_R_BITSET_BASETYPE]

\ID SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY
  \DESCRIPTION    In an internal function, data is written through a pointer to a service 0x2A scheduler table entry, or
                  the pointer is passed to a function expecting a valid reference to a service 0x2A scheduler table
                  entry. The memory entry pointer is initialized by Dcm_Svc2ASchdGetEntry() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_2ASCHEDULERENTRY]

\ID SBSW_DCM_POINTER_WRITE_2CSRCITEM
  \DESCRIPTION    In an internal function, data is written through a pointer to a service 0x2C source item, or the
                  pointer is passed to a function expecting a valid reference to a service 0x2C source item. The memory
                  entry pointer is initialized by Dcm_Svc2CGetSrcItem() which will always return a pointer to a valid
                  memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_2CSRCITEM]

\ID SBSW_DCM_POINTER_WRITE_2CITEM
  \DESCRIPTION    In an internal function, data is written through a pointer to a service 0x2C item, or the pointer is
                  passed to a function expecting a valid reference to a service 0x2C item. The memory entry pointer is
                  initialized by Dcm_Svc2CGetItem() which will always return a pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_2CITEM]

\ID SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a process context of a DID, or the
                  pointer is passed to a function expecting a valid reference to a process context. The memory entry
                  pointer is initialized by Dcm_Svc2CGetDDDidProcessContext() which will always return a pointer to a
                  valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_2CPROCESSCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_2FACTIVEIODIDS
  \DESCRIPTION    In an internal function, data is written through a pointer to a bitmask of active IODIDs, or the
                  pointer is passed to a function expecting a valid reference to a bitmask of active IODIDs. The memory
                  entry pointer is initialized by Dcm_Svc2FGetActiveIoDids() which will always return a pointer to a
                  valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_2FACTIVEIODIDS]

\ID SBSW_DCM_POINTER_WRITE_86DIDRECORD
  \DESCRIPTION    In an internal function, data is written through a pointer to a service 0x86 DID record, or the
                  pointer is passed to a function expecting a valid reference to a service 0x86 DID record. The memory
                  entry pointer is initialized by Dcm_Svc86GetDidRecord() which will always return a pointer to a valid
                  memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_86DIDRECORD]

\ID SBSW_DCM_POINTER_WRITE_VSGACTIVECFGVARIANTS
  \DESCRIPTION    In an internal function, data is written to the array Dcm_SingletonContext.VarMgr.ActiveCfgVariants[]
                  using an iterator.
  \COUNTERMEASURE \R [CM_DCM_R_GET_VSGACTIVECFGVARIANTS]

\ID SBSW_DCM_POINTER_WRITE_PERIODICTXBUFFER
  \DESCRIPTION    In an internal function, data is written through a pointer to the tx buffer of a periodic message, or
                  the pointer is passed to a function expecting a valid reference to the tx buffer of a periodic
                  message. The memory entry pointer is initialized by Dcm_NetPeriodicMsgGetTxBuffer() which will always
                  return a pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_PERIODICTXBUFFER]

\ID SBSW_DCM_POINTER_WRITE_RXPDUINFO
  \DESCRIPTION    In an internal function, data is written through a pointer to a Rx-PduInfo, or the
                  pointer is passed to a function expecting a valid reference to a Rx-PduInfo element.
                  The memory entry pointer is initialized by Dcm_NetProvideRxBuffer() which will always return a
                  pointer to a valid memory entry if the return values is BUFREQ_OK.
  \COUNTERMEASURE \R [CM_DCM_R_GET_RXPDUINFO]

\ID SBSW_DCM_POINTER_WRITE_DIDINFOCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a Did info context, or the
                  pointer is passed to a function expecting a valid reference to a Did info context.
                  The memory entry pointer is initialized by Dcm_Svc22GetDidInfoContext() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_DIDINFOCONTEXT]

\ID SBSW_DCM_POINTER_INIT_MESSAGE_CONTEXT
  \DESCRIPTION    The global message context variable is passed to Dcm_DiagInitMsgContextBufferInfo() for
                  initialization. That initalization function ensures that all pointer members are pointing to valid
                  memory entry pointer and the corresponding buffer size members are matching to the pointed memory
                  entry sizes.
  \COUNTERMEASURE \N The pointer is taken from a global variable, as such it is always valid.

\ID SBSW_DCM_POINTER_WRITE_MESSAGE_CONTEXT_REQBUFFER
  \DESCRIPTION    In an internal function, data is written through a pointer to a message context request buffer,
                  or the pointer is passed to a function expecting a valid reference to a message context
                  request buffer. The caller ensures that the reqData member points to a valid memory entry pointer
                  and the reqBufSize member matches to the pointed memory entry size.
  \COUNTERMEASURE \R [CM_DCM_R_SET_MESSAGE_CONTEXT_REQBUFFER]

\ID SBSW_DCM_POINTER_WRITE_MESSAGE_CONTEXT_RESBUFFER
  \DESCRIPTION    In an internal function, data is written through a pointer to a message context response buffer,
                  or the pointer is passed to a function expecting a valid reference to a message context
                  response buffer. The caller ensures that the resData member points to a valid memory entry pointer
                  and the resBufSize member matches to the pointed memory entry size.
  \COUNTERMEASURE \R [CM_DCM_R_SET_MESSAGE_CONTEXT_RESBUFFER]

\ID SBSW_DCM_POINTER_WRITE_IO_CTRL_CEMR_SESSION_MASK
  \DESCRIPTION    In an internal function, data is written through a pointer to an IO control CEMR session mask, or the
                  pointer is passed to a function expecting a valid reference to an IO control CEMR session mask.
  \COUNTERMEASURE \R [CM_DCM_R_WRITE_IO_CTRL_CEMR_SESSION_MASK]

\ID SBSW_DCM_POINTER_WRITE_RECOVERYINFOCOMMCHANNELSTATE
  \DESCRIPTION    In an internal function, data is written through a pointer to a ComM channel state of the recovery
                  info, or the pointer is passed to a function expecting a valid reference to a ComM channel state of
                  the recovery info. The memory entry pointer is initialized by
                  Dcm_DiagGetRecoveryInfoComMChannelState() which will always return a pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_RECOVERYINFOCOMMCHANNELSTATE]

\ID SBSW_DCM_POINTER_WRITE_RECOVERYINFOCOMMCONTROLSTATE
  \DESCRIPTION    In an internal function, data is written through a pointer to the communication state of a ComM
                  channel of the recovery info, or the pointer is passed to a function expecting a valid reference to
                  the communication state of a ComM channel of the recovery info. The memory entry pointer is
                  initialized by Dcm_DiagGetRecoveryInfoCommControlState() which will always return a pointer to a
                  valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_RECOVERYINFOCOMMCONTROLSTATE]

\ID SBSW_DCM_POINTER_INIT_DATA_CONTEXT
  \DESCRIPTION    The data context pointer is locally allocated and passed to Dcm_UtiInitDataContext() for
                  initialization. The caller ensures that the passed buffer pointer points to a valid memory entry
                  pointer and the passed buffer size matches to the pointed memory entry size.
  \COUNTERMEASURE \N The pointer is taken from a local variable, as such it is always valid.

\ID SBSW_DCM_POINTER_WRITE_DATA_CONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a data context, or the
                  pointer is passed to a function expecting a valid reference to a data context.
                  The pointer is initialized by Dcm_UtiInitDataContext(), which will always initialize it to point
                  to a valid memory entry. A data context ensures that the sum of Usage and AvailLen member is always
                  equal to or smaller than the referenced buffer size.
  \COUNTERMEASURE \R [CM_DCM_R_SET_DATA_CONTEXT_BUFFER]
                  \R [CM_DCM_R_SET_DATA_CONTEXT_USAGE]

\ID SBSW_DCM_POINTER_MEMCPY_BUFFER
  \DESCRIPTION    In an internal function, data is copied into a buffer through a pointer using memcpy, or the
                  buffer pointer with the appropriate buffer size are passed to a function expecting a valid pair
                  of buffer pointer and buffer size.
  \COUNTERMEASURE \R [CM_DCM_R_MEMCPY_PASS_BUFFER]
                  \R [CM_DCM_R_MEMCPY_WRITE]

\ID SBSW_DCM_CALL_FUNCPTR_TASKINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_TskGetTaskInfo().
  \COUNTERMEASURE \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_FUNCPTR_TIMERINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_TmrGetTimerInfo() which will always return a valid function pointer.
  \COUNTERMEASURE \R [CM_DCM_R_GET_TIMERINFO]

\ID SBSW_DCM_CALL_FUNCPTR_SVCPOSTPROCESSORS
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_DiagGetPostProcessorFunc() which will always return a valid function pointer.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVCPOSTPROCESSORS]
                  \R [CM_DCM_R_GET_SVCPOSTPROCESSORS]

\ID SBSW_DCM_CALL_FUNCPTR_SVCUPDATERS
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_DiagGetUpdateFunc() which will always return a valid function pointer.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVCUPDATERS]
                  \R [CM_DCM_R_GET_SVCUPDATERS]

\ID SBSW_DCM_CALL_FUNCPTR_SVCCANCELLERS
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_DiagGetCancelFunc() which will always return a valid function pointer.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVCCANCELLERS]
                  \R [CM_DCM_R_GET_SVCCANCELLERS]

\ID SBSW_DCM_CALL_FUNCPTR_MODEMGRRULES
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgModeMgrRulesGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_MODEMGRRULES]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_FUNCPTR_TERMINATED_LIST
  \DESCRIPTION    In an internal function, iteration over all elements of a given table is done.
                  Each element is a function pointer or a structure containing only function pointer members.
                  The end of iteration is marked by NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_TERMINATED_LIST]
                  \R [CM_DCM_R_TERMINATED_LIST]

\ID SBSW_DCM_LOOP
  \DESCRIPTION    In an internal function, iteration over all elements of a given context member is done.
  \COUNTERMEASURE \R [CM_DCM_R_LOOP]

\ID SBSW_DCM_POINTER_WRITE_TOBJ_ADDBUFFER
  \DESCRIPTION    In an internal function, data is written to array AddBuffer[] of a specific transport object using a
                  function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_TOBJ_ADDBUFFER]

\ID SBSW_DCM_POINTER_WRITE_COMCONTROLCHANNEL
  \DESCRIPTION    In an internal function, data is written to array Dcm_PbRamNetComCtrlChannels[] using a
                  function argument as index.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_COMCONTROLCHANNEL]
                  \R [CM_DCM_R_SET_COMCONTROLCHANNEL]

\ID SBSW_DCM_POINTER_WRITE_AUTHNVMDATA
  \DESCRIPTION    In an internal function, data is written to array Dcm_AuthMgrNvMData[] using a
                  function argument as index.
                  Alternatively, data is written to that array through a pointer.
                  In the latter case the memory entry pointer is initialized by Dcm_AuthMgrGetWLContext().
  \COUNTERMEASURE \R [CM_DCM_R_SET_AUTHNVMDATA]

\ID SBSW_DCM_ARRAY_WRITE_PENDINGROLEDATA
  \DESCRIPTION    In an external API, data is written to array Dcm_SingletonContext.AuthMgr.PendingData.Role[].
  \COUNTERMEASURE \R [CM_DCM_R_SET_PENDINGROLEDATA]

\ID SBSW_DCM_POINTER_WRITE_SERVICE_WL_ELEMENT
  \DESCRIPTION    In an internal function, data is written through a pointer to array WLServiceContext.WLServiceElement[]
                  of a connection white list context, or the pointer is passed to a function expecting a valid reference
                  to a connection white list context.
                  The memory entry pointer is either initialized by Dcm_AuthMgrWLContextGetEntry(),
                  or is taken from global variable repeater context, and a loop iterator is used as index.
                  The caller ensures that the element length matches to the pointed memory entry size.
  \COUNTERMEASURE \R [CM_DCM_R_GET_VALID_POINTER]
                  \R [CM_DCM_R_SET_WLSERVICEELEMENT]

\ID SBSW_DCM_POINTER_WRITE_DID_WL_ELEMENT
  \DESCRIPTION    In an internal function, data is written through a pointer to array WLDidContext.WLDidElement[]
                  of a connection white list context.
                  The memory entry pointer is either initialized by Dcm_AuthMgrWLContextGetEntry(),
                  or is taken from global variable repeater context, and a loop iterator is used as index.
  \COUNTERMEASURE \R [CM_DCM_R_GET_VALID_POINTER]
                  \R [CM_DCM_R_SET_WLDIDELEMENT]

\ID SBSW_DCM_POINTER_WRITE_RID_WL_ELEMENT
  \DESCRIPTION    In an internal function, data is written through a pointer to array WLRidContext.WLRidElement[]
                  of a connection white list context.
                  The memory entry pointer is either initialized by Dcm_AuthMgrWLContextGetEntry(),
                  or is taken from global variable repeater context, and a loop iterator is used as index.
  \COUNTERMEASURE \R [CM_DCM_R_GET_VALID_POINTER]
                  \R [CM_DCM_R_SET_WLRIDELEMENT]

\ID SBSW_DCM_POINTER_WRITE_MEM_WL_ELEMENT
  \DESCRIPTION    In an internal function, data is written through a pointer to array WLMemContext.WLMemElement[]
                  of a connection white list context.
                  The memory entry pointer is either initialized by Dcm_AuthMgrWLContextGetEntry(),
                  or is taken from global variable repeater context, and a loop iterator is used as index.
  \COUNTERMEASURE \R [CM_DCM_R_GET_VALID_POINTER]
                  \R [CM_DCM_R_SET_WLMEMELEMENT]

\ID SBSW_DCM_POINTER_WRITE_WL_ELEMENT
  \DESCRIPTION    The white list element pointer is passed to a function expecting a valid reference to a white list
                  element buffer. The caller ensures that the white list element points to a valid memory pointer and
                  the white list element length matches to the pointed memory entry size.
  \COUNTERMEASURE \N The pointer is taken from a local variable, as such it is always valid.

\ID SBSW_DCM_POINTER_WRITE_CERTIFICATE_DATA
  \DESCRIPTION    In an internal function, data is written through a pointer to a certificate data buffer,
                  or the certificate data pointer is passed to a function expecting a valid reference to a certificate
                  data buffer. The caller ensures that the certData member points to a valid memory entry pointer and
                  the certDataLength member matches to the pointed memory entry size.
  \COUNTERMEASURE \N The pointer is taken from a local variable, as such it is always valid.

\ID SBSW_DCM_POINTER_WRITE_CHALLENGE_SWAP_BUFFER
  \DESCRIPTION    In an internal function, data is written through a pointer to the challenge swap buffer,
                  or the challenge swap buffer pointer is passed to a function expecting a valid reference to
                  the challenge swap buffer. The caller ensures that the challenge swap buffer points to a valid memory
                  pointer and buffer length matches to the pointed memory size.
  \COUNTERMEASURE \N The pointer is taken from a global variable, as such it is always valid.

\ID SBSW_DCM_POINTER_WRITE_CERTIFICATE_ROLE
  \DESCRIPTION    The certificate role pointer is passed to a function expecting a valid reference to a certificate
                  role buffer. The caller ensures that the role element points to a valid memory pointer and
                  the role element length matches to the pointed memory entry size.
  \COUNTERMEASURE \N The pointer is taken from a local variable, as such it is always valid.

\ID SBSW_DCM_POINTER_WRITE_TOBJHANDLE
  \DESCRIPTION    In an internal function, data is written to array Dcm_PbRamNetConnHdl2TObjMap[] using a
                  function argument as index.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TOBJHANDLE]
                  \R [CM_DCM_R_SET_TOBJHANDLE]

\ID SBSW_DCM_POINTER_WRITE_DELAYTIMER
  \DESCRIPTION    In an internal function, data is written to array
                  Dcm_SingletonContext.Network.PeriodicTxContext.DelayTimer[] using a function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_DELAYTIMER]

\ID SBSW_DCM_POINTER_WRITE_TIMER
  \DESCRIPTION    In an internal function, data is written to array Dcm_SingletonContext.TimerMgr.Timer[] using a
                  function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_TIMER]

\ID SBSW_DCM_POINTER_WRITE_START_UP_FBL_RES_BUFFER
  \DESCRIPTION    In an internal function, data is written to array Dcm_SingletonContext.Diag.StartUpFbl.ResBuffer[]
                  using a function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_START_UP_FBL_RES_BUFFER]

\ID SBSW_DCM_POINTER_WRITE_CURRENT_TASK_PRIO_STACK
  \DESCRIPTION    In an internal function, data is written to array CurrentTaskPrioStack.Stack[] using a
                  function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_CURRENT_TASK_PRIO_STACK]

\ID SBSW_DCM_POINTER_WRITE_ATTEMPTCOUNT
  \DESCRIPTION    In an internal function, data is written to array
                  Dcm_SingletonContext.Diag.Services.Svc27.AttemptCount[] using a function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_ATTEMPTCOUNT]

\ID SBSW_DCM_POINTER_WRITE_DELAYTIME_SEC
  \DESCRIPTION    In an internal function, data is written to array Dcm_SingletonContext.Diag.Services.Svc27.DelayTime[]
                  using a function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_DELAYTIME_SEC]

\ID SBSW_DCM_POINTER_WRITE_DELAYTIME_AUTH
  \DESCRIPTION    In an internal function, data is written to array Dcm_SingletonContext.AuthMgr.DelayTime[]
                  using a function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_DELAYTIME_AUTH]

\ID SBSW_DCM_POINTER_WRITE_DIDLOCKLIST
  \DESCRIPTION    In an internal function, data is written to array Dcm_SingletonContext.DidMgr.DidLockList[] using a
                  loop iterator as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_DIDLOCKLIST]

\ID SBSW_DCM_CALL_FUNCPTR_SVC11SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc11SubFuncInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC11SUBFUNC]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_FUNCPTR_SVC19SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc19SubFuncInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC19SUBFUNC]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC
  \DESCRIPTION    In an internal function, a function pointer is called.
                  The pointer is initialized by Dcm_CfgDidMgrSignalOpClassInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_DIDMGROPFUNC]
                  \R [CM_DCM_R_GET_VALID_POINTER]
                  \S [CM_DCM_S_DIDMGR_OP_FUNC_SIGNATURE]
                  \S [CM_DCM_S_DIDMGR_OP_FUNC_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgDidMgrIoControlSenderReceiverHandlersGetEntry() which will always return a valid function
                  pointer.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_IOCTRLSRHANDLERS]

\ID SBSW_DCM_CALL_FUNCPTR_SVC27SECLEVEL
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc27SecLevelInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC27SECLEVEL]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_FUNCPTR_SVC27GETSEED
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc27SecLevelInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC27SECLEVEL]
                  \R [CM_DCM_R_GET_VALID_POINTER]
                  \S [CM_DCM_S_GET_SEED_FUNC_SIGNATURE]
                  \S [CM_DCM_S_GET_SEED_FUNC_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgRidMgrOpInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC31OPFUNC]
                  \R [CM_DCM_R_GET_VALID_POINTER]
                  \S [CM_DCM_S_ROUTINE_OP_FUNC_SIGNATURE]
                  \S [CM_DCM_S_ROUTINE_OP_FUNC_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_SVC28SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc28SubFuncInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC28SUBFUNC]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_FUNCPTR_SVC29SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc29SubFuncInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC29SUBFUNC]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_FUNCPTR_SVC2CSUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc2CSubFuncInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC2CSUBFUNC]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_FUNCPTR_SVC85SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc85SubFuncInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC85SUBFUNC]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_FUNCPTR_SVC86SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc86SubFuncInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC86SUBFUNC]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_FUNCPTR_ROEMODESWITCH
  \DESCRIPTION    In an internal function, a function pointer is called. The index to the called function pointer
                  is a function argument.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_ROEEVENTMODESWITCHINFO]
                  \R [CM_DCM_R_GET_ROEEVENTMODESWITCHINFO]

\ID SBSW_DCM_CALL_FUNCPTR_AUTHMODESWITCH
  \DESCRIPTION    In an internal function, a function pointer is called. The index to the called function pointer
                  is a function argument.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_CFGAUTHMGRNETCONNINFO]
                  \R [CM_DCM_R_GET_CFGAUTHMGRNETCONNINFO]

\ID SBSW_DCM_CALL_FUNCPTR_SERVICEINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgDiagServiceInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SERVICEINFO]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_READMEMORY
  \DESCRIPTION    The callout Dcm_ReadMemory uses a write-able pointer of the DCM buffer, which is always valid. The
                  application always writes as many data as the caller expects.
  \COUNTERMEASURE \S [CM_DCM_S_READMEMORY_FUNC_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_SVC01SERVICEINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc01ServiceInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC01SERVICEINFO]
                  \R [CM_DCM_R_GET_VALID_POINTER]
                  \S [CM_DCM_S_GET_SVC01SERVICEINFO_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_SVC08SERVICEINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc08ServiceInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC08SERVICEINFO]
                  \R [CM_DCM_R_GET_VALID_POINTER]
                  \S [CM_DCM_S_GET_SVC08SERVICEINFO_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_SVC09SERVICEINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc09ServiceInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC09SERVICEINFO]
                  \R [CM_DCM_R_GET_VALID_POINTER]
                  \S [CM_DCM_S_GET_SVC09SERVICEINFO_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_SVC06MIDTIDINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc06MidTidInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC06MIDTIDINFO]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_POINTER_CONVERTTOARRAY
  \DESCRIPTION    In an internal function, data is copied into a buffer through a pointer, or the
                  buffer pointer with the appropriate buffer size are passed to a function expecting a valid pair
                  of buffer pointer and buffer size.
  \COUNTERMEASURE \R [CM_DCM_R_CONVERTTOARRAY_PASS_BUFFER]
                  \R [CM_DCM_R_CONVERTTOARRAY_WRITE]
                  \S [CM_DCM_S_GEN_POINTER_FORWARD_STACK]

\ID SBSW_DCM_CALL_PROCESSREQUESTTRANSFEREXIT
  \DESCRIPTION    The callout Dcm_ProcessRequestTransferExit uses a write-able pointer of the DCM buffer, which 
                  is always valid. The amount of data which can be written is indicated by an function argument 
                  to the application.
  \COUNTERMEASURE \S [CM_DCM_S_PROCESSREQUESTTRANSFEREXIT_FUNC_WRITE_DATA_LENGTH]

\ID SBSW_DCM_POINTER_SVC31_REDIRECT_MESSAGE_CONTEXT
  \DESCRIPTION    A local message context variable is passed to Dcm_Svc31RedirectMsgContext() for
                  initialization. That initalization function ensures that all pointer members are pointing to valid
                  memory entry pointer and the corresponding buffer size members are matching to the pointed memory
                  entry sizes.
  \COUNTERMEASURE \N The pointer is taken from a local variable, as such it is always valid.

SBSW_JUSTIFICATION_END */

/*
\CM CM_DCM_N_PASS_PARAM_PTR
  The caller ensures the pointers passed to this function are valid.

\CM CM_DCM_N_ARRAY_INDEX_WRITE
  The function insures calculating the correct array size and writing in an array index within the array index limit.

\CM CM_DCM_S_GEN_PARAM_PTR_WRITE
  The user of MICROSAR Safe shall verify that none of the generated functions in Dcm_Lcfg.c modifies the pointer
  passed as an argument, but only writes a new value to it.
  SMI-37386

\CM CM_DCM_S_GEN_PARAM_PTR_FORWARD
  The user of MICROSAR Safe shall verify that none of the generated functions in Dcm_Lcfg.c modifies the pointer
  passed as an argument, but only forwards it to another function.
  SMI-37387

\CM CM_DCM_S_GEN_POINTER_FORWARD_STACK
  The user of MICROSAR Safe shall verify that none of the generated functions in Dcm_Lcfg.c modifies the pointer taken
  from a local variable, and that the function receiving those pointer parameter(s) neither stores the addresses after
  return nor writes more data to the addesses than specified by the byte size of the local variable (especially in
  case of local arrays).
  SMI-37388

\CM CM_DCM_S_DIDMGR_OP_FUNC_SIGNATURE
  The user of MICROSAR Safe shall verify that all generated OpFunc functions in table Dcm_CfgDidMgrSignalOpClassInfo
  located in Dcm_Lcfg.c match the signature indicated by the FuncClass setting.
  SMI-106112, SMI-117436, SMI-126353, SMI-163630

\CM CM_DCM_S_GET_SEED_FUNC_SIGNATURE
  The user of MICROSAR Safe shall verify that all generated GetSeedFunc functions in table Dcm_CfgSvc27SecLevelInfo
  located in Dcm_Lcfg.c match the signature indicated by the GetSeedFuncClass setting.
  SMI-40607

\CM CM_DCM_S_GET_SEED_FUNC_WRITE_DATA_LENGTH
  The user of MICROSAR Safe shall verify that for all generated GetSeedFunc functions in table Dcm_CfgSvc27SecLevelInfo
  located in Dcm_Lcfg.c no more data will be written than specified by the corresponding SeedResLength setting.
  SMI-49478

\CM CM_DCM_S_ROUTINE_OP_FUNC_SIGNATURE
  The user of MICROSAR Safe shall verify that all generated OpFunc functions in table Dcm_CfgRidMgrOpInfo located
  in Dcm_Lcfg.c match the signature indicated by the OpType setting.
  SMI-64952

\CM CM_DCM_S_ROUTINE_OP_FUNC_WRITE_DATA_LENGTH
  The user of MICROSAR Safe shall verify that for all generated OpFunc functions in table Dcm_CfgRidMgrOpInfo located
  in Dcm_Lcfg.c no more data will be written than specified by the corresponding ResMaxLength setting.
  SMI-64953

\CM CM_DCM_S_ROUTINE_WRAPPER_WRITE_DATA_LENGTH
  The user of MICROSAR Safe shall verify all generated Dcm_RidMgr_<RID>_<Start|Stop|RequestResults> functions
  implemented in Dcm_Lcfg.c that for each Dcm_UtiGetResDataRel(pMsgContext, *<offset>*) usage on out signals the
  application does not write more data than (ResMaxLength - *<offset>*), specified by the corresponding ResMaxLength
  setting in table Dcm_CfgRidMgrOpInfo located in _Dcm_Lcfg.c.
  SMI-65597

\CM CM_DCM_S_DID_WRAPPER_WRITE_DATA_LENGTH
  The user of MICROSAR Safe shall verify that for all generated OpFunc functions in table
  Dcm_CfgDidMgrSignalOpClassInfo located in Dcm_Lcfg.c with a FuncClass setting of 0x00XX or 0x30XX, that are entirely
  or partially (e.g. through a wrapper function) implemented by the application, no more data will be written than
  specified by the corresponding MaxLength setting.
  SMI-105069

\CM CM_DCM_S_DID_WRAPPER_NV_BLOCK_ID_READ
  The user of MICROSAR Safe shall verify that in the table Dcm_CfgDidMgrSignalOpClassInfo, if OpFunc requires
  Nv Block ID, the Nv Block ID passed to the function Dcm_DidMgrNvMReadSignal() is intended to be used exclusively
  by Dcm.

  This SMI is required to fulfill SMI-22 by NvM.

  The user of MICROSAR Safe shall verify that in the table Dcm_CfgDidMgrSignalOpClassInfo, if OpFunc requires
  Nv Block ID, the Nv Block ID passed to the function Dcm_DidMgrNvMReadSignal() has a size equals to MaxLength.

  This SMI is required to fulfill SMI-23 by NvM.

  OpFunc functions that require Nv Block ID are implemented in Dcm_Lcfg.c both of:
  - with a generic name Dcm_DidMgr_<SignalName>_Read,
  - and the corresponding FuncClass equals to 0x0002.

  The table Dcm_CfgDidMgrSignalOpClassInfo is located in Dcm_Lcfg.c.
  SMI-106815, SMI-106816

\CM CM_DCM_S_DID_WRAPPER_NV_BLOCK_ID_WRITE
  The user of MICROSAR Safe shall verify that in the table Dcm_CfgDidMgrSignalOpClassInfo, if OpFunc requires
  Nv Block ID, the Nv Block ID passed to the function Dcm_DidMgrNvMWriteSignal() is intended to be used exclusively
  by Dcm.

  This SMI is required to fulfill SMI-22 by NvM.

  The user of MICROSAR Safe shall verify that in the table Dcm_CfgDidMgrSignalOpClassInfo, if OpFunc requires
  Nv Block ID, the Nv Block ID passed to the function Dcm_DidMgrNvMWriteSignal() has a size equals to MaxLength.

  This SMI is required to fulfill SMI-23 by NvM.

  OpFunc functions that require Nv Block ID are implemented in Dcm_Lcfg.c both of:
  - with a generic name Dcm_DidMgr_<SignalName>_Write,
  - and the corresponding FuncClass equals to 0x1002.

  The table Dcm_CfgDidMgrSignalOpClassInfo is located in Dcm_Lcfg.c.
  SMI-117437, SMI-117438

\CM CM_DCM_S_ROE_NV_BLOCK_ID_ACCESS
  The user of MICROSAR Safe shall verify that the Nv Block with the ID defined by DCM_EXT_SVC_86_NVRAM_BLOCKID located
  in Dcm_Cfg.h is intended to be used exclusively by Dcm.

  This SMI is required to fulfill SMI-22 by NvM.

  The user of MICROSAR Safe shall verify that the Nv Block with the ID defined by DCM_EXT_SVC_86_NVRAM_BLOCKID located
  in Dcm_Cfg.h has a size equals to the size of the structure data type Dcm_ExtSvc86NvMDataType.

  This SMI is required to fulfill SMI-23 by NvM.
  SMI-163518, SMI-163519

\CM CM_DCM_S_SVC29_NV_BLOCK_ID_ACCESS
  The user of MICROSAR Safe shall verify that each Nv Block, with the ID defined by NvMBlockId setting of table
  Dcm_CfgAuthMgrNetConnInfo located in Dcm_Lcfg.c, is intended to be used exclusively by Dcm.

  This SMI is required to fulfill SMI-22 by NvM.

  The user of MICROSAR Safe shall verify that each Nv Block, with the ID defined by NvMBlockId setting of table
  Dcm_CfgAuthMgrNetConnInfo located in Dcm_Lcfg.c, has a size of the structure data type Dcm_AuthMgrNvMDataType.

  This SMI is required to fulfill SMI-23 by NvM.
  SMI-440519, SMI-440520

\CM CM_DCM_S_READMEMORY_FUNC_WRITE_DATA_LENGTH
  The user of MICROSAR Safe shall verify that the implementation of the call-out function Dcm_ReadMemory() will not
  write more data than specified by the MemorySize parameter.
  SMI-74833

\CM CM_DCM_S_DIDMGR_OP_FUNC_WRITE_DATA_LENGTH
  The user of MICROSAR Safe shall verify that for all generated OpFunc functions in table
  Dcm_CfgDidMgrSignalOpClassInfo located in Dcm_Lcfg.c with a FuncClass setting of 0x00XX or 0x30XX, that are entirely
  or partially (e.g. through a wrapper function) implemented by the application, no more data will be written than
  specified by the corresponding MaxLength setting.

  The user of MICROSAR Safe shall verify that for all generated OpFunc functions in table
  Dcm_CfgDidMgrSignalOpClassInfo located in Dcm_Lcfg.c with a FuncClass setting of 0x0003 no more data will be written
  than specified by DCM_DIDMGR_READ_PAGE_SIZE setting located in Dcm_Cfg.h.
  SMI-105069, SMI-105312

\CM CM_DCM_S_GET_SVC01SERVICEINFO_WRITE_DATA_LENGTH
  The user of MICROSAR Safe shall verify that for all generated OpFunc functions in table Dcm_CfgSvc01ServiceInfoTable
  located in Dcm_Lcfg.c no more data will be written than specified by the corresponding ResLength setting.
  SMI-147940

\CM CM_DCM_S_GET_SVC08SERVICEINFO_WRITE_DATA_LENGTH
  The user of MICROSAR Safe shall verify that for all generated OpFunc functions in table Dcm_CfgSvc08ServiceInfoTable
  located in Dcm_Lcfg.c no more data will be written than specified by the corresponding ResLength setting.
  SMI-143395

\CM CM_DCM_S_GET_SVC09SERVICEINFO_WRITE_DATA_LENGTH
  The user of MICROSAR Safe shall verify that for all generated OpFunc functions in table Dcm_CfgSvc09ServiceInfoTable
  located in Dcm_Lcfg.c no more data will be written than specified by the corresponding ResLength setting.
  SMI-147938

\CM CM_DCM_S_PROCESSREQUESTTRANSFEREXIT_FUNC_WRITE_DATA_LENGTH
  The user of MICROSAR Safe shall verify that the implementation of the call-out function
  Dcm_ProcessRequestTransferExit() will not write more data than specified by the transferResponseParameterRecordSize
  parameter.
  SMI-579281

\CM CM_DCM_N_CALL_PARAM_FUNCPTR
  The caller ensures the pointers passed to this function are valid.

\CM CM_DCM_M_DEV_ERROR_DETECT
  Verify that development error detection is active in the configuration.

\CM CM_DCM_M_CONSISTENCY_BUFFERINFO
  Verify for each element in Dcm_CfgNetBufferInfo[] that the member 'Size' matches to the size of the array the
  member 'BufferPtr' is pointing to.

\CM CM_DCM_M_SIZEOF_BUFFERINFO
  Verify Dcm_PbCfgNetBufferInfo[] is defined for each id in range [0..Dcm_PbCfgNetNumBuffers[.

\CM CM_DCM_M_SIZEOF_COMMCONTEXT
  Verify Dcm_PbRamNetComMContext[] is defined for each id in range [0..Dcm_PbCfgNetNumComMChannels[.

\CM CM_DCM_M_SIZEOF_BUFFERCONTEXT
  Verify Dcm_PbRamNetBufferContext[] is defined for each id in range [0..Dcm_PbCfgNetNumBuffers[.

\CM CM_DCM_M_SIZEOF_TRANSPORTOBJECT
  Verify Dcm_PbRamNetTransportObject[] is defined for each id in range [0..Dcm_PbCfgNetNumTransportObjects[.

\CM CM_DCM_M_SIZEOF_COMCONTROLCHANNEL
  Verify Dcm_PbRamNetComCtrlChannels[] is defined for each id in range [0..Dcm_PbCfgNetNumComMChannels[.

\CM CM_DCM_M_SIZEOF_TOBJHANDLE
  Verify Dcm_PbRamNetConnHdl2TObjMap[] is defined for each id in range [0..Dcm_PbCfgNetNumConnections[.

\CM CM_DCM_M_SIZEOF_PERTXOBJ
  Verify Dcm_PbRamNetPeriodicTxObject[] is defined for each id in range [0..Dcm_PbCfgNetNumPerTxObjects[.

\CM CM_DCM_M_SIZEOF_SVCPOSTPROCESSORS
  Verify Dcm_CfgDiagSvcPostProcessors[] is defined for each id in range [0..DCM_CFGDIAGSVCPOSTPROCESSORS_SIZE[.

\CM CM_DCM_M_SIZEOF_SVCUPDATERS
  Verify Dcm_CfgDiagSvcUpdaters[] is defined for each id in range [0..DCM_CFGDIAGSVCUPDATERS_SIZE[.

\CM CM_DCM_M_SIZEOF_SVCCANCELLERS
  Verify Dcm_CfgDiagSvcCancellers[] is defined for each id in range [0..DCM_CFGDIAGSVCCANCELLERS_SIZE[.

\CM CM_DCM_M_SIZEOF_MODEMGRRULES
  Verify Dcm_CfgModeMgrRules[] is defined for each id in range [0..DCM_CFGMODEMGRRULES_SIZE[.

\CM CM_DCM_M_TERMINATED_LIST
  Verify that the last element of the given table is a NULL_PTR.

\CM CM_DCM_M_SIZEOF_SVC11SUBFUNC
  Verify Dcm_CfgSvc11SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC11SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC19SUBFUNC
  Verify Dcm_CfgSvc19SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC19SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_DIDMGROPFUNC
  Verify Dcm_CfgDidMgrSignalOpClassInfo[] is defined for each id in range [0..DCM_CFGDIDMGRSIGNALOPCLASSINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_IOCTRLSRHANDLERS
  Verify Dcm_CfgDidMgr_IOControlSenderReceiverHandlers[] is defined for each id in range
  [0..DCM_CFGDIDMGR_IOCONTROLSENDERRECEIVERHANDLERS_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC27SECLEVEL
  Verify Dcm_CfgSvc27SecLevelInfo[] is defined for each id in range [0..DCM_CFGSVC27SECLEVELINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC31OPFUNC
  Verify Dcm_CfgRidMgrOpInfo[] is defined for each id in range [0..DCM_CFGRIDMGROPINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC28SUBFUNC
  Verify Dcm_CfgSvc28SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC28SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC29SUBFUNC
  Verify Dcm_CfgSvc29SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC29SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC2CSUBFUNC
  Verify Dcm_CfgSvc2CSubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC2CSUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC85SUBFUNC
  Verify Dcm_CfgSvc85SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC85SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC86SUBFUNC
  Verify Dcm_CfgSvc86SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC86SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_ROEEVENTMODESWITCHINFO
  Verify Dcm_CfgModeRoEEventModeSwitchInfoTable[] is defined for each id in range [0..DCM_CFGMODEROEEVENTMODESWITCHINFOTABLE_SIZE[.

\CM CM_DCM_M_SIZEOF_CFGAUTHMGRNETCONNINFO
  Verify Dcm_CfgAuthMgrNetConnInfo[] is defined for each id in range [0..DCM_CFGAUTHMGRNETCONNINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SERVICEINFO
  Verify Dcm_CfgDiagServiceInfo[] is defined for each id in range [0..DCM_CFGDIAGSERVICEINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC01SERVICEINFO
  Verify Dcm_CfgSvc01ServiceInfoTable[] is defined for each id in range [0..DCM_CFGSVC01SERVICEINFOTABLE_SIZE[.

 \CM CM_DCM_M_SIZEOF_SVC06MIDTIDINFO
  Verify Dcm_CfgSvc06MidTidInfoTable[] is defined for each id in range [0..DCM_CFGSVC06MIDTIDINFOTABLE_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC08SERVICEINFO
  Verify Dcm_CfgSvc08ServiceInfoTable[] is defined for each id in range [0..DCM_CFGSVC08SERVICEINFOTABLE_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC09SERVICEINFO
  Verify Dcm_CfgSvc09ServiceInfoTable[] is defined for each id in range [0..DCM_CFGSVC09SERVICEINFOTABLE_SIZE[.

\CM CM_DCM_R_CHECK_REMAINING_BUFFER
  Before writing data to a buffer, check that the buffer is large enough for the data written to it.

\CM CM_DCM_R_GET_BUFFERINFO
  Dcm_NetGetBufferInfo() will always return a valid buffer info element even when the passed memory index is
  not a handle to a buffer info element.

\CM CM_DCM_R_GET_COMMCONTEXT
  Dcm_NetGetComMContext() will always return a valid ComM context element even when the passed memory index is
  not a handle to a ComM context element.

\CM CM_DCM_R_GET_BUFFERCONTEXT
  Dcm_NetGetBufferContext() will always return a valid buffer context element even when the passed memory index is
  not a handle to a buffer context element.

\CM CM_DCM_R_GET_TRANSPORTOBJECT
  Dcm_NetGetTransportObject() will always return a valid transport object even when the passed memory index is
  not a handle to a transport object.

\CM CM_DCM_R_GET_TIMERCONTEXT
  Dcm_TmrGetTimerContext() will always return a valid transport object even when the passed memory index is
  not a handle to a timer context.

\CM CM_DCM_R_INIT_CONTEXT
  Dcm_InitContext() will always return a valid context even when the passed memory index is
  not a handle to a context.

\CM CM_DCM_R_GET_BITSETROWINDEX
  Dcm_UtiBitSetGetRowIdxSafe() will return a index within the given bitset array, even when the passed bit position is
  not within the bitset.

\CM CM_DCM_R_BITSET_BASETYPE
  Verify that the base type passed to the bitset manipulation macro matches the base type of the respective bitset
  array.

\CM CM_DCM_R_GET_2ASCHEDULERENTRY
  Dcm_Svc2ASchdGetEntry() will return a valid entry of the 0x2A scheduler table, even when the passed memory index is
  not a handle to a scheduler table entry.

\CM CM_DCM_R_GET_2CSRCITEM
  Dcm_Svc2CGetSrcItem() will return a valid entry of the 0x2C source item table, even when the passed memory index is
  not a handle to a source item table entry.

\CM CM_DCM_R_GET_2CITEM
  Dcm_Svc2CGetItem() will return a valid entry of the 0x2C item table, even when the passed memory index is not a handle
  to an item table entry.

\CM CM_DCM_R_GET_2CPROCESSCONTEXT
  Dcm_Svc2CGetDDDidProcessContext() will return a valid process context of a DID, even when the passed memory index is
  not a handle to a process context.

\CM CM_DCM_R_GET_2FACTIVEIODIDS
  Dcm_Svc2FGetActiveIoDids() will return a valid bitmask of active IODIDs, even when the passed memory index is not a
  handle to a bitmask of active IODIDs.

\CM CM_DCM_R_GET_86DIDRECORD
  Dcm_Svc86GetDidRecord() will return a valid entry of the DID record table, even when the passed memory index is
  not a handle to a DID record table entry.

\CM CM_DCM_R_GET_VSGACTIVECFGVARIANTS
  Verify that the array index is in range before writing to Dcm_SingletonContext.VarMgr.ActiveCfgVariants[].

\CM CM_DCM_R_GET_PERIODICTXBUFFER
  Dcm_NetPeriodicMsgGetTxBuffer() will return a valid tx buffer of a periodic message, even when the passed memory index
  is not a handle to a periodic tx object.

\CM CM_DCM_R_GET_RXPDUINFO
  Verify that the local pointer initialized as a NULL_PTR is set after calling Dcm_NetProvideRxBuffer().

\CM CM_DCM_R_GET_THREADCONTEXT
  Dcm_GetThreadContext() will always return a valid thread info pointer even when the passed memory index is
  not a handle to a thread info.

\CM CM_DCM_R_GET_TIMERINFO
  Dcm_TmrGetTimerInfo() will always return a valid timer info even when the passed memory index is
  not a handle to a timer info.

\CM CM_DCM_R_GET_SVCPOSTPROCESSORS
  Dcm_DiagGetPostProcessorFunc() will always return a valid function pointer even when the passed memory index is
  not a handle to a post-processor function.

\CM CM_DCM_R_GET_SVCUPDATERS
  Dcm_DiagGetUpdateFunc() will always return a valid function pointer even when the passed memory index is
  not a handle to an update function.

\CM CM_DCM_R_GET_SVCCANCELLERS
  Dcm_DiagGetCancelFunc() will always return a valid function pointer even when the passed memory index is
  not a handle to a cancellation function.

\CM CM_DCM_R_TERMINATED_LIST
  Verify that iteration over all elements of a given table is only done until NULL_PTR element.

\CM CM_DCM_R_LOOP
  The for loop or while loop with constrains ensures that the index never exceeds the size of the given table.

\CM CM_DCM_R_SET_TOBJ_ADDBUFFER
  Verify that the array index is in range before writing to AddBfufer[] of a specific transport object.

\CM CM_DCM_R_SET_COMCONTROLCHANNEL
  Verify that the array index is in range before writing to Dcm_PbRamNetComCtrlChannels[].

\CM CM_DCM_R_SET_AUTHNVMDATA
  Verify that the array index is in range before writing to Dcm_AuthMgrNvMData[].

\CM CM_DCM_R_SET_PENDINGROLEDATA
  Verify that the array index is in range before writing to Dcm_SingletonContext.AuthMgr.PendingData.Role[].

\CM CM_DCM_R_SET_WLSERVICEELEMENT
  Verify that the array index is in range before writing to pWLServiceContext->WLServiceElement[].

\CM CM_DCM_R_SET_WLDIDELEMENT
  Verify that the array index is in range before writing to pWLDidContext->WLDidElement[].

\CM CM_DCM_R_SET_WLRIDELEMENT
  Verify that the array index is in range before writing to pWLRidContext->WLRidElement[].

\CM CM_DCM_R_SET_WLMEMELEMENT
  Verify that the array index is in range before writing to pWLMemContext->WLMemElement[].

\CM CM_DCM_R_SET_TOBJHANDLE
  Verify that the array index is in range before writing to Dcm_PbRamNetConnHdl2TObjMap[].

\CM CM_DCM_R_SET_TIMER
  Verify that the array index is in range before writing to Dcm_SingletonContext.TimerMgr.Timer[].

\CM CM_DCM_R_SET_START_UP_FBL_RES_BUFFER
  Verify that the array index is in range before writing to Dcm_SingletonContext.Diag.StartUpFbl.ResBuffer[].

\CM CM_DCM_R_SET_CURRENT_TASK_PRIO_STACK
  Verify that the array index is in range before writing to CurrentTaskPrioStack.Stack[].

\CM CM_DCM_R_SET_ATTEMPTCOUNT
  Verify that the array index is in range before writing to Dcm_SingletonContext.Diag.Services.Svc27.AttemptCount[].

\CM CM_DCM_R_SET_DELAYTIME_SEC
  Verify that the array index is in range before writing to Dcm_SingletonContext.Diag.Services.Svc27.DelayTime[].

\CM CM_DCM_R_SET_DELAYTIME_AUTH
  Verify that the array index is in range before writing to Dcm_SingletonContext.AuthMgr.DelayTime[].

\CM CM_DCM_R_SET_DIDLOCKLIST
  Verify that the array index is in range before writing to Dcm_SingletonContext.DidMgr.DidLockList[].

\CM CM_DCM_R_SET_PERTXOBJ
  Verify that the array index is in range before writing to Dcm_PbRamNetPeriodicTxObject[].

\CM CM_DCM_R_SET_DELAYTIMER
  Verify that the array index is in range before writing to Dcm_SingletonContext.Network.PeriodicTxContext.DelayTimer[].

\CM CM_DCM_R_SET_DATA_CONTEXT_BUFFER
  Verify that the array index is in range [0..pDataContext->Size[ before writing to pDataContext->Buffer.

\CM CM_DCM_R_SET_MESSAGE_CONTEXT_RESBUFFER
  Verify that the array index is in range [0..pMsgContext->resBufSize[ before writing to pMsgContext->resData.

\CM CM_DCM_R_WRITE_IO_CTRL_CEMR_SESSION_MASK
  Verify that the write access to the bitmask Dcm_DidMgrIoControlCemrSessionMask does not exceed its
  size (DCM_DIDMGR_IODID_MAX_EXT_CEMR_SIZE).

\CM CM_DCM_R_SET_MESSAGE_CONTEXT_REQBUFFER
  Verify that the array index is in range [0..pMsgContext->reqBufSize[ before writing to pMsgContext->reqData.

\CM CM_DCM_R_SET_DATA_CONTEXT_USAGE
  Verify that the sum of pDataContext->Usage and pDataContext->AvailLen is always equal to or smaller as
  pDataContext->Size.

\CM CM_DCM_R_MEMCPY_PASS_BUFFER
  Verify that the passed pair of buffer pointer and buffer size matches to referenced memory entry and memory size.

\CM CM_DCM_R_MEMCPY_WRITE
  Verify that the array index is in range between 0 and the passed buffer size before writing to the passed
  buffer pointer.

\CM CM_DCM_R_GET_DIDINFOCONTEXT
  Dcm_Svc22GetDidInfoContext() will always return a valid Did info context even when the passed memory index is
  not a handle to a Did info context.

\CM CM_DCM_R_GET_CFGAUTHMGRNETCONNINFO
  Verify that the array index is in range before getting the mode switch function from Dcm_CfgAuthMgrNetConnInfo[].

\CM CM_DCM_R_GET_ROEEVENTMODESWITCHINFO
  Verify that the array index is in range before getting the mode switch function from Dcm_CfgModeRoEEventModeSwitchInfoTable[].

\CM CM_DCM_R_GET_RECOVERYINFOCOMMCHANNELSTATE
  Dcm_DiagGetRecoveryInfoComMChannelState() will return a valid ComM channel state of the recovery info, even when the
  passed memory index is not a handle to a ComM channel state of the recovery info.

\CM CM_DCM_R_GET_RECOVERYINFOCOMMCONTROLSTATE
  Dcm_DiagGetRecoveryInfoCommControlState() will return a valid communication state of a ComM channel of the recovery
  info, even when the passed memory index is not a handle to a communication state of a ComM channel of the recovery
  info.

\CM CM_DCM_R_CONVERTTOARRAY_PASS_BUFFER
  Verify that the passed pair of buffer pointer and buffer size matches to referenced memory entry and memory size.

\CM CM_DCM_R_CONVERTTOARRAY_WRITE
  Verify that the array index is in range between 0 and the passed buffer size before writing to the passed
  buffer pointer.

\CM CM_DCM_R_GET_VALID_POINTER
  The pointer concerned is initialized with a getter-function by memory index.
  The caller must explicitly verify that the initialization was successful before forwarding or writing to the pointer,
  unless when it can be guaranteed that the passed memory index is valid.

*/
/**********************************************************************************************************************
 *  END OF FILE: Dcm.c
 *********************************************************************************************************************/
