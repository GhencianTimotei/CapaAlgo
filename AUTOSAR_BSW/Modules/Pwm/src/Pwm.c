/**
*   @file           Pwm.c
*   @version        1.0.1
*
*   @brief          AUTOSAR Pwm - Pwm high level interface implementation.
*   @details        Pwm high level interface implementation.
*
*   @addtogroup     PWM_MODULE
*   @{
*/
/*==================================================================================================
*   Project              : AUTOSAR 4.3 MCAL
*   Platform             : ARM
*   Peripheral           : Ftm
*   Dependencies         : none
*
*   Autosar Version      : 4.3.1
*   Autosar Revision     : ASR_REL_4_3_REV_0001
*   Autosar Conf.Variant :
*   SW Version           : 1.0.1
*   Build Version        : S32K14x_MCAL_1_0_1_RTM_ASR_REL_4_3_REV_0001_20190621
*
*   (c) Copyright 2006-2016 Freescale Semiconductor, Inc. 
*       Copyright 2017-2019 NXP
*   All Rights Reserved.
==================================================================================================*/
/*==================================================================================================
==================================================================================================*/

#ifdef __cplusplus
extern "C"{
#endif

/**
* @page misra_violations MISRA-C:2004 violations
*
* @section Pwm_C_REF_1
* Violates MISRA 2004 Advisory Rule 19.1, only preprocessor statements and comments
* before '#include'
* MemMap.h included after each section define in order to set the current memory section
*
* @section Pwm_C_REF_2
* Violates MISRA 2004 Required Rule 8.10, external ... could be made static
* The respective code could not be made static because of layers architecture design of the driver.
*
* @section Pwm_C_REF_3
* Violates MISRA 2004 Required Rule 1.4, The compiler/linker shall be checked to ensure 31 character
* significance and case sensitivity are supported for external identifiers.
* This is not a violation since all the compilers used interpret the identifiers correctly.
*
* @section Pwm_C_REF_4
* Violates MISRA 2004 Required Rule 19.15, Precautions shall be taken in order to prevent the
* contents of a header file being included twice
* This is not a violation since all header files are protected against multiple inclusions
*
* @section Pwm_C_REF_5
* Violates MISRA 2004 Required Rule 14.2, All non-null statements shall either: 
* a) have at least one side efect however executed, or
* b) cause control flow to change.
* The function might be empty for certain driver environments
*
* @section Pwm_C_REF_6
* Violates MISRA 2004 Required Rule 5.1, Identifiers (internal and external) shall not 
* rely on the significance of more than 31 characters.
* This is not a violation since all the compilers used interpret the identifiers correctly.
*
* @section Pwm_C_REF_7
* Violates MISRA 2004 Required Rule 8.7, Objects shall be defined at block scope if they
* are accessed from within a sigle function.
* These symbols are used in the entire driver.
*
* @section Pwm_C_REF_8
* Violates MISRA 2004 Required Rule 13.7, Boolean operations whose results are invariant shall
* not be permited
* The results are generated by macros used for only with eMIOS hardware, all other hardware do not 
* need these checks so the results should always be the same.
*
* @section Pwm_C_REF_9
* Violates MISRA 2004 Required Rule 16.10, Ignore value is ignored as return value is 
* always the same and the value itself is not needed.
*
* @section Pwm_C_REF_10
* Violates MISRA 2004 Required Rule 14.1, There shall be no unreachable code 
*
*/


/*===============================================================================================
*                                         INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
===============================================================================================*/
/*
* @file           Pwm.c
*/
#include "Pwm.h"
#include "Pwm_Ipw.h"
#include "Pwm_Notif.h"

#if (PWM_DEV_ERROR_DETECT == STD_ON)
    #include "Det.h"
#endif


/*===============================================================================================
*                                        SOURCE FILE VERSION INFORMATION
===============================================================================================*/
/**
* @{
* @file           Pwm.c
*/
#define PWM_VENDOR_ID_C                         43
#define PWM_AR_RELEASE_MAJOR_VERSION_C          4
#define PWM_AR_RELEASE_MINOR_VERSION_C          3
/*
* @violates @ref Pwm_C_REF_3 Identifier clash.
*/
/* @violates @ref Pwm_C_REF_6 Identifier exceeds 31 chars. */
#define PWM_AR_RELEASE_REVISION_VERSION_C       1
#define PWM_SW_MAJOR_VERSION_C                  1
#define PWM_SW_MINOR_VERSION_C                  0
#define PWM_SW_PATCH_VERSION_C                  1
/**@}*/

/*===============================================================================================
*                                      FILE VERSION CHECKS
===============================================================================================*/
#ifndef DISABLE_MCAL_INTERMODULE_ASR_CHECK
#if (PWM_DEV_ERROR_DETECT == STD_ON)
    /* Check if source file and DET header file are of the same version */
    #if ((PWM_AR_RELEASE_MAJOR_VERSION_C != DET_AR_RELEASE_MAJOR_VERSION) || \
         (PWM_AR_RELEASE_MINOR_VERSION_C != DET_AR_RELEASE_MINOR_VERSION))
        #error "AutoSar Version Numbers of Pwm.c and Det.h are different"
    #endif
#endif

#endif /* DISABLE_MCAL_INTERMODULE_ASR_CHECK */

/* Check if source file and PWM header file are of the same vendor */
#if (PWM_VENDOR_ID_C != PWM_VENDOR_ID)
    #error "Pwm.c and Pwm.h have different vendor ids"
#endif
/* Check if source file and PWM header file are of the same Autosar version */
#if ((PWM_AR_RELEASE_MAJOR_VERSION_C    != PWM_AR_RELEASE_MAJOR_VERSION) || \
     (PWM_AR_RELEASE_MINOR_VERSION_C    != PWM_AR_RELEASE_MINOR_VERSION) || \
     (PWM_AR_RELEASE_REVISION_VERSION_C != PWM_AR_RELEASE_REVISION_VERSION))
    #error "AutoSar Version Numbers of Pwm.c and Pwm.h are different"
#endif
/* Check if source file and PWM header file are of the same Software version */
#if ((PWM_SW_MAJOR_VERSION_C != PWM_SW_MAJOR_VERSION)  || \
     (PWM_SW_MINOR_VERSION_C != PWM_SW_MINOR_VERSION)  || \
     (PWM_SW_PATCH_VERSION_C != PWM_SW_PATCH_VERSION))
    #error "Software Version Numbers of Pwm.c and Pwm.h are different"
#endif

/* Check if source file and Pwm_Ipw.h file are of the same vendor */
#if (PWM_VENDOR_ID_C != PWM_IPW_VENDOR_ID)
    #error "Pwm.c and Pwm_Ipw.h have different vendor ids"
#endif
/* Check if source file and Pwm_Ipw.h file are of the same Autosar version */
#if ((PWM_AR_RELEASE_MAJOR_VERSION_C    != PWM_IPW_AR_RELEASE_MAJOR_VERSION) || \
     (PWM_AR_RELEASE_MINOR_VERSION_C    != PWM_IPW_AR_RELEASE_MINOR_VERSION) || \
     (PWM_AR_RELEASE_REVISION_VERSION_C != PWM_IPW_AR_RELEASE_REVISION_VERSION))
    #error "AutoSar Version Numbers of Pwm.c and Pwm_Ipw.h are different"
#endif
/* Check if source file and Pwm_Ipw.h file are of the same Software version */
#if ((PWM_SW_MAJOR_VERSION_C != PWM_IPW_SW_MAJOR_VERSION) || \
     (PWM_SW_MINOR_VERSION_C != PWM_IPW_SW_MINOR_VERSION) || \
     (PWM_SW_PATCH_VERSION_C != PWM_IPW_SW_PATCH_VERSION))
    #error "Software Version Numbers of Pwm.c and Pwm_Ipw.h are different"
#endif

/* Check if source file and Pwm_Notif.h file are of the same vendor */
#if (PWM_VENDOR_ID_C != PWM_NOTIF_VENDOR_ID)
    #error "Pwm.c and Pwm_Notif.h have different vendor ids"
#endif
/* Check if source file and Pwm_Notif.h file are of the same Autosar version */
#if ((PWM_AR_RELEASE_MAJOR_VERSION_C    != PWM_NOTIF_AR_RELEASE_MAJOR_VERSION) || \
     (PWM_AR_RELEASE_MINOR_VERSION_C    != PWM_NOTIF_AR_RELEASE_MINOR_VERSION) || \
     (PWM_AR_RELEASE_REVISION_VERSION_C != PWM_NOTIF_AR_RELEASE_REVISION_VERSION))
    #error "AutoSar Version Numbers of Pwm.c and Pwm_Notif.h are different"
#endif
/* Check if source file and Pwm_Notif.h file are of the same Software version */
#if ((PWM_SW_MAJOR_VERSION_C != PWM_NOTIF_SW_MAJOR_VERSION) || \
     (PWM_SW_MINOR_VERSION_C != PWM_NOTIF_SW_MINOR_VERSION) || \
     (PWM_SW_PATCH_VERSION_C != PWM_NOTIF_SW_PATCH_VERSION))
    #error "Software Version Numbers of Pwm.c and Pwm_Notif.h are different"
#endif

/*===============================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
===============================================================================================*/
/**
@brief Enum containing the possible states of the Pwm driver
*/
typedef enum
{
    PWM_STATE_UNINIT = 0x00,
    PWM_STATE_IDLE
} Pwm_GlobalStateType;


/*===============================================================================================
*                                       LOCAL CONSTANTS
===============================================================================================*/

/*===============================================================================================
*                                       LOCAL VARIABLES
===============================================================================================*/
/* @violates @ref Pwm_C_REF_6 Identifier exceeds 31 chars. */
#define PWM_START_SEC_VAR_INIT_UNSPECIFIED
/*
* @violates @ref Pwm_C_REF_1 Only preprocessor statements and comments before "#include"
*/
/*
* @violates @ref Pwm_C_REF_4 precautions to prevent the contents
*        of a header file being included twice
*/
#include "Pwm_MemMap.h"
/**
@brief Pointer to the top level configuration structure - valid only when the driver is in the
       initialized state
*/
/* @violates @ref Pwm_C_REF_7 It is accessed from multiple functions. */
static P2CONST(Pwm_ConfigType, PWM_VAR, PWM_APPL_CONST) Pwm_pConfig = NULL_PTR;

#if ((PWM_VALIDATE_GLOBAL_CONFIG_CALL  == STD_ON) || \
     (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON))
/**
@brief Variable storing the current state of the Pwm driver
*/
static VAR(Pwm_GlobalStateType, PWM_VAR) Pwm_eGlobalState = PWM_STATE_UNINIT;
#endif

/* @violates @ref Pwm_C_REF_6 Identifier exceeds 31 chars. */
#define PWM_STOP_SEC_VAR_INIT_UNSPECIFIED
/*
* @violates @ref Pwm_C_REF_1 Only preprocessor statements and comments before "#include"
*/
/*
* @violates @ref Pwm_C_REF_4 precautions to prevent the contents
*        of a header file being included twice
*/
#include "Pwm_MemMap.h"


#if (PWM_POWER_STATE_SUPPORTED == STD_ON)
/* @violates @ref Pwm_C_REF_6 Identifier exceeds 31 chars. */
#define PWM_START_SEC_VAR_NO_INIT_UNSPECIFIED
/*
* @violates @ref Pwm_C_REF_1 Only preprocessor statements and comments before "#include"
*/
/*
* @violates @ref Pwm_C_REF_4 precautions to prevent the contents
*        of a header file being included twice
*/
#include "Pwm_MemMap.h"

/**
@brief Variable storing the current power state of the Pwm driver
*/
static VAR(Pwm_PowerStateType, PWM_VAR) Pwm_eCurrentPowerState;

/**
@brief Variable storing the target power state of the Pwm driver
*/
static VAR(Pwm_PowerStateType, PWM_VAR) Pwm_eTargetPowerState;

/* @violates @ref Pwm_C_REF_6 Identifier exceeds 31 chars. */
#define PWM_STOP_SEC_VAR_NO_INIT_UNSPECIFIED
/*
* @violates @ref Pwm_C_REF_1 Only preprocessor statements and comments before "#include"
*/
/*
* @violates @ref Pwm_C_REF_4 precautions to prevent the contents
*        of a header file being included twice
*/
#include "Pwm_MemMap.h"

#endif


/*===============================================================================================
*                                       GLOBAL CONSTANTS
===============================================================================================*/
#if ( PWM_PRECOMPILE_SUPPORT == STD_ON)

/* @violates @ref Pwm_C_REF_6 Identifier exceeds 31 chars. */
#define PWM_START_SEC_CONFIG_DATA_UNSPECIFIED
/*
* @violates @ref Pwm_C_REF_4 precautions to prevent the contents
*        of a header file being included twice
*/
/*
* @violates @ref Pwm_C_REF_1 Only preprocessor statements and comments before "#include"
*/
#include "Pwm_MemMap.h"

/* @violates @ref Pwm_C_REF_7 External declaration required. */
extern CONST(Pwm_ConfigType, PWM_CONST) Pwm_PBCfgVariantPredefined;

/* @violates @ref Pwm_C_REF_6 Identifier exceeds 31 chars. */
#define PWM_STOP_SEC_CONFIG_DATA_UNSPECIFIED
/*
* @violates @ref Pwm_C_REF_4 precautions to prevent the contents
*        of a header file being included twice
*/
/*
* @violates @ref Pwm_C_REF_1 Only preprocessor statements and comments before "#include"
*/
#include "Pwm_MemMap.h"

#endif /*PWM_PRECOMPILE_SUPPORT*/
/*===============================================================================================
*                                       GLOBAL VARIABLES
===============================================================================================*/

/*===============================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
===============================================================================================*/
#define PWM_START_SEC_CODE
/*
* @violates @ref Pwm_C_REF_1 Only preprocessor statements and comments before "#include"
*/
/*
* @violates @ref Pwm_C_REF_4 precautions to prevent the contents
*        of a header file being included twice
*/
#include "Pwm_MemMap.h"

#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    
static FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateGlobalConfigCall
(
    VAR(uint8, AUTOMATIC) u8ServiceId
);

LOCAL_INLINE  FUNC(void, PWM_CODE) Pwm_EndValidateGlobalConfigCall
(
    VAR(Std_ReturnType, AUTOMATIC) ValidCall,
    VAR(uint8,          AUTOMATIC) u8ServiceId
);
    
#endif /* (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON) */

#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)

#if ((PWM_SET_DUTY_CYCLE_API      == STD_ON)  || \
    (PWM_SET_PERIOD_AND_DUTY_API == STD_ON)  || \
    (PWM_SET_OUTPUT_TO_IDLE_API  == STD_ON)  || \
    (PWM_GET_OUTPUT_STATE_API  == STD_ON)  ||   \
    (PWM_GET_CHANNEL_STATE_API == STD_ON)  || \
    (PWM_FORCE_OUTPUT_TO_ZERO_API  == STD_ON)  || \
    (PWM_NOTIFICATION_SUPPORTED  == STD_ON) || \
    (PWM_SET_COUNTER_BUS_API        == STD_ON)  || \
    (PWM_SET_CHANNEL_OUTPUT_API     == STD_ON)  || \
    (PWM_SET_TRIGGER_DELAY_API      == STD_ON) || \
    (PWM_SET_PERIOD_AND_DUTY_NO_UPDATE_API == STD_ON) || \
    (PWM_SET_DUTY_CYCLE_NO_UPDATE_API == STD_ON) || \
    (PWM_SET_PHASE_SHIFT_NO_UPDATE_API == STD_ON) || \
    (PWM_SET_PHASE_SHIFT_API == STD_ON))

static  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateChannelConfigCall
(
    VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber,
    VAR(uint8,           AUTOMATIC) u8ServiceId
);

LOCAL_INLINE  FUNC(void, PWM_CODE) Pwm_EndValidateChannelConfigCall
/* @violates @ref Pwm_C_REF_6 Identifier exceeds 31 chars. */
(
    VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber
);
#endif /* PWM_SET_DUTY_CYCLE_API || PWM_SET_PERIOD_AND_DUTY_API || ... */

#endif /* (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON) */


#if (PWM_PARAM_CHECK == STD_ON)
#if (PWM_PRECOMPILE_SUPPORT == STD_OFF)
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateParamPtrInit
(
    P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigPtr
);
#endif

#if ((PWM_SET_DUTY_CYCLE_API == STD_ON) || (PWM_SET_DUTY_CYCLE_NO_UPDATE_API == STD_ON))
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateParamDuty
(
    VAR(uint16, AUTOMATIC) u16DutyCycle,
    VAR(uint8, AUTOMATIC)  u8ServiceId
);
#endif

#if ((PWM_SET_DUTY_CYCLE_API == STD_ON) && (PWM_OFFSET_PLAUSABILITY == STD_ON))  
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateParamOffsetDuty
(
    VAR(Pwm_ChannelType,            AUTOMATIC)                  ChannelNumber,
    VAR(uint16,                     AUTOMATIC)                  u16DutyCycle,
    CONSTP2CONST(Pwm_IpConfigType,  AUTOMATIC, PWM_APPL_CONST)  pIpConfig
);
#endif /* (PWM_SET_DUTY_CYCLE_API == STD_ON) */

#if ((PWM_SET_PERIOD_AND_DUTY_API == STD_ON) || (PWM_SET_PERIOD_AND_DUTY_NO_UPDATE_API == STD_ON))
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateParamsPeriodDuty
(
    VAR(Pwm_ChannelType,      AUTOMATIC) ChannelNumber,
    VAR(Pwm_ChannelClassType, AUTOMATIC) eChannelClass,
    VAR(Pwm_PeriodType,       AUTOMATIC) Period,
    VAR(uint16,               AUTOMATIC) u16DutyCycle,
    VAR(uint8,                AUTOMATIC) u8ServiceId
);
#endif /* (PWM_SET_PERIOD_AND_DUTY_API == STD_ON) || (PWM_SET_PERIOD_AND_DUTY_NO_UPDATE_API == STD_ON) */

#if (PWM_NOTIFICATION_SUPPORTED == STD_ON)
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateParamNotification
(
    VAR(Pwm_ChannelType,          AUTOMATIC) ChannelNumber,
    VAR(Pwm_EdgeNotificationType, AUTOMATIC) Notification
);
#endif /* (PWM_NOTIFICATION_SUPPORTED == STD_ON) */

#ifdef PWM_SET_TRIGGER_DELAY_API
#if (PWM_SET_TRIGGER_DELAY_API == STD_ON)
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateParamTrigger
(
    VAR(Pwm_ChannelType,      AUTOMATIC) ChannelNumber,
    VAR(Pwm_PeriodType,       AUTOMATIC) nTriggerDelay
);
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateTriggerMode
(
    VAR(Pwm_ChannelType,      AUTOMATIC) ChannelNumber
);
#endif /* (PWM_SET_TRIGGER_DELAY_API == STD_ON) */
#endif /* (PWM_SET_TRIGGER_DELAY_API == STD_ON) */

#if (   (PWM_BUFFER_TRANSFER_EN_DIS_API == STD_ON) || \
        (PWM_SYNC_UPDATE_API == STD_ON) || \
        (PWM_ENABLE_TRIGEER_API == STD_ON) || \
        (PWM_DISABLE_TRIGEER_API == STD_ON) || \
        (PWM_RESET_COUNTER_API == STD_ON) || \
        (PWM_ENABLE_MASKING_OPERATIONS == STD_ON) ||\
        (PWM_RELOAD_NOTIF_SUPPORTED == STD_ON)\
    )
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateModuleId
(
    VAR(uint8,               AUTOMATIC) u8ModuleId,
    VAR(uint8,               AUTOMATIC) u8ServiceId
);
#endif /* (PWM_BUFFER_TRANSFER_EN_DIS_API == STD_ON) */


#ifdef PWM_SET_COUNTER_BUS_API
#if (PWM_SET_COUNTER_BUS_API == STD_ON)
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateCounterBus
(
    VAR(uint32,               AUTOMATIC) u32Bus
);
#endif /* (PWM_SET_COUNTER_BUS_API == STD_ON) */
#endif /* (PWM_SET_COUNTER_BUS_API == STD_ON) */

#if (PWM_SET_CHANNEL_OUTPUT_API == STD_ON)
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateOutputState
(
    VAR(Pwm_ChannelType,      AUTOMATIC) ChannelNumber,
    VAR(Pwm_StateType,        AUTOMATIC) nState
);
#endif /* (PWM_SET_CHANNEL_OUTPUT_API == STD_ON) */

#if (PWM_OFFSET_PLAUSABILITY == STD_ON)
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateParamsOffset
(
    P2CONST(Pwm_IpConfigType, AUTOMATIC, PWM_APPL_CONST) pIpConfig
);
#endif
#if ((PWM_SET_PHASE_SHIFT_API == STD_ON) || (PWM_SET_PHASE_SHIFT_NO_UPDATE_API == STD_ON))
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateParamsPhaseShift
(
    VAR(uint16,                                     AUTOMATIC) u16PhaseShift,
    VAR(uint8,                                      AUTOMATIC) u8ServiceId
);
#endif
#if ((PWM_DISABLE_TRIGEER_API == STD_ON) || (PWM_ENABLE_TRIGEER_API == STD_ON))
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateBitMask
(
    VAR(uint32,                                     AUTOMATIC) u32TriggerMask,
    VAR(uint8,                                      AUTOMATIC) u8ServiceId
);
#endif
#if (PWM_SET_OUTPUT_TO_IDLE_API == STD_ON)
LOCAL_INLINE FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateSetOutPutToIdle
(
    VAR(Pwm_ChannelType,          AUTOMATIC) ChannelNumber
);
#endif /* PWM_SET_OUTPUT_TO_IDLE_API */

#endif /* (PWM_PARAM_CHECK == STD_ON) */

#if (PWM_POWER_STATE_SUPPORTED == STD_ON)
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateIdleState
(
    P2CONST(Pwm_IpConfigType, AUTOMATIC, PWM_APPL_CONST) pIpConfig
);
#endif

/*===============================================================================================
*                                       LOCAL FUNCTIONS
===============================================================================================*/
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)

/**
* @brief          Validate the call of a function impacting the configuration of the entire driver.
* @details        Before executing, a function which changes the configuration of the entire driver
*                 shall check if:
*                 1. It is not preempting itself
*                 2. It is not preempting another function that changes the configuration of the 
*                    entire driver
*                 3. It is not preempting a function that changes the configuration of one of the
*                    driver's channels
*                 In any of the above cases, the function will report an error to Det or Serr,
*                 depending on the environment the driver is run in.
*
*
* @param[in]      u8ServiceId       Id of the service calling this function
*
* @return         Std_ReturnType  Call is valid or not  
* @retval         E_OK            Caller of the function can continue its execution
* @retval         E_NOT_OK        Caller of the function should drop execution
*
*
* @note           .
*/
static FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateGlobalConfigCall
(
    VAR(uint8, AUTOMATIC) u8ServiceId
)
{
    /* Variable to store the value returned by the function */ 
    VAR(Std_ReturnType, AUTOMATIC) retVal = (Std_ReturnType)E_OK;

    if (PWM_STATE_UNINIT == Pwm_eGlobalState)
    {
        if (PWM_INIT_ID != u8ServiceId)
        {
            Det_ReportError
            (
                (uint16) PWM_MODULE_ID,
                (uint8)  PWM_INDEX,
                (uint8)  u8ServiceId,
                (uint8)  PWM_E_UNINIT
          /*
                 * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
                 *  the same and the value itself is not needed
                 */
            );
            retVal = (Std_ReturnType)E_NOT_OK;
        }
    }
    else
    {
        if (PWM_INIT_ID == u8ServiceId)
        {
            Det_ReportError
            (
                (uint16) PWM_MODULE_ID,
                (uint8)  PWM_INDEX,
                (uint8)  u8ServiceId,
                (uint8)  PWM_E_ALREADY_INITIALIZED
          /*
                 * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
                 *  the same and the value itself is not needed
                 */
            );
            retVal = (Std_ReturnType)E_NOT_OK;
        }
    }
    return retVal;
}


/**
* @brief          Completes the execution of a function impacting the configuration of the entire driver.
* @details        Performs actions in order to ensure that after it's caller has completed the execution
*                 the driver will remain in a state allowing execution of other functions updating the 
*                 configuration of the entire driver or of a single channel
*
* @param[in]   u8ServiceId  The service id of the caller function
* @param[in]   ValidCall  The function call was previously validated
* @return void
*
*
* @note           .
*/
LOCAL_INLINE  FUNC(void, PWM_CODE) Pwm_EndValidateGlobalConfigCall
(
    VAR(Std_ReturnType, AUTOMATIC) ValidCall,
    VAR(uint8,          AUTOMATIC) u8ServiceId
)
{
    /* Change the state of the driver only if the previous call to Pwm_ValidateGlobalConfigCall() 
    stated that the API call is valid, */
    if ((Std_ReturnType)E_OK == ValidCall)
    {
        if (PWM_DEINIT_ID == u8ServiceId)
        {
            Pwm_eGlobalState = PWM_STATE_UNINIT;
        }
        else
        {
            Pwm_eGlobalState = PWM_STATE_IDLE;
        }
    }
}
#endif /* (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON) */


#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)

#if ((PWM_SET_DUTY_CYCLE_API      == STD_ON)  || \
    (PWM_SET_PERIOD_AND_DUTY_API == STD_ON)  || \
    (PWM_SET_OUTPUT_TO_IDLE_API  == STD_ON)  || \
    (PWM_GET_OUTPUT_STATE_API  == STD_ON)  ||   \
    (PWM_GET_CHANNEL_STATE_API == STD_ON)  || \
    (PWM_FORCE_OUTPUT_TO_ZERO_API  == STD_ON)  || \
    (PWM_NOTIFICATION_SUPPORTED  == STD_ON) || \
    (PWM_SET_COUNTER_BUS_API        == STD_ON)  || \
    (PWM_SET_CHANNEL_OUTPUT_API     == STD_ON)  || \
    (PWM_SET_TRIGGER_DELAY_API      == STD_ON) || \
    (PWM_SET_PERIOD_AND_DUTY_NO_UPDATE_API == STD_ON) || \
    (PWM_SET_DUTY_CYCLE_NO_UPDATE_API == STD_ON) || \
    (PWM_SET_PHASE_SHIFT_NO_UPDATE_API == STD_ON) || \
    (PWM_SET_PHASE_SHIFT_API == STD_ON))

    
/**
* @brief          Validate the call of a function impacting the configuration of one of the driver's
* @details        channels. Before executing, a function which changes the configuration of a 
*                 channel shall check if:
*                 1. It is not preempting itself
*                 2. It is not preempting a function that changes the configuration of the 
*                    entire driver
*                 In any of the above cases, the function will report an error to Det or Serr,
*                 depending on the environment the driver is run in.
*
*
* @param[in]      ChannelId       Id of the channel the caller tries to update
* @param[in]      u8ServiceId       Id of the service calling this function
*
* @return         Std_ReturnType  Call is valid or not  
* @retval         E_OK            Caller of the function can continue its execution
* @retval         E_NOT_OK        Caller of the function should drop execution
*
*
* @note           .
*/
static FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateChannelConfigCall
(
    VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber,
    VAR(uint8,           AUTOMATIC) u8ServiceId
)
{
    /* Variable to store the value returned by the function */ 
    VAR(Std_ReturnType, AUTOMATIC) retVal = (Std_ReturnType)E_OK;

    /* Check if the driver is initialized */
    if (PWM_STATE_UNINIT == Pwm_eGlobalState)
    {
        retVal = (Std_ReturnType)E_NOT_OK;
        
        /* Driver not initialized yet */
        Det_ReportError
        (
            (uint16) PWM_MODULE_ID,
            (uint8)  PWM_INDEX,
            (uint8)  u8ServiceId,
            (uint8)  PWM_E_UNINIT
      /*
             * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
             *  the same and the value itself is not needed
             */
        );
    }
    else
    {
        /* Check that the channel is in valid range */
        if (ChannelNumber >= Pwm_pConfig->nNumChannels)
        {
            retVal = (Std_ReturnType)E_NOT_OK;

            Det_ReportError
            (
                (uint16) PWM_MODULE_ID,
                (uint8)  PWM_INDEX,
                (uint8)  u8ServiceId,
                (uint8)  PWM_E_PARAM_CHANNEL
          /*
                 * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
                 *  the same and the value itself is not needed
                 */
            );
        }
        else
        {
#if ((PWM_SET_PHASE_SHIFT_API == STD_ON) || (PWM_SET_PHASE_SHIFT_NO_UPDATE_API == STD_ON))
            if(( PWM_SETPHASESHIFT_ID == u8ServiceId) || (PWM_SETPHASESHIFTNOUPDATE_ID == u8ServiceId))
            {
        
                /* @violates @ref Pwm_C_REF_8 booleand operations should not have invariant results */
                if((Std_ReturnType)E_OK != Pwm_Ipw_ValidateChannelSetPhaseShift(ChannelNumber, &Pwm_pConfig->IpConfig))
                {
                    retVal = (Std_ReturnType)E_NOT_OK;
                    
                    Det_ReportError
                    (
                        (uint16) PWM_MODULE_ID,
                        (uint8)  PWM_INDEX,
                        (uint8)  u8ServiceId,
                        (uint8)  PWM_E_CHANNEL_PHASE_SHIFT_WITHOUT_COMBINE
                        /*
                        * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
                        *  the same and the value itself is not needed
                        */
                    );
                }
            }
            
#endif
    
#if ((PWM_SET_PERIOD_AND_DUTY_NO_UPDATE_API == STD_ON) || (PWM_SET_DUTY_CYCLE_NO_UPDATE_API == STD_ON))
        
            if ((PWM_SETPERIODANDDUTY_NO_UPDATE_ID == u8ServiceId) || (PWM_SETDUTYCYCLE_NO_UPDATE_ID == u8ServiceId))
            {               
                /*
                 * @violates @ref Pwm_C_REF_10 There shall be no unreachable code 
                 * eTimer-FlexPwm does not require this validation
                 * @violates @ref Pwm_C_REF_8 booleand operations should not have invariant results 
                 */
                if((Std_ReturnType)E_OK != Pwm_Ipw_ValidateChannelSync(ChannelNumber, &Pwm_pConfig->IpConfig))
                {
                    retVal = (Std_ReturnType)E_NOT_OK;
                    
                    Det_ReportError
                    (
                        (uint16) PWM_MODULE_ID,
                        (uint8)  PWM_INDEX,
                        (uint8)  u8ServiceId,
                        (uint8)  PWM_E_PARAM_SYNCHRONOUS_MODIFIED_COMBINE
                        /*
                        * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
                        *  the same and the value itself is not needed
                        */
                    );
                }
            }        
#endif
        }

    }
    return retVal;    
}

/**
* @brief          Completes the execution of a function impacting the configuration of a driver channel.
* @details        Performs actions in order to ensure that after it's caller has completed the execution
*                 the driver will remain in a state allowing execution of other functions updating the 
*                 configuration of the entire driver or of a single channel.
*
*
*
* @return         void
*
*
* @note           .
*/
LOCAL_INLINE  FUNC(void, PWM_CODE) Pwm_EndValidateChannelConfigCall
/* @violates @ref Pwm_C_REF_6 Identifier exceeds 31 chars. */
(
    VAR(Pwm_ChannelType,    AUTOMATIC) ChannelNumber
)
{
    /* Avoid compiler warning */
    (void)ChannelNumber;
}
#endif /* PWM_SET_DUTY_CYCLE_API || PWM_SET_PERIOD_AND_DUTY_API || ... */

#endif /* (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON) */



#if (PWM_PARAM_CHECK == STD_ON)
#if (PWM_PRECOMPILE_SUPPORT == STD_OFF)
/**
* @brief          Validate the configuration parameter of the Pwm_Init API. The check is required
*                 only in variant Post-Build, where the pointer should not be NULL.In case an
*                 error is detected, the function will report an error to Det or Serr,
*                 depending on the environment the driver is run in.
*
*
* @param[in]      ConfigPtr       Pointer to the configuration the driver is to be init with
*
* @return         Std_ReturnType  Validity of the pointer  
* @nRetVal        E_OK            Pointer is valid
* @nRetVal        E_NOT_OK        Pointer is invalid
*
*
* @note           .
*/
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateParamPtrInit
(
    P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigPtr
)
{
    /* Variable to store the value returned by the function */ 
    VAR(Std_ReturnType, AUTOMATIC) nRetVal = (Std_ReturnType)E_OK;

    /* Check if the config pointer received as param is NULL */
    if(NULL_PTR == ConfigPtr)
    {
        Det_ReportError
        (
            (uint16) PWM_MODULE_ID,
            (uint8)  PWM_INDEX,
            (uint8)  PWM_INIT_ID,
            (uint8)  PWM_E_INIT_FAILED
      /*
             * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
             *  the same and the value itself is not needed
             */
        );
        nRetVal = (Std_ReturnType)E_NOT_OK;        
    }

    return nRetVal;
}

#endif /*PWM_PRECOMPILE_SUPPORT == STD_OFF*/

#if ((PWM_SET_DUTY_CYCLE_API == STD_ON) || (PWM_SET_DUTY_CYCLE_NO_UPDATE_API == STD_ON))
/**
* @brief          Validate the DutyCycle parameter of the Pwm_SetDutyCycle API.In case an
*                 error is detected, the function will report it to Det or Serr,
*                 depending on the environment the driver is run in.
*
*
* @param[in]      u16DutyCycle    DutyCycle value to be validated
* @param[in]      u8ServiceId     Id of calling API   
*
* @return         Std_ReturnType  Validity of the DutyCycle parameter  
* @nRetVal        E_OK            DutyCycle is valid
* @nRetVal        E_NOT_OK        DutyCycle is invalid
*
*
* @note           .
*/
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateParamDuty
(
    VAR(uint16, AUTOMATIC) u16DutyCycle,
    VAR(uint8, AUTOMATIC)  u8ServiceId
)
{
    /* Variable to store the value returned by the function */ 
    VAR(Std_ReturnType, AUTOMATIC) nRetVal = (Std_ReturnType)E_OK;
    
    /* Check if the dutyCycle param is in valid range */
    if (u16DutyCycle > PWM_DUTY_CYCLE_100)
    {
        Det_ReportError
        (
            (uint16) PWM_MODULE_ID,
            (uint8)  PWM_INDEX,
            (uint8)  u8ServiceId,
            (uint8)  PWM_E_DUTYCYCLE_RANGE
      /*
             * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
             *  the same and the value itself is not needed
             */
        );
        nRetVal = (Std_ReturnType)E_NOT_OK;        
    }
    return nRetVal;    
}
#endif

#if ((PWM_SET_DUTY_CYCLE_API == STD_ON) && (PWM_OFFSET_PLAUSABILITY == STD_ON))
/**
* @brief          Validate the offset parameter with duty cycle input of pwm channel.
*                 In order to be valid, the offset value should less than current period default. In this 
*                 case the function will report an error to Det or Serr, depending on the environment
*                 the driver is run in.
*
*
* @param[in]      ChannelNumber   logic channel of pwm channel
* @param[in]      u16DutyCycle    the duty cycle
* @param[in]      u8ServiceId     Id of calling API  
* @param[in]      pIpConfig       The pointer to IP Emios config
*
* @return         Std_ReturnType  Validity of notification handler  
* @nRetVal        E_OK            the offset parameter is valid
* @nRetVal        E_NOT_OK        the offset parameter is not valid
*
*
* @note           .
*/
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateParamOffsetDuty
(
        VAR(Pwm_ChannelType,            AUTOMATIC)                  ChannelNumber,
        VAR(uint16,                     AUTOMATIC)                  u16DutyCycle,
        CONSTP2CONST(Pwm_IpConfigType,  AUTOMATIC, PWM_APPL_CONST)  pIpConfig
)
{
    VAR(uint8,          AUTOMATIC) u8InvalidParam = (uint8)0U;
    VAR(Std_ReturnType, AUTOMATIC) nRetVal;

    nRetVal = (Std_ReturnType)E_OK;
    
    u8InvalidParam = Pwm_Ipw_ValidateParamParamOffsetDuty(ChannelNumber, u16DutyCycle, pIpConfig);
    /* @violates @ref Pwm_C_REF_8 booleand operations should not have invariant results */
    if((uint8)0U != u8InvalidParam)
    {
        nRetVal = (Std_ReturnType)E_NOT_OK;
        Det_ReportError
        (
            (uint16) PWM_MODULE_ID,
            (uint8)  PWM_INDEX,
            (uint8)  PWM_SETDUTYCYCLE_ID,
            (uint8)  u8InvalidParam
      /*
             * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
             *  the same and the value itself is not needed
             */
        );
    }
    return nRetVal;
}
    
#endif /* ((PWM_SET_DUTY_CYCLE_API == STD_ON) && (PWM_OFFSET_PLAUSABILITY == STD_ON))) */

#if ((PWM_SET_PERIOD_AND_DUTY_API == STD_ON) || (PWM_SET_PERIOD_AND_DUTY_NO_UPDATE_API == STD_ON))
/**
* @brief          Validate the Period and DutyCycle parameters of the Pwm_SetPeriodAndDuty
*                 API.The Period is validated in the sense that it can be updated only
*                 for channels having Variable Period class. Also it may be possible (when hardware allows it) 
*                 for the Pwm period that would be written to hardware, to be constructed taking into 
*                 consideration some initial value. In such case the total value (maximum value) should not exceed 
*                 the maximum value supported by the hardware (0xFFFFU).
*                 In case any of the parameters   is invalid, the function will report an error to 
*                 Det or Serr,depending on the environment the driver is run in.
*
*
* @param[in]      ChannelNumber   The Id of the given channel
* @param[in]      eChannelClass    Class of the channel to be validated
* @param[in]      Period          Value of the Pwm period in ticks
* @param[in]      u16DutyCycle    DutyCycle value to be validated
* @param[in]      u8ServiceId     Id of calling API  
*
* @return         Std_ReturnType  Validity of Channel Class, DutyCycle, Period parameters  
* @nRetVal        E_OK            Channel Class, Duty, Period are all valid
* @nRetVal        E_NOT_OK        One of or Channel Class, DutytCycle or Period is invalid
*
* @note           .
*/
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateParamsPeriodDuty
(
    VAR(Pwm_ChannelType,      AUTOMATIC) ChannelNumber,
    VAR(Pwm_ChannelClassType, AUTOMATIC) eChannelClass,
    VAR(Pwm_PeriodType,       AUTOMATIC) Period,
    VAR(uint16,               AUTOMATIC) u16DutyCycle,
    VAR(uint8,                AUTOMATIC) u8ServiceId
)
{
    /* Variable to store the value returned by the function */ 
    VAR(Std_ReturnType, AUTOMATIC) nRetVal = (Std_ReturnType)E_OK;

#if  (PWM_MAX_PERIOD_PLAUSABILITY == STD_ON)     
    VAR(uint32, AUTOMATIC) PeriodMaxValue =  (uint32)0U;
#else
    (void) Period;
    (void) ChannelNumber;
#endif    
    
    /* Check if channel suports updates of the period and if the DutyCycle param is in range */
    if(PWM_VARIABLE_PERIOD != eChannelClass)
    {
        Det_ReportError
        (
            (uint16) PWM_MODULE_ID,
            (uint8)  PWM_INDEX,
            (uint8)  u8ServiceId,
            (uint8)  PWM_E_PERIOD_UNCHANGEABLE
      /*
             * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
             *  the same and the value itself is not needed
             */
        );
        nRetVal = (Std_ReturnType)E_NOT_OK;        
    }
    else
    {     

#if  (PWM_MAX_PERIOD_PLAUSABILITY == STD_ON) 
        PeriodMaxValue = Pwm_Ipw_GetMaxPeriodValue(ChannelNumber, &Pwm_pConfig->IpConfig);
        /* @violates @ref Pwm_C_REF_8 booleand operations should not have invariant results */
        if ((uint32)Period > PeriodMaxValue)
        {
            Det_ReportError
            (
                (uint16) PWM_MODULE_ID,
                (uint8)  PWM_INDEX,
                (uint8)  u8ServiceId,
                (uint8)  PWM_E_PERIODVALUE
          /*
                 * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
                 *  the same and the value itself is not needed
                 */
            );
            
            nRetVal = (Std_ReturnType)E_NOT_OK;        
        }
        else
        {      
#endif
            if (u16DutyCycle > PWM_DUTY_CYCLE_100)
            {
                Det_ReportError
                (
                    (uint16) PWM_MODULE_ID,
                    (uint8)  PWM_INDEX,
                    (uint8)  u8ServiceId,
                    (uint8)  PWM_E_DUTYCYCLE_RANGE
        /*
                     * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
                     *  the same and the value itself is not needed
                     */
                );
                nRetVal = (Std_ReturnType)E_NOT_OK;        
            }
            else
            {
                /*no error detected*/
            }
#if  (PWM_MAX_PERIOD_PLAUSABILITY == STD_ON)            
        }
#endif
        
    }
    return nRetVal;   
}
#endif /* (PWM_SET_PERIOD_AND_DUTY_API == STD_ON)  || (PWM_SET_PERIOD_AND_DUTY_NO_UPDATE_API == STD_ON) */

#if (PWM_NOTIFICATION_SUPPORTED == STD_ON)

/**
* @brief          Validate the notification handler of a Pwm channel.
*                 In order to be valid, the notification handler should not be
*                 NULL. In case it is NULL, the function will report an error to 
*                 Det or Serr,depending on the environment the driver is run in.
*
*
* @param[in]      ChannelNumber   The Id of the given channel
* @param[in]      Notification    The notification edge type
*
* @return         Std_ReturnType  Validity of notification handler  
* @nRetVal        E_OK            Notification handler is valid
* @nRetVal        E_NOT_OK        Notification handler is not valid
*
*
* @note           .
*/
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateParamNotification
(
    VAR(Pwm_ChannelType,          AUTOMATIC) ChannelNumber,
    VAR(Pwm_EdgeNotificationType, AUTOMATIC) Notification
)
{
   
   /* Variable to store the value returned by the function */ 
    VAR(Std_ReturnType, AUTOMATIC) nRetVal = (Std_ReturnType)E_OK;
    VAR(Pwm_NotifyType, AUTOMATIC) pPwmChannelNotification;
#if (PWM_NOTIFICATON_PLAUSABILITY == STD_OFF)    
    (void)Notification;
#endif
    pPwmChannelNotification = (*Pwm_pConfig->pPwmChannelsConfig)[ChannelNumber].pfPwmChannelNotification;
    /* Check if Notification param is not NULL */
    if(NULL_PTR == pPwmChannelNotification)
    {
        Det_ReportError
        (
            (uint16) PWM_MODULE_ID,
            (uint8)  PWM_INDEX,
            (uint8)  PWM_ENABLENOTIFICATION_ID,
            (uint8)  PWM_E_PARAM_NOTIFICATION_NULL
      /*
             * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
             *  the same and the value itself is not needed
             */
        );
        nRetVal = (Std_ReturnType)E_NOT_OK;  

#if (PWM_NOTIFICATON_PLAUSABILITY == STD_ON)        
    }
    else
    {        
        nRetVal = Pwm_Ipw_ValidateNotification(ChannelNumber, Notification, &Pwm_pConfig->IpConfig);
        /* @violates @ref Pwm_C_REF_8 booleand operations should not have invariant results */
        if((Std_ReturnType)E_OK != nRetVal)
        {
            Det_ReportError
            (
                (uint16) PWM_MODULE_ID,
                (uint8)  PWM_INDEX,
                (uint8)  PWM_ENABLENOTIFICATION_ID,
                (uint8)  PWM_E_PARAM_NOTIFICATION
          /*
                 * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
                 *  the same and the value itself is not needed
                 */
            );
        }
 #endif       
    }
    return nRetVal;   
}
#endif /* (PWM_NOTIFICATION_SUPPORTED == STD_ON) */

#ifdef PWM_SET_TRIGGER_DELAY_API
#if (PWM_SET_TRIGGER_DELAY_API == STD_ON)
/**
* @brief          Validate the trigger delay with current period of pwm channel.
*                 In order to be valid, the trigger value should less than current default. In this 
*                 case the function will report an error to Det or Serr, depending on the environment
*                 the driver is run in.
*
*
* @param[in]      ChannelNumber   The Id of the given channel
* @param[in]      nTriggerDelay   The trigger delay value
*
* @return         Std_ReturnType  Validity of notification handler  
* @nRetVal        E_OK            the trigger delay parameter is valid
* @nRetVal        E_NOT_OK        the trigger delay parameter is not valid
*
*
* @note           .
*/
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateParamTrigger
(
    VAR(Pwm_ChannelType,      AUTOMATIC) ChannelNumber,
    VAR(Pwm_PeriodType,       AUTOMATIC) nTriggerDelay
)
{
    VAR(Std_ReturnType, AUTOMATIC) nRetVal = (Std_ReturnType)E_OK;
    VAR(Pwm_PeriodType, AUTOMATIC) PeriodCurValue = (Pwm_PeriodType)0U;

    PeriodCurValue = Pwm_Ipw_GetCurrentPeriodValue(ChannelNumber, &Pwm_pConfig->IpConfig);
    if (nTriggerDelay >= PeriodCurValue)
    {
        nRetVal = (Std_ReturnType)E_NOT_OK;
        Det_ReportError
        (
            (uint16) PWM_MODULE_ID,
            (uint8)  PWM_INDEX,
            (uint8)  PWM_SETTRIGGERDELAY_ID,
            (uint8)  PWM_E_OPWMT_CHANNEL_TRIGGER_RANGE
      /*
             * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
             *  the same and the value itself is not needed
             */
        );
    }
    return nRetVal;
}

/**
* @brief          Validate the mode of current channel.
*                 In order to be valid, the mode of current channel must be OPWMT 
*                 case the function will report an error to Det or Serr, depending on the environment
*                 the driver is run in.
*
*
* @param[in]      ChannelNumber   The Id of the given channel
* @param[in]      pIpConfig       The pointer to IP Emios config
*
* @return         Std_ReturnType  Validity of notification handler  
* @nRetVal        E_OK            the mode of current channel is valid
* @nRetVal        E_NOT_OK        the mode of current channel is not valid
*
*
* @note           .
*/
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateTriggerMode
(
    VAR(Pwm_ChannelType,      AUTOMATIC) ChannelNumber
)
{
    VAR(Std_ReturnType, AUTOMATIC) nRetVal = (Std_ReturnType)E_OK;

    nRetVal = Pwm_Ipw_ValidateTriggerMode(ChannelNumber, &Pwm_pConfig->IpConfig);
    if ((Std_ReturnType)E_OK != nRetVal)
    {
        Det_ReportError
        (
            (uint16) PWM_MODULE_ID,
            (uint8)  PWM_INDEX,
            (uint8)  PWM_SETTRIGGERDELAY_ID,
            (uint8)  PWM_E_PARAM_CHANNEL
      /*
             * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
             *  the same and the value itself is not needed
             */
        );
    }
    return nRetVal;
}

#endif /* (PWM_SET_TRIGGER_DELAY_API == STD_ON) */
#endif /* (PWM_SET_TRIGGER_DELAY_API == STD_ON) */


#if (   (PWM_BUFFER_TRANSFER_EN_DIS_API == STD_ON) || \
        (PWM_SYNC_UPDATE_API == STD_ON) || \
        (PWM_ENABLE_TRIGEER_API == STD_ON) || \
        (PWM_DISABLE_TRIGEER_API == STD_ON) || \
        (PWM_RESET_COUNTER_API == STD_ON) || \
        (PWM_ENABLE_MASKING_OPERATIONS == STD_ON) || \
        (PWM_RELOAD_NOTIF_SUPPORTED == STD_ON)\
    )
/**
* @brief          Validate the module id.
*                 In order to be valid, the module id should less than number of module that supported
*
*
* @param[in]      u8moduleid      The Id of the ipv module
*
* @return         Std_ReturnType  Validity of notification handler  
* @retval         E_OK            the module id is valid
* @retval         E_NOT_OK        module id is not valid
*
*
* @note           .
*/
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateModuleId
(
    VAR(uint8,               AUTOMATIC) u8ModuleId,
    VAR(uint8,               AUTOMATIC) u8ServiceId
)
{
    VAR(Std_ReturnType, AUTOMATIC) retVal = (Std_ReturnType)E_OK;
    /* Avoid compiler warning when comparison of unsigned integer with zero */
    if((PWM_HW_MODULES_CFG_U8 + (uint8)1) <= (u8ModuleId + (uint8)1))
    {
        retVal = (Std_ReturnType)E_NOT_OK;
        Det_ReportError
        (
            (uint16) PWM_MODULE_ID,
            (uint8)  PWM_INDEX,
            (uint8)  u8ServiceId,
            (uint8)  PWM_E_PARAM_INSTANCE
      /*
             * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
             *  the same and the value itself is not needed
             */
        );
    }
    return retVal;
}
#endif /* (PWM_BUFFER_TRANSFER_EN_DIS_API == STD_ON) || (PWM_SYNC_UPDATE_API == STD_ON) */


#ifdef PWM_SET_COUNTER_BUS_API
#if (PWM_SET_COUNTER_BUS_API == STD_ON)
/**
* @brief          Validate the counter bus.
*                 In order to be valid, the trigger value should less than current default. In this 
*                 case the function will report an error to Det or Serr, depending on the environment
*                 the driver is run in.
*
*
* @param[in]      u32Bus          The Id current counter bus
*
* @return         Std_ReturnType  Validity of notification handler  
* @retval         E_OK            Counter bus parameter is valid
* @retval         E_NOT_OK        Counter bus parameter is not valid
*
*
* @note           .
*/
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateCounterBus
(
    VAR(uint32,               AUTOMATIC) u32Bus
)
{
    VAR(Std_ReturnType, AUTOMATIC) retVal = (Std_ReturnType)E_OK;

    retVal = Pwm_Ipw_ValidateCounterBus(u32Bus);
    if((Std_ReturnType)E_OK != retVal)
    {
        Det_ReportError
        (
            (uint16) PWM_MODULE_ID,
            (uint8)  PWM_INDEX,
            (uint8)  PWM_SETCOUNTERBUS_ID,
            (uint8)  PWM_E_COUNTERBUS
      /*
             * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
             *  the same and the value itself is not needed
             */
        );
    }
    return retVal;
}
#endif /* (PWM_SETCOUNTERBUS_ID == STD_ON) */
#endif /* (PWM_SETCOUNTERBUS_ID == STD_ON) */


#if (PWM_SET_CHANNEL_OUTPUT_API == STD_ON)
/**
* @brief          Validate the output state.
*                 In order to be valid, the output state is only PWM_STATE_LOW or PWM_STATE_HIGH if  
*                 the hardware channel is PWM_X
*
*
* @param[in]      nState          The state of output
* @param[in]      ChannelNumber   The id of channel number
*
* @return         Std_ReturnType  Validity of notification handler  
* @retval         E_OK            output state parameter is valid
* @retval         E_NOT_OK        output state parameter is not valid
*
*
* @note           .
*/
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateOutputState
(
    VAR(Pwm_ChannelType,      AUTOMATIC) ChannelNumber,
    VAR(Pwm_StateType,        AUTOMATIC) nState
)
{
    VAR(Std_ReturnType, AUTOMATIC) retVal = (Std_ReturnType)E_OK;
#if (PWM_OUTPUT_STATE_PLAUSABILITY == STD_OFF)
    (void)ChannelNumber;
    (void)nState;
#endif

#if (PWM_OUTPUT_STATE_PLAUSABILITY == STD_ON)
    retVal = Pwm_Ipw_ValidateOutputState(ChannelNumber, nState, &Pwm_pConfig->IpConfig);
    if((Std_ReturnType)E_OK != retVal)
    {
        Det_ReportError
        (
            (uint16) PWM_MODULE_ID,
            (uint8)  PWM_INDEX,
            (uint8)  PWM_SETCHANNELOUTPUT_ID,
            (uint8)  PWM_E_OUTPUT_STATE
      /*
             * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
             *  the same and the value itself is not needed
             */
        );
    }
#endif
    return retVal;
}
#endif /* (PWM_SET_CHANNEL_OUTPUT_API == STD_ON) */


#if (PWM_OFFSET_PLAUSABILITY == STD_ON)
/**
* @brief          Validate the offset parameter with current period and duty of pwm channel.
*                 In order to be valid, the offset value should less than current period default. In this 
*                 case the function will report an error to Det or Serr, depending on the environment
*                 the driver is run in.
*
*
* @param[in]      pIpConfig       The pointer to IP Emios config
*
* @return         Std_ReturnType  Validity of notification handler  
* @retval         E_OK            offset parameter is valid
* @retval         E_NOT_OK        offset parameter is not valid
*
* @note           .
*/
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateParamsOffset
(
    P2CONST(Pwm_IpConfigType, AUTOMATIC, PWM_APPL_CONST) pIpConfig
)
{
    VAR(uint8,          AUTOMATIC) u8InvalidParam;
    VAR(Std_ReturnType, AUTOMATIC) retVal;

    retVal = (Std_ReturnType)E_OK;
        
    u8InvalidParam = Pwm_Ipw_ValidateParamOffset(pIpConfig);
    /* @violates @ref Pwm_C_REF_8 booleand operations should not have invariant results */
    if((uint8)0U != u8InvalidParam)
    {
        retVal = (Std_ReturnType)E_NOT_OK;
        Det_ReportError
        (
            (uint16) PWM_MODULE_ID,
            (uint8)  PWM_INDEX,
            (uint8)  PWM_INIT_ID,
            (uint8)  u8InvalidParam
      /*
             * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
             *  the same and the value itself is not needed
             */
        );
    }
    return retVal;
}
#endif

#if ((PWM_SET_PHASE_SHIFT_API == STD_ON) || (PWM_SET_PHASE_SHIFT_NO_UPDATE_API == STD_ON))
/**
* @brief            Pwm_Ipw_ValidateParamsPhaseShift
* @details          This function will check phase shift parameter to make sure it is not greater than 50% duty (0x4000U)
* @param[in]        u16PhaseShift    Phase shift value
*
* @retVal           retVal          E_NOT_OK  Pwm_SetPhaseShift is not supported this channel
*/
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateParamsPhaseShift
(
    VAR(uint16,                                     AUTOMATIC) u16PhaseShift,
    VAR(uint8,                                      AUTOMATIC) u8ServiceId
)
{
    VAR(Std_ReturnType, AUTOMATIC) retVal = (Std_ReturnType)E_OK;
    
        retVal = Pwm_Ipw_ValidateParamsPhaseShift(u16PhaseShift);
        
        /* @violates @ref Pwm_C_REF_8 booleand operations should not have invariant results */
        if((Std_ReturnType)E_OK != retVal)
        {
            Det_ReportError
            (
                (uint16) PWM_MODULE_ID,
                (uint8)  PWM_INDEX,
                (uint8)  u8ServiceId,
                (uint8)  PWM_E_PARAM_PHASESHIFT_RANGE
                /*
                 * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
                 *  the same and the value itself is not needed
                 */
            );
        }
    return retVal;
}
#endif

#if ((PWM_DISABLE_TRIGEER_API == STD_ON) || (PWM_ENABLE_TRIGEER_API == STD_ON))
/**
* @brief            This function will check bit mask.
* @details          Bis mask will be process at lower layer has to be compatible with  hardware register 
*
* @param[in]        u32TriggerMask    Trigger mask value
* @param[in]        u8ServiceId       Id of the service calling this function
*
* @retVal           retVal          E_NOT_OK  Bit mask is not compatible.
*/
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateBitMask
(
    VAR(uint32,                                     AUTOMATIC) u32TriggerMask,
    VAR(uint8,                                      AUTOMATIC) u8ServiceId
)
{
    VAR(Std_ReturnType, AUTOMATIC) retVal = (Std_ReturnType)E_OK;
    
    if((PWM_ENABLETRIGGER_ID == u8ServiceId) || (PWM_DISABLETRIGGER_ID == u8ServiceId))
    {
        retVal = Pwm_Ipw_ValidateTriggerMask(u32TriggerMask);
        
        /* @violates @ref Pwm_C_REF_8 booleand operations should not have invariant results */
        if((Std_ReturnType)E_OK != retVal)
        {
            Det_ReportError
            (
                (uint16) PWM_MODULE_ID,
                (uint8)  PWM_INDEX,
                (uint8)  u8ServiceId,
                (uint8)  PWM_E_TRIGGER_MASK
                /*
                 * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
                 *  the same and the value itself is not needed
                 */
            );
        }
    }
        
    return retVal;
}
#endif

#if (PWM_SET_OUTPUT_TO_IDLE_API == STD_ON)
/**
* @brief            This function will check .
* @details          This function will check module support set output to idle. 
*
* @param[in]        ChannelNumber    The id of channel number
*
* @retVal           retVal          E_NOT_OK  Set output to idle is not valid
                                    E_OK      Set output to idle is valid
*/  
LOCAL_INLINE FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateSetOutPutToIdle
(
    VAR(Pwm_ChannelType,          AUTOMATIC) ChannelNumber
)
{
    VAR(Std_ReturnType, AUTOMATIC) nRetVal = (Std_ReturnType)E_OK;
    {        
        nRetVal = Pwm_Ipw_ValidateSetOutPutToIdle(ChannelNumber,&Pwm_pConfig->IpConfig);
        
        if((Std_ReturnType)E_OK != nRetVal)
        {
            Det_ReportError
            (
                (uint16) PWM_MODULE_ID,
                (uint8)  PWM_INDEX,
                (uint8)  PWM_SETOUTPUTTOIDLE_ID,
                (uint8)  PWM_E_SETOUTPUTTOIDLE_NOT_SUPPORT
                /*
                * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
                *  the same and the value itself is not needed
                */
            );
        }     
    }
    return nRetVal;   
}
#endif /* PWM_SET_OUTPUT_TO_IDLE_API */

#endif /* (PWM_PARAM_CHECK == STD_ON) */


#if (PWM_POWER_STATE_SUPPORTED == STD_ON)
LOCAL_INLINE  FUNC(Std_ReturnType, PWM_CODE) Pwm_ValidateIdleState
(
    P2CONST(Pwm_IpConfigType, AUTOMATIC, PWM_APPL_CONST) pIpConfig
)
{
    VAR(Std_ReturnType, AUTOMATIC) retVal;

    retVal = Pwm_Ipw_ValidateIdleState(pIpConfig);
    
    return retVal;
}
#endif

    
/*===============================================================================================
*                                       GLOBAL FUNCTIONS
===============================================================================================*/

/**
* @brief        This function initializes the Pwm driver.
* @details      The function Pwm_Init shall initialize all internals variables and the used
*               PWM structure of the microcontroller according to the parameters
*               specified in ConfigPtr.
*               If the duty cycle parameter equals:
*
*                   - 0% or 100% : Then the PWM output signal shall be in the state according
*                       to the configured polarity parameter;
*
*                   - >0% and <100%: Then the PWM output signal shall be modulated according
*                       to parameters period, duty cycle and configured polarity.
*
*               The function Pwm_SetDutyCycle shall update the duty cycle always at the end
*               of the period if supported by the implementation and configured
*               with PwmDutycycleUpdatedEndperiod.
*
*               The driver shall avoid spikes on the PWM output signal when updating
*               the PWM period and duty.
*
*               If development error detection for the Pwm module is enabled, the PWM functions
*               shall check the channel class type and raise development error PWM_E_PERIOD_UNCHANGEABLE
*               if the PWM channel is not declared as a variable period type.
*
*               If development error detection for the Pwm module is enabled, the PWM functions
*               shall check the parameter ChannelNumber and raise development error PWM_E_PARAM_CHANNEL
*               if the parameter ChannelNumber is invalid.
*
*               If development error detection for the Pwm module is enabled, when a development
*               error occurs, the corresponding PWM function shall:
*
*                   - Report the error to the Development Error Tracer.
*                   - Skip the desired functionality in order to avoid any corruptions of
*                       data or hardware registers (this means leave the function without any actions).
*                   - Return pwm level low for the function Pwm_GetOutputState.
*
*               The function Pwm_Init shall disable all notifications. The reason is that the users
*               of these notifications may not be ready. They can call Pwm_EnableNotification
*               to start notifications.
*
*               The function Pwm_Init shall only initialize the configured resources and shall not touch
*               resources that are not configured in the configuration file.
*
*               If the PwmDevErorDetect switch is enabled, API parameter checking is enabled.
*               The detailed description of the detected errors can be found in chapter
*               Error classification and chapter API specification (see PWM_SWS).
*
*               If development error detection is enabled, calling the routine Pwm_Init
*               while the PWM driver and hardware are already initialized will cause a
*               development error PWM_E_ALREADY_INITIALIZED.
*               The desired functionality shall be left without any action.
*
*               For pre-compile and link time configuration variants, a NULL pointer shall be passed
*               to the initialization routine. In this case the check for this NULL pointer
*               has to be omitted.
*
*               If development error detection for the Pwm module is enabled, if any function
*               (except Pwm_Init) is called before Pwm_Init has been called, the called function
*               shall raise development error PWM_E_UNINIT.
*
* @param[in]    ConfigPtr       pointer to PWM top configuration structure
*
* @return       void
*
* @api
*
* @implements   Pwm_Init_Activity
*
*/
/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_Init
(
    P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigPtr
)
{
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON) || (PWM_PARAM_CHECK == STD_ON)
    VAR(Std_ReturnType, AUTOMATIC)  CallIsValid;
#endif

#if (PWM_PRECOMPILE_SUPPORT == STD_ON)
    /*This parameter is not used*/
    (void)ConfigPtr;
#endif

#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    CallIsValid = Pwm_ValidateGlobalConfigCall(PWM_INIT_ID);
    if((Std_ReturnType)E_OK == CallIsValid)
    {
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */

#if (PWM_PRECOMPILE_SUPPORT == STD_ON)
        /* Save configuration pointer in global variable */
        Pwm_pConfig = &Pwm_PBCfgVariantPredefined;
#else
        Pwm_pConfig = ConfigPtr;
#endif /* PWM_PRECOMPILE_SUPPORT */

#if (PWM_PARAM_CHECK == STD_ON)
#if (PWM_PRECOMPILE_SUPPORT == STD_OFF)
        CallIsValid = Pwm_ValidateParamPtrInit(ConfigPtr);
        if((Std_ReturnType)E_OK == CallIsValid)
        {
#endif /*(PWM_PRECOMPILE_SUPPORT == STD_OFF)*/
#if (PWM_OFFSET_PLAUSABILITY == STD_ON)
            CallIsValid = Pwm_ValidateParamsOffset(&Pwm_pConfig->IpConfig);
            if((Std_ReturnType)E_OK == CallIsValid)
            {
#endif /*PWM_OFFSET_PLAUSABILITY*/
#endif /* PWM_PARAM_CHECK */          

                /* All validations passed. Here starts the actual
                functional code of the function */
                
                Pwm_Ipw_Init(&Pwm_pConfig->IpConfig);
#if (PWM_POWER_STATE_SUPPORTED == STD_ON)
                Pwm_eCurrentPowerState = PWM_FULL_POWER;
                Pwm_eTargetPowerState = PWM_NODEFINE_POWER;
#endif

#if (PWM_PARAM_CHECK == STD_ON)
#if (PWM_OFFSET_PLAUSABILITY == STD_ON)   
            }
#endif
#if (PWM_PRECOMPILE_SUPPORT == STD_OFF)
        }
#endif /*(PWM_PRECOMPILE_SUPPORT == STD_OFF)*/
#endif /* PWM_PARAM_CHECK */             

#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateGlobalConfigCall(CallIsValid, PWM_INIT_ID);
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
}


/*===============================================================================================*/
#if (PWM_DE_INIT_API == STD_ON)
/**
* @brief        This function deinitializes the Pwm driver.
* @details      The function Pwm_DeInit shall deinitialize the PWM module.
*
*               The function Pwm_DeInit shall set the state of the PWM output signals
*               to the idle state.
*               The function Pwm_DeInit shall disable PWM interrupts and PWM signal edge notifications.
*               The function Pwm_DeInit shall be pre-compile time configurable On-Off by the
*               configuration parameter PwmDeInitApi function prototype.
*               If development error detection for the Pwm module is enabled,
*               when a development error occurs, the corresponding PWM function shall:
*                   - Report the error to the Development Error Tracer.
*                   - Skip the desired functionality in order to avoid any corruptions
*                       of data or hardware registers (this means leave the function without any actions).
*                   - Return pwm level low for the function Pwm_GetOutputState.
*
*               If development error detection for the Pwm module is enabled, if any function
*               (except Pwm_Init) is called before Pwm_Init has been called, the called function
*               shall raise development error PWM_E_UNINIT.
*
* @return       void
*
* @api
*
* @implements   Pwm_DeInit_Activity
*
*/
/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_DeInit
(
    void
)
{

#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    VAR(Std_ReturnType, AUTOMATIC) CallIsValid = Pwm_ValidateGlobalConfigCall(PWM_DEINIT_ID);
    if((Std_ReturnType)E_OK == CallIsValid)
    {
 #endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */

        /* All validations passed. Here starts the actual
        functional code of the function */
        Pwm_Ipw_DeInit(&Pwm_pConfig->IpConfig);
        /* Set global configuration pointer back to NULL, flagging that
        the driver is deinitialized */
        Pwm_pConfig = NULL_PTR;

#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateGlobalConfigCall(CallIsValid, PWM_DEINIT_ID);   
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
}
#endif /* (PWM_DE_INIT_API == STD_ON) */


/*===============================================================================================*/
#if (PWM_SET_DUTY_CYCLE_API == STD_ON)
/**
* @brief            This function sets the dutycycle for the specified Pwm channel.
* @details          The function Pwm_SetDutyCycle shall set the duty cycle of the PWM channel.
*
*                   The function Pwm_SetDutyCycle shall set the PWM output state according
*                   to the configured polarity parameter, when the duty cycle = 0% or 100%.
*                   The function Pwm_SetDutyCycle shall modulate the PWM output signal according
*                   to parameters period, duty cycle and configured polarity,
*                   when the duty cycle > 0 % and < 100%.
*
*                   If development error detection for the Pwm module is enabled,
*                   the PWM functions shall check the parameter ChannelNumber and raise development error
*                   PWM_E_PARAM_CHANNEL if the parameter ChannelNumber is invalid.
*
*                   If development error detection for the Pwm module is enabled,
*                   when a development error occurs, the corresponding PWM function shall:
*                       - Report the error to the Development Error Tracer.
*                       - Skip the desired functionality in order to avoid any corruptions
*                           of data or hardware registers (this means leave the function without any actions).
*                       - Return pwm level low for the function Pwm_GetOutputState.
*
*                   The Pwm module shall comply with the following scaling scheme for the duty cycle:
*                       - 0x0000 means 0%.
*                       - 0x8000 means 100%.
*                       - 0x8000 gives the highest resolution while allowing 100% duty cycle to be
*                           represented with a 16 bit value.
*                           As an implementation guide, the following source code example is given:
*                           AbsoluteDutyCycle = ((uint32)AbsolutePeriodTime * RelativeDutyCycle) >> 15;
*
*                   If the PwmDevErorDetect switch is enabled, API parameter checking is enabled.
*                   The detailed description of the detected errors can be found in chapter
*                   Error classification and chapter API specification (see PWM_SWS).
*
*
* @param[in]        ChannelNumber       pwm channel id
* @param[in]        u16DutyCycle        pwm dutycycle value 0x0000 for 0% ... 0x8000 for 100%
*
* @return void
*
* @api
*
* @implements       Pwm_SetDutyCycle_Activity
*/

/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_SetDutyCycle
(
    VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber,
    VAR(uint16,          AUTOMATIC) u16DutyCycle
)
{
#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Pwm_ValidateChannelConfigCall(ChannelNumber, PWM_SETDUTYCYCLE_ID))
    {
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */

#if (PWM_PARAM_CHECK == STD_ON)
        if((Std_ReturnType)E_OK == Pwm_ValidateParamDuty(u16DutyCycle, PWM_SETDUTYCYCLE_ID))
        {
#if (PWM_OFFSET_PLAUSABILITY == STD_ON)
            if((Std_ReturnType)E_OK == Pwm_ValidateParamOffsetDuty(ChannelNumber, u16DutyCycle, &Pwm_pConfig->IpConfig))
            {
#endif
#endif /* PWM_PARAM_CHECK */             

                /* All validations passed. Here starts the actual
                functional code of the function */
                Pwm_Ipw_SetDutyCycle(ChannelNumber, u16DutyCycle, &Pwm_pConfig->IpConfig);

#if (PWM_PARAM_CHECK == STD_ON)
#if (PWM_OFFSET_PLAUSABILITY == STD_ON)
            }
#endif            
        }
#endif /* PWM_PARAM_CHECK */             
        

#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateChannelConfigCall(ChannelNumber);   
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */   
}
#endif /* (PWM_SET_DUTY_CYCLE_API == STD_ON) */



/*===============================================================================================*/
#if (PWM_SET_PERIOD_AND_DUTY_API == STD_ON)
/**
* @brief            This function sets the period and the dutycycle for the specified Pwm channel.
* @details          The function Pwm_SetPeriodAndDuty shall set the duty cycle of the PWM channel.
*
*                   If development error detection for the Pwm module is enabled, the PWM functions
*                   shall check the channel class type and raise development error PWM_E_PERIOD_UNCHANGEABLE
*                   if the PWM channel is not declared as a variable period type.
*
*                   If development error detection for the Pwm module is enabled,
*                   the PWM functions shall check the parameter ChannelNumber and raise development error
*                   PWM_E_PARAM_CHANNEL if the parameter ChannelNumber is invalid.
*
*                   If development error detection for the Pwm module is enabled,
*                   when a development error occurs, the corresponding PWM function shall:
*                       - Report the error to the Development Error Tracer.
*                       - Skip the desired functionality in order to avoid any corruptions
*                           of data or hardware registers (this means leave the function without any actions).
*                       - Return pwm level low for the function Pwm_GetOutputState.
*
*                   The Pwm module shall comply with the following scaling scheme for the duty cycle:
*                       - 0x0000 means 0%.
*                       - 0x8000 means 100%.
*                       - 0x8000 gives the highest resolution while allowing 100% duty cycle to be
*                           represented with a 16 bit value.
*                           As an implementation guide, the following source code example is given:
*                           AbsoluteDutyCycle = ((uint32)AbsolutePeriodTime * RelativeDutyCycle) >> 15;
*
*                   If the PwmDevErorDetect switch is enabled, API parameter checking is enabled.
*                   The detailed description of the detected errors can be found in chapter
*                   Error classification and chapter API specification (see PWM_SWS).
*
*                   If development error detection for the Pwm module is enabled, if any function
*                   (except Pwm_Init) is called before Pwm_Init has been called, the called function shall
*                   raise development error PWM_E_UNINIT.
*
* @param[in]        ChannelNumber - pwm channel id
* @param[in]        Period        - pwm signal period value
* @param[in]        u16DutyCycle     - pwm dutycycle value 0x0000 for 0% ... 0x8000 for 100%
*
* @return           void
*
* @api
*
* @implements       Pwm_SetPeriodAndDuty_Activity
*
*/

/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_SetPeriodAndDuty
(
    VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber,
    VAR(Pwm_PeriodType,  AUTOMATIC) Period,
    VAR(uint16,          AUTOMATIC) u16DutyCycle
)
{
#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Pwm_ValidateChannelConfigCall(ChannelNumber, PWM_SETPERIODANDDUTY_ID))
    {
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */

#if (PWM_PARAM_CHECK == STD_ON)
        if((Std_ReturnType)E_OK == Pwm_ValidateParamsPeriodDuty(ChannelNumber,(*Pwm_pConfig->pPwmChannelsConfig)[ChannelNumber].ePwmChannelClass, Period, u16DutyCycle, PWM_SETPERIODANDDUTY_ID))
        {
#endif /* PWM_PARAM_CHECK */             

            /* All validations passed. Here starts the actual
            functional code of the function */
            Pwm_Ipw_SetPeriodAndDuty(ChannelNumber, Period, u16DutyCycle, &Pwm_pConfig->IpConfig);
        
#if (PWM_PARAM_CHECK == STD_ON)
        }
#endif /* PWM_PARAM_CHECK */             
        

#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateChannelConfigCall(ChannelNumber);   
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */       
}
#endif /* PWM_SET_PERIOD_AND_DUTY_API */


/*===============================================================================================*/
#if (PWM_SET_OUTPUT_TO_IDLE_API == STD_ON)
/**
* @brief            This function sets the generated pwm signal to the idle value configured.
* @details          The function Pwm_SetOutputToIdle shall set immediately the
*                   PWM output to the configured Idle state.
*
*                   If development error detection for the Pwm module is enabled, the PWM functions
*                   shall check the parameter ChannelNumber and raise development error PWM_E_PARAM_CHANNEL
*                   if the parameter ChannelNumber is invalid.
*
*                   If development error detection for the Pwm module is enabled, when a
*                   development error occurs, the corresponding PWM function shall:
*                       - Report the error to the Development Error Tracer.
*                       - Skip the desired functionality in order to avoid any corruptions of data
*                           or hardware registers (this means leave the function without any actions).
*
*                   If the PwmDevErorDetect switch is enabled, API parameter checking is enabled.
*                   The detailed description of the detected errors can be found in chapter
*                   Error classification and chapter API specification (see PWM_SWS).
*
*                   After the call of the function Pwm_SetOutputToIdle, variable period type channels
*                   shall be reactivated either using the Api Pwm_SetPeriodAndDuty() to activate
*                   the PWM channel with the new passed period or Api Pwm_SetDutyCycle() to activate
*                   the PWM channel with the old period.
*
*                   After the call of the function Pwm_SetOutputToIdle, fixed period type channels
*                   shall be reactivated using only the API Api Pwm_SetDutyCycle() to activate
*                   the PWM channel with the old period.
*
*                   If development error detection for the Pwm module is enabled, if any function
*                   (except Pwm_Init) is called before Pwm_Init has been called, the called function
*                   shall raise development error PWM_E_UNINIT.
*
* @param[in]        ChannelNumber - pwm channel id
*
* @return           void
*
* @api
*
* @implements       Pwm_SetOutputToIdle_Activity
*
*/
/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_SetOutputToIdle
(
    VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber
)
{
#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Pwm_ValidateChannelConfigCall(ChannelNumber, PWM_SETOUTPUTTOIDLE_ID))
    {
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */
    #if ((PWM_SETOUTPUTTOIDLE_PLAUSABILITY == STD_ON) && (PWM_PARAM_CHECK == STD_ON))
        if((Std_ReturnType)E_OK == Pwm_ValidateSetOutPutToIdle(ChannelNumber))
        {
    #endif /* PWM_SETOUTPUTTOIDLE_PLAUSABILITY && PWM_PARAM_CHECK */
    
            /* All validations passed. Here starts the actual
            functional code of the function */
            Pwm_Ipw_SetOutputToIdle(ChannelNumber, &Pwm_pConfig->IpConfig);
        
    #if ((PWM_SETOUTPUTTOIDLE_PLAUSABILITY == STD_ON) && (PWM_PARAM_CHECK == STD_ON))
        }
    #endif /* PWM_SETOUTPUTTOIDLE_PLAUSABILITY && PWM_PARAM_CHECK */   
#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateChannelConfigCall(ChannelNumber);   
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */       
}
#endif /* PWM_SET_OUTPUT_TO_IDLE_API */


/*===============================================================================================*/
#if (PWM_GET_OUTPUT_STATE_API == STD_ON)
/**
* @brief            This function returns the signal output state.
* @details          The function Pwm_GetOutputState shall read the internal state of
*                   the PWM output signal and return it as defined in the diagram below (see PWM_SWS).
*
*                   If development error detection for the Pwm module is enabled,
*                   the PWM functions shall check the parameter ChannelNumber and
*                   raise development error PWM_E_PARAM_CHANNEL if the parameter ChannelNumber is invalid.
*
*                   If development error detection for the Pwm module is enabled, when a
*                   development error occurs, the corresponding PWM function shall:
*                      - Report the error to the Development Error Tracer.
*                      - Skip the desired functionality in order to avoid any corruptions of
*                           data or hardware registers (this means leave the function without any actions).
*                      - Return pwm level low for the function Pwm_GetOutputState.
*
*                   If the PwmDevErorDetect switch is enabled, API parameter checking is enabled.
*                   The detailed description of the detected errors can be found in chapter
*                   Error classification and chapter API specification (see PWM_SWS).
*
*                   Due to real time constraint and setting of the PWM channel (project dependant),
*                   the output state can be modified just after the call of the service Pwm_GetOutputState.
*
*                   If development error detection for the Pwm module is enabled, if any function
*                   (except Pwm_Init) is called before Pwm_Init has been called, the called function
*                   shall raise development error PWM_E_UNINIT.
*
* @param[in]        ChannelNumber - pwm channel id
*
* @return           Pwm_OutputStateType  pwm signal output logic value
* @retval           PWM_LOW -  The output state of PWM channel is low
* @retval           PWM_HIGH - The output state of PWM channel is high
*
* @api
*
* @implements       Pwm_GetOutputState_Activity
*
* @note             Due to hardware limitation this function will always return PWM_LOW for eTimer channels
*
*/

/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(Pwm_OutputStateType, PWM_CODE) Pwm_GetOutputState
(
    VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber
)
{
    VAR(Pwm_OutputStateType, AUTOMATIC) retVal = (Pwm_OutputStateType)PWM_LOW;

#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Pwm_ValidateChannelConfigCall(ChannelNumber, PWM_GETOUTPUTSTATE_ID))
    {
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */

        /* All validations passed. Here starts the actual
        functional code of the function */
        retVal = Pwm_Ipw_GetOutputState(ChannelNumber, &Pwm_pConfig->IpConfig);
        
#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateChannelConfigCall(ChannelNumber);   
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */       

    return (Pwm_OutputStateType)retVal;
}
#endif /* PWM_GET_OUTPUT_STATE_API */


/*===============================================================================================*/
#if (PWM_NOTIFICATION_SUPPORTED == STD_ON)
/**
* @brief            This function disables the user notifications.
* @details          If development error detection for the Pwm module is enabled:
*                   - The PWM functions shall check the parameter ChannelNumber and raise
*                   development error PWM_E_PARAM_CHANNEL if the parameter ChannelNumber is invalid.
*
*                   If development error detection for the Pwm module is enabled,
*                   when a development error occurs, the corresponding PWM function shall:
*                   - Report the error to the Development Error Tracer.
*                   - Skip the desired functionality in order to avoid any corruptions of
*                      data or hardware registers (this means leave the function without any actions).
*                   - Return pwm level low for the function Pwm_GetOutputState.
*
*                   If the PwmDevErorDetect switch is enabled, API parameter checking is enabled.
*                   The detailed description of the detected errors can be found in chapter
*                   Error classification and chapter API specification (see PWM_SWS).
*
*                    All functions from the PWM module except Pwm_Init, Pwm_DeInit and Pwm_GetVersionInfo
*                   shall be re-entrant for different PWM channel numbers. In order to keep a simple module
*                   implementation, no check of PWM088 must be performed by the module.
*                   The function Pwm_DisableNotification shall be pre compile time configurable On-Off by the
*                   configuration parameter: PwmNotificationSupported.
*
*                   If development error detection for the Pwm module is enabled, if any function
*                   (except Pwm_Init) is called before Pwm_Init has been called, the called function shall
*                   raise development error PWM_E_UNINIT.
*
* @param[in]        ChannelNumber - pwm channel id
*
* @return           void
*
* @api
*
* @implements       Pwm_DisableNotification_Activity
*
*/

/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_DisableNotification
(
    VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber
)
{
#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Pwm_ValidateChannelConfigCall(ChannelNumber, PWM_DISABLENOTIFICATION_ID))
    {
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */

        /* All validations passed. Here starts the actual
        functional code of the function */
        Pwm_Ipw_DisableNotification(ChannelNumber, &Pwm_pConfig->IpConfig);
        
#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateChannelConfigCall(ChannelNumber);   
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */       
}
#endif /* PWM_NOTIFICATION_SUPPORTED */



/*===============================================================================================*/
#if (PWM_NOTIFICATION_SUPPORTED == STD_ON)
/**
* @brief            This function enables the user notifications.
* @details          The function Pwm_EnableNotification shall enable the PWM signal edge notification
*                   according to notification parameter.
*                   If development error detection for the Pwm module is enabled:
*                   - The PWM functions shall check the parameter ChannelNumber and raise
*                   development error PWM_E_PARAM_CHANNEL if the parameter ChannelNumber is invalid.
*
*                   If development error detection for the Pwm module is enabled, when a development error
*                   occurs, the corresponding PWM function shall:
*
*                       - Report the error to the Development Error Tracer.
*                       - Skip the desired functionality in order to avoid any corruptions of
*                           data or hardware registers (this means leave the function without any actions).
*                       - Return pwm level low for the function Pwm_GetOutputState.
*
*                   If the PwmDevErorDetect switch is enabled, API parameter checking is enabled.
*                   The detailed description of the detected errors can be found in chapter
*                   Error classification and chapter API specification (see PWM_SWS).
*
*                   If development error detection for the Pwm module is enabled, if any function
*                   (except Pwm_Init) is called before Pwm_Init has been called, the called function
*                   shall raise development error PWM_E_UNINIT.
*
* @param[in]        ChannelNumber - pwm channel id
* @param[in]        Notification  - notification type to be enabled
*
* @return           void
*
* @api
*
* @implements       Pwm_EnableNotification_Activity
*
*/
/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_EnableNotification
(
    VAR(Pwm_ChannelType,          AUTOMATIC) ChannelNumber,
    VAR(Pwm_EdgeNotificationType, AUTOMATIC) Notification
)
{
#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Pwm_ValidateChannelConfigCall(ChannelNumber, PWM_ENABLENOTIFICATION_ID))
    {
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */

#if (PWM_PARAM_CHECK == STD_ON)
        if((Std_ReturnType)E_OK == Pwm_ValidateParamNotification(ChannelNumber, Notification))
        {
#endif /* (PWM_PARAM_CHECK == STD_ON) */

            /* All validations passed. Here starts the actual
            functional code of the function */
            Pwm_Ipw_EnableNotification(ChannelNumber, Notification, &Pwm_pConfig->IpConfig);
#if (PWM_PARAM_CHECK == STD_ON)
        }
#endif /* (PWM_PARAM_CHECK == STD_ON) */
        

#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateChannelConfigCall(ChannelNumber);   
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */  
}
#endif /* PWM_NOTIFICATION_SUPPORTED */


/*===============================================================================================*/
#if (PWM_VERSION_INFO_API == STD_ON)
/**
* @brief            This function returns Pwm driver version details
* @details          The function Pwm_GetVersionInfo shall return the version information of this module.
*                   The version information includes: Module Id, Vendor Id, Vendor specific version number.
*
* @param[in,out]    pVersioninfo - pointer to Std_VersionInfoType output variable
*
* @return           void
*
* @api
*
* @implements       Pwm_GetVersionInfo_Activity
*
*/
/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_GetVersionInfo
(
    P2VAR(Std_VersionInfoType , AUTOMATIC, PWM_APPL_DATA) pVersioninfo
)
{
#if (PWM_DEV_ERROR_DETECT == STD_ON)
    if (NULL_PTR != pVersioninfo)
    {
#endif /* PWM_DEV_ERROR_DETECT */

        (pVersioninfo)->vendorID         = (uint16)PWM_VENDOR_ID;
        (pVersioninfo)->moduleID         = (uint16)PWM_MODULE_ID;

        (pVersioninfo)->sw_major_version = (uint8)PWM_SW_MAJOR_VERSION;
        (pVersioninfo)->sw_minor_version = (uint8)PWM_SW_MINOR_VERSION;
        (pVersioninfo)->sw_patch_version = (uint8)PWM_SW_PATCH_VERSION;

#if (PWM_DEV_ERROR_DETECT == STD_ON)
    }
    else
    {
        /* if the parameter pVersioninfo is NULL_PTR then report the error */

        Det_ReportError
        (
            (uint16) PWM_MODULE_ID,
            (uint8)  PWM_INDEX,
            (uint8)  PWM_GETVERSIONINFO_ID,
            (uint8)  PWM_E_PARAM_POINTER
      /*
             * @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
             * the same and the value itself is not needed
             */
        );
    }
#endif /* PWM_DEV_ERROR_DETECT */
}
#endif /* PWM_VERSION_INFO_API */


/*===============================================================================================*/
#if (PWM_GET_CHANNEL_STATE_API == STD_ON)
/**
* @brief            This function returns the duty cycle of the channel passed as parameter
* @details          The function Pwm_GetChannelState shall return the dutyCycle of the channel.
*                   In case the channel is idle, the returned value will be zero.
*
* @param[in]        ChannelNumber - pwm channel id
*
* @return           uint16        - DutyCycle of the requested channel 
*
* @api
*
* @implements       Pwm_GetChannelState_Activity
*
*/
/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(uint16, PWM_CODE) Pwm_GetChannelState
(
    VAR(Pwm_ChannelType,          AUTOMATIC) ChannelNumber
)
{
    VAR(uint16, AUTOMATIC) u16DutyCycle = (uint16)0U;

#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Pwm_ValidateChannelConfigCall(ChannelNumber, PWM_GETCHANNELSTATE_ID))
    {
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */

        /* All validations passed. Here starts the actual
        functional code of the function */
        u16DutyCycle = Pwm_Ipw_GetChannelState(ChannelNumber,  &Pwm_pConfig->IpConfig);

#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateChannelConfigCall(ChannelNumber);   
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */

    return u16DutyCycle;
}
#endif /* PWM_GET_CHANNEL_STATE_API */


/*===============================================================================================*/
#if (PWM_NOTIFICATION_SUPPORTED == STD_ON)
/**
* @brief         Pwm_Notification
* @details       This function is called from Pwm_Ipw.c file in order to forward a 
*                channel notification call from the IP configuration. 
*                   
* @param         Channel - Hw channel for which notification should be called 
* @return        Void
*
* @implements       Pwm_Notification_Activity
*
*/
/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_Notification
(
    VAR(Pwm_ChannelType, AUTOMATIC) Channel
)
{
    VAR(uint8,          AUTOMATIC) u8LogicChannel;
    VAR(Pwm_NotifyType, AUTOMATIC) pfNotify;
    
    if(NULL_PTR != Pwm_pConfig)
    {
        u8LogicChannel = Pwm_pConfig->HwToLogicChannelMap[Channel];
        /* Check that there is a logic channel associated with the Hw one */
        pfNotify = (*Pwm_pConfig->pPwmChannelsConfig)[u8LogicChannel].pfPwmChannelNotification;
        /* Check that a notification is defined for the associated 
        logic channel. This is a double check not necessarily needed because if notification were
        enabled in IP layer for the channel that generated the interrupt causing this notify to
        be called, it means that this channel cannot have a null notification, otherwise notification
        could not have been enabled  */
        if(NULL_PTR != pfNotify)
        {
            pfNotify();   
        }
    }
}
#endif /* (PWM_NOTIFICATION_SUPPORTED == STD_ON) */


/*===============================================================================================*/
#if ((PWM_FAULT_SUPPORTED == STD_ON) || (PWM_RELOAD_NOTIF_SUPPORTED == STD_ON))
/**
* @brief         Pwm_GetIpConfigPtr
* @details       This function is called from Pwm_Ipw.c file in order to get the pointer
*                to the IP configuration. Function is required only for FlexPwm fault notification
*                functionality
*                   
* @param         None
* @return        Pwm_IpConfigType* - Pointer to the IP configuration structure
*
*
*/
FUNC(P2CONST(Pwm_IpConfigType, AUTOMATIC, PWM_APPL_CONST), PWM_CODE) Pwm_GetIpConfigPtr
(
    void
)
{
    P2CONST(Pwm_IpConfigType, AUTOMATIC, PWM_APPL_CONST) pIpConfig;
    /* If global config pointer is NULL, return NULL pointer */
    if(NULL_PTR == Pwm_pConfig)
    {
        pIpConfig = NULL_PTR;   
    }
    else
    {
        pIpConfig =  &Pwm_pConfig->IpConfig;   
    }
    return pIpConfig;
}
#endif /* ((PWM_FAULT_SUPPORTED == STD_ON) || (PWM_RELOAD_NOTIF_SUPPORTED == STD_ON)) */


/*===============================================================================================*/
#if (PWM_FORCE_OUTPUT_TO_ZERO_API == STD_ON)
/**
* @brief            This function enables-disables the forcing of the output of a given FlexPwm channel to logic 0.
* @details          This API sets-clears the bit  of the MASK register corresponding to the FlexPWM channel.
*                   
*
* @param[in]        ChannelNumber - pwm channel id
* @param[in]        bForce        - boolean value to state if the output of the flexPwm channel will be forced
*                                   to zero logic or not
*                   The function will have no effect when called for an eTimer channel and no error will be reported.
*                   
* @return           void
*
* @api
*
*
*
*/
/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_ForceOutputToZero
(
    VAR(Pwm_ChannelType,        AUTOMATIC) ChannelNumber,
    VAR(boolean,                AUTOMATIC) bForce
)
{
#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Pwm_ValidateChannelConfigCall(ChannelNumber, PWM_FORCEOUTPUTTOZERO_ID))
    {
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */

        /* All validations passed. Here starts the actual
        functional code of the function */
        Pwm_Ipw_ForceOutputToZero(ChannelNumber, bForce, &Pwm_pConfig->IpConfig);

#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateChannelConfigCall(ChannelNumber);   
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */  
}
#endif /* PWM_FORCE_OUTPUT_TO_ZERO_API */

/*===============================================================================================*/
#ifdef PWM_SET_COUNTER_BUS_API
#if (PWM_SET_COUNTER_BUS_API == STD_ON)
/**
* @brief            This function will change the bus of pwm channels running.
* @details          This function is useful to change the frequency of the output PWM signal between
*                   two counter buses frequency
* @param[in]        ChannelNumber - pwm channel id
* @param[in]        u32Bus           - the eMIOS bus to change to
*
* 
*
*/
/* @violates @ref Pwm_C_REF_2 external ... could be made static */
FUNC(void, PWM_CODE) Pwm_SetCounterBus
(
    VAR(Pwm_ChannelType,    AUTOMATIC) ChannelNumber,
    VAR(uint32,             AUTOMATIC) u32Bus
)
{
#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Pwm_ValidateChannelConfigCall(ChannelNumber, PWM_SETCOUNTERBUS_ID))
    {
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */
#if (PWM_PARAM_CHECK == STD_ON)
        if((Std_ReturnType)E_OK == Pwm_ValidateCounterBus(u32Bus))
        {
#endif /* (PWM_PARAM_CHECK == STD_ON) */
            Pwm_Ipw_SetCounterBus( ChannelNumber, u32Bus, &Pwm_pConfig->IpConfig);

#if (PWM_PARAM_CHECK == STD_ON)
        }
#endif /* (PWM_PARAM_CHECK == STD_ON) */
#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateChannelConfigCall(ChannelNumber);   
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */
}
#endif
#endif /* PWM_SET_COUNTER_BUS_API */


/*===============================================================================================*/
#ifdef PWM_SET_CHANNEL_OUTPUT_API
#if (PWM_SET_CHANNEL_OUTPUT_API == STD_ON)
/**
* @brief            function to set the state of the PWM pin as requested for the current cycle
* @details          This function is useful to set the state of the PWM pin as requested
*                   for the current cycle and continues with normal PWM operation from the next cycle
* @param[in]        ChannelNumber - pwm channel id
* @param[in]        nState        - Active-Inactive state of the channel
*
*
*/
/*
* @violates @ref Pwm_C_REF_3 The respective code could not be made static because
*  of layers architecture design of the driver
*/
/* @violates @ref Pwm_C_REF_2 external ... could be made static */
FUNC(void, PWM_CODE) Pwm_SetChannelOutput
(
    VAR(Pwm_ChannelType,        AUTOMATIC) ChannelNumber,
    VAR(Pwm_StateType,          AUTOMATIC) nState
)
{
#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Pwm_ValidateChannelConfigCall(ChannelNumber, PWM_SETCHANNELOUTPUT_ID))
    {
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */
#if (PWM_PARAM_CHECK == STD_ON)
        if((Std_ReturnType)E_OK == Pwm_ValidateOutputState(ChannelNumber, nState))
        {
#endif /* (PWM_PARAM_CHECK == STD_ON) */
            Pwm_Ipw_SetChannelOutput( ChannelNumber, nState, &Pwm_pConfig->IpConfig);
#if (PWM_PARAM_CHECK == STD_ON)
        }
#endif /* (PWM_PARAM_CHECK == STD_ON) */
#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateChannelConfigCall(ChannelNumber);   
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */
}
#endif
#endif /* PWM_SET_CHANNEL_OUTPUT_API */

/*===============================================================================================*/
#ifdef PWM_SET_TRIGGER_DELAY_API
#if (PWM_SET_TRIGGER_DELAY_API == STD_ON)
/**
* @brief            Implementation specific function to change the trigger delay
* @details          This function is useful to set the trigger delay to opwmt mode. If no DET error
*                   reported then the trigger delay for  the PWM channels will be set. If development
*                   error detection for the Pwm module is enabled:
*                       - Report the error to the Development Error Tracer.
*                       - Skip the desired functionality in order to avoid any corruptions of data 
*                   or hardware registers: This means leave the function without any actions.
*
* @param[in]        ChannelNumber   - pwm channel id
* @param[in]        nTriggerDelay   - triggerdelay
*
*
*
*/
/* @violates @ref Pwm_C_REF_2 external ... could be made static */
FUNC(void, PWM_CODE) Pwm_SetTriggerDelay
(
    VAR(Pwm_ChannelType,        AUTOMATIC) ChannelNumber,
    VAR(Pwm_PeriodType,         AUTOMATIC) nTriggerDelay
)
{
#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Pwm_ValidateChannelConfigCall(ChannelNumber, PWM_SETTRIGGERDELAY_ID))
    {
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */

#if (PWM_PARAM_CHECK == STD_ON)
        if((Std_ReturnType)E_OK == Pwm_ValidateParamTrigger(ChannelNumber, nTriggerDelay))
        {
            if((Std_ReturnType)E_OK == Pwm_ValidateTriggerMode(ChannelNumber))
            {
#endif /* (PWM_PARAM_CHECK == STD_ON) */
                Pwm_Ipw_SetTriggerDelay(ChannelNumber,nTriggerDelay, &Pwm_pConfig->IpConfig);

#if (PWM_PARAM_CHECK == STD_ON)
            }
        }
#endif /* (PWM_PARAM_CHECK == STD_ON) */

#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateChannelConfigCall(ChannelNumber);   
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */
}
#endif
#endif/*PWM_SET_TRIGGER_DELAY_API*/


/*===============================================================================================*/
#ifdef PWM_BUFFER_TRANSFER_EN_DIS_API
#if (PWM_BUFFER_TRANSFER_EN_DIS_API == STD_ON)
/**
* @brief            Implementation specific function to enable-disable the buffer transfer.
* @details          This function is useful to enable-disable the buffer transfer to synchronize
*                   multiple PWM channels.
*                   If any function (except Pwm_Init) is called before Pwm_Init has been called,
*                   the called function shall raise development error PWM_E_UNINIT.
*                   Report the error to the Development Error Tracer.
*                   Skip the desired functionality in order to avoid any corruptions of
*                   data or hardware registers: This means leave the function without any actions.
* @param[in]        u8ModuleIndex   - eMIOS module
* @param[in]        u32ChannelMasks - channel mask set
*                   
*
*/
/* @violates @ref Pwm_C_REF_2 external ... could be made static */
FUNC(void, PWM_CODE) Pwm_BufferTransferEnableDisable
(
    VAR(uint8,          AUTOMATIC) u8ModuleIndex,
    VAR(uint32,         AUTOMATIC) u32ChannelMasks
)
{
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    VAR(Std_ReturnType, AUTOMATIC)  CallIsValid;
#endif

#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    CallIsValid = Pwm_ValidateGlobalConfigCall(PWM_BUFFERTRANSFERENDIS_ID);
    if((Std_ReturnType)E_OK == CallIsValid)
    {
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */

#if (PWM_PARAM_CHECK == STD_ON)
        if((Std_ReturnType)E_OK == Pwm_ValidateModuleId(u8ModuleIndex, PWM_BUFFERTRANSFERENDIS_ID))
        {
#endif /* (PWM_PARAM_CHECK == STD_ON) */
            Pwm_Ipw_BufferTransferEnableDisable(u8ModuleIndex, u32ChannelMasks);

#if (PWM_PARAM_CHECK == STD_ON)
        }
#endif /* (PWM_PARAM_CHECK == STD_ON) */

#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateGlobalConfigCall(CallIsValid, PWM_BUFFERTRANSFERENDIS_ID);
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
}
#endif
#endif


/*===============================================================================================*/
#ifdef PWM_SET_CLOCK_MODE_API
#if (PWM_SET_CLOCK_MODE_API == STD_ON)
/**
* @brief            Implementation specific function to change the peripheral clock frequency.
* @details          This function is useful to set the prescalers that divide the PWM channels
*                   clock frequency.
*
* @param[in]        Prescaler - prescaler type 
*                   Possible values:    
* 
* @implements       Pwm_SetClockMode_Activity
*
*/
/* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_SetClockMode(VAR(Pwm_PrescalerType, AUTOMATIC) ePrescaler)
{
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    VAR(Std_ReturnType, AUTOMATIC)  CallIsValid;
#endif

#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    CallIsValid = Pwm_ValidateGlobalConfigCall(PWM_SETCLOCKMODE_ID);
    if((Std_ReturnType)E_OK == CallIsValid)
    {
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */

            Pwm_Ipw_SetClockMode(ePrescaler, &Pwm_pConfig->IpConfig);
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateGlobalConfigCall(CallIsValid, PWM_SETCLOCKMODE_ID);
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
}
#endif /* PWM_SET_CLOCK_MODE_API */
#endif



/*===============================================================================================*/
#if (PWM_UPDATE_DUTY_SYNCHRONOUS == STD_ON)
#if (PWM_SET_DUTY_CYCLE_NO_UPDATE_API == STD_ON)
/**
* @brief            This function sets the values of dutycycle for the specified Pwm channel but without 
*                   updating the PWM output.
* @details          The function Pwm_SetDutyCycle_NoUpdate shall set the duty cycle of the PWM channel to the 
*                   coresponding hardware buffers without updating the wave form on the output pin.
*                   This feature will allow a pre-buffering of new PWM duty cycle values for several channel,
*                   which can all be updated synchronos by calling Pwm_SyncUpdate.  
*
*                   The function Pwm_SetDutyCycle_NoUpdate shall set the PWM output state according
*                   to the configured polarity parameter, when the duty cycle = 0% or 100%.
*                   The function Pwm_SetDutyCycle_NoUpdate shall modulate the PWM output signal according
*                   to parameters period, duty cycle and configured polarity,
*                   when the duty cycle > 0 % and < 100%.
*
*                   If development error detection for the Pwm module is enabled,
*                   the PWM functions shall check the parameter ChannelNumber and raise development error
*                   PWM_E_PARAM_CHANNEL if the parameter ChannelNumber is invalid.
*
*                   If development error detection for the Pwm module is enabled,
*                   when a development error occurs, the corresponding PWM function shall:
*                       - Report the error to the Development Error Tracer.
*                       - Skip the desired functionality in order to avoid any corruptions
*                           of data or hardware registers (this means leave the function without any actions).
*                       - Return pwm level low for the function Pwm_GetOutputState.
*
*                   The Pwm module shall comply with the following scaling scheme for the duty cycle:
*                       - 0x0000 means 0%.
*                       - 0x8000 means 100%.
*                       - 0x8000 gives the highest resolution while allowing 100% duty cycle to be
*                           represented with a 16 bit value.
*                           As an implementation guide, the following source code example is given:
*                           AbsoluteDutyCycle = ((uint32)AbsolutePeriodTime * RelativeDutyCycle) >> 15;
*
*                   If the PwmDevErorDetect switch is enabled, API parameter checking is enabled.
*                   The detailed description of the detected errors can be found in chapter
*                   Error classification and chapter API specification (see PWM_SWS).
*
*
* @param[in]        ChannelNumber       pwm channel id
* @param[in]        u16DutyCycle        pwm dutycycle value 0x0000 for 0% ... 0x8000 for 100%
*
* @return void
* @implements       Pwm_SetDutyCycle_NoUpdate_Activity
*/

/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_SetDutyCycle_NoUpdate
(
    VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber,
    VAR(uint16,          AUTOMATIC) u16DutyCycle
)
{
#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Pwm_ValidateChannelConfigCall(ChannelNumber, PWM_SETDUTYCYCLE_NO_UPDATE_ID))
    {
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */

#if (PWM_PARAM_CHECK == STD_ON)
        if((Std_ReturnType)E_OK == Pwm_ValidateParamDuty(u16DutyCycle, PWM_SETDUTYCYCLE_NO_UPDATE_ID))
        {
#endif /* PWM_PARAM_CHECK */             

            /* All validations passed. Here starts the actual
            functional code of the function */
            Pwm_Ipw_SetDutyCycle_NoUpdate(ChannelNumber, u16DutyCycle, &Pwm_pConfig->IpConfig);
            
#if (PWM_PARAM_CHECK == STD_ON)
        }
#endif /* PWM_PARAM_CHECK */            

#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateChannelConfigCall(ChannelNumber);   
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */   
}
#endif /* (PWM_SET_DUTY_CYCLE_NO_UPDATE_API == STD_ON) */



/*===============================================================================================*/
#if (PWM_SET_PERIOD_AND_DUTY_NO_UPDATE_API == STD_ON)
/**
* @brief            This function sets the values of the period and the dutycycle for the specified Pwm channel
*                   into the hardware buffers but without updating the PWM output..
* @details          The function Pwm_SetPeriodAndDuty_NoUpdate shall set the period and duty cycle of the PWM 
*                   channel to the coresponding hardware buffers without updating the wave form on the output pin.
*                   This feature will allow a pre-buffering of new PWM duty cycle values for several channel,
*                   which can all be updated synchronos by calling Pwm_SyncUpdate.
*
*                   If development error detection for the Pwm module is enabled, the PWM functions
*                   shall check the channel class type and raise development error PWM_E_PERIOD_UNCHANGEABLE
*                   if the PWM channel is not declared as a variable period type.
*
*                   If development error detection for the Pwm module is enabled,
*                   the PWM functions shall check the parameter ChannelNumber and raise development error
*                   PWM_E_PARAM_CHANNEL if the parameter ChannelNumber is invalid.
*
*                   If development error detection for the Pwm module is enabled,
*                   when a development error occurs, the corresponding PWM function shall:
*                       - Report the error to the Development Error Tracer.
*                       - Skip the desired functionality in order to avoid any corruptions
*                           of data or hardware registers (this means leave the function without any actions).
*                       - Return pwm level low for the function Pwm_GetOutputState.
*
*                   The Pwm module shall comply with the following scaling scheme for the duty cycle:
*                       - 0x0000 means 0%.
*                       - 0x8000 means 100%.
*                       - 0x8000 gives the highest resolution while allowing 100% duty cycle to be
*                           represented with a 16 bit value.
*                           As an implementation guide, the following source code example is given:
*                           AbsoluteDutyCycle = ((uint32)AbsolutePeriodTime * RelativeDutyCycle) >> 15;
*
*                   If the PwmDevErorDetect switch is enabled, API parameter checking is enabled.
*                   The detailed description of the detected errors can be found in chapter
*                   Error classification and chapter API specification (see PWM_SWS).
*
*                   If development error detection for the Pwm module is enabled, if any function
*                   (except Pwm_Init) is called before Pwm_Init has been called, the called function shall
*                   raise development error PWM_E_UNINIT.
*
* @param[in]        ChannelNumber - pwm channel id
* @param[in]        Period        - pwm signal period value
* @param[in]        u16DutyCycle  - pwm dutycycle value 0x0000 for 0% ... 0x8000 for 100%
*
* @return           void
* @implements       Pwm_SetPeriodAndDuty_NoUpdate_Activity
*
*/

/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_SetPeriodAndDuty_NoUpdate
(
    VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber,
    VAR(Pwm_PeriodType,  AUTOMATIC) Period,
    VAR(uint16,          AUTOMATIC) u16DutyCycle
)
{
#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Pwm_ValidateChannelConfigCall(ChannelNumber, PWM_SETPERIODANDDUTY_NO_UPDATE_ID))
    {
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */

#if (PWM_PARAM_CHECK == STD_ON)
        if((Std_ReturnType)E_OK == Pwm_ValidateParamsPeriodDuty(ChannelNumber,(*Pwm_pConfig->pPwmChannelsConfig)[ChannelNumber].ePwmChannelClass, Period, u16DutyCycle, PWM_SETPERIODANDDUTY_NO_UPDATE_ID))
        {
#endif /* PWM_PARAM_CHECK */             

            /* All validations passed. Here starts the actual
            functional code of the function */
            Pwm_Ipw_SetPeriodAndDuty_NoUpdate(ChannelNumber, Period, u16DutyCycle, &Pwm_pConfig->IpConfig);
        
#if (PWM_PARAM_CHECK == STD_ON)
        }
#endif /* PWM_PARAM_CHECK */            

#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateChannelConfigCall(ChannelNumber);   
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */       
}
#endif /* PWM_SET_PERIOD_AND_DUTY_NO_UPDATE_API */

#if (PWM_SYNC_UPDATE_API == STD_ON)
/**
* @brief       Implementation specific function to updates the LDOK bits of flexpwm submodules.
*
* @details     This function is used to update the LDOK bits of Flex PWM channels of all the
*              submodules synchronously, this should be called after calling
*              Pwm_SetPeriodAndDuty_NoUpdate() or Pwm_SetDutyCycle_NoUpdate() API.
*              example:- For Submodule 0 MaskValue is 1
*                        For Submodule 0 and Submodule 1 MaskValue is 3
*                        For Submodule 0, Submodule 1 and Submodule 2 MaskValue is 7
*                        For Submodule 0, Submodule 1, Submodule 2 and Submodule 3 MaskValue is 15
*                        For Module value 0 means FlexPWM0
*                        For Module value 1 means FlexPWM1
*
* @param[in]   ModuleId         pwm module id
* @param[in]   u16SubmoduleMask      pwm submodule mask value
*
* @return      void
* @implements  Pwm_SyncUpdate_Activity
*/
/* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_SyncUpdate
(
    VAR(uint8, AUTOMATIC) ModuleId
#if (PWM_ALLOW_SUBMODULE_SYNC == STD_ON)
    ,
    VAR(uint16,         AUTOMATIC) u16SubmoduleMask
#endif
)
{
  #if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    VAR(Std_ReturnType, AUTOMATIC)  CallIsValid;
#endif

#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    CallIsValid = Pwm_ValidateGlobalConfigCall(PWM_SYNCUPDATE_ID);
    if((Std_ReturnType)E_OK == CallIsValid)
    {
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */

#if (PWM_PARAM_CHECK == STD_ON)
        if((Std_ReturnType)E_OK == Pwm_ValidateModuleId((uint8)ModuleId, PWM_SYNCUPDATE_ID))
        {        
#endif /* (PWM_PARAM_CHECK == STD_ON) */
           Pwm_Ipw_SyncUpdate(
                                ModuleId
#if (PWM_ALLOW_SUBMODULE_SYNC == STD_ON)
                                , u16SubmoduleMask
#endif
                             );
#if (PWM_PARAM_CHECK == STD_ON)
        }
#endif /* (PWM_PARAM_CHECK == STD_ON) */
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateGlobalConfigCall(CallIsValid, PWM_SYNCUPDATE_ID);
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
}
#endif /* PWM_SYNC_UPDATE_API */
#endif /* PWM_UPDATE_DUTY_SYNCHRONOUS */



/*===============================================================================================*/
#if (PWM_SET_PHASE_SHIFT_API == STD_ON)
/**
* @brief        This function set phase shift value and also force duty cycle to 50%
*
* @details      In order to have Phase-Shifted Full-Bridge controller, Pwm_SetPhaseShift is introduced.
*               This function bases on FTM Combine mode with Cn and C(n+1) combine to generate leading 
*               edge and trailing edge. Pwm_SetPhaseShift allows to set both phase shift value and period,
*               the duty value is fixed to 50%.
* @param[in]    ChannelNumber -         Pwm Channel Id in the configuration
* @param[in]    nPeriod                 Pwm signal period value
* @param[in]    u16PhaseShift           Phase shift value
*
* @return       void
* @implements   Pwm_SetPhaseShift_Activity
*/

/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_SetPhaseShift
(
    VAR(Pwm_ChannelType, AUTOMATIC) u8ChannelNumber,
    VAR(Pwm_PeriodType,          AUTOMATIC) nPeriod,
    VAR(uint16,          AUTOMATIC) u16PhaseShift
)
{
#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Pwm_ValidateChannelConfigCall(u8ChannelNumber, PWM_SETPHASESHIFT_ID))
    {
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */

#if (PWM_PARAM_CHECK == STD_ON)
        if((Std_ReturnType)E_OK == Pwm_ValidateParamsPhaseShift(u16PhaseShift, PWM_SETPHASESHIFT_ID))
        {

#endif /* PWM_PARAM_CHECK */             

                /* All validations passed. Here starts the actual
                functional code of the function */
                Pwm_Ipw_SetPhaseShift(u8ChannelNumber, nPeriod, u16PhaseShift, &Pwm_pConfig->IpConfig);

#if (PWM_PARAM_CHECK == STD_ON)           
        }
#endif /* PWM_PARAM_CHECK */             
        

#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateChannelConfigCall(u8ChannelNumber);   
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */
}
#endif

#if (PWM_SET_PHASE_SHIFT_NO_UPDATE_API == STD_ON)

/*=======================================================================================*/
/**
* @brief        This function set phase shift value and also force duty cycle to 50%. The output will take 
*               effect after Pwm_SyncUpdate be called.
*
* @details      In order to have Phase-Shifted Full-Bridge controller, Pwm_SetPhaseShift/Pwm_SetPhaseShift_NoUpdate
*               is introduced. This function bases on FTM Combine mode with Cn and C(n+1) combine to generate leading 
*               edge and trailing edge. Pwm_SetPhaseShift allows to set both phase shift value and period,
*               the duty value is fixed to 50%.
* @param[in]    ChannelNumber -         Pwm Channel Id in the configuration
* @param[in]    nPeriod                 Pwm signal period value
* @param[in]    u16PhaseShift           Phase shift value
*
* @return       void
*/

/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_SetPhaseShift_NoUpdate
(
    VAR(Pwm_ChannelType, AUTOMATIC) u8ChannelNumber,
    VAR(Pwm_PeriodType,          AUTOMATIC) nPeriod,
    VAR(uint16,          AUTOMATIC) u16PhaseShift
)
{
#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Pwm_ValidateChannelConfigCall(u8ChannelNumber, PWM_SETPHASESHIFTNOUPDATE_ID))
    {
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */

#if (PWM_PARAM_CHECK == STD_ON)
        if((Std_ReturnType)E_OK == Pwm_ValidateParamsPhaseShift(u16PhaseShift, PWM_SETPHASESHIFTNOUPDATE_ID))
        {

#endif /* PWM_PARAM_CHECK */             

                /* All validations passed. Here starts the actual
                functional code of the function */
                Pwm_Ipw_SetPhaseShift_NoUpdate(u8ChannelNumber, nPeriod, u16PhaseShift, &Pwm_pConfig->IpConfig);

#if (PWM_PARAM_CHECK == STD_ON)           
        }
#endif /* PWM_PARAM_CHECK */             
        

#if (PWM_VALIDATE_CHANNEL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateChannelConfigCall(u8ChannelNumber);   
#endif /* PWM_VALIDATE_CHANNEL_CONFIG_CALL */   
}
#endif /* (PWM_SET_PHASE_SHIFT_NO_UPDATE_API == STD_ON) */


#if ( PWM_ENABLE_TRIGEER_API == STD_ON)
/**
* @brief        This function enable trigger generation for specific source
* @details      Corresponding bits with trigger source as bellow:
*       Bit 0   Channel 2 Trigger Enable
*       Bit 1   Channel 3 Trigger Enable
*       Bit 2   Channel 4 Trigger Enable
*       Bit 3   Channel 5 Trigger Enable
*       Bit 4   Channel 0 Trigger Enable
*       Bit 5   Channel 1 Trigger Enable
*       Bit 6   Initialization Trigger Enable
*       Bit 8   Channel 6 Trigger Enable
*       Bit 9   Channel 7 Trigger Enable
*
* @param[in]    u8TriggerHostId - Hardware module
* @param[in]    u16TriggerMask - bit mask will be set to enable trigger with coresponding sources. 
*
* @return       void
*
*/
/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_EnableTrigger
(
    VAR(uint8, AUTOMATIC) u8TriggerHostId,
    VAR(uint16,AUTOMATIC) u16TriggerMask
)
{
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    VAR(Std_ReturnType, AUTOMATIC)  CallIsValid;
#endif

#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    CallIsValid = Pwm_ValidateGlobalConfigCall(PWM_ENABLETRIGGER_ID);
    if((Std_ReturnType)E_OK == CallIsValid)
    {
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */

#if (PWM_PARAM_CHECK == STD_ON)
        if((Std_ReturnType)E_OK == Pwm_ValidateModuleId(u8TriggerHostId, PWM_ENABLETRIGGER_ID))
        {
            if ((Std_ReturnType)E_OK == Pwm_ValidateBitMask((uint32)u16TriggerMask, PWM_ENABLETRIGGER_ID))
            {
#endif /* (PWM_PARAM_CHECK == STD_ON) */                

                Pwm_Ipw_EnableTrigger(u8TriggerHostId, u16TriggerMask);

#if (PWM_PARAM_CHECK == STD_ON)                
            }
        }
#endif /* (PWM_PARAM_CHECK == STD_ON) */

#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateGlobalConfigCall(CallIsValid, PWM_ENABLETRIGGER_ID);
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
}
#endif
#if (PWM_DISABLE_TRIGEER_API == STD_ON)
/**
* @brief        This function disable trigger generation for specific source
* @details      Corresponding bits with trigger source as bellow:
*       Bit 0   Channel 2 Trigger Enable
*       Bit 1   Channel 3 Trigger Enable
*       Bit 2   Channel 4 Trigger Enable
*       Bit 3   Channel 5 Trigger Enable
*       Bit 4   Channel 0 Trigger Enable
*       Bit 5   Channel 1 Trigger Enable
*       Bit 6   Initialization Trigger Enable
*       Bit 8   Channel 6 Trigger Enable
*       Bit 9   Channel 7 Trigger Enable
*
* @param[in]    u8TriggerHostId - Hardware module
* @param[in]    u16TriggerMask - bit mask will be cleared to disable trigger with coresponding sources. 
*
* @return       void
*
*/
/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_DisableTrigger
(
    VAR(uint8, AUTOMATIC) u8TriggerHostId,
    VAR(uint16,AUTOMATIC) u16TriggerMask
)
{
  #if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    VAR(Std_ReturnType, AUTOMATIC)  CallIsValid;
#endif

#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    CallIsValid = Pwm_ValidateGlobalConfigCall(PWM_DISABLETRIGGER_ID);
    if((Std_ReturnType)E_OK == CallIsValid)
    {
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */

#if (PWM_PARAM_CHECK == STD_ON)
        if((Std_ReturnType)E_OK == Pwm_ValidateModuleId(u8TriggerHostId, PWM_DISABLETRIGGER_ID))
        {
            if ((Std_ReturnType)E_OK == Pwm_ValidateBitMask((uint32)u16TriggerMask, PWM_DISABLETRIGGER_ID))
            {
#endif /* (PWM_PARAM_CHECK == STD_ON) */                

                Pwm_Ipw_DisableTrigger(u8TriggerHostId, u16TriggerMask);

#if (PWM_PARAM_CHECK == STD_ON)                
            }
        }
#endif /* (PWM_PARAM_CHECK == STD_ON) */

#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateGlobalConfigCall(CallIsValid, PWM_DISABLETRIGGER_ID);
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
}
#endif /* PWM_DISABLE_TRIGEER_API */





#if (PWM_RESET_COUNTER_API == STD_ON)
/**
* @brief        This function shall enable the PWM timer HW counter reset
*               by Pwm_SyncUpdate() function.
* @details
*
*
* @param[in]    u8ModuleId - Hardware module
*
* @return       void
*
*/
/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_ResetCounterEnable
(
    VAR(uint8, AUTOMATIC) u8ModuleId
)
{
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    VAR(Std_ReturnType, AUTOMATIC)  CallIsValid;
#endif

#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    CallIsValid = Pwm_ValidateGlobalConfigCall(PWM_RESETCOUNTERENABLE_ID);
    if((Std_ReturnType)E_OK == CallIsValid)
    {
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */

#if (PWM_PARAM_CHECK == STD_ON)
        if((Std_ReturnType)E_OK == Pwm_ValidateModuleId((uint8)u8ModuleId, PWM_RESETCOUNTERENABLE_ID))
        {        
#endif /* (PWM_PARAM_CHECK == STD_ON) */
           Pwm_Ipw_ResetCounterEnable(u8ModuleId);
#if (PWM_PARAM_CHECK == STD_ON)
        }
#endif /* (PWM_PARAM_CHECK == STD_ON) */
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateGlobalConfigCall(CallIsValid, PWM_RESETCOUNTERENABLE_ID);
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */    
}


/**
* @brief        This function shall disable the PWM timer HW counter reset
*               by Pwm_SyncUpdate() function.
* @details
*
*
* @param[in]    u8ModuleId - Hardware module
*
* @return       void
*
*/
/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_ResetCounterDisable
(
    VAR(uint8, AUTOMATIC) u8ModuleId
)
{
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    VAR(Std_ReturnType, AUTOMATIC)  CallIsValid;
#endif

#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    CallIsValid = Pwm_ValidateGlobalConfigCall(PWM_RESETCOUNTERDISABLE_ID);
    if((Std_ReturnType)E_OK == CallIsValid)
    {
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */

#if (PWM_PARAM_CHECK == STD_ON)
        if((Std_ReturnType)E_OK == Pwm_ValidateModuleId((uint8)u8ModuleId, PWM_RESETCOUNTERDISABLE_ID))
        {        
#endif /* (PWM_PARAM_CHECK == STD_ON) */
           Pwm_Ipw_ResetCounterDisable(u8ModuleId);
#if (PWM_PARAM_CHECK == STD_ON)
        }
#endif /* (PWM_PARAM_CHECK == STD_ON) */
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateGlobalConfigCall(CallIsValid, PWM_RESETCOUNTERDISABLE_ID);
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */        
}
#endif /* PWM_RESET_COUNTER_API */


#if (PWM_ENABLE_MASKING_OPERATIONS == STD_ON)
/**
* @brief        This function force channels output to their inactive state
* @details      Corresponding bits with channel will be masked:
*       Bit 0   Channel 0 Output Mask
*       Bit 1   Channel 1 Output Mask
*       Bit 2   Channel 2 Output Mask
*       Bit 3   Channel 3 Output Mask
*       Bit 4   Channel 4 Output Mask
*       Bit 5   Channel 5 Output Mask
*       Bit 6   Channel 6 Output Mask
*       Bit 7   Channel 7 Output Mask
*
* @param[in]    u8ModuleId - Hardware module
* @param[in]    u8ChannelMask - bit mask will be set to mask coresponding channel. 
*
* @return       void
*
*/
/* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_MaskOutputs
(
    VAR(uint8 , AUTOMATIC)     u8ModuleId,
    VAR(uint8 , AUTOMATIC)     u8ChannelMask
)
{
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    VAR(Std_ReturnType, AUTOMATIC)  CallIsValid;
#endif

#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    CallIsValid = Pwm_ValidateGlobalConfigCall(PWM_MASKOUTPUT_ID);
    if((Std_ReturnType)E_OK == CallIsValid)
    {
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */

#if (PWM_PARAM_CHECK == STD_ON)
        if((Std_ReturnType)E_OK == Pwm_ValidateModuleId(u8ModuleId, PWM_MASKOUTPUT_ID))
        {        
#endif /* (PWM_PARAM_CHECK == STD_ON) */
           Pwm_Ipw_MaskOutputs(u8ModuleId,u8ChannelMask);
#if (PWM_PARAM_CHECK == STD_ON)
        }
#endif /* (PWM_PARAM_CHECK == STD_ON) */
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateGlobalConfigCall(CallIsValid, PWM_MASKOUTPUT_ID);
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
}

/**
* @brief        This function puts channels output to normal operation state
* @details      Corresponding bits with channel will be masked:
*       Bit 0   Channel 0 Output Mask
*       Bit 1   Channel 1 Output Mask
*       Bit 2   Channel 2 Output Mask
*       Bit 3   Channel 3 Output Mask
*       Bit 4   Channel 4 Output Mask
*       Bit 5   Channel 5 Output Mask
*       Bit 6   Channel 6 Output Mask
*       Bit 7   Channel 7 Output Mask
*
* @param[in]    u8ModuleId - Hardware module
* @param[in]    u8ChannelMask - bit mask will be cleared to un-mask coresponding channel.
*
* @return       void
*
*/
/* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_UnMaskOutputs
(
    VAR(uint8 , AUTOMATIC)     u8ModuleId,
    VAR(uint8 , AUTOMATIC)     u8ChannelMask
)
{
  #if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    VAR(Std_ReturnType, AUTOMATIC)  CallIsValid;
#endif

#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    CallIsValid = Pwm_ValidateGlobalConfigCall(PWM_UNMASKOUTPUT_ID);
    if((Std_ReturnType)E_OK == CallIsValid)
    {
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */

#if (PWM_PARAM_CHECK == STD_ON)
        if((Std_ReturnType)E_OK == Pwm_ValidateModuleId((uint8)u8ModuleId, PWM_UNMASKOUTPUT_ID))
        {        
#endif /* (PWM_PARAM_CHECK == STD_ON) */
           Pwm_Ipw_UnMaskOutputs(u8ModuleId,u8ChannelMask);
#if (PWM_PARAM_CHECK == STD_ON)
        }
#endif /* (PWM_PARAM_CHECK == STD_ON) */
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateGlobalConfigCall(CallIsValid, PWM_UNMASKOUTPUT_ID);
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
}
#endif /* PWM_ENABLE_MASKING_OPERATIONS */

/*===============================================================================================*/
#if (PWM_RELOAD_NOTIF_SUPPORTED == STD_ON)
/**
* @brief            This function enables the user reload notifications.
* @details          The function Pwm_EnableReloadNotification shall enable the PWM reload notification
*                   If development error detection for the Pwm module is enabled:
*                   - The PWM functions shall check the parameter u8ModuleId and raise
*                   development error PWM_E_PARAM_INSTANCE if the parameter u8ModuleId is invalid.
*
*                   If development error detection for the Pwm module is enabled, when a development error
*                   occurs, the corresponding PWM function shall:
*
*                       - Report the error to the Development Error Tracer.
*                       - Skip the desired functionality in order to avoid any corruptions of
*                           data or hardware registers (this means leave the function without any actions).
*                       - Return pwm level low for the function Pwm_GetOutputState.
*
*                   If the PwmDevErorDetect switch is enabled, API parameter checking is enabled.
*                   The detailed description of the detected errors can be found in chapter
*                   Error classification and chapter API specification (see PWM_SWS).
*
*                   If development error detection for the Pwm module is enabled, if any function
*                   (except Pwm_Init) is called before Pwm_Init has been called, the called function
*                   shall raise development error PWM_E_UNINIT.
*
* @param[in]        u8ModuleId - pwm hardware module id
*
* @return           void
*
* @api
*
*/
/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_EnableReloadNotification
(
    VAR(uint8 , AUTOMATIC)     u8ModuleId
)
{
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    VAR(Std_ReturnType, AUTOMATIC)  CallIsValid;
#endif
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    CallIsValid = Pwm_ValidateGlobalConfigCall(PWM_ENABLERELOADNOTIF_ID);
    if((Std_ReturnType)E_OK == CallIsValid)
    {
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
#if (PWM_PARAM_CHECK == STD_ON)
        if((Std_ReturnType)E_OK == Pwm_ValidateModuleId((uint8)u8ModuleId, PWM_ENABLERELOADNOTIF_ID))
        {
#endif
            /* All validations passed. Here starts the actual
            functional code of the function */
            Pwm_Ipw_EnableReloadNotification(u8ModuleId);
#if (PWM_PARAM_CHECK == STD_ON)
        }
#endif /* (PWM_PARAM_CHECK == STD_ON) */
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateGlobalConfigCall(CallIsValid, PWM_ENABLERELOADNOTIF_ID);
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
} 

/**
* @brief            This function enables the user reload notifications.
* @details          The function Pwm_DisableReloadNotification shall disable the PWM reload notification
*                   If development error detection for the Pwm module is enabled:
*                   - The PWM functions shall check the parameter u8ModuleId and raise
*                   development error PWM_E_PARAM_INSTANCE if the parameter u8ModuleId is invalid.
*
*                   If development error detection for the Pwm module is enabled, when a development error
*                   occurs, the corresponding PWM function shall:
*
*                       - Report the error to the Development Error Tracer.
*                       - Skip the desired functionality in order to avoid any corruptions of
*                           data or hardware registers (this means leave the function without any actions).
*                       - Return pwm level low for the function Pwm_GetOutputState.
*
*                   If the PwmDevErorDetect switch is enabled, API parameter checking is enabled.
*                   The detailed description of the detected errors can be found in chapter
*                   Error classification and chapter API specification (see PWM_SWS).
*
*                   If development error detection for the Pwm module is enabled, if any function
*                   (except Pwm_Init) is called before Pwm_Init has been called, the called function
*                   shall raise development error PWM_E_UNINIT.
*
* @param[in]        u8ModuleId - pwm hardware module id
*
* @return           void
*
* @api
*
*/
/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_DisableReloadNotification
(
    VAR(uint8 , AUTOMATIC)     u8ModuleId
)
{
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    VAR(Std_ReturnType, AUTOMATIC)  CallIsValid;
#endif
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    CallIsValid = Pwm_ValidateGlobalConfigCall(PWM_DISABLERELOADNOTIF_ID);
    if((Std_ReturnType)E_OK == CallIsValid)
    {
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
#if (PWM_PARAM_CHECK == STD_ON)
        if((Std_ReturnType)E_OK == Pwm_ValidateModuleId((uint8)u8ModuleId, PWM_DISABLERELOADNOTIF_ID))
        {
#endif
            /* All validations passed. Here starts the actual
            functional code of the function */
            Pwm_Ipw_DisableReloadNotification(u8ModuleId);
#if (PWM_PARAM_CHECK == STD_ON)
        }
#endif /* (PWM_PARAM_CHECK == STD_ON) */
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    }
    /*
    * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
    * one side efect however executed, or b)cause control flow to change.
    */
    Pwm_EndValidateGlobalConfigCall(CallIsValid, PWM_DISABLERELOADNOTIF_ID);
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
} 

#endif /* PWM_RELOAD_NOTIF_SUPPORTED */

#if (PWM_POWER_STATE_SUPPORTED == STD_ON)
/**
* @brief          Enters the already prepared power state.
* @details        This API configures the Pwm module so that it enters the already prepared power 
*                 state, chosen between a predefined set of configured ones.
*
* @param[out]     Result        Pointer to a variable to store the result of this function
*                 
* @return         Std_ReturnType  Standard return type.
* @retval         E_OK:           Power Mode changed.
* @retval         E_NOT_OK:       Request rejected.
*
* @implements     Pwm_SetPowerState_Activity
*/
/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(Std_ReturnType, PWM_CODE) Pwm_SetPowerState
(
    P2VAR(Pwm_PowerStateRequestResultType,   AUTOMATIC, PWM_APPL_DATA) pResult
)
{
    VAR(Std_ReturnType, AUTOMATIC)  nRetVal = (Std_ReturnType)E_OK;

    if(NULL_PTR == pResult)
    {
        nRetVal = (Std_ReturnType)E_NOT_OK;
        #if (PWM_PARAM_CHECK == STD_ON)
        Det_ReportError
        (
            (uint16) PWM_MODULE_ID,
            (uint8)  PWM_INDEX,
            (uint8)  PWM_SETPOWERSTATE_ID,
            (uint8)  PWM_E_PARAM_POINTER
        /** @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
         * the same and the value itself is not needed */
        );
        #endif
    }
    else
    {
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
        nRetVal = Pwm_ValidateGlobalConfigCall(PWM_SETPOWERSTATE_ID);
        if((Std_ReturnType)E_OK == nRetVal)
        {
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
            if(Pwm_eCurrentPowerState == Pwm_eTargetPowerState)
            {
                *pResult = PWM_SERVICE_ACCEPTED;
            }
            else
            {
                if(PWM_NODEFINE_POWER == Pwm_eTargetPowerState)
                {
                    #if (PWM_PARAM_CHECK == STD_ON)
                    Det_ReportError
                    (
                        (uint16) PWM_MODULE_ID,
                        (uint8)  PWM_INDEX,
                        (uint8)  PWM_SETPOWERSTATE_ID,
                        (uint8)  PWM_E_PERIPHERAL_NOT_PREPARED
                    /** @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
                      * the same and the value itself is not needed */
                    );
                    #endif
                    *pResult = PWM_SEQUENCE_ERROR;
                    nRetVal = (Std_ReturnType)E_NOT_OK;
                }
                else
                {
                    if((PWM_LOW_POWER != Pwm_eTargetPowerState) && (PWM_FULL_POWER != Pwm_eTargetPowerState))
                    {
                        #if (PWM_PARAM_CHECK == STD_ON)
                        Det_ReportError
                        (
                            (uint16) PWM_MODULE_ID,
                            (uint8)  PWM_INDEX,
                            (uint8)  PWM_SETPOWERSTATE_ID,
                            (uint8)  PWM_E_POWER_STATE_NOT_SUPPORTED
                        /** @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
                          * the same and the value itself is not needed */
                        );
                        #endif

                        *pResult = PWM_POWER_STATE_NOT_SUPP;
                        nRetVal = (Std_ReturnType)E_NOT_OK;
                    }
                    else
                    {
                        nRetVal = Pwm_ValidateIdleState(&Pwm_pConfig->IpConfig);
                        if((Std_ReturnType)E_OK == nRetVal)
                        {
                            Pwm_Ipw_SetPowerState(&Pwm_pConfig->IpConfig, Pwm_eTargetPowerState);
                            *pResult = PWM_SERVICE_ACCEPTED;
                            Pwm_eCurrentPowerState = Pwm_eTargetPowerState;
                            Pwm_eTargetPowerState = PWM_NODEFINE_POWER;
                        }
                        else
                        {
                            #if (PWM_PARAM_CHECK == STD_ON)
                             Det_ReportRuntimeError
                            (
                                (uint16) PWM_MODULE_ID,
                                (uint8)  PWM_INDEX,
                                (uint8)  PWM_SETPOWERSTATE_ID,
                                (uint8)  PWM_E_NOT_DISENGAGED
                            /** @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
                              * the same and the value itself is not needed */
                            );
                             #endif
                            *pResult = PWM_HW_FAILURE;
                        }
                    }
                }
            }
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
        }
        else
        {
            *pResult = PWM_NOT_INIT;
        }
        /*
        * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
        * one side efect however executed, or b)cause control flow to change.
        */
        Pwm_EndValidateGlobalConfigCall(nRetVal, PWM_SETPOWERSTATE_ID);
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
    }
    return nRetVal;
}

/**
* @brief          Get the current power state of the Pwm HW unit.
* @details        This API returns the current power state of the Pwm HW unit.
*
* @param[out]     CurrentPowerState     The current power mode of the Pwm HW Unit is returned in this parameter
* @param[out]     Result                Pointer to a variable to store the result of this function
*                 
* @return         Std_ReturnType  Standard return type.
* @retval         E_OK:           Mode could be read.
* @retval         E_NOT_OK:       Service is rejected.
*
* @implements     Pwm_GetCurrentPowerState_Activity
*/
/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(Std_ReturnType, PWM_CODE) Pwm_GetCurrentPowerState
(
    P2VAR(Pwm_PowerStateType,                AUTOMATIC, PWM_APPL_DATA) pCurrentPowerState,
    P2VAR(Pwm_PowerStateRequestResultType,   AUTOMATIC, PWM_APPL_DATA) pResult
)
{
    VAR(Std_ReturnType, AUTOMATIC)  nRetVal = (Std_ReturnType)E_OK;

    if((NULL_PTR == pResult) || (NULL_PTR == pCurrentPowerState))
    {
        nRetVal = (Std_ReturnType)E_NOT_OK;
        #if (PWM_PARAM_CHECK == STD_ON)
        Det_ReportError
        (
            (uint16) PWM_MODULE_ID,
            (uint8)  PWM_INDEX,
            (uint8)  PWM_GETCURRENTPOWERSTATE_ID,
            (uint8)  PWM_E_PARAM_POINTER
        /** @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
         * the same and the value itself is not needed */
        );
        #endif
    }
    else
    {
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
        nRetVal = Pwm_ValidateGlobalConfigCall(PWM_GETCURRENTPOWERSTATE_ID);
        if((Std_ReturnType)E_OK == nRetVal)
        {
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
            *pCurrentPowerState = Pwm_eCurrentPowerState;
            *pResult = PWM_SERVICE_ACCEPTED;
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
        }
        else
        {
            *pResult = PWM_NOT_INIT;
        }
        /*
        * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
        * one side efect however executed, or b)cause control flow to change.
        */
        Pwm_EndValidateGlobalConfigCall(nRetVal, PWM_GETCURRENTPOWERSTATE_ID);
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
    }
    return nRetVal;
}

/**
* @brief          Get the target power state of the Pwm HW unit.
* @details        This API returns the target power state of the Pwm HW unit.
*
* @param[out]     TargetPowerState      The Target power mode of the Pwm HW Unit is returned in this parameter.
* @param[out]     Result                Pointer to a variable to store the result of this function.
*                 
* @return         Std_ReturnType  Standard return type.
* @retval         E_OK:           Mode could be read.
* @retval         E_NOT_OK:       Service is rejected.
*
* @implements     Pwm_GetTargetPowerState_Activity
*/
/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(Std_ReturnType, PWM_CODE) Pwm_GetTargetPowerState
(
    P2VAR(Pwm_PowerStateType,                AUTOMATIC, PWM_APPL_DATA) pTargetPowerState,
    P2VAR(Pwm_PowerStateRequestResultType,   AUTOMATIC, PWM_APPL_DATA) pResult
)
{
    VAR(Std_ReturnType, AUTOMATIC)  nRetVal = (Std_ReturnType)E_OK;

#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
    VAR(Std_ReturnType, AUTOMATIC)  CallIsValid;
#endif

    if((NULL_PTR == pResult) || (NULL_PTR == pTargetPowerState))
    {
        nRetVal = (Std_ReturnType)E_NOT_OK;
        #if (PWM_PARAM_CHECK == STD_ON)
        Det_ReportError
        (
            (uint16) PWM_MODULE_ID,
            (uint8)  PWM_INDEX,
            (uint8)  PWM_GETTARGETPOWERSTATE_ID,
            (uint8)  PWM_E_PARAM_POINTER
        /** @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
         * the same and the value itself is not needed */
        );
        #endif
    }
    else
    {
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
        CallIsValid = Pwm_ValidateGlobalConfigCall(PWM_GETTARGETPOWERSTATE_ID);
        if((Std_ReturnType)E_OK == CallIsValid)
        {
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
            *pTargetPowerState = Pwm_eTargetPowerState;
            *pResult = PWM_SERVICE_ACCEPTED;

#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
        }
        else
        {
            nRetVal = (Std_ReturnType)E_NOT_OK;
            *pResult = PWM_NOT_INIT;
        }
        /*
        * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
        * one side efect however executed, or b)cause control flow to change.
        */
        Pwm_EndValidateGlobalConfigCall(CallIsValid, PWM_GETTARGETPOWERSTATE_ID);
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
    }
    return nRetVal;
}

/**
* @brief          Starts the needed process to allow the Pwm HW module to enter the requested power state.
* @details        This API starts the needed process to allow the Pwm HW module to enter the requested power state.
*
* @param[in]      PowerState      The target power state intended to be attained.
* @param[out]     Result          Pointer to a variable to store the result of this function.
*                 
* @return         Std_ReturnType  Standard return type.
* @retval         E_OK:           Mode could be read.
* @retval         E_NOT_OK:       Service is rejected.
*
* @implements     Pwm_PreparePowerState_Activity
*/
/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(Std_ReturnType, PWM_CODE) Pwm_PreparePowerState
(
    VAR(Pwm_PowerStateType,                  AUTOMATIC)                ePowerState,
    P2VAR(Pwm_PowerStateRequestResultType,   AUTOMATIC, PWM_APPL_DATA) pResult
)
{
    VAR(Std_ReturnType, AUTOMATIC)  nRetVal = (Std_ReturnType)E_OK;

    if(NULL_PTR == pResult)
    {
        nRetVal = (Std_ReturnType)E_NOT_OK;
        #if (PWM_PARAM_CHECK == STD_ON)
        Det_ReportError
        (
            (uint16) PWM_MODULE_ID,
            (uint8)  PWM_INDEX,
            (uint8)  PWM_PREPAREPOWERSTATE_ID,
            (uint8)  PWM_E_PARAM_POINTER
        /** @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
         * the same and the value itself is not needed */
        );
        #endif
    }
    else
    {
#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
        nRetVal = Pwm_ValidateGlobalConfigCall(PWM_PREPAREPOWERSTATE_ID);
        if((Std_ReturnType)E_OK == nRetVal)
        {
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
            if(Pwm_eCurrentPowerState != ePowerState)
            {
                if((PWM_LOW_POWER != ePowerState) && (PWM_FULL_POWER != ePowerState))
                {
                    *pResult = PWM_POWER_STATE_NOT_SUPP;
                    nRetVal = (Std_ReturnType)E_NOT_OK;
    
                    #if (PWM_PARAM_CHECK == STD_ON)
                    Det_ReportError
                    (
                        (uint16) PWM_MODULE_ID,
                        (uint8)  PWM_INDEX,
                        (uint8)  PWM_PREPAREPOWERSTATE_ID,
                        (uint8)  PWM_E_POWER_STATE_NOT_SUPPORTED
                    /** @violates @ref Pwm_C_REF_9 Ignore value is ignored as return value is always 
                      * the same and the value itself is not needed */
                    );
                    #endif
                }
                else
                {
                    *pResult = PWM_SERVICE_ACCEPTED;
                    Pwm_eTargetPowerState = ePowerState;
                }
            }
            else
            {
                *pResult = PWM_SEQUENCE_ERROR;
                nRetVal = (Std_ReturnType)E_NOT_OK;
            }

#if (PWM_VALIDATE_GLOBAL_CONFIG_CALL == STD_ON)
        }
        else
        {
            *pResult = PWM_NOT_INIT;
        }
        /*
        * @violates @ref Pwm_C_REF_5 All non-null statements shall either a)have at least
        * one side efect however executed, or b)cause control flow to change.
        */
        Pwm_EndValidateGlobalConfigCall(nRetVal, PWM_PREPAREPOWERSTATE_ID);
#endif /* PWM_VALIDATE_GLOBAL_CONFIG_CALL */
    }
    return nRetVal;
}

/**
* @brief          Cyclically called and supervises the power state transitions.
* @details        This API is cyclically called and supervises the power state transitions, checking
*                 for the readiness of the module and issuing the callbacks.
* @param[in]      none
* @param[out]     none
*                 
* @return         none
*
*/
/*
* @violates @ref Pwm_C_REF_2 external ... could be made static
*/
FUNC(void, PWM_CODE) Pwm_Main_PowerTransitionManager
(
    void
)
{

}
#endif /*PWM_POWER_STATE_SUPPORTED*/


#define PWM_STOP_SEC_CODE
/*
* @violates @ref Pwm_C_REF_1 Only preprocessor statements and comments before "#include"
*/
/*
* @violates @ref Pwm_C_REF_4 precautions to prevent the contents
*        of a header file being included twice
*/
#include "Pwm_MemMap.h"

#ifdef __cplusplus
}
#endif

/** @} */