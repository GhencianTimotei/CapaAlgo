/*
 *!
 * \defgroup <module_group (MOD_SERV_TIME_SERVICE)>
 * \{
 ******************************************************************************
 * \image html "Kopf_oZusatz_A4hoch_4C.jpg"
 *
 * \par Module Owner:
 *   Huf H&uuml;lsbeck & F&uuml;rst GmbH & Co. KG \n
 *   Steeger Str. 17 \n
 *   42551 Velbert \n
 *   Department PDE-S
 *
 ******************************************************************************
 *
 * \par Purpose:
 *    Time Service module , SERV Layer
 *
 * \par Compiler:
 *    ANSI compiler
 *
 * \par Controller:
 *   independent controller
 *
 * \par Resources:
 *    | Resource      | Amount    | Remarks     |
 *    | ------------- | --------: | ----------- |
 *    | ROM           |  X Byte   |             |
 *    | RAM           |  X Byte   |             |
 *    | EEPROM        |  X Byte   |             |
 *    | Runtime Init  |    X ms   |             |
 *    | Runtime Task  |    X ms   |             |
 *
 * \par Quality:
 *    | Factor            | Excl  | Good  | Fair  | Poor  |
 *    | ----------------- | ----: | ----: | ----: | ----: |
 *    | _Maintainability_ |   0 % |   0 % |   0 % |   0 % |
 *    | Analyzability     |   0 % |   0 % |   0 % |   0 % |
 *    | Changeability     |   0 % |   0 % |   0 % |   0 % |
 *    | Stability         |   0 % |   0 % |   0 % |   0 % |
 *    | Testability       |   0 % |   0 % |   0 % |   0 % |
 *
 * \par MISRA rules violations:
 *     \li none(?)
 *
 ******************************************************************************
 *
 * \attention
 *   \li text for Information, to do ..
 *
 ******************************************************************************
 * %PCMS_HEADER_SUBSTITUTION_START:%
 *
 * Document Management Information Log (generated by Dimensions CM)
 *
 *
 *  CM Item:   %PID:%
 * Itemname:   %PM:%
 *  Location:  %ARCHIVE:%
 *  Revision:  %PR:%
 *  Date:      %DATE:%
 *  Author:    %AUTHOR:%
 *
 * %PCMS_HEADER_SUBSTITUTION_END:%
 *
 ******************************************************************************/
/*!
 \defgroup module_group_det Details
 \ingroup module_group
 \{
 */

/* Provide interface */
/* ----------------- */

#include "TimeService.h"

/* polyspace +3 MISRA-C3:5.1 [Not a defect:Unset] "Array variables are named according to Huf Specifications" */
#if( TM_16BIT_TIMER_ENABLE == STD_ON )
/* Array structure define to save the 16 bits software timers configured by the user*/
static Tm_SoftwareTimer1us16bitType Tm_GlobalTimers16bit_AS[NO_OF_16BIT_SWT_U8];
#endif /* TM_16BIT_TIMER_ENABLE == STD_ON */

#if( TM_32BIT_TIMER_ENABLE == STD_ON )
/* Array structure define to save the 32 bits software timers configured by the user*/
static Tm_SoftwareTimer1us32bitType Tm_GlobalTimers32bit_AS[NO_OF_32BIT_SWT_U8];
/* Internal free running timer on 32bit */
static U32 Tm_SoftwareTimer_U32;
#endif /* TM_32BIT_TIMER_ENABLE == STD_ON */

#if (TM_SLOW_TIMER_ENABLE == STD_ON)
/* Array structure define to save the slow 1ms software timers configured by the user*/
static Tm_SoftwareTimerSlow1msType Tm_GlobalTimers1ms_AS[NO_OF_SLOW_SWT_U8];
/* Variable holding data about current time */
static Tm_1ms_Type Tm_1ms_UT;
#endif /* #if (TM_SLOW_TIMER_ENABLE == STD_ON) */

/* Private functions declaration */
#if( TM_16BIT_TIMER_ENABLE == STD_ON )
static Std_ReturnType ltm_CheckTimer16bit( U8 TimerIdx_U8 ) ;
#endif /* TM_16BIT_TIMER_ENABLE == STD_ON */

#if( TM_32BIT_TIMER_ENABLE == STD_ON )
static Std_ReturnType ltm_CheckTimer32bit( U8 TimerIdx_U8 ) ;
static void ltm_Check_Time( void );
#endif /* TM_32BIT_TIMER_ENABLE == STD_ON */

/* polyspace-begin MISRA-C3:5.1 [Not a defect:Unset] "Functions are named according to Autosar and Huf Specifications" */
/******************************************************************************
 * \brief
 * Resets a timer instance (user point of view).
 *
 * \details
 * The function resets a timer by saving the current value of the predefined hardware timer.
 *
 ******************************************************************************
 *
 * \sync          Synchronous
 * \reent         Reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[in]              TimerPtr: [In] Tm_PredefTimer1us16bitType * - : Pointer to a timer instance defined by the user.
 * \param[in]              none

 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \retval        Std_ReturnType  - E_OK: The underlying GPT driver service has returned E_OK
 *                                           and no development error has been detected
 *                                  E_NOT_OK: The underlying GPT driver service has returned E_NOT_OK,
 *                                           or a development error has been detected
 *
 ******************************************************************************
 *
 * \author        BSW
 * \version       1.0
 * \date          29.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 22.05.2020, BSW:
 *       -
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* [BSW_SWS_TimeService_005],[BSW_SWS_TimeService_047] */
/* polyspace +1 MISRA-C3:8.7 [Not a defect:Unset] "Function may be called by the user when the module is integrated." */
Std_ReturnType Tm_ResetTimer1us16bit(Tm_PredefTimer1us16bitType* TimerPtr )
{
   Std_ReturnType A_RetVal = E_NOT_OK;
   if( TimerPtr != NULL )
   {
      /*[BSW_SWS_TimeService_003] */
      A_RetVal = Gpt_GetPredefTimerValue(TimerPtr->Channel, &TimerPtr->ReferenceTime);  /* Gets the current value of the free running hardware timer and sets it as the reference time for the timer. */
   }
   else
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if TimerPtr is NULL" */
   {
      A_RetVal = E_NOT_OK;
   }

   return A_RetVal;
}

/******************************************************************************
 * \brief
 * Delivers the time difference (current time - reference time).
 *
 * \details
 * The function reads the current value of the predefined hardware timer an returns the difference between current time and reference time.
 *
 ******************************************************************************
 *
 * \sync          Synchronous
 * \reent         Reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[in]              TimerPtr: [In] Tm_PredefTimer1us16bitType * - : Pointer to a timer instance defined by the user.
 * \param[out]             TimeSpanPtr: [Out]  U16 * - Pointer to time span destination data in RAM.

 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \retval        Std_ReturnType  - E_OK: The underlying GPT driver service has returned E_OK
 *                                           and no development error has been detected
 *                                - E_NOT_OK: The underlying GPT driver service has returned E_NOT_OK,
 *                                           or a development error has been detected
 *
 ******************************************************************************
 *
 * \author        BSW
 * \version       1.0
 * \date          29.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 22.05.2020, BSW:
 *       -
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* [BSW_SWS_TimeService_009],[BSW_SWS_TimeService_048] */
Std_ReturnType Tm_GetTimeSpan1us16bit(const Tm_PredefTimer1us16bitType* TimerPtr, U16* TimeSpanPtr )
{
   Tm_PredefTimerRefTimeType A_Tm_CurrentTime_UT = 0u;
   Std_ReturnType A_RetVal = E_NOT_OK;
   if ( ( TimerPtr != NULL ) && ( TimeSpanPtr != NULL ))
   {
      /*  [BSW_SWS_TimeService_006], [BSW_SWS_TimeService_007] */
      A_RetVal = Gpt_GetPredefTimerValue(TimerPtr->Channel , &A_Tm_CurrentTime_UT); /* Gets the current time value */
      /* polyspace +1 MISRA-C3:14.3 RTE:UNR DEFECT:USELESS_IF [Not a defect:Unset] "Code is reachable under normal usage of the module." */
      if( A_RetVal == E_OK)
      {
         /* polyspace +1 RTE:OVFL MISRA-C3:D4.1 [Not a defect:Unset] "Overflow is an expected outcome for the addition and subtraction operations on this timers." */
         * TimeSpanPtr = (U16)( A_Tm_CurrentTime_UT - TimerPtr->ReferenceTime ); /* Calculate the time span as the difference between the current time and the reference time. */
      /* polyspace +3 RTE:UNR MISRA-C3:2.1 [Not a defect:Unset] "The code is reachable if Gpt_GetPredefTimerValue() returns E_NOT_OK" */
      }
      else
      {
         /* [BSW_SWS_TimeService_010] */
         * TimeSpanPtr = 0u; /* When an error is detected and the parameter TimeSpanPtr is not a null pointer, the GetTimeSpan functions shall deliver the time span "0" */
      }
   }
   else
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if TimerPtr or TimeSpanPtr is NULL" */
   {
      A_RetVal = E_NOT_OK;
   }
   return A_RetVal;
}

/******************************************************************************
 * \brief
 * Shifts the reference time of the timer instance.
 *
 * \details
 * The function adds to the reference time the time span given by the user.
 *
 ******************************************************************************
 *
 * \sync          Synchronous
 * \reent         Reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[in]              TimerPtr: [In] Tm_PredefTimer1us16bitType * - : Pointer to a timer instance defined by the user.
 * \param[in]              TimeValue : [In] U16 - : Time value in µs, the reference time has to be shifted.
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \retval        Std_ReturnType  - E_OK: The underlying GPT driver service has returned E_OK
 *                                           and no development error has been detected
 *                                - E_NOT_OK: The underlying GPT driver service has returned E_NOT_OK,
 *                                           or a development error has been detected
 *
 ******************************************************************************
 *
 * \author        BSW
 * \version       1.0
 * \date          29.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 22.05.2020, BSW:
 *       -
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* [BSW_SWS_TimeService_049] */
void Tm_ShiftTimer1us16bit( Tm_PredefTimer1us16bitType * TimerPtr, U16 TimeValue )
{
   /*[BSW_SWS_TimeService_011],[BSW_SWS_TimeService_012]*/
   /* polyspace +1 RTE:OVFL MISRA-C3:D4.1 [Not a defect:Unset] "Overflow is an expected outcome for the addition and subtraction operations on this timers." */
   TimerPtr->ReferenceTime =(U16)( TimeValue + TimerPtr->ReferenceTime ); /* TimerValue is added to the reference time to shift the timer */
}

/******************************************************************************
 * \brief
 * Synchronizes two timer instances.
 *
 * \details
 * The function copies the reference time from the source timer to the destination timer.
 *
 ******************************************************************************
 *
 * \sync          Synchronous
 * \reent         Reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[in]              TimerSrcPtr: [In] const Tm_PredefTimer1us16bitTyp - : Pointer to the source timer instance defined by the user.
 * \param[out]             TimerDstPtr : [Out] Tm_PredefTimer1us16bitType* - : Pointer to the destination timer instance defined by the user.
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \retval     void
 *
 ******************************************************************************
 *
 * \author        BSW
 * \version       1.0
 * \date          29.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 22.05.2020, BSW:
 *       -
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* [BSW_SWS_TimeService_050] */
void Tm_SyncTimer1us16bit( Tm_PredefTimer1us16bitType * TimerDstPtr,const Tm_PredefTimer1us16bitType* TimerSrcPtr )
{
   /*[BSW_SWS_TimeService_014] */
   TimerDstPtr->ReferenceTime = TimerSrcPtr->ReferenceTime; /*The reference time from the destination timer is set to the refence time of the source timer. */
}

/******************************************************************************
 * \brief
 * Performs busy waiting by polling with a guaranteed minimum waiting time.
 *
 * \details
 * The function reads the current value of the predefined hardware timer in a loop, waiting for a minimum time to pass.
 *
 ******************************************************************************
 *
 * \sync          Synchronous
 * \reent         Reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[in]              WaitingTimeMin  [In] U8 - : Minimum waiting time in microseconds
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \retval     Std_ReturnType  - E_OK: The underlying GPT driver service has returned E_OK
 *                                           and no development error has been detected
 *                             - E_NOT_OK: The underlying GPT driver service has returned E_NOT_OK,
 *                                           or a development error has been detected
 *
 ******************************************************************************
 *
 * \author        BSW
 * \version       1.0
 * \date          29.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 22.05.2020, BSW:
 *       -
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/*[BSW_SWS_TimeService_016],[BSW_SWS_TimeService_017],[BSW_SWS_TimeService_018],[BSW_SWS_TimeService_051] */
Std_ReturnType Tm_BusyWait1us16bit( U8 WaitingTimeMin )
{
   Tm_PredefTimer1us16bitType  TimerPtr;
   Std_ReturnType A_RetVal = E_NOT_OK;
   Tm_PredefTimerRefTimeType A_Tm_CurrentTime_UT = 0u;
   TimerPtr.Channel = PREDEFINED_TIMER;
   TimerPtr.ReferenceTime = 0u;
   A_RetVal = Tm_ResetTimer1us16bit(&TimerPtr); /* Resets timer.*/
   if ( A_RetVal == E_OK)
   {
      do
      {
         A_RetVal = Gpt_GetPredefTimerValue(TimerPtr.Channel , &A_Tm_CurrentTime_UT); /* Gets the current time value */
      }
      /* polyspace +2 RTE:OVFL MISRA-C3:D4.1 [Not a defect:Unset] "Overflow is an expected outcome for the addition and subtraction operations on this timers." */
      /* [BSW_SWS_TimeService_020] */
      while((((U16)(A_Tm_CurrentTime_UT - TimerPtr.ReferenceTime)) <  WaitingTimeMin)&&( A_RetVal == E_OK)); /* Busy waits for minimum waiting time, while no error is detected. */
   }
   else
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if Tm_ResetTimer1us16bit returns E_NOT_OK" */
   {
      /* In case Tm_ResetTimer1us16bit() returns E_NOT_OK , do nothing */
   }
   return A_RetVal;
}


#if ( TM_16BIT_TIMER_ENABLE == STD_ON )


/******************************************************************************
 * \brief
 * Starts a timer instance with set value
 *
 * \details
 * The function changes the selected timer to TM_RUNNING MODE. Also it sets the minimum time in microseconds that
 * the timer must run before being set to TM_READY.
 *
 *
 ******************************************************************************
 *
 * \sync          Synchronous
 * \reent         Reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[in]              TimerIdx_U8  [In] U8 - : The index of the timer that the user wants to start
 * \param[in]              Value_U16  [In] U16 - : The time in microseconds that the timer must run.
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \retval     Std_ReturnType  - E_OK: The underlying GPT driver service has returned E_OK
 *                                           and no development error has been detected
 *                             - E_NOT_OK: The underlying GPT driver service has returned E_NOT_OK,
 *                                           or a development error has been detected
 *
 ******************************************************************************
 *
 * \author        BSW
 * \version       1.0
 * \date          29.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 22.05.2020, BSW:
 *       -
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* [BSW_SWS_TimeService_023],[BSW_SWS_TimeService_052]*/
Std_ReturnType Tm_StartTimer16bit( U8 TimerIdx_U8, U16 Value_U16 )
{
   Tm_PredefTimerRefTimeType A_Tm_CurrentTime_UT = 0u;
   Std_ReturnType A_RetVal = E_NOT_OK;
   /* [BSW_SWS_TimeService_022] */
   SuspendAllInterrupts();
   if(TimerIdx_U8 < NO_OF_16BIT_SWT_U8)
   {
      /*[BSW_SWS_TimeService_021]*/
      Tm_GlobalTimers16bit_AS[TimerIdx_U8].Value = Value_U16; /* Sets the value of the 16bit timer */
      Tm_GlobalTimers16bit_AS[TimerIdx_U8].TimerState = TM_RUNNING;/* Sets the state of the 16bit time to TM_RUNNING */
      A_RetVal = Gpt_GetPredefTimerValue(PREDEFINED_TIMER , &A_Tm_CurrentTime_UT); /* Gets the current time value */
      Tm_GlobalTimers16bit_AS[TimerIdx_U8].HWRTicks = A_Tm_CurrentTime_UT ; /*Sets current time as the reference time of the 16bit timer. */
   }
   else
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if TimerIdx_U8 is not defined" */
   {
      A_RetVal = E_NOT_OK;
   }
   ResumeAllInterrupts();
   return A_RetVal;
}

/******************************************************************************
 * \brief
 * Stops a timer instance.
 *
 * \details
 * The function changes the timer instance status to TM_STOPPED.
 *
 ******************************************************************************
 *
 * \sync          Synchronous
 * \reent         Reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[in]              TimerIdx_U8  [In] U8 - : The index of the timer that the user wants to stop
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \retval     Std_ReturnType  - E_OK: No development error has been detected
 *                             - E_NOT_OK: A development error has been detected
 *
 ******************************************************************************
 *
 * \author        BSW
 * \version       1.0
 * \date          29.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 22.05.2020, BSW:
 *       -
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* [BSW_SWS_TimeService_027],[BSW_SWS_TimeService_053]*/
Std_ReturnType Tm_StopTimer16bit( U8 TimerIdx_U8 )
{
   Std_ReturnType A_RetVal = E_NOT_OK;
   /* [BSW_SWS_TimeService_026]*/
   SuspendAllInterrupts();
   if(TimerIdx_U8 < NO_OF_16BIT_SWT_U8)
   {
      /* [BSW_SWS_TimeService_025]*/
      Tm_GlobalTimers16bit_AS[TimerIdx_U8].TimerState = TM_STOPPED;/* Sets the state of the 16bit time to TM_STOPPED */
      A_RetVal = E_OK;
   }
   else
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if TimerIdx_U8 is not defined" */
   {
      A_RetVal = E_NOT_OK;
   }
   ResumeAllInterrupts();
   return A_RetVal;
}

/******************************************************************************
 * \brief
 * Gets the status of a timer instance.
 *
 * \details
 * The function returns the timer's status through the TimerStatus_PU8 parameter.
 *
 ******************************************************************************
 *
 * \sync          Synchronous
 * \reent         Reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[in]              TimerIdx_U8  [In] U8 - : The index of the timer that the user wants to check.
 * \param[out]             TimerStatus_PU8  [Out] U8 * - : The status of the timer instance.
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \retval     Std_ReturnType  - E_OK: The underlying GPT driver service has returned E_OK
 *                                           and no development error has been detected
 *                             - E_NOT_OK: The underlying GPT driver service has returned E_NOT_OK,
 *                                           or a development error has been detected
 *
 ******************************************************************************
 *
 * \author        BSW
 * \version       1.0
 * \date          29.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 22.05.2020, BSW:
 *       -
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* [BSW_SWS_TimeService_031],[BSW_SWS_TimeService_054] */
Std_ReturnType Tm_GetStatus16bit( U8 TimerIdx_U8 , U8 * TimerStatus_PU8 )
{
   Std_ReturnType A_RetVal = E_NOT_OK;
   /*[BSW_SWS_TimeService_030]*/
   SuspendAllInterrupts();
   /* polyspace +1 RTE:UNR [Not a defect:Unset] "The condition is important to check if TimerIdx_U8 is defined and TimerStatus_U8 is not NULL" */
   if((TimerIdx_U8 < NO_OF_16BIT_SWT_U8)&&(TimerStatus_PU8 != NULL))
   {
      A_RetVal = E_OK;
      if((Tm_GlobalTimers16bit_AS[TimerIdx_U8].TimerState)== TM_RUNNING)
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if the 16bit timer instance is running" */
      {
         A_RetVal = ltm_CheckTimer16bit(TimerIdx_U8 ); /*Checks if the timer had expired. */
      }
      else
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if the timer instance is not running." */
      {
         /* Do nothing, the timer is not running - no need to check if timer expired */
      }
      /*[BSW_SWS_TimeService_029]*/
      * TimerStatus_PU8 = Tm_GlobalTimers16bit_AS[TimerIdx_U8].TimerState;
   }
   else
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if TimerIdx_U8 is not defined or TimeStatus is NULL" */
   {
      A_RetVal = E_NOT_OK;
   }
   ResumeAllInterrupts();
   return A_RetVal;
}

/******************************************************************************
 * \brief
 * Changes the status of a 16bit timer instance in TM_READY.
 *
 * \details
 *
 *
 ******************************************************************************
 *
 * \sync          Synchronous
 * \reent         Reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[in]              TTimerIdx_U8  [In] U8 - : The index of the timer that the user wants to set to TM_READY.
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \retval    Std_ReturnType  - E_OK: No development error has been detected
 *                            - E_NOT_OK: A development error has been detected
 *
 ******************************************************************************
 *
 * \author        BSW
 * \version       1.0
 * \date          29.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 22.05.2020, BSW:
 *       -
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/*[BSW_SWS_TimeService_035],[BSW_SWS_TimeService_055]*/
Std_ReturnType Tm_SetReady16bit( U8 TimerIdx_U8 )
{
   Std_ReturnType A_RetVal = E_NOT_OK;
   /*[BSW_SWS_TimeService_030]*/
   SuspendAllInterrupts();
   if( TimerIdx_U8 < NO_OF_16BIT_SWT_U8)
   {
      /*[BSW_SWS_TimeService_033] */
      Tm_GlobalTimers16bit_AS[TimerIdx_U8].TimerState = TM_READY;/*Sets the timer's status to TM_READY. */
      A_RetVal = E_OK;
   }
   else
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if TimerIdx_U8 is not defined" */
   {
      A_RetVal = E_NOT_OK;
   }
   ResumeAllInterrupts();
   return A_RetVal;
}
#endif /* TM_16BIT_TIMER_ENABLE == STD_ON */

#if( TM_32BIT_TIMER_ENABLE == STD_ON )
/******************************************************************************
 * \brief
 * Starts a timer instance with set value
 *
 * \details
 * The function changes the selected timer to TM_RUNNING MODE. Also it sets the minimum time in microseconds that
 * the timer must run before being set to TM_READY.
 *
 ******************************************************************************
 *
 * \sync          Synchronous
 * \reent         Reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[in]              TimerIdx_U8  [In] U8 - : The index of the timer that the user wants to start
 * \param[in]              Value_U32  [In] U32 - : The time in microseconds that the timer must run.
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \retval     Std_ReturnType  - E_OK: The underlying GPT driver service has returned E_OK
 *                                           and no development error has been detected
 *                             - E_NOT_OK: The underlying GPT driver service has returned E_NOT_OK,
 *                                           or a development error has been detected
 *
 ******************************************************************************
 *
 * \author        BSW
 * \version       1.0
 * \date          29.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 22.05.2020, BSW:
 *       -
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* [BSW_SWS_TimeService_023],[BSW_SWS_TimeService_056]*/
Std_ReturnType Tm_StartTimer32bit( U8 TimerIdx_U8, U32 Value_U32 )
{
   Std_ReturnType A_RetVal = E_NOT_OK;
   U32 CurrentSoftwareTime = 0u;
   /*[BSW_SWS_TimeService_022]*/
   SuspendAllInterrupts();
   if(TimerIdx_U8 < NO_OF_32BIT_SWT_U8 )
   {
      if( Value_U32 <= 0x7FFFFFFF ) /*For the 32bit timer the maximum value is 0x7FFFFFFF. */
      {
         /*[BSW_SWS_TimeService_021]*/
         Tm_GlobalTimers32bit_AS[TimerIdx_U8].Value = Value_U32; /* Sets the value of the 32bit timer */
         Tm_GlobalTimers32bit_AS[TimerIdx_U8].TimerState = TM_RUNNING;/* Sets the state of the 32bit time to TM_RUNNING */
         A_RetVal = Tm_GetCurrentSoftwareTimer32bit( &CurrentSoftwareTime);/* Gets the current time of the free running 32bit timer. */
         Tm_GlobalTimers32bit_AS[TimerIdx_U8].HWRTicks = CurrentSoftwareTime;/*Sets current time as the reference time of the 32bit timer. */
      }
      else
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if Value_U32 > 0x7FFFFFFF" */
      {
         A_RetVal = E_NOT_OK;
      }
   }
   else
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if TimerIdx_U8 is not defined" */
   {
      A_RetVal = E_NOT_OK;
   }
   ResumeAllInterrupts();
   return A_RetVal;
}

/******************************************************************************
 * \brief
 * Stops a timer instance.
 *
 * \details
 * The function changes the timer instance status to TM_STOPPED.
 *
 ******************************************************************************
 *
 * \sync          Synchronous
 * \reent         Reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[in]              TimerIdx_U8  [In] U8 - : The index of the timer that the user wants to start
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \retval     Std_ReturnType  - E_OK: No development error has been detected
 *                             - E_NOT_OK: A development error has been detected
 *
 ******************************************************************************
 *
 * \author        BSW
 * \version       1.0
 * \date          29.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 22.05.2020, BSW:
 *       -
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* [BSW_SWS_TimeService_027],[BSW_SWS_TimeService_057]*/
Std_ReturnType Tm_StopTimer32bit( U8 TimerIdx_U8 )
{
   Std_ReturnType A_RetVal = E_NOT_OK;
   /* [BSW_SWS_TimeService_026]*/
   SuspendAllInterrupts();
   if(TimerIdx_U8 < NO_OF_32BIT_SWT_U8)
   {
      /* [BSW_SWS_TimeService_025]*/
      Tm_GlobalTimers32bit_AS[TimerIdx_U8].TimerState = TM_STOPPED;/* Sets the state of the 32bit time to TM_STOPPED */
      A_RetVal = E_OK;
   }
   else
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if TimerIdx_U8 is not defined" */
   {
      A_RetVal = E_NOT_OK;
   }
   ResumeAllInterrupts();
   return A_RetVal;
}


/******************************************************************************
 * \brief
 * Gets the status of a timer instance.
 *
 * \details
 * The function returns the timer's status through the TimerStatus_PU8 parameter.
 *
 ******************************************************************************
 *
 * \sync          Synchronous
 * \reent         Reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[in]              TimerIdx_U8  [In] U8 - : The index of the timer that the user wants to check.
 * \param[out]             TimerStatus_PU8  [Out] U8 * - : The status of the timer instance.
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \retval     Std_ReturnType  - E_OK: The underlying GPT driver service has returned E_OK
 *                                           and no development error has been detected
 *                             - E_NOT_OK: The underlying GPT driver service has returned E_NOT_OK,
 *                                           or a development error has been detected
 *
 ******************************************************************************
 *
 * \author        BSW
 * \version       1.0
 * \date          29.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 22.05.2020, BSW:
 *       -
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* [BSW_SWS_TimeService_031],[BSW_SWS_TimeService_058] */
Std_ReturnType Tm_GetStatus32bit( U8 TimerIdx_U8 , U8 * TimerStatus_PU8 )
{
   Std_ReturnType A_RetVal = E_NOT_OK;
   /*[BSW_SWS_TimeService_030]*/
   SuspendAllInterrupts();
   /* polyspace +1 RTE:UNR [Not a defect:Unset] "The condition is important to check if TimerIdx_U8 is defined and TimerStatus_PU8 is not NULL" */
   if((TimerIdx_U8 < NO_OF_32BIT_SWT_U8)&&(TimerStatus_PU8 != NULL))
   {
      A_RetVal = E_OK;
      if((Tm_GlobalTimers32bit_AS[TimerIdx_U8].TimerState)== TM_RUNNING)
         /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if the 32bit timer instance is running" */
      {
         A_RetVal = ltm_CheckTimer32bit(TimerIdx_U8 );/*Checks if the timer had expired. */
      }
      else
         /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if the timer instance is not running." */
      {
         /* Do nothing, the timer is not running -no need to check if timer expired */
      }
      /*[BSW_SWS_TimeService_029]*/
      * TimerStatus_PU8 = Tm_GlobalTimers32bit_AS[TimerIdx_U8].TimerState;
   }
   else
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if TimerIdx_U8 is not defined or TimerStatus is NULL" */
   {
      A_RetVal = E_NOT_OK;
   }
   ResumeAllInterrupts();
   return A_RetVal;
}

/******************************************************************************
 * \brief
 * Changes the status of a 32bit timer instance in TM_READY .
 *
 * \details
 *
 *
 ******************************************************************************
 *
 * \sync          Synchronous
 * \reent         Reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[in]              TimerIdx_U8  [In] U8 - : The index of the timer that the user wants to set to TM_READY.
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \retval     Std_ReturnType  - E_OK: No development error has been detected
 *                             - E_NOT_OK: A development error has been detected
 *
 ******************************************************************************
 *
 * \author        BSW
 * \version       1.0
 * \date          29.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 22.05.2020, BSW:
 *       -
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/*[BSW_SWS_TimeService_035],[BSW_SWS_TimeService_059] */
Std_ReturnType Tm_SetReady32bit( U8 TimerIdx_U8 )
{
   Std_ReturnType A_RetVal = E_NOT_OK;
   /*[BSW_SWS_TimeService_034] */
   SuspendAllInterrupts();
   if( TimerIdx_U8 < NO_OF_32BIT_SWT_U8)
   {
      /*[BSW_SWS_TimeService_033] */
      Tm_GlobalTimers32bit_AS[TimerIdx_U8].TimerState = TM_READY; /*Sets the timer's status to TM_READY. */
      A_RetVal = E_OK;
   }
   else
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if TimerIdx_U8 is not defined" */
   {
      A_RetVal = E_NOT_OK;
   }
   ResumeAllInterrupts();
   return A_RetVal;
}
#endif /* ( TM_32BIT_TIMER_ENABLE == STD_ON ) */

#if (TM_SLOW_TIMER_ENABLE == STD_ON)
/*!
****************************************************************************
* \brief
* Updates the Tm_1ms_UT counter variable that the slow timers use.
*
* \details
* The function updates the counter which is based on the OS tick;
* also updates the current time passed in ms.
*
****************************************************************************
*
* \par Reentrance:
* Non Reentrant
* \par ASIL:
* QM
* \pre
* Module is initialized
*
* \param[IN] none
* \param[OUT] none
* \param[IN/OUT] none
*
* \par Used global variables:
* \parblock
* __Read:__
*
* __Write:__
*
* __Read/Write:__
* Tm_1ms_UT
*
* \endparblock
*
* \par Called functions:
* GetCounterValue
*
* \returns
* void
*
****************************************************************************
*
* \par Developer:
* PES-SWPS
* \par Tester:
* PES-SWPS
*
****************************************************************************/
/*[BSW_SWS_TimeService_071]*/
/* polyspace +1 MISRA-C3:8.7 [Not a defect:Unset] "Function may be called by the user when the module is integrated." */
void Tm_UpdateTimer1ms(void)
{
	TickType A_Tm_NewOsTick;
	U32 A_Tm_OsElapsedMs;
	if(FALSE == Tm_1ms_UT.Tm_LPM_Entered)
	{
	   /* Get system counter value */
		(void)GetCounterValue(SystemTimer, &A_Tm_NewOsTick);
		if(A_Tm_NewOsTick != Tm_1ms_UT.Os_Tick)
		{
		   /* Calculate elapsed time in ms between current time and last saved OS tick */
	      /* polyspace +1 RTE:OVFL MISRA-C3:D4.1 [Not a defect:Unset] "Overflow is an expected outcome for the addition and subtraction operations on this free running timer." */
		   A_Tm_OsElapsedMs = OS_TICKS2MS_SystemTimer(A_Tm_NewOsTick - Tm_1ms_UT.Os_Tick);
			if (A_Tm_OsElapsedMs > 0u)
			{
		      /* polyspace +2 RTE:OVFL MISRA-C3:D4.1 [Not a defect:Unset] "Overflow is an expected outcome for the addition and subtraction operations on this free running timer." */
			   /* Update time passed in ms and the value of the OS tick */
				Tm_1ms_UT.CurrentTime += A_Tm_OsElapsedMs;
				Tm_1ms_UT.Os_Tick = A_Tm_NewOsTick;
			}
			else
			{
			   /* Elapsed ms is 0 */
			}
		}
		else
		{
		   /* Os tick not changed */
		}
	}
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "The code is reachable when LPM is entered." */
	else
	{
	   /* Do nothing if LPM was entered, Tm_UpdateSlowCounter_LPM function is used to update the time passed */
	}
}
/*!
****************************************************************************
* \brief
* Starts a timer instance with set value.
*
* \details
* The function changes the selected timer to TM_RUNNING MODE. Also it sets the minimum time in milliseconds that
* the timer must run before being set to TM_READY.
*
****************************************************************************
*
* \par Reentrance:
* Reentrant
* \par ASIL:
* QM
* \pre
* Module is initialized
* \param[IN] TimerIdx_U8: The index of the timer that the user wants to start
*            Value_U32: The time in milliseconds that the timer must run.
* \param[OUT] none
* \param[IN/OUT] none
*
* \par Used global variables:
* \parblock
* __Read:__
* Tm_1ms_UT
*
* __Write:__
* Tm_GlobalTimers1ms_AS
*
* __Read/Write:__
*
* \endparblock
*
* \par Called functions:
* Tm_UpdateTimer1ms()
* SuspendAllInterrupts()
* ResumeAllInterrupts()
*
* \returns
* Std_ReturnType - E_OK - no error detected
*                  E_NOT_OK - aborted due to errors
*
****************************************************************************
*
* \par Developer:
* PES-SWPS
* \par Tester:
* PES-SWPS
*
****************************************************************************/
/*[BSW_SWS_TimeService_023],[BSW_SWS_TimeService_067]*/
Std_ReturnType Tm_StartTimer_SlowTimer( U8 TimerIdx_U8, U32 Value_U32 )
{
	Std_ReturnType A_RetVal = E_NOT_OK;
	/*[BSW_SWS_TimeService_022]*/
	SuspendAllInterrupts();
	if ((TimerIdx_U8 < NO_OF_SLOW_SWT_U8) && (Value_U32 < 0x0FFFFFFFu) && (Value_U32 > 0u))
	{
	   /* Get current value of system counter */
	   Tm_UpdateTimer1ms();
      /*[BSW_SWS_TimeService_021]*/
		/* Set the value that the counter has to reach */
	   /* polyspace +1 RTE:OVFL MISRA-C3:D4.1 [Not a defect:Unset] "Overflow is an expected outcome for the addition and subtraction operations on this free running timer." */
		Tm_GlobalTimers1ms_AS[TimerIdx_U8].Value = Tm_1ms_UT.CurrentTime + Value_U32;
		Tm_GlobalTimers1ms_AS[TimerIdx_U8].TimerState = TM_RUNNING;/* Sets the state of the 16bit time to TM_RUNNING */
		A_RetVal = E_OK;
	}
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "The code is reachable if the input parameters are not valid." */
	else
	{
	  A_RetVal = E_NOT_OK;
	}
	ResumeAllInterrupts();
	return A_RetVal;
}
/*!
****************************************************************************
* \brief
* Stops a timer instance.
*
* \details
* The function changes the timer instance status to TM_STOPPED.
*
****************************************************************************
*
* \par Reentrance:
* Reentrant
* \par ASIL:
* QM
* \pre
* Module is initialized
* \param[IN] TimerIdx_U8: The index of the timer that the user wants to stop
* \param[OUT] none
* \param[IN/OUT] none
*
* \par Used global variables:
* \parblock
* __Read:__
*
* __Write:__
* Tm_GlobalTimers1ms_AS
*
* __Read/Write:__
*
* \endparblock
*
* \par Called functions:
* SuspendAllInterrupts()
* ResumeAllInterrupts()
*
* \returns
* Std_ReturnType - E_OK - no error detected
*                  E_NOT_OK - aborted due to errors
*
****************************************************************************
*
* \par Developer:
* PES-SWPS
* \par Tester:
* PES-SWPS
*
****************************************************************************/
/*[BSW_SWS_TimeService_027],[BSW_SWS_TimeService_068]*/
Std_ReturnType Tm_StopTimer_SlowTimer( U8 TimerIdx_U8 )
{
	Std_ReturnType A_RetVal = E_NOT_OK;
   /* [BSW_SWS_TimeService_026]*/
	SuspendAllInterrupts();
	if(TimerIdx_U8 < NO_OF_SLOW_SWT_U8)
	{
      /* [BSW_SWS_TimeService_025]*/
		Tm_GlobalTimers1ms_AS[TimerIdx_U8].TimerState = TM_STOPPED;/* Sets the state of the 32bit time to TM_STOPPED */
		A_RetVal = E_OK;
	}
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "The code is reachable if the timer id is not valid." */
	else
	{
	  A_RetVal = E_NOT_OK;
	}
	ResumeAllInterrupts();
	return A_RetVal;
}
/*!
****************************************************************************
* \brief
* Gets the status of a timer instance.
*
* \details
* The function returns the timer's status through the TimerStatus_PU8 parameter.
*
****************************************************************************
*
* \par Reentrance:
* Reentrant
* \par ASIL:
* QM
* \pre
* Module is initialized
* \param[IN] TimerIdx_U8: The index of the timer that the user wants to check
* \param[OUT] none
* \param[IN/OUT] TimerStatus_PU8: The status of the timer instance.
*
* \par Used global variables:
* \parblock
* __Read:__
* Tm_1ms_UT
*
* __Write:__
*
* __Read/Write:__
* Tm_GlobalTimers1ms_AS
*
* \endparblock
*
* \par Called functions:
* Tm_UpdateTimer1ms()
* SuspendAllInterrupts()
* ResumeAllInterrupts()
*
* \returns
* Std_ReturnType - E_OK - no error detected
*                  E_NOT_OK - aborted due to errors
*
****************************************************************************
*
* \par Developer:
* PES-SWPS
* \par Tester:
* PES-SWPS
*
****************************************************************************/
/*[BSW_SWS_TimeService_031],[BSW_SWS_TimeService_069]*/
Std_ReturnType Tm_GetStatus_SlowTimer( U8 TimerIdx_U8 , U8 * TimerStatus_PU8)
{
	Std_ReturnType A_RetVal = E_NOT_OK;
	 /*[BSW_SWS_TimeService_030]*/
	SuspendAllInterrupts();
	if((TimerIdx_U8 < NO_OF_SLOW_SWT_U8)&&(TimerStatus_PU8 != NULL))
	{
	  A_RetVal = E_OK;
     /* polyspace +2 RTE:UNR [Not a defect:Unset] "The code is reachable if the timer is running." */
	  if((Tm_GlobalTimers1ms_AS[TimerIdx_U8].TimerState) == TM_RUNNING)
	  {
	     /* Get current time */
	     Tm_UpdateTimer1ms();
        /* polyspace +2 RTE:OVFL MISRA-C3:D4.1 [Not a defect:Unset] "Overflow is an expected outcome for the addition and subtraction operations on this free running timer." */
		  if( (Tm_GlobalTimers1ms_AS[TimerIdx_U8].Value - Tm_1ms_UT.CurrentTime) > 0x0FFFFFFFu)
		  {
			  Tm_GlobalTimers1ms_AS[TimerIdx_U8].TimerState = TM_READY;
		  }
	  }
	  else
	  {
	     /* Do nothing, timer is not running */
	  }
	  /*[BSW_SWS_TimeService_029]*/
	  * TimerStatus_PU8 = Tm_GlobalTimers1ms_AS[TimerIdx_U8].TimerState;
	}
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "The code is reachable if the input parameters are not valid." */
	else
	{
	  A_RetVal = E_NOT_OK;
	}
	ResumeAllInterrupts();
	return A_RetVal;
}
/*!
****************************************************************************
* \brief
* Changes the status of a slow timer instance in TM_READY.
*
* \details
*
****************************************************************************
*
* \par Reentrance:
* Reentrant
* \par ASIL:
* QM
* \pre
* Module is initialized
* \param[IN] TimerIdx_U8: The index of the timer that the user wants to set to TM_READY.
* \param[OUT] none
* \param[IN/OUT] none
*
* \par Used global variables:
* \parblock
* __Read:__
*
* __Write:__
* Tm_GlobalTimers1ms_AS
*
* __Read/Write:__
*
* \endparblock
*
* \par Called functions:
* SuspendAllInterrupts()
* ResumeAllInterrupts()
*
* \returns
* Std_ReturnType - E_OK - no error detected
*                  E_NOT_OK - aborted due to errors
*
****************************************************************************
*
* \par Developer:
* PES-SWPS
* \par Tester:
* PES-SWPS
*
****************************************************************************/
/*[BSW_SWS_TimeService_035],[BSW_SWS_TimeService_070]*/
Std_ReturnType Tm_SetReady_SlowTimer( U8 TimerIdx_U8 )
{
	Std_ReturnType A_RetVal = E_NOT_OK;
   /*[BSW_SWS_TimeService_034] */
	SuspendAllInterrupts();
	if( TimerIdx_U8 < NO_OF_SLOW_SWT_U8)
	{
      /*[BSW_SWS_TimeService_033] */
		Tm_GlobalTimers1ms_AS[TimerIdx_U8].TimerState = TM_READY; /*Sets the timer's status to TM_READY. */
		A_RetVal = E_OK;
	}
   /* polyspace +2 RTE:UNR [Not a defect:Unset] "The code is reachable if the timer id is not valid." */
	else
	{
	  A_RetVal = E_NOT_OK;
	}
	ResumeAllInterrupts();
	return A_RetVal;
}
/*!
****************************************************************************
* \brief
* Function used to change the Tm_1ms_UT.Tm_LPM_Entered to TRUE. It needs to be
* called when entering LPM
*
* \details
*
****************************************************************************
*
* \par Reentrance:
* Reentrant
* \par ASIL:
* QM
* \pre
* Module is initialized
* \param[IN] none
* \param[OUT] none
* \param[IN/OUT] none
*
* \par Used global variables:
* \parblock
* __Read:__
*
* __Write:__
* Tm_1ms_UT
*
* __Read/Write:__
*
* \endparblock
*
* \par Called functions:
*
* \returns
* void
*
****************************************************************************
*
* \par Developer:
* PES-SWPS
* \par Tester:
* PES-SWPS
*
****************************************************************************/
/*[BSW_SWS_TimeService_072]*/
void Tm_EnterLPM(void)
{
   Tm_1ms_UT.Tm_LPM_Entered = (boolean) TRUE;
}
/*!
****************************************************************************
* \brief
* Function used to change the Tm_1ms_UT.Tm_LPM_Entered to FALSE and sets the last
* tick counter to 0. It needs to be called when exiting LPM
*
* \details
*
****************************************************************************
*
* \par Reentrance:
* Reentrant
* \par ASIL:
* QM
* \pre
* Module is initialized
* \param[IN] none
* \param[OUT] none
* \param[IN/OUT] none
*
* \par Used global variables:
* \parblock
* __Read:__
*
* __Write:__
* Tm_1ms_UT
*
* __Read/Write:__
*
* \endparblock
*
* \par Called functions:
*
* \returns
* void
*
****************************************************************************
*
* \par Developer:
* PES-SWPS
* \par Tester:
* PES-SWPS
*
****************************************************************************/
/*[BSW_SWS_TimeService_073]*/
void Tm_ExitLPM(void)
{
   Tm_1ms_UT.Tm_LPM_Entered = (boolean) FALSE;
   Tm_1ms_UT.Os_Tick = 0u; /* OS tick counter is set to 0 because OS is reinitialized */
}
/*!
****************************************************************************
* \brief
* Function used to update the slow timer's time when in LPM. It needs to be called periodically
* in LPM.
*
* \details
*
****************************************************************************
*
* \par Reentrance:
* Reentrant
* \par ASIL:
* QM
* \pre
* Module is initialized
* \param[IN] CountMs_U8 - the number of milliseconds to add to the current time
* \param[OUT] none
* \param[IN/OUT] none
*
* \par Used global variables:
* \parblock
* __Read:__
*
* __Write:__
* Tm_1ms_UT
*
* __Read/Write:__
*
* \endparblock
*
* \par Called functions:
*
* \returns
* void
*
****************************************************************************
*
* \par Developer:
* PES-SWPS
* \par Tester:
* PES-SWPS
*
****************************************************************************/
/*[BSW_SWS_TimeService_074]*/
void Tm_UpdateSlowTimer_LPM(U8 CountMs_U8)
{
   /* polyspace +1 RTE:OVFL MISRA-C3:D4.1 [Not a defect:Unset] "Overflow is an expected outcome for the addition and subtraction operations on this free running timer." */
   Tm_1ms_UT.CurrentTime += CountMs_U8;
}
#endif /*#if (TM_SLOW_TIMER_ENABLE == STD_ON)*/
/******************************************************************************
 * \brief
 * Checks the status for each running timer and update the internal software timer on 32 bit - task should be called periodical
 *
 * \details
 * The function checks the status of the TM_RUNNING timers, both on 16 its and 32 bits and updates
 * the software timer on 32 bits - CheckTime(). If a timer had expired, it's status changes in TM_READY.
 *
 ******************************************************************************
 *
 * \sync          Synchronous
 * \reent         Non Reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[in]              void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \retval     void
 *
 ******************************************************************************
 *
 * \author        BSW
 * \version       1.0
 * \date          29.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 22.05.2020, BSW:
 *       -
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/*[BSW_SWS_TimeService_040],[BSW_SWS_TimeService_061]*/
void Tm_MainFunction (void )
{
   U8 A_Tm_Index_U8;

#if( TM_16BIT_TIMER_ENABLE == STD_ON )
   for(A_Tm_Index_U8 = 0; A_Tm_Index_U8 < NO_OF_16BIT_SWT_U8 ; A_Tm_Index_U8++)
   {
      /*[BSW_SWS_TimeService_041]*/
      SuspendAllInterrupts();
      if((Tm_GlobalTimers16bit_AS[A_Tm_Index_U8].TimerState)== TM_RUNNING)
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if the 16bit timer instance is running" */
      {
         (void)ltm_CheckTimer16bit(A_Tm_Index_U8);/*Checks if the timer had expired. */
      }
      else
      {
         /* Do nothing, the timer is not running */
      }
      ResumeAllInterrupts();
   }
#endif /*  TM_16BIT_TIMER_ENABLE == STD_ON ) */

#if( TM_32BIT_TIMER_ENABLE == STD_ON )
   for(A_Tm_Index_U8 = 0; A_Tm_Index_U8 < NO_OF_32BIT_SWT_U8 ; A_Tm_Index_U8++)
   {
      /*[BSW_SWS_TimeService_041]*/
      SuspendAllInterrupts();
      if((Tm_GlobalTimers32bit_AS[A_Tm_Index_U8].TimerState)== TM_RUNNING)
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if the 32bit timer instance is running" */
      {
         (void)ltm_CheckTimer32bit(A_Tm_Index_U8);/*Checks if the timer had expired. */
      }
      else
      {
         /* Do nothing, the timer is not running */
      }
      ResumeAllInterrupts();
   }
   ltm_Check_Time();/*Checks if the 16bit free running timer had expired and update the 32bit free running timer */
#endif /*  TM_32BIT_TIMER_ENABLE == STD_ON ) */

}

/******************************************************************************
 * \brief
 * Initializes each timer defined by the user.
 *
 * \details
 * The function sets each timer's status on TM_STOPPED.
 *
 ******************************************************************************
 *
 * \sync          Synchronous
 * \reent         Non Reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[in]              void
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \retval     void
 *
 ******************************************************************************
 *
 * \author        BSW
 * \version       1.0
 * \date          29.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 22.05.2020, BSW:
 *       -
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/*[BSW_SWS_TimeService_060]*/
void Tm_InitTimers ( void )
{
   U8 A_Tm_Index_U8;
   /*[BSW_SWS_TimeService_038]*/
   SuspendAllInterrupts();
#if( TM_16BIT_TIMER_ENABLE == STD_ON )
   for(A_Tm_Index_U8 = 0; A_Tm_Index_U8 < NO_OF_16BIT_SWT_U8 ; A_Tm_Index_U8++)
   {
      /*[BSW_SWS_TimeService_037]*/
      Tm_GlobalTimers16bit_AS[A_Tm_Index_U8].TimerState = TM_STOPPED;/* Sets the state of the 16bit time to TM_STOPPED */
   }
#endif /* TM_16BIT_TIMER_ENABLE == STD_ON ) */

#if( TM_32BIT_TIMER_ENABLE == STD_ON )
   Tm_SoftwareTimer_U32 = 0u;
   for(A_Tm_Index_U8 = 0; A_Tm_Index_U8 < NO_OF_32BIT_SWT_U8 ; A_Tm_Index_U8++)
   {
      /*[BSW_SWS_TimeService_037]*/
      Tm_GlobalTimers32bit_AS[A_Tm_Index_U8].TimerState = TM_STOPPED;/* Sets the state of the 32bit time to TM_STOPPED */
   }
#endif /* TM_32BIT_TIMER_ENABLE == STD_ON ) */
#if( TM_SLOW_TIMER_ENABLE == STD_ON )
   for(A_Tm_Index_U8 = 0; A_Tm_Index_U8 < NO_OF_SLOW_SWT_U8 ; A_Tm_Index_U8++)
   {
      Tm_GlobalTimers1ms_AS[A_Tm_Index_U8].TimerState = TM_STOPPED;/* Sets the state of the 32bit time to TM_STOPPED */
   }
#endif /* TM_SLOW_TIMER_ENABLE == STD_ON ) */
   ResumeAllInterrupts();
}
/* polyspace-end MISRA-C3:5.1 [Not a defect:Unset] "Functions are named according to Autosar and Huf Specifications" */

#if( TM_32BIT_TIMER_ENABLE == STD_ON )
/******************************************************************************
 * \brief
 * Check if the predefined free running hardware timer has restarted - update the software timer on 32 bits
 *
 * \details
 * The function checks the flag of the free running hardware timer and updates the software timer on 32 bits.
 *
 ******************************************************************************
 *
 * \sync          Synchronous
 * \reent         Reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[in]              TimerIdx_U8  [In] U8 - : The index of the timer that the user wants to check.
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \retval     void
 *
 ******************************************************************************
 *
 * \author        BSW
 * \version       1.0
 * \date          29.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 22.05.2020, BSW:
 *       -
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
static void ltm_Check_Time( void ) /* [BSW_SWS_TimeService_062]  */
{
   if(TM_TIMER_INT != 0)
   {
      /* [BSW_SWS_TimeService_063] */
      /* polyspace +1 RTE:OVFL MISRA-C3:D4.1 [Not a defect:Unset] "Overflow is an expected outcome for the addition and subtraction operations on this free running timer." */
      Tm_SoftwareTimer_U32 = Tm_SoftwareTimer_U32 + (U32) ((U32)1<<16) ;
      TM_CLEAR_TIMER_PENDING_INT;
   }
   else
   {
      /* Do nothing, the hardware free running timer has not expired */
   }
}
#endif /*  TM_32BIT_TIMER_ENABLE == STD_ON ) */

#if( TM_16BIT_TIMER_ENABLE == STD_ON )
/******************************************************************************
 * \brief
 * Check if a timer instance has expired -if expired change status to TM_READY
 *
 * \details
 * The function checks if a timer has expired and changes it's status
 *
 ******************************************************************************
 *
 * \sync          Synchronous
 * \reent         Reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[in]              TimerIdx_U8  [In] U8 - : The index of the timer that the user wants to check.
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \retval     Std_ReturnType  - E_OK: The underlying GPT driver service has returned E_OK
 *                                           and no development error has been detected
 *                             - E_NOT_OK: The underlying GPT driver service has returned E_NOT_OK,
 *                                           or a development error has been detected
 *
 ******************************************************************************
 *
 * \author        BSW
 * \version       1.0
 * \date          29.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 22.05.2020, BSW:
 *       -
 *
 ******************************************************************************
 *
 * \par Remarks:Language Scope : current metric = 4.1 due to the number of operations and variables needed check the 16bit timer
 *
 ******************************************************************************/
/* [BSW_SWS_TimeService_064] */
static Std_ReturnType ltm_CheckTimer16bit( U8 TimerIdx_U8 )
{
   Tm_PredefTimerRefTimeType A_Tm_CurrentTime_UT = 0u;
   Std_ReturnType A_RetVal ;
   if( TimerIdx_U8 < NO_OF_16BIT_SWT_U8)
   {
      A_RetVal = E_OK;
      if((Tm_GlobalTimers16bit_AS[TimerIdx_U8].TimerState)== TM_RUNNING)
      {
         A_RetVal = Gpt_GetPredefTimerValue(PREDEFINED_TIMER, &A_Tm_CurrentTime_UT);
         /* polyspace +1 RTE:OVFL MISRA-C3:D4.1 [Not a defect:Unset] "Overflow is an expected outcome for the addition and subtraction operations on this timers." */
         if(((U16)(A_Tm_CurrentTime_UT - Tm_GlobalTimers16bit_AS[TimerIdx_U8].HWRTicks)) >= Tm_GlobalTimers16bit_AS[TimerIdx_U8].Value )
         {
            Tm_GlobalTimers16bit_AS[TimerIdx_U8].TimerState = TM_READY;
         }
         else
         {
            Tm_GlobalTimers16bit_AS[TimerIdx_U8].Value = Tm_GlobalTimers16bit_AS[TimerIdx_U8].Value -(A_Tm_CurrentTime_UT - Tm_GlobalTimers16bit_AS[TimerIdx_U8].HWRTicks);
            Tm_GlobalTimers16bit_AS[TimerIdx_U8].HWRTicks = A_Tm_CurrentTime_UT ;
         }
      }
      else
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if the timer is not running" */
      {
         /* Do nothing, the timer is not running */
      }
   }
   else
      /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if TimerIdx_U8 is not defined" */
   {
      A_RetVal = E_NOT_OK ;
   }
   return A_RetVal;
}
#endif /*TM_16BIT_TIMER_ENABLE == STD_ON */

#if( TM_32BIT_TIMER_ENABLE == STD_ON )
/******************************************************************************
 * \brief
 * Check if a timer instance has expired -if expired change status to TM_READY
 *
 * \details
 * The function checks if a timer has expired and changes it's status
 *
 ******************************************************************************
 *
 * \sync          Synchronous
 * \reent         Reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[in]              TimerIdx_U8  [In] U8 - : The index of the timer that the user wants to check.
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \retval     void
 *
 ******************************************************************************
 *
 * \author        BSW
 * \version       1.0
 * \date          29.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 22.05.2020, BSW:
 *       -
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* [BSW_SWS_TimeService_065] */
static Std_ReturnType ltm_CheckTimer32bit( U8 TimerIdx_U8 )
{
   U32 CurrentSoftwareTime = 0u;
   Std_ReturnType A_RetVal = E_NOT_OK;
   if( TimerIdx_U8 < NO_OF_32BIT_SWT_U8)
   {
      A_RetVal = E_OK;
      if((Tm_GlobalTimers32bit_AS[TimerIdx_U8].TimerState)== TM_RUNNING)
       /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if the 32bit timer instance is running" */
      {
         A_RetVal = Tm_GetCurrentSoftwareTimer32bit(&CurrentSoftwareTime) ;
         /* polyspace +3 RTE:UNR [Not a defect:Unset] "Condition checks if timer has expired." */
         /* polyspace +1 RTE:OVFL MISRA-C3:D4.1 [Not a defect:Unset] "Overflow is an expected outcome for the addition and subtraction operations on this timers." */
         if(((U32)(CurrentSoftwareTime - Tm_GlobalTimers32bit_AS[TimerIdx_U8].HWRTicks)) >= Tm_GlobalTimers32bit_AS[TimerIdx_U8].Value)
         {
            Tm_GlobalTimers32bit_AS[TimerIdx_U8].TimerState = TM_READY;
         }
         /* polyspace +2 RTE:UNR [Not a defect:Unset] "Condition true if timer has not expired." */
         else
         {
            /* Do nothing, the timer is not ready */
         }
      }
      /* polyspace +2 RTE:UNR [Not a defect:Unset] "Condition true if timer is not running." */
      else
      {
         /* Do nothing, the timer is not running */
      }
   }
   else
   /* polyspace +1 RTE:UNR [Not a defect:Unset] "The code is reachable if TimerIdx_U8 is not defined" */
   {
      A_RetVal = E_NOT_OK;
   }
   return A_RetVal;
}
/******************************************************************************
 * \brief
 * Return the current value of the software timer on 32 bits
 *
 * \details
 * The function reads the value of the predefined free running timer, checks its flag
 *  and calculates the current time of the 32 bits timer.
 *
 ******************************************************************************
 *
 * \sync          Synchronous
 * \reent         Reentrant
 *
 * \pre           all must be initialized.
 * \post          process is started
 *
 * \param[out]      CurrentSoftwareTime [out] U32* - The current time in microseconds fot the free running
 *                                                    32 bits software timer.
 *
 * \glob_start
 *   \glob_item{in,  U8_GlobA, global variable used}
 *   \glob_item{out, U8_GlobB, global variable used}
 * \glob_end
 *
 * \retval     Std_ReturnType  - E_OK: The underlying GPT driver service has returned E_OK
 *                                           and no development error has been detected
 *                             - E_NOT_OK: The underlying GPT driver service has returned E_NOT_OK,
 *                                           or a development error has been detected
 *
 ******************************************************************************
 *
 * \author        BSW
 * \version       1.0
 * \date          29.01.2021
 *
 ******************************************************************************
 *
 * \par Change history:
 *    \li 22.05.2020, BSW:
 *       -
 *
 ******************************************************************************
 *
 * \par Remarks:
 *
 ******************************************************************************/
/* [BSW_SWS_TimeService_066] */
/* polyspace +1 MISRA-C3:8.7 [Not a defect:Unset] "Function may be called by the user when the module is integrated." */
Std_ReturnType Tm_GetCurrentSoftwareTimer32bit ( U32* CurrentSoftwareTime )
{
   Tm_PredefTimerRefTimeType A_Tm_CurrentTime_UT = 0u;
   Std_ReturnType A_RetVal = E_NOT_OK;

   SuspendAllInterrupts();
   A_RetVal = Gpt_GetPredefTimerValue(PREDEFINED_TIMER , &A_Tm_CurrentTime_UT);

   if (TM_TIMER_INT == 0u)
   {
      *CurrentSoftwareTime = ((U32)Tm_SoftwareTimer_U32 +(U32)A_Tm_CurrentTime_UT);
   }
   else
   {
      /* polyspace +1 RTE:OVFL MISRA-C3:D4.1 [Not a defect:Unset] "Overflow is an expected outcome for the addition and subtraction operations on this timers." */
      Tm_SoftwareTimer_U32 = (U32)(Tm_SoftwareTimer_U32 + (U32) ((U32)1<<16)) ;
      A_RetVal = Gpt_GetPredefTimerValue(PREDEFINED_TIMER , &A_Tm_CurrentTime_UT);
      TM_CLEAR_TIMER_PENDING_INT;
      *CurrentSoftwareTime = ((U32)Tm_SoftwareTimer_U32 +(U32)A_Tm_CurrentTime_UT);
   }
   ResumeAllInterrupts();
   return A_RetVal;
}
#endif /*  TM_32BIT_TIMER_ENABLE == STD_ON ) */

/*!
 \defgroup module_group_int Integration instructions
 \ingroup module_group
 \{

 1. Module parameters / compiler switches
 ========================================

 1.1 Module parameters
 ---------------------

 1.2 Compiler switches
 ---------------------


 2. Operating system integration
 ===============================


 3. General directions
 =====================


 \}
 */
/* %PCMS_HEADER_SUBSTITUTION_START:%
 ******************************************************************************
 * Document Management Information Log (generated by Dimensions CM)
 *
 *  Description:
 *  %PD:%
 *
 *  Used by Baselines:
 *  %PIRB:%
 *
 *  Used by Dimensions CM Projects:
 *  %PIRW:%
 *
 *  Change History:
 *  %PL:%
 *
 * %PCMS_HEADER_SUBSTITUTION_END:%
 */
