/*!
 * \defgroup measure_supply (MeasureSupply.c) Supplies analogue Measurement values to state monitors
 * \{
 ******************************************************************************
 * \image html "Kopf_oZusatz_A4hoch_4C.jpg"
 *
 * \par Module Owner:
 *   Huf H&uuml;lsbeck & F&uuml;rst GmbH & Co. KG \n
 *   Steeger Str. 17 \n
 *   42551 Velbert \n
 *   Department PDE-S
 *
 * \par Initial Project:
 * BMW 1665.00x
 *
 ******************************************************************************
 * \par Description:
 * Supplies analogue Measurement values to state monitors
 *
 ******************************************************************************
 *
 * %PCMS_HEADER_SUBSTITUTION_START:%
 *
 * Configuration Management Information Log (generated by Dimensions CM)
 *
 *
 * CM Item: %PID:%
 * Item name: %PM:%
 * Location: %ARCHIVE:%
 * Revision: %PR:%
 * Date: %DATE:%
 * Author: %AUTHOR:%
 *
 * %PCMS_HEADER_SUBSTITUTION_END:% *
 *
 ******************************************************************************
 *
 * \par Layer:
 *    Service
 *
 * \par Controller:
 *    RL78
 *
 * \par Compiler Dialect:
 *    C90
 *
 * \par Resource Estimations:
 *    | Resource      | Amount         | Remarks         |
 *    | ------------- | -------------: | --------------- |
 *    | ROM           | 300 Byte     | estimation   |
 *    | RAM           | 0 Byte     | estimation   |
 *    | NVRAM         | 0 Byte   | estimation |
 *    | Runtime Init  | na    | there is no init  |
 *    | Runtime Task  | <210�s; normally <110�s    | longest wait times in microswitch readout with NFC collision  |
 *
 ******************************************************************************
 \defgroup measure_supply_det Details
 \ingroup measure_supply
 \{
*/

#include "Platform_Types.h"

#include "Dio.h"
#include "Reg_eSys.h"
#include "MeasureSupply.h"

#define ADC_CFG1_OFFSET_ADDR32          (0x40uL)
#define ADC_CFG2_OFFSET_ADDR32          (0x44uL)
#define ADC_Rn_OFFSET_ADDR32            (0x48uL)
#define ADC_CV1_OFFSET_ADDR32           (0x88uL)
#define ADC_CV2_OFFSET_ADDR32           (0x8CuL)
#define ADC_SC2_OFFSET_ADDR32           (0x90uL)
#define ADC_SC3_OFFSET_ADDR32           (0x94uL)

/* polyspace+10 MISRA-C3:2.5 [Justified:Low] "Macro should be kept for future usage" */
#define ADC_SC2_ADTRG_HW_U32            (0x00000040UL)
#define ADC_SC1_ADCH_DIS_MASK_U32       (0x1FuL)
#define ADC_SC1_ADCH_CH5_MASK_U32       (0x05) /* 011101b VREFSH */
#define ADC_SC1_ADCH_VREFSL_MASK_U32    (0x1EuL) /* 011110b VREFSL */
#define ADC_SC1_AIEN_DIS_MASK_U32       (0x00uL) /* bit 6 */
#define ADC_CFG1_CLOCK_SOURCE           (0x00uL) /* clock source alt 1 */
#define ADC_CFG1_ADC_RESOLUTION         (0x08uL) /* 10 bit size, bit 2 and 3, value 10b */
#define ADC_CFG2_SAMPLE_TIME            (0x02uL)
#define ADC_CFG2_SAMPLE_TIME_10         (15uL)

#define ADC_NUM_OF_CHANNELS             (16u)

Std_ReturnType Adc_readADC(U16 *buffer, U8 index_ch, U8 inputChannel);
static void Adc_initChannel(U32 baseAddress);
static U32 REG_READ32_func(U32 address);

/*------------------------------------------------------------------------
    MACRO       : U16_DELAY_ADC_AQUIS_TIME_*
    Author      : omuelle
    Input       :
    Description :  Additional Sample time to make sure the whole load is transfered to the ADC
    ------------------------------------------------------------------------*/
/* polyspace < MISRA-C3:2.5 : Not a defect : Justify with annotations > Should be kept for future usage */

U16 MeasureSupply_getUbattVoltage(void)
{
    U16 adcValue = 0u;
    U16 u16Val = 0u;

    /* enable measurement path*/
    Dio_WriteChannel(DioConf_DioChannel_Dio_PTB2_U_SPG1_IO, STD_HIGH);
    (void)Adc_readADC(&u16Val, 0, ADC_INPUT_CH_VREFSL);
    if(Adc_readADC(&adcValue, 0, ADC_INPUT_CH_VREFSH) != E_OK)
    {
        adcValue = 0u;
    }
    /* return pins to previous state*/
    Dio_WriteChannel(DioConf_DioChannel_Dio_PTB2_U_SPG1_IO, STD_LOW);
    (void)Adc_readADC(&u16Val, 0, ADC_INPUT_CH_VREFSL);

    //AlTo ADPC is handled by the bsw driver. ADPC = U8_ADPC_old;
    /* ad-value       divisor   V/digit => 1.45V/2^10    transistor voltage * 10    RefVoltage = 1.45V */
    /* This in to get value in 0.1V                     */
#ifdef UBAT_DEBUG_OUT
    static U16 debug_voltage;
    debug_voltage = (U16) ((float)adValue_u16 * ((100.0+8.2)/8.2) * (1.45/1024.0) * 10.0) + 6;
#endif
    return adcValue;
}
/* polyspace+1 MISRA-C3:8.7 [Justified:Low] "used in other module if ifdef MCAL_ENABLE_USER_MODE_SUPPORT" */
void REG_WRITE32_func(U32 address, U32 value)
{
	REG_WRITE32(address, value);
}

static U32 REG_READ32_func(U32 address)
{
	return REG_READ32(address);
}

/* Read ADC */
/* polyspace+1 MISRA-C3:8.7 [Justified:Low] "Function may be referenced from internal or external" */
Std_ReturnType Adc_readADC(U16 *buffer, U8 index_ch, U8 inputChannel)
{
    Std_ReturnType returnVal =  E_OK;
    U8 Adc_timeout = 0x40u;
    U32 regVal = 0u;

    if(index_ch < ADC_NUM_OF_CHANNELS)
    {
        regVal = ADC_CFG1_ADC_RESOLUTION;
        REG_WRITE32_func(ADC0_BASEADDR + ADC_CFG1_OFFSET_ADDR32, regVal);
        regVal = ADC_CFG2_SAMPLE_TIME_10;
        REG_WRITE32_func(ADC0_BASEADDR + ADC_CFG2_OFFSET_ADDR32, regVal);
        /* Check if there is a on going convertion */
        regVal =  REG_READ32_func(ADC0_BASEADDR + ADC_SC2_OFFSET_ADDR32);
        if((regVal & 0x10uL) == 0u)
        {
            /* Trigger convertion */
            if (inputChannel == ADC_INPUT_CH_VREFSH)
            {
                /* Enable Channel with VREFSH as input */
            	REG_WRITE32_func((ADC0_BASEADDR + ((uint32)index_ch << 2u)), ADC_SC1_ADCH_CH5_MASK_U32);
            }
            else
            {
                /* Enable Channel with VREFSL as input */
            	REG_WRITE32_func(ADC0_BASEADDR + ((uint32)index_ch << 2u), ADC_SC1_ADCH_VREFSL_MASK_U32);
            }
            /**/
            SuspendAllInterrupts();
            
            regVal =  REG_READ32_func(ADC0_BASEADDR + ((uint32)index_ch << 2u));
            while(((regVal & 0x80uL) == 0u) && (Adc_timeout > 0u))
            {
                regVal =  REG_READ32_func(ADC0_BASEADDR + ((uint32)index_ch << 2u));
                Adc_timeout--;
            }
            ResumeAllInterrupts();
            if(Adc_timeout == 0u)
            {
                returnVal = E_NOT_OK;
            }
            *buffer = (U16) REG_READ32_func(ADC0_BASEADDR + ADC_Rn_OFFSET_ADDR32 + ((uint32)index_ch << 2u));
            /* Disable Channel */
            REG_WRITE32_func(ADC0_BASEADDR + ((uint32)index_ch << 2u), ADC_SC1_AIEN_DIS_MASK_U32 | ADC_SC1_ADCH_DIS_MASK_U32);
        }
        else
        {
            /* This should never be the case, since this is a synch function */
            returnVal = E_NOT_OK;
        }
    }
    else
    {
        returnVal = E_NOT_OK;
    }
    return returnVal;
}

/* For controller S32K144 only up to refisters are only up to E8h */
static void Adc_initChannel(U32 baseAddress)
{
    U32 value;
    U8 u8Counter;
    for(u8Counter = 0u; u8Counter < ADC_NUM_OF_CHANNELS; u8Counter += 1u)
    {
        /* AIEN = 0 - ISR disabled, input channel disabled */
        value = ADC_SC1_ADCH_DIS_MASK_U32;
        REG_WRITE32_func((baseAddress + ((uint32)u8Counter << 2u)), value);
    }
    /* 10 bit ADC, clock devider 1 - 0 as value, clock source alt 1 - 0 as value*/
    value = ADC_CFG1_ADC_RESOLUTION;
    REG_WRITE32_func(baseAddress + ADC_CFG1_OFFSET_ADDR32, value);
    /* Sample time of 2, lowest possible value */
    value = ADC_CFG2_SAMPLE_TIME;
    REG_WRITE32_func(baseAddress + ADC_CFG2_OFFSET_ADDR32, value);

    /* CAL - 0, bit 7 , no calibration,
    ADCO - 0, one shot conversion, bit 3,
    AVGE - 0, Hardware average disalbe, bit 2
    AVGS - 0 , 4 samples for average, bit 01 */
    value = 0u;
    REG_WRITE32_func(baseAddress + ADC_SC3_OFFSET_ADDR32, value);
    /* HW trigger, value - 0, bit 6, 
    compare function disabled, value - 0, bit 5, 
    DMA disabled, value - 0, bit 2,
    Voltage Reference Selector, default - VREFH and VREFL, value - 0, bit 01,  */
    value = 0x00u;
    REG_WRITE32_func(baseAddress + ADC_SC2_OFFSET_ADDR32, value);
    /* Reset value is 0, but just write then from safety */
    value = 0u;
    REG_WRITE32_func(baseAddress + ADC_CV1_OFFSET_ADDR32, value);
    REG_WRITE32_func(baseAddress + ADC_CV2_OFFSET_ADDR32, value);
    /* Write PDB0 reg */
    value = 0u;
    REG_WRITE32_func(PDB0_BASEADDR, value);
}

void Adc_init(void)
{
    Adc_initChannel(ADC0_BASEADDR);
}
