 /*!
* \defgroup MOD_MCAL_OS
* \{
******************************************************************************
*
* \par Module Owner:
* Huf Group
*
* \par Initial Project:
* 1656.001 BSW
*
******************************************************************************
* \par Description:
*  This file contains the definitions of the PendSV and SVCall interrupts' handlers.
*  It is generated only for the S32K controller and is used in case background task
*  is enabled.
******************************************************************************
*
* %PCMS_HEADER_SUBSTITUTION_START:%
*
* Configuration Management Information Log (generated by Dimensions CM)
*
*
* CM Item: %PID:%
* Item name: %PM:%
* Location: %ARCHIVE:%
* Revision: %PR:%
* Date: %DATE:%
* Author: %AUTHOR:%
*
* %PCMS_HEADER_SUBSTITUTION_END:% *
******************************************************************************
*
* \par Layer:
*  Mcal
*
* \par Compiler dialect:
*  C99
*
* \par Controller:
*  S32K
*
* \par Estimated resources:
* | Resource | Amount   | Remarks         |
* | ---------| -------- | ----------------|
* | ROM      | x Byte   | on x controller |
* | RAM      | y Byte   | on x controller |
* | NVRAM    | z Byte   | on x controller |
* | Runtime Init | X ms |                 |
* | Runtime Task | X ms |                 |
*
******************************************************************************/  

    MODULE interrupts.s
	EXTERN Os_CheckAlarms
	EXTERN Os_ContextSaved_BO
	PUBLIC PendSV_Handler
	PUBLIC SVC_Handler
	SECTION .text : CODE (2)

/*!
 ****************************************************************************
 * \brief
 * PendSV exception handler is used to save the context on stack. It is set to pending from Os_ISR_Tick.
 *
 * \details
 * When entering an exception, the processor changes from Thread mode(where Process Stack is used)
 * to Handler Mode(where the Main Stack is used) and saves the processor state(r0-r3, r12, r14, r15, PSR)
 * on the Process Stack.
 * On the PendSV handler, first, Os_ContextSaved_BO is checked.  If the value is TRUE, it
 * means that the previous execution of PendSV_Handler was not yet followed by a execution of SVC_Handler (the context was
 * saved on the stack, but not removed yet). In this case it is not necessary to save the context again, therefore the exception
 * handler is exited. If the value is FALSE, Os_ContextSaved_BO is set to TRUE and execution proceeds.
 * The current address of the Processor stack is saved in a general purpose register
 * in order to use that address for storing the modified context on the Process Stack.
 * Then, the r4-r11 registers are stored on the stack because they are not saved automatically 
 * when an exception occurs and the Arm Procedure Call Standard specifies that their value must be preserved
 * between function calls. After this, the new context from which Os_CheckAlarms is called will be created as follows:
 * - for PSR register the value 0x01000000 will be used(T bit should be 1 because the Cortex M4 processor only supports
 *   Thumb instructions; otherwise, if T=0, a fault is generated; the rest of the bits are irrelevant for Os_CheckAlarms
 *   and are set to 0
 * - for R15(Program Counter) and R14(Link Register), the address of Os_CheckAlarms will be used
 * - r12, r0-r3 are saved with the current value because their value does not impact the execution of Os_CheckAlarms
 * The modified context is saved on the stack and the Process Stack Pointer will be updated with the new
 * address stored in the general purpose register after all the storing was performed.
 * On exception exit, the modified context will be unstacked, the processor will change back to Thread mode
 * and will start executing Os_CheckAlarms.
 ****************************************************************************
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  The module has to be initialized
 *
 * \param[IN] -
 * \param[OUT] -
 * \param[IN/OUT] -
 *
 * \par Used global variables:
 * \parblock
 * __Read:__
 * none
 *
 * __Write:__
 * none
 *
 * __Read/Write:__
 * Os_ContextSaved_BO
 *
 * \endparblock
 *
 * \par Called functions: none
 *
 * \returns  void
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS

 ****************************************************************************/  
PendSV_Handler:
    /*[SWPS_SWS_MCALOS_00035]*/
	/*Disable interrupts*/
	CPSID i
	/* Store in r0 the address of Os_ContextSaved_BO*/
	LDR r0, =Os_ContextSaved_BO
	/* Store in r2 the value of Os_ContextSaved_BO*/
	LDRB r2, [r0]
	/* Check if the value of Os_ContextSaved_BO is FALSE */
	CMP r2, #0x00
	/* In case the value is TRUE, jump to B2 and exit the interrupt*/
	BNE .B2
	/* Set Os_ContextSaved_BO to TRUE */
	MOV r1, #0x01
	STRB r1, [r0]
	/*Since handler mode is active, the main stack is used; we need to save the context on the process stack
	 *store the current PSP value into r0 and use it to store the registers*/
	MRS r0, PSP
	/*Flush the pipeline of the processor, so that all instructions following the ISB are fetched
	 *from cache or memory again, after the ISB instruction has been completed*/
	ISB /*Instruction Synchronization Barrier*/
	/*Store r4-r11 registers onto the stack because they are not saved automatically when an exception occurs
	 *and the Arm Procedure Call Standard specifies that their value must be preserved between function calls )*/
	STMDB r0!, {r4,r5,r6,r7,r8,r9,r10,r11}
	/*Save the new process stack pointer value(stored into r0) in r4 because later we will need to store
	 *r0 on the stack and it cannot be used as destination and source at the same time with stmdb instruction and writeback(!) specified*/
	MOV r4, r0
	/*Save in r8 the value that will be used as PSR register; Set Thumb bit(bit[24]) to 1 for correct return in Thumb state
	 *the value of the APSR bits is not important for the execution of Os_CheckAlarms, so they are set to 0*/
	MOV.W r8, #0x01000000
	/*Save into r7 the value that will be use for Program Counter; in this case, store the address of the Os_CheckAlarms*/
	LDR r7, =Os_CheckAlarms
	/*Save into r6 the value that will be used as Link Register*/
	MOV r6, r7
	/*Store the values that will be used for Link Register, Program Counter and PSR on the stack*/
	STMDB r4!, {r6,r7,r8} /*r14(LR), r15(PC), PSR*/
	/*Store r0-r12 registers on the stack*/
	STMDB r4!, {r0,r1,r2,r3,r12}
	/*Update process stack pointer with the new address after all the registers were stored*/
	MSR PSP, r4
	/*Instruction Synchronization Barrier*/
	ISB
	.B2:
	/*Enable interrupts*/
	CPSIE i
	
	/*Exit interrupt*/
	BX lr

/*!
 ****************************************************************************
 * \brief
 * SVCall exception handler is used to restore the context from the stack.It is set to
 * pending from Os_CheckAlarms, right after the OS_CHECK_ALARMS_FUNCTION is executed.
 *
 * \details
 * When executing this function, the processor will be in Handler Mode and the Main Stack will be used.
 * As a first action, Os_ContextSaved_BO is set to FALSE (as a proof that SVC_Handler was executed).
 * The current value of the Process Stack Pointer is saved in a general purpose register. Then,
 * to that value 40 bytes are added in order to reach the address from where the r4-r11 are stored.
 * 40 bytes: - 2 registers are saved on the Process Stack when entering Os_CheckAlarms(2 x 4 bytes = 8 bytes)
 *           - processor state(r0-r3, r12, r14, r15 and PSR) is saved on the Process Stack when the SVCall
 *             exception is entered (8 x 4 bytes = 32 bytes)
 * After that, the r4-r11 registers are restored with their initial value, before the program was interrupted,
 * and the value of the Process Stack Pointer will be updated with the new address(after the r4-r11 registers were loaded).
 * On exception exit, the processor will return to its initial state, right before the Os_ISR_Tick interrupted.
 ****************************************************************************
 * \par Reentrance:
 *  Non-Reentrant
 * \par ASIL:
 *  QM
 * \pre
 *  The module has to be initialized
 *
 * \param[IN] -
 * \param[OUT] -
 * \param[IN/OUT] -
 *
 * \par Used global variables:
 * \parblock
 * __Read:__
 * none
 *
 * __Write:__
 * Os_ContextSaved_BO
 *
 * __Read/Write:__
 * none
 *
 * \endparblock
 *
 * \par Called functions: none
 *
 *
 * \returns  void
 ****************************************************************************
 *
 * \par Developer:
 *  PES-SWPS
 * \par Tester:
 *  PES-SWPS
 *
 ****************************************************************************/ 
SVC_Handler:
     /*[SWPS_SWS_MCALOS_00036]*/
    /*Disable interrupts*/
	CPSID i
	
	/* Load in r0 the address of Os_ContextSaved_BO*/
	LDR r0, =Os_ContextSaved_BO
	/* Set r1 to 0*/
	MOV r1, #0x00
	/* Set the value of Os_ContextSaved_BO to FALSE(0x00)*/
	STRB r1, [r0]
	
	/*Since handler mode is active, the main stack is used; we need to save the context on the process stack
	 *store the current PSP value into r0 and use it to restore the registers*/
	MRS r0, PSP
	/*Flush the pipeline of the processor, so that all instructions following the ISB are fetched
	 *from cache or memory again, after the ISB instruction has been completed*/
	ISB /*Instruction Synchronization Barrier*/
	/*Set the stack pointer to point to the address right after the r4-r11 registers were stored in the stack
	 *add 40 bytes to the current address (2 registers were stored when entering Os_CheckAlarms function
	 *and 8 when entering the exception)*/
	ADDW r0,r0, #40
	/*Pop r4-r11 registers from the stack */
	LDMFD r0!, {r4,r5,r6,r7,r8,r9,r10,r11}
	/*Update process stack pointer with the new value after all the registers were loaded*/
	MSR PSP, r0
	/*Instruction Synchronization Barrier*/
	ISB
	/*Enable interrupts*/
	CPSIE i
	/*Exit interrupt*/
	BX lr

	END
/* %PCMS_HEADER_SUBSTITUTION_START:%
******************************************************************************
* Document Management Information Log (generated by Dimensions CM)
*
* Description:
* %PD:%
*
* Used by Baselines:
* %PIRB:%
*
* Used by Dimensions CM Projects:
* %PIRW:%
*
* Change History:
* %PL:%
*
* %PCMS_HEADER_SUBSTITUTION_END:%
*/
